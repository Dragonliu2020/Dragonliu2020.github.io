<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dragon Liu</title>
  
  
  <link href="https://dragonliu2022.github.io/atom.xml" rel="self"/>
  
  <link href="https://dragonliu2022.github.io/"/>
  <updated>2022-05-29T14:28:07.991Z</updated>
  <id>https://dragonliu2022.github.io/</id>
  
  <author>
    <name>Dragon Liu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java中调用Python程序</title>
    <link href="https://dragonliu2022.github.io/2022/05/29/Java%E4%B8%AD%E8%B0%83%E7%94%A8Python%E7%A8%8B%E5%BA%8F/"/>
    <id>https://dragonliu2022.github.io/2022/05/29/Java%E4%B8%AD%E8%B0%83%E7%94%A8Python%E7%A8%8B%E5%BA%8F/</id>
    <published>2022-05-29T14:28:07.000Z</published>
    <updated>2022-05-29T14:28:07.991Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Python-列表-生成列表</title>
    <link href="https://dragonliu2022.github.io/2022/05/12/Python-%E5%88%97%E8%A1%A8-%E7%94%9F%E6%88%90%E5%88%97%E8%A1%A8/"/>
    <id>https://dragonliu2022.github.io/2022/05/12/Python-%E5%88%97%E8%A1%A8-%E7%94%9F%E6%88%90%E5%88%97%E8%A1%A8/</id>
    <published>2022-05-12T14:39:10.000Z</published>
    <updated>2022-05-12T16:59:20.484Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-问题"><a class="markdownIt-Anchor" href="#1-问题"></a> 1 问题</h1><p>需求：生成1-10的列表；生成10个0的列表</p><h1 id="2-解决"><a class="markdownIt-Anchor" href="#2-解决"></a> 2 解决</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># list方法</span></span><br><span class="line">init_list = list(range(<span class="number">1</span>, <span class="number">10</span>+<span class="number">1</span>))  <span class="comment"># [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># []方法</span></span><br><span class="line">init_list = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>+<span class="number">1</span>)]  <span class="comment"># [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环方法</span></span><br><span class="line">init_list = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>+<span class="number">1</span>):</span><br><span class="line">    init_list.append(i)</span><br><span class="line">print(init_list)  <span class="comment"># [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 乘法</span></span><br><span class="line">init_list = [<span class="number">0</span>] * <span class="number">10</span>  <span class="comment"># [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</span></span><br></pre></td></tr></table></figure><h1 id="x-参考"><a class="markdownIt-Anchor" href="#x-参考"></a> X 参考</h1><ul><li><a href="https://blog.csdn.net/QQ18180564/article/details/105839040" target="_blank" rel="noopener">python------用多种方法生成1到100的列表并打印</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Python" scheme="https://dragonliu2022.github.io/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>matplotlib画图出现中文乱码</title>
    <link href="https://dragonliu2022.github.io/2022/05/12/matplotlib%E7%94%BB%E5%9B%BE%E5%87%BA%E7%8E%B0%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/"/>
    <id>https://dragonliu2022.github.io/2022/05/12/matplotlib%E7%94%BB%E5%9B%BE%E5%87%BA%E7%8E%B0%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/</id>
    <published>2022-05-12T14:32:27.000Z</published>
    <updated>2022-05-12T14:35:01.118Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-问题描述"><a class="markdownIt-Anchor" href="#1-问题描述"></a> 1 问题描述</h1><p>使用matplotlib画图，其中x和y轴标题中出现中文乱码。</p><h1 id="2-解决"><a class="markdownIt-Anchor" href="#2-解决"></a> 2 解决</h1><p>在代码前面加入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pylab <span class="keyword">import</span> *</span><br><span class="line">mpl.rcParams[<span class="string">'font.sans-serif'</span>] = [<span class="string">'SimHei'</span>]</span><br><span class="line">mpl.rcParams[<span class="string">'axes.unicode_minus'</span>] = <span class="literal">False</span></span><br></pre></td></tr></table></figure><h1 id="3-参考"><a class="markdownIt-Anchor" href="#3-参考"></a> 3 参考</h1><ul><li><a href="https://blog.csdn.net/xjh163/article/details/101076551" target="_blank" rel="noopener">python中画图显示中文乱码</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="环境与工具" scheme="https://dragonliu2022.github.io/categories/环境与工具/"/>
    
    <category term="Python" scheme="https://dragonliu2022.github.io/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>git报错之error: object file .git/objects/31/65329bb680e30595f242b7c4d8406ca63eeab0 is empty</title>
    <link href="https://dragonliu2022.github.io/2022/05/11/git%E6%8A%A5%E9%94%99%E4%B9%8Berror-object-file-git-objects-31-65329bb680e30595f242b7c4d8406ca63eeab0-is-empty/"/>
    <id>https://dragonliu2022.github.io/2022/05/11/git%E6%8A%A5%E9%94%99%E4%B9%8Berror-object-file-git-objects-31-65329bb680e30595f242b7c4d8406ca63eeab0-is-empty/</id>
    <published>2022-05-10T16:34:25.000Z</published>
    <updated>2022-05-12T14:29:06.771Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-问题"><a class="markdownIt-Anchor" href="#1-问题"></a> 1 问题</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error: object file .git/objects/31/65329bb680e30595f242b7c4d8406ca63eeab0 is empty</span><br><span class="line">fatal: loose object 3165329bb680e30595f242b7c4d8406ca63eeab0 (stored <span class="keyword">in</span> .git/objects/31/65329bb680e30595f242b7c4d8406ca63eeab0) is corrupt</span><br></pre></td></tr></table></figure><h1 id="2-解决"><a class="markdownIt-Anchor" href="#2-解决"></a> 2 解决</h1><h1 id="3-参考"><a class="markdownIt-Anchor" href="#3-参考"></a> 3 参考</h1><ul><li><a href="https://segmentfault.com/a/1190000008734662" target="_blank" rel="noopener">git错误：对象文件为空（object-file-is-empty）解决方案</a></li><li><a href="https://stackoverflow.com/questions/11706215/how-can-i-fix-the-git-error-object-file-is-empty" target="_blank" rel="noopener">How can I fix the Git error “object file … is empty”?</a></li><li><a href="https://localcoder.org/git-status-shows-fatal-bad-object-head" target="_blank" rel="noopener">git status shows fatal: bad object HEAD</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="环境与工具" scheme="https://dragonliu2022.github.io/categories/环境与工具/"/>
    
    
    <category term="Git" scheme="https://dragonliu2022.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>git报错之error: refs/heads/pa2 does not point to a valid object</title>
    <link href="https://dragonliu2022.github.io/2022/05/10/git%E6%8A%A5%E9%94%99%E4%B9%8Berror-refs-heads-pa2-does-not-point-to-a-valid-object/"/>
    <id>https://dragonliu2022.github.io/2022/05/10/git%E6%8A%A5%E9%94%99%E4%B9%8Berror-refs-heads-pa2-does-not-point-to-a-valid-object/</id>
    <published>2022-05-10T15:31:38.000Z</published>
    <updated>2022-05-12T14:35:27.373Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-问题引入"><a class="markdownIt-Anchor" href="#1-问题引入"></a> 1 问题引入</h1><p>目前项目有两个分支：pa1和pa2。pa1分支没有更新到云端，需要更新；pa2分支出现问题。</p><p><strong>目标</strong>：删除pa2分支，将pa1 push到云端。</p><h1 id="2-解决"><a class="markdownIt-Anchor" href="#2-解决"></a> 2 解决</h1><ol><li><p>切换到pa1分支，<code>git checkout pa1</code></p><img src="https://s2.loli.net/2022/05/10/FZmLMNhPlxiUCd1.png" width="550" height="300" alt="图片名称" align="center" id="199"></li><li><p>提交本地pa2修改的代码，出现如下报错：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br><span class="line">$ git commit</span><br><span class="line">fatal: could not parse HEAD</span><br></pre></td></tr></table></figure></li><li><p>强制切换pa1分支：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -f pa1</span><br></pre></td></tr></table></figure></li><li><p>将pa1分支push到云端，出现报错：</p><img src="https://s2.loli.net/2022/05/10/iNlGDgz2kVKxjoW.png" width="650" height="100" alt="图片名称" align="center" id="200"></li><li><p>执行下面的操作再进行push操作，成功执行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm .git/refs/heads/pa2</span><br></pre></td></tr></table></figure></li></ol><h1 id="3-参考"><a class="markdownIt-Anchor" href="#3-参考"></a> 3 参考</h1><ul><li><a href="https://stackoverflow.com/questions/20694882/how-do-i-delete-a-local-git-branch-when-it-cant-look-up-commit-object-in-refs" target="_blank" rel="noopener">How do I delete a local git branch when it can’t look up commit object in ‘refs/heads’?</a></li><li><a href="https://zhuanlan.zhihu.com/p/426003354" target="_blank" rel="noopener">解决git报错fatal: could not parse HEAD</a></li><li><a href="https://blog.csdn.net/SMonkeyKing/article/details/89850416" target="_blank" rel="noopener">【git操作】强制切换到本地某个分支</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="环境与工具" scheme="https://dragonliu2022.github.io/categories/环境与工具/"/>
    
    
    <category term="Git" scheme="https://dragonliu2022.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Python-os模块-文件(夹)操作</title>
    <link href="https://dragonliu2022.github.io/2022/04/23/Python-os%E6%A8%A1%E5%9D%97-%E6%96%87%E4%BB%B6-%E5%A4%B9-%E6%93%8D%E4%BD%9C/"/>
    <id>https://dragonliu2022.github.io/2022/04/23/Python-os%E6%A8%A1%E5%9D%97-%E6%96%87%E4%BB%B6-%E5%A4%B9-%E6%93%8D%E4%BD%9C/</id>
    <published>2022-04-23T08:47:23.000Z</published>
    <updated>2022-04-24T14:31:58.911Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-判断文件夹是否存在"><a class="markdownIt-Anchor" href="#1-判断文件夹是否存在"></a> 1 判断文件(夹)是否存在</h1><p><strong>参考</strong>：<a href="https://www.cnblogs.com/jhao/p/7243043.html" target="_blank" rel="noopener">Python判断文件是否存在的三种方法</a></p><p><code>os</code>模块中的<code>os.path.exists()</code>方法用于检验文件是否存在。</p><p>判断文件(夹)是否存在：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.path.exists(path)</span><br><span class="line"><span class="comment">#True</span></span><br><span class="line"></span><br><span class="line">os.path.exists(path)</span><br><span class="line"><span class="comment">#False</span></span><br></pre></td></tr></table></figure><p><strong>问题</strong>：如果文件夹和文件同路径+同名会出现bug。</p><p>只检查文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.path.isfile(<span class="string">"test-data"</span>)</span><br></pre></td></tr></table></figure><h1 id="2-创建目录"><a class="markdownIt-Anchor" href="#2-创建目录"></a> 2 创建目录</h1><p><strong>参考</strong>：<a href="https://blog.csdn.net/MuWinter/article/details/77215768" target="_blank" rel="noopener">python创建目录（文件夹）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.path.exists(path) <span class="comment"># 判断一个目录是否存在</span></span><br><span class="line"></span><br><span class="line">os.makedirs(path) <span class="comment"># 创建多级目录</span></span><br><span class="line"></span><br><span class="line">os.mkdir(path) <span class="comment"># 创建单级目录</span></span><br></pre></td></tr></table></figure><h1 id="3-复制文件"><a class="markdownIt-Anchor" href="#3-复制文件"></a> 3 复制文件</h1><p><strong>参考</strong>：<a href="https://zhuanlan.zhihu.com/p/35725217" target="_blank" rel="noopener">用Python复制文件的9个方法</a></p><p>这是运行任何系统命令的最常用方式。使用 system() 方法，你可以调用 subshell 中的任何命令。在内部，该方法将调用 C 语言的标准库函数。该方法返回该命令的退出状态。</p><p>对于 Windows 系统：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.system(<span class="string">'copy 1.txt.py 2.txt.py'</span>)</span><br><span class="line">os.system(<span class="string">f'copy <span class="subst">&#123;source&#125;</span> <span class="subst">&#123;target&#125;</span>'</span>)</span><br></pre></td></tr></table></figure><p>对于 Liunx 系统：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.system(<span class="string">'cp 1.txt.py 2.txt.py'</span>)</span><br></pre></td></tr></table></figure><p>速度较慢，大量文件复制效果不佳。</p><h1 id="4-路径拼接"><a class="markdownIt-Anchor" href="#4-路径拼接"></a> 4 路径拼接</h1><p>os.path.join()函数用于路径拼接文件路径：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">dir = <span class="string">"xxx"</span></span><br><span class="line">file_name = <span class="string">"xxx"</span></span><br><span class="line"></span><br><span class="line">path = os.path.join(dir, file_name)</span><br></pre></td></tr></table></figure><h1 id="5-删除文件夹"><a class="markdownIt-Anchor" href="#5-删除文件夹"></a> 5 删除文件(夹)</h1><p><strong>参考</strong>：<a href="https://developer.51cto.com/article/648822.html" target="_blank" rel="noopener">Python中删除文件的几种方法</a></p><p><strong>删除文件</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.remove(path)</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：如果文件在之前被打开，会出现报错：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    os.remove(file_path)</span><br><span class="line">PermissionError: [WinError <span class="number">32</span>] 另一个程序正在使用此文件，进程无法访问。: <span class="string">'data3\\dataset\\test\\Benign\\4447.txt'</span></span><br></pre></td></tr></table></figure><p>所以删除前要关闭文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">file_path = os.path.join(type_dir, name)</span><br><span class="line">f = open(file_path, <span class="string">"r"</span>)</span><br><span class="line">f.close()</span><br><span class="line">os.remove(file_path)</span><br></pre></td></tr></table></figure><hr><p><strong>删除目录</strong>：Python中的<code>os.remove()</code>方法用于删除文件路径。此方法无法删除目录。如果指定的路径是目录，则该方法将引发OSError。可以使用下面代码删除目录：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.rmdir(dir_path)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Python" scheme="https://dragonliu2022.github.io/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>pylab.show()或plt.show()报错</title>
    <link href="https://dragonliu2022.github.io/2022/04/22/pylab-show-%E6%88%96plt-show-%E6%8A%A5%E9%94%99/"/>
    <id>https://dragonliu2022.github.io/2022/04/22/pylab-show-%E6%88%96plt-show-%E6%8A%A5%E9%94%99/</id>
    <published>2022-04-22T12:04:21.000Z</published>
    <updated>2022-04-22T12:11:51.525Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-pylabshow问题"><a class="markdownIt-Anchor" href="#1-pylabshow问题"></a> 1 pylab.show()问题</h1><p>最近使用实验室的机子进行模型训练，<strong>发生报错</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XIO:  fatal IO error 0 (Success) on X server <span class="string">"localhost:13.0"</span></span><br><span class="line">      after 355 requests (355 known processed) with 2 events remaining.</span><br></pre></td></tr></table></figure><p><strong>定位代码</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pylab.show()</span><br></pre></td></tr></table></figure><p><strong>原因</strong>：机子没有界面，导致显示失败。</p><p><strong>解决</strong>：只需将图片保存，而非显示。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pylab.show()</span></span><br><span class="line">pylab.savefig(<span class="string">'./data/net_pic/textcnn_100_0.001_300.jpg'</span>)</span><br></pre></td></tr></table></figure><h1 id="2-pltshow问题"><a class="markdownIt-Anchor" href="#2-pltshow问题"></a> 2 plt.show()问题</h1><p>之前一个同学也遇到了类似的报错：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UserWarning: Matplotlib is currently using agg, <span class="built_in">which</span> is a non GUI backend, so cannot show the figure.</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><strong>定位代码</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><strong>解决方法</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># plt.show()</span></span><br><span class="line">plt.savefig(<span class="string">'./data/net_pic/textcnn_100_0.001_300.jpg'</span>)</span><br></pre></td></tr></table></figure><h1 id="x-参考"><a class="markdownIt-Anchor" href="#x-参考"></a> X 参考</h1><ul><li><a href="https://blog.csdn.net/m0_37052320/article/details/79640467" target="_blank" rel="noopener">python matplotlib 画图保存图片简单例子</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="环境与工具" scheme="https://dragonliu2022.github.io/categories/环境与工具/"/>
    
    
  </entry>
  
  <entry>
    <title>Pycharm远程开发</title>
    <link href="https://dragonliu2022.github.io/2022/04/21/PyCharm%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    <id>https://dragonliu2022.github.io/2022/04/21/PyCharm%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91/</id>
    <published>2022-04-21T14:22:11.000Z</published>
    <updated>2022-04-24T15:18:34.516Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-引入"><a class="markdownIt-Anchor" href="#1-引入"></a> 1 引入</h1><p>最近跑深度学习模型，自己的笔记本吃不消了，于是打算使用实验室的机子。为了提高开发效率，使用PyCharm进行远程开发。</p><h1 id="2-查看远程环境"><a class="markdownIt-Anchor" href="#2-查看远程环境"></a> 2 查看远程环境</h1><ol><li><p>使用<code>MobaXterm</code>软件登陆实验室的机子，并将代码+数据集上传至指定位置；（其实这一步可以不做，在后面使用PyCharm进行同步）</p></li><li><p>查看机子的系统：Centos7</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/os-release</span><br><span class="line">NAME=<span class="string">"CentOS Linux"</span></span><br><span class="line">VERSION=<span class="string">"7 (Core)"</span></span><br><span class="line">ID=<span class="string">"centos"</span></span><br><span class="line">ID_LIKE=<span class="string">"rhel fedora"</span></span><br><span class="line">VERSION_ID=<span class="string">"7"</span></span><br><span class="line">PRETTY_NAME=<span class="string">"CentOS Linux 7 (Core)"</span></span><br><span class="line">ANSI_COLOR=<span class="string">"0;31"</span></span><br><span class="line">CPE_NAME=<span class="string">"cpe:/o:centos:centos:7"</span></span><br><span class="line">HOME_URL=<span class="string">"https://www.centos.org/"</span></span><br><span class="line">BUG_REPORT_URL=<span class="string">"https://bugs.centos.org/"</span></span><br><span class="line"></span><br><span class="line">CENTOS_MANTISBT_PROJECT=<span class="string">"CentOS-7"</span></span><br><span class="line">CENTOS_MANTISBT_PROJECT_VERSION=<span class="string">"7"</span></span><br><span class="line">REDHAT_SUPPORT_PRODUCT=<span class="string">"centos"</span></span><br><span class="line">REDHAT_SUPPORT_PRODUCT_VERSION=<span class="string">"7"</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="3-配置远程python环境"><a class="markdownIt-Anchor" href="#3-配置远程python环境"></a> 3 配置远程Python环境</h1><ol><li><p>发现机子是使用conda管理python的，查看系统中的所有环境：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(base) [ccyin@localhost Malware-Detection]$ conda info -e</span><br><span class="line"><span class="comment"># conda environments:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">base                  *  /home/ccyin/miniconda3</span><br><span class="line">junxuan                  /home/ccyin/miniconda3/envs/junxuan</span><br></pre></td></tr></table></figure></li><li><p>创建环境，名称为<code>malware</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda create --name malware python=3.9</span><br><span class="line"><span class="comment"># 指定Python版本是3.9（不用管是3.9.x，conda会为我们自动寻找3.9.x中的最新版本）</span></span><br></pre></td></tr></table></figure></li><li><p>激活环境：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(base) [ccyin@localhost Malware-Detection]$ <span class="built_in">source</span> activate malware</span><br><span class="line">(malware) [ccyin@localhost Malware-Detection]$</span><br></pre></td></tr></table></figure><p>命令行前出现<code>(malware)</code>证明成功激活<code>malware</code>环境</p></li><li><p>查看python版本：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(malware) [ccyin@localhost Malware-Detection]$ python --version</span><br><span class="line">Python 3.9.12</span><br></pre></td></tr></table></figure></li><li><p>安装一些库：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install torch</span><br><span class="line">pip install torchvision</span><br><span class="line">pip install d2l</span><br></pre></td></tr></table></figure></li><li><p>查看已经安装的库：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda list</span><br></pre></td></tr></table></figure></li></ol><h1 id="4-本地代码备份"><a class="markdownIt-Anchor" href="#4-本地代码备份"></a> 4 本地代码备份</h1><p>后期本地与服务器的代码同步，以防万一，把本地代码整到GitHub上。</p><ol><li><p>在项目主目录生成空版本库；</p></li><li><p>由于数据集占空间较大，不上传云端，所以新建<code>.gitignore</code>将一些文件夹进行忽略：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.idea</span><br><span class="line">__pycache__</span><br><span class="line">data</span><br><span class="line">model</span><br></pre></td></tr></table></figure></li><li><p>Github上新建仓库，然后将本地代码push上去。</p></li></ol><h1 id="5-配置pycharm"><a class="markdownIt-Anchor" href="#5-配置pycharm"></a> 5 配置PyCharm</h1><ol><li><p>将本地的<code>Python Interperter</code>更换为远端的，新建python解释器，选择<code>SSH Interpreter</code>，输入IP+用户名+密码：</p><img src="https://s2.loli.net/2022/04/21/mQNWwoLCqUBE3Zi.png" width="800" height="500" alt="图片名称" align="center" id="191"></li><li><p>查找conda虚拟环境<code>malware</code>中的解释器：（<code>3 配置远程Python环境</code>中已经创建好<code>malware</code>虚拟环境）</p><p>首先确定虚拟环境<code>malware</code>的目录：<code>/home/ccyin/miniconda3/envs/malware</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ conda info -e</span><br><span class="line"><span class="comment"># conda environments:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">base                     /home/ccyin/miniconda3</span><br><span class="line">malware               *  /home/ccyin/miniconda3/envs/malware</span><br></pre></td></tr></table></figure><p>然后点开<code>bin</code>，选择<code>python</code>（<strong>注意是<code>python</code>不是<code>python3</code></strong>）</p><img src="https://s2.loli.net/2022/04/21/6VolZ1XPqikx7rB.png" width="750" height="500" alt="图片名称" align="center" id="192"></li><li><p>选择好解释器之后，就要确定项目在服务器上的同步路径，默认是在<code>/tmp/</code>下的文件夹中，现在修改为之前上传的目录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(malware) [ccyin@localhost Malware-Detection]$ <span class="built_in">pwd</span></span><br><span class="line">/home/ccyin/zhenlong/Malware-Detection</span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2022/04/21/35wchZX61t7Jqnv.png" width="750" height="500" alt="图片名称" align="center" id="193"></li><li><p>点击确定后，然后在<code>Collectiong files...</code>和<code>Uploading xxx</code>，应该是更新远端文件，因为数据集中有许多文件，所以比较慢；（这样看来，之前上传代码+数据集显得多此一举🥦）</p></li><li><p>更新完毕后，可以<strong>从右边“remote host”中看到服务器上的文件</strong>，而且标绿了，表示其为我们对应的同步路径：</p><img src="https://s2.loli.net/2022/04/22/Mu5KH72ORaS6oQi.png" width="550" height="500" alt="图片名称" align="center" id="194"></li><li><p><strong>要对该文件进行修改时，注意一定要先Download下来</strong>，<strong>不可直接双击点开</strong>。Remote Host里的文件，当你执行非打开操作的时候，所指代的都是服务器上的文件，比如你可以从这里选择下载，进行比对操作等。但是当你从Remote Host双击打开文件时，这时打开的就不是服务器上的，而是一个镜像文件。所以如果直接修改从Remote Host双击打开的文件，修改是无效的。一定要先下载下来，进行修改，然后再上传过去。（<strong>第7步设置自动同步，这样本地的修改会自动上传至远端，但是在远端修改或添加删除文件，不会影响本地</strong>）</p><img src="https://s2.loli.net/2022/04/22/QaDvPkOryYlbmgx.png" width="450" height="250" alt="图片名称" align="center" id="195"></li><li><p>确保工具栏中的<code>Tools/Deployment/Automatic Upload</code>前面有对勾（默认有），这样以来，在本地的修改会自动同步到服务器上，我不需要手动进行上传。</p><img src="https://s2.loli.net/2022/04/22/lVEc6rSKUWR5LPi.png" width="450" height="300" alt="图片名称" align="center" id="196"></li><li><p>此外，如果运行python文件需要使用到命令行参数的时候，可以在<code>Configurations</code>中进行增加：</p><img src="https://s2.loli.net/2022/04/22/yYbOl6i5cxI2zXg.png" width="750" height="400" alt="图片名称" align="center" id="197"></li></ol><h1 id="6-后台运行py脚本"><a class="markdownIt-Anchor" href="#6-后台运行py脚本"></a> 6 后台运行py脚本</h1><p>训练脚本耗时长，使用pycharm直接运行脚本，可能会因为笔记本息屏、断网等因素而中断，所以考虑将脚本挂在后台运行。</p><ol><li><p>使用<code>MobaXterm</code>登陆远程主机；</p></li><li><p>切换到项目目录并激活虚拟机环境；</p></li><li><p>后台运行脚本：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(malware) [ccyin@localhost Malware-Detection]$ nohup python -u train_textcnn.py &gt; textcnn.log 2&gt;&amp;1 &amp;</span><br><span class="line">[1] 46583</span><br><span class="line">(malware) [ccyin@localhost Malware-Detection]$ nohup python -u train_rnn.py &gt; rnn.log 2&gt;&amp;1 &amp;</span><br><span class="line">[2] 46823</span><br></pre></td></tr></table></figure></li><li><p>检查下后台是否运行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(malware) [ccyin@localhost Malware-Detection]$ ps aux|grep python</span><br><span class="line">...</span><br><span class="line">ccyin     46583 70.4  4.3 67868816 11451892 pts/13 Rl 14:20   1:47 python -u train_textcnn.py</span><br><span class="line">ccyin     46823  129  0.8 41704128 2243816 pts/13 Rl 14:23   0:09 python -u train_rnn.py</span><br></pre></td></tr></table></figure></li><li><p>此时后台成功运行，笔记本断网、关机都不会影响脚本的运行。</p></li></ol><h1 id="7-取消后台运行"><a class="markdownIt-Anchor" href="#7-取消后台运行"></a> 7 取消后台运行</h1><ol><li><p>确定运行脚本的进程ID(<code>6.3</code>中已经给出ID)，也可以通过下面的命令获取：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(malware) [ccyin@localhost Malware-Detection]$ ps aux|grep python</span><br><span class="line">...</span><br><span class="line">ccyin     46583 70.4  4.3 67868816 11451892 pts/13 Rl 14:20   1:47 python -u train_textcnn.py</span><br><span class="line">ccyin     46823  129  0.8 41704128 2243816 pts/13 Rl 14:23   0:09 python -u train_rnn.py</span><br></pre></td></tr></table></figure></li><li><p>杀掉进程：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">kill</span> -9 46583</span><br><span class="line">$ <span class="built_in">kill</span> -9 46823</span><br></pre></td></tr></table></figure></li></ol><h1 id="x-参考"><a class="markdownIt-Anchor" href="#x-参考"></a> X 参考</h1><ul><li><a href="https://www.jianshu.com/p/a09a9b40ad20" target="_blank" rel="noopener">Git忽略文件.gitignore的使用</a></li><li><a href="https://zhuanlan.zhihu.com/p/44398592" target="_blank" rel="noopener">Conda使用指南</a></li><li><a href="https://zhuanlan.zhihu.com/p/93236936" target="_blank" rel="noopener">PyCharm远程开发的配置与流程</a></li><li><a href="https://www.jianshu.com/p/4041c4e6e1b0" target="_blank" rel="noopener">linux 下后台运行python脚本</a></li><li><a href="https://blog.csdn.net/lingyunxianhe/article/details/119328987" target="_blank" rel="noopener">nohup后台python3程序及关闭</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="环境与工具" scheme="https://dragonliu2022.github.io/categories/环境与工具/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL-错误1153：max_allowed_packet</title>
    <link href="https://dragonliu2022.github.io/2022/04/20/MySQL-%E9%94%99%E8%AF%AF1153%EF%BC%9Amax_allowed_packet/"/>
    <id>https://dragonliu2022.github.io/2022/04/20/MySQL-%E9%94%99%E8%AF%AF1153%EF%BC%9Amax_allowed_packet/</id>
    <published>2022-04-20T06:53:01.000Z</published>
    <updated>2022-04-20T07:01:05.376Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-问题"><a class="markdownIt-Anchor" href="#1-问题"></a> 1 问题</h1><p>编码过程中，有个字段使用<code>TEXT</code>无法存储，改用<code>TEXT(65536)</code> 后成功存储，但是导入mysql时报错：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (1153, <span class="string">"Got a packet bigger than 'max_allowed_packet' bytes"</span>)</span><br></pre></td></tr></table></figure><p>原因：<code>TEXT(65536)</code>为16M，超过了上限<code>max_allowed_packet</code>。</p><h1 id="2-解决"><a class="markdownIt-Anchor" href="#2-解决"></a> 2 解决</h1><p>修改<code>max_allowed_packet</code>值即可，在Mysql命令行运行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="built_in">set</span> global net_buffer_length=1000000; </span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="built_in">set</span> global max_allowed_packet=1000000000;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><h1 id="3-参考"><a class="markdownIt-Anchor" href="#3-参考"></a> 3 参考</h1><ul><li><a href="https://stackoverflow.com/questions/93128/mysql-error-1153-got-a-packet-bigger-than-max-allowed-packet-bytes" target="_blank" rel="noopener">MySQL Error 1153 - Got a packet bigger than ‘max_allowed_packet’ bytes</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Python" scheme="https://dragonliu2022.github.io/categories/Python/"/>
    
    <category term="数据库" scheme="https://dragonliu2022.github.io/categories/数据库/"/>
    
    
    <category term="MySQL" scheme="https://dragonliu2022.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>C++新标准</title>
    <link href="https://dragonliu2022.github.io/2022/04/19/C++%E6%96%B0%E6%A0%87%E5%87%86/"/>
    <id>https://dragonliu2022.github.io/2022/04/19/C++%E6%96%B0%E6%A0%87%E5%87%86/</id>
    <published>2022-04-19T05:58:58.000Z</published>
    <updated>2022-04-19T06:02:00.154Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><ul><li>《面向对象C++程序设计》皮德常 编著 清华大学出版社 2017</li><li>《C++ Primer Plus (第6版)中文版》Stephen Prata 著 张海龙 袁国忠 译 人民邮电出版社 2012</li></ul></blockquote><h1 id="1-c11-的新特性"><a class="markdownIt-Anchor" href="#1-c11-的新特性"></a> 1 C++11 的新特性</h1><ol><li>核心特性：<strong>智能指针、右值引用、移动语义、完美转发、lambda 表达式</strong>（必答）</li><li>其它特性：auto、decltype、long long、函数返回类型自动推导、删除函数、列表初始化、nullptr、using 声明、限定作用域的枚举类型、const_iterator、override 声明、noexcept 声明、constexpr、范围 for 循环</li></ol><h1 id="2-智能指针"><a class="markdownIt-Anchor" href="#2-智能指针"></a> 2 智能指针</h1><p>C++11 中引入了智能指针的概念，<strong>方便管理堆内存</strong>。</p><ul><li>智能指针是利用了一种叫做 RAII（资源获取即初始化）的技术对普通的指针进行封装，这使得智能指针实质是一个对象，行为表现的却像一个指针。</li><li>智能指针的作用是防止忘记调用delete释放内存和程序异常的进入catch块忘记释放内存。另外指针的释放时机也是非常有考究的，多次释放同一个指针会造成程序崩溃，这些都可以通过智能指针来解决。</li><li>智能指针还有一个作用是把值语义转换成引用语义。</li></ul><ol><li><strong>unique_ptr</strong>：实现的是专属所有权的语义，它是智能指针的默认选项。unique_ptr 是个只移型别，不能复制或共享。unique_ptr 小巧高效，大小等同于一个指针且支持右值引用，从而可实现快速插入和对 STL 集合的检索。</li><li><strong>shared_ptr</strong>：采用引用计数的智能指针。如果你想要将一个裸指针分配给多个所有者，请使用该指针。直至所有 shared_ptr 所有者超出了范围或放弃所有权，才会删除裸指针。大小为两个裸指针：一个用于指向裸指针指向的对象，另一个用于指向包含引用计数的共享控制块。</li><li><strong>weak_ptr</strong> ：结合 shared_ptr 使用的特例智能指针。 weak_ptr 提供对一个或多个 shared_ptr 实例拥有的对象的访问，但不参与引用计数。如果你想要观察某个对象但不需要其保持活动状态，请使用该实例。在某些情况下，用于断开 shared_ptr 实例间的循环引用。</li></ol><p><a href="https://www.cnblogs.com/wxquare/p/4759020.html" target="_blank" rel="noopener">https://www.cnblogs.com/wxquare/p/4759020.html</a></p><h1 id="3-右值引用"><a class="markdownIt-Anchor" href="#3-右值引用"></a> 3 右值引用</h1><p>左值和右值的概念</p><p>值引用的目的是为了延长用来初始化对象的生命周期。</p><p><a href="https://zhuanlan.zhihu.com/p/54050093" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/54050093</a></p><h1 id="4-移动语义"><a class="markdownIt-Anchor" href="#4-移动语义"></a> 4 移动语义</h1><p>将内存的所有权从一个对象转移到另外一个对象，高效的移动用来替换效率低下的复制，对象的移动语义需要实现移动构造函数（move constructor）和移动赋值运算符（move assignment operator）。</p><h1 id="5-完美转发"><a class="markdownIt-Anchor" href="#5-完美转发"></a> 5 完美转发</h1><p>定义一个函数模板，该函数模板可以接收任意类型参数，然后将参数转发给其它目标函数，且保证目标函数接受的参数其类型与传递给模板函数的类型相同。</p><h1 id="6-lambda-表达式"><a class="markdownIt-Anchor" href="#6-lambda-表达式"></a> 6 lambda 表达式</h1><p>利用Lambda表达式，可以方便的定义和创建匿名函数。</p><p><a href="https://www.cnblogs.com/DswCnblog/p/5629165.html" target="_blank" rel="noopener">https://www.cnblogs.com/DswCnblog/p/5629165.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="C++" scheme="https://dragonliu2022.github.io/categories/C/"/>
    
    
    <category term="面试" scheme="https://dragonliu2022.github.io/tags/面试/"/>
    
  </entry>
  
  <entry>
    <title>C++编译与底层</title>
    <link href="https://dragonliu2022.github.io/2022/04/19/C++%E7%BC%96%E8%AF%91%E4%B8%8E%E5%BA%95%E5%B1%82/"/>
    <id>https://dragonliu2022.github.io/2022/04/19/C++%E7%BC%96%E8%AF%91%E4%B8%8E%E5%BA%95%E5%B1%82/</id>
    <published>2022-04-19T05:58:45.000Z</published>
    <updated>2022-04-19T06:03:35.217Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><ul><li>《面向对象C++程序设计》皮德常 编著 清华大学出版社 2017</li><li>《C++ Primer Plus (第6版)中文版》Stephen Prata 著 张海龙 袁国忠 译 人民邮电出版社 2012</li></ul></blockquote><h1 id="1-栈区和堆区的区别"><a class="markdownIt-Anchor" href="#1-栈区和堆区的区别"></a> 1 栈区和堆区的区别</h1><ol><li><p><strong>申请方式</strong></p><ul><li>栈区：由编译器自动分配释放，存放函数的参数值，局部变量值等；</li><li>堆区：一般由程序员分配释放（使用new/delete或malloc/free），若程序员不释放，程序结束时可能由OS回收。</li></ul></li><li><p><strong>操作方式</strong></p><ul><li>栈区：操作方式类似于数据结构中的栈；</li><li>堆区：不同于数据结构中的堆，分配方式类似于链表。</li></ul></li><li><p><strong>申请后系统的响应</strong></p><ul><li>栈区：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出；</li><li>堆区：操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。</li></ul></li><li><p><strong>申请大小的限制</strong></p><ul><li>栈区：在Windows下，栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。</li><li>堆区：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</li></ul></li><li><p><strong>申请效率的比较</strong></p><ul><li><p>栈区：系统自动分配，速度较快。但程序员是无法控制的。</p></li><li><p>堆区：由new分配的内存，一般速度比较慢，而且容易产生内存碎片，不过用起来最方便.</p></li></ul></li><li><p><strong>堆和栈中的存储内容</strong></p><ul><li>栈区：在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。</li></ul></li></ol><ul><li>堆区：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。</li></ul><h1 id="2-c语言程序从源代码到二进制行程序都经历了那些过程"><a class="markdownIt-Anchor" href="#2-c语言程序从源代码到二进制行程序都经历了那些过程"></a> 2 C语言程序从源代码到二进制行程序都经历了那些过程？</h1><p><a href="https://www.cnblogs.com/CarpenterLee/p/5994681.html" target="_blank" rel="noopener">https://www.cnblogs.com/CarpenterLee/p/5994681.html</a></p><ol><li>预处理(Preprocessing)：预处理用于将所有的#include头文件以及宏定义替换成其真正的内容，预处理之后得到的仍然是文本文件，但文件体积会大很多。gcc的预处理是预处理器cpp来完成的；</li><li>编译(Compilation)：将经过预处理之后的程序转换成特定汇编代码(assembly code)的过程；命令中<code>-S</code>让编译器在编译之后停止，不进行后续过程。</li><li>汇编(Assemble)：将上一步的汇编代码转换成机器码(machine code)，这一步产生的文件叫做目标文件，是二进制格式。gcc汇编过程通过as命令完成。</li><li>链接(Linking)：链接过程将多个目标文以及所需的库文件(.so等)链接成最终的可执行文件(executable file)。</li></ol><h1 id="3-cc的内存分配方式"><a class="markdownIt-Anchor" href="#3-cc的内存分配方式"></a> 3 <strong>C/C++的内存分配方式</strong></h1><h2 id="31-c"><a class="markdownIt-Anchor" href="#31-c"></a> 3.1 C</h2><img src="https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/24708340_1325647816h2y2.jpg" width="400" height="400" alt="图片名称" align="center" id="190"><table><thead><tr><th style="text-align:center">栈(stack)</th><th style="text-align:left">由编译器自动分配、翻译。存放函数的参数值和局部变量值。操作方式类似数据结构中的栈</th></tr></thead><tbody><tr><td style="text-align:center">堆(heap)</td><td style="text-align:left">由程序员分配释放。程序员不释放，程序结束时有可能由OS释放。与数据结构中的堆不同，操作方式类似于链表</td></tr><tr><td style="text-align:center">bss</td><td style="text-align:left">存放未初始化的全局变量和静态变量</td></tr><tr><td style="text-align:center">数据段data</td><td style="text-align:left">存放初始化之后的全局变量、静态变量和常量</td></tr><tr><td style="text-align:center">代码段text</td><td style="text-align:left">程序代码主体，函数主体等。注意为二进制格式</td></tr></tbody></table><h2 id="32-c"><a class="markdownIt-Anchor" href="#32-c"></a> 3.2 C++</h2><ol><li>栈</li><li>堆</li><li>全局/静态存储区</li><li>常量存储区</li><li>程序代码区</li></ol><h1 id="4-int-有几个字节"><a class="markdownIt-Anchor" href="#4-int-有几个字节"></a> 4 <strong>int 有几个字节？</strong></h1><p>C语言标准规定了每种数据类型的最小取值范围，例如int类型至少应为16位(2字节)，int类型数据具体的取值范围则由ABI规范规定。通常，int型在16位机器中为16位，在32位和64位机器中都为32位。(计组课本P42)</p><p>ABI指应用二进制接口，规定了二进制程序两个模块之间或者二进制程序与操作系统之间的接口。</p><p>2 或 4 个字节，具体取决于编译器。<strong>千万不要直接答4个字节</strong></p><h1 id="5-内存对齐的原则"><a class="markdownIt-Anchor" href="#5-内存对齐的原则"></a> 5 内存对齐的原则</h1><p>从0位置开始存储；变量存储的起始位置是该变量大小的整数倍；结构体总的大小是其最大元素的整数倍，不足的后面要补齐。</p><ol><li>数据成员对齐规则：结构体的数据成员，第一个数据成员放在offset为0的地方，之后的每个数据成员存储的起始位置要从该成员大小的整数倍开始（比如int在32位机子上为4字节，所以要从4的整数倍地址开始存储）。</li><li>结构体作为成员：如果一个结构体里同时包含结构体成员，则结构体成员要从其内部最大元素大小的整数倍地址开始存储（如struct a里有struct b，b里有char,int,double等元素，那么b应该从8(即double类型的大小)的整数倍开始存储）。</li><li>结构体的总大小：即sizeof的结果。在按之前的对齐原则计算出来的大小的基础上，必须还得是其内部最大成员的整数倍，不足的要补齐（如struct里最大为double，现在计算得到的已经是11，则总大小为16）。</li></ol><h1 id="6-main-函数执行以前还会执行什么代码"><a class="markdownIt-Anchor" href="#6-main-函数执行以前还会执行什么代码"></a> 6 <strong>main 函数执行以前，还会执行什么代码？</strong></h1><p>全局对象的构造函数会在 main 函数之前执行。</p><h1 id="7-空类编译器会自动生成哪些函数"><a class="markdownIt-Anchor" href="#7-空类编译器会自动生成哪些函数"></a> 7 <strong>空类编译器会自动生成哪些函数</strong></h1><p>默认构造函数、析构函数、拷贝构造函数、赋值函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="C++" scheme="https://dragonliu2022.github.io/categories/C/"/>
    
    
    <category term="面试" scheme="https://dragonliu2022.github.io/tags/面试/"/>
    
  </entry>
  
  <entry>
    <title>C++STL</title>
    <link href="https://dragonliu2022.github.io/2022/04/19/C++STL/"/>
    <id>https://dragonliu2022.github.io/2022/04/19/C++STL/</id>
    <published>2022-04-19T05:58:31.000Z</published>
    <updated>2022-04-19T06:04:03.386Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><ul><li>《面向对象C++程序设计》皮德常 编著 清华大学出版社 2017</li><li>《C++ Primer Plus (第6版)中文版》Stephen Prata 著 张海龙 袁国忠 译 人民邮电出版社 2012</li></ul></blockquote><h1 id="1-c容器类的底层实现"><a class="markdownIt-Anchor" href="#1-c容器类的底层实现"></a> 1 C++容器类的底层实现</h1><p><strong>以下分别用<code>K</code>、<code>T</code>指代泛型参数</strong>。</p><table><thead><tr><th>C++</th><th>特点</th><th>底层数据结构</th></tr></thead><tbody><tr><td><code>T 变量名[数值]</code>、<code>array&lt;T,数值&gt;</code></td><td>固定大小数组。支持快速随机访问，不能添加和删除元素</td><td>普通数组</td></tr><tr><td><code>vector&lt;T&gt;</code></td><td>可变大小数组。支持快速随机访问，在尾部之外的位置插入或删除元素可能很慢</td><td>数组</td></tr><tr><td><code>list&lt;T&gt;</code></td><td>双向循环链表。只支持双向顺序访问，在任何位置进行插入删除操作都很快</td><td>链表</td></tr><tr><td><code>forward_list&lt;T&gt;</code></td><td>单向链表。只支持单向顺序访问，在任何位置进行插入删除操作都很快</td><td>链表</td></tr><tr><td><code>stack&lt;T&gt;</code></td><td>栈。后进先出容器</td><td>数组或链表</td></tr><tr><td><code>queue&lt;T&gt;</code></td><td>队列。先进先出容器</td><td>数组或链表</td></tr><tr><td><code>deque&lt;T&gt;</code></td><td>双端队列。支持首尾快速增删，也支持随机访问</td><td>底层数据结构为一个中央控制器和多个缓冲区</td></tr><tr><td><code>priority_queue&lt;T&gt;</code></td><td>优先级队列。队列中的元素具有优先级，优先级最高的元素位于队首，队首元素可以弹出队列</td><td>二叉大根堆</td></tr><tr><td><code>unordered_set&lt;T&gt;</code></td><td>集合。关键字无序且不可重复出现</td><td>哈希表</td></tr><tr><td><code>set&lt;T&gt;</code></td><td>集合。关键字有序且不可重复出现</td><td>红黑树</td></tr><tr><td><code>unordered_map&lt;K,T&gt;</code></td><td>关联数组。保存键值对，键值对无序且键不可重复出现</td><td>哈希表</td></tr><tr><td><code>map&lt;K,T&gt;</code></td><td>关联数组。保存键值对，键值对有序且键不可重复出现</td><td>红黑树</td></tr></tbody></table><p>注意 stack、queue、priority_queue 均为容器适配器。stack 和 queue 底层一般用 list 或 deque 实现，不用 vector 的原因应该是容量大小有限制，扩容耗时。priority_queue 一般用 vector 作底层容器。</p><h1 id="2-unordered_map-和-map-区别"><a class="markdownIt-Anchor" href="#2-unordered_map-和-map-区别"></a> 2 unordered_map 和 map 区别</h1><ol><li>map 内部实现了一个红黑树（红黑树是非严格平衡二叉搜索树，而 AVL 是严格平衡二叉搜索树），因此 map 内部的所有元素都是有序的，存取一个元素时间复杂度是 O(logn)</li><li>unordered_map 内部实现了一个哈希表，其元素的排列顺序是无序的，取一个元素时间复杂度是 O(1)</li></ol><h1 id="3-红黑树"><a class="markdownIt-Anchor" href="#3-红黑树"></a> 3 红黑树</h1><p>红黑树是一颗满足如下性质的二叉查找树：</p><ol><li>每个结点或者为黑色或者为红色；</li><li>根结点为黑色；</li><li>每个叶节点为黑色；</li><li>如果一个结点为红色，那么他的两个子结点为黑色；</li><li>对于每个结点，从该节点到其所有子孙叶结点的路径中，所包含的黑色结点数量必须相同。</li></ol><p>红黑树的每个结点的属性除了有一个key、3个指针(parent、lchild、rchild)以外，还有个color属性。</p><p>通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，<strong>红黑树确保没有一条路径会比其它路径长出两倍</strong>。</p><h1 id="4-vector-和-list-区别"><a class="markdownIt-Anchor" href="#4-vector-和-list-区别"></a> 4 vector 和 list 区别</h1><h1 id="5-vector-扩容原理"><a class="markdownIt-Anchor" href="#5-vector-扩容原理"></a> 5 vector 扩容原理</h1><h1 id="6-迭代器失效问题"><a class="markdownIt-Anchor" href="#6-迭代器失效问题"></a> 6 迭代器失效问题</h1><h1 id="7-使用-map-的使用不是基础数据类型需要重载什么运算符"><a class="markdownIt-Anchor" href="#7-使用-map-的使用不是基础数据类型需要重载什么运算符"></a> 7 使用 map 的使用不是基础数据类型需要重载什么运算符</h1><h1 id="8-list-和-map-的区别"><a class="markdownIt-Anchor" href="#8-list-和-map-的区别"></a> 8 list 和 map 的区别</h1><h1 id="9-二叉搜索树-平衡二叉树和红黑树的区别"><a class="markdownIt-Anchor" href="#9-二叉搜索树-平衡二叉树和红黑树的区别"></a> 9 二叉搜索树、平衡二叉树和红黑树的区别</h1><p><a href="https://zhuanlan.zhihu.com/p/258078863" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/258078863</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="C++" scheme="https://dragonliu2022.github.io/categories/C/"/>
    
    
    <category term="面试" scheme="https://dragonliu2022.github.io/tags/面试/"/>
    
  </entry>
  
  <entry>
    <title>C++模板</title>
    <link href="https://dragonliu2022.github.io/2022/04/19/C++%E6%A8%A1%E6%9D%BF/"/>
    <id>https://dragonliu2022.github.io/2022/04/19/C++%E6%A8%A1%E6%9D%BF/</id>
    <published>2022-04-19T05:58:21.000Z</published>
    <updated>2022-04-19T06:00:54.287Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><ul><li>《面向对象C++程序设计》皮德常 编著 清华大学出版社 2017</li><li>《C++ Primer Plus (第6版)中文版》Stephen Prata 著 张海龙 袁国忠 译 人民邮电出版社 2012</li></ul></blockquote><h1 id="1-模版特化"><a class="markdownIt-Anchor" href="#1-模版特化"></a> 1 模版特化</h1><p>模板特化分为全特化和偏特化，模板特化的目的就是对于某一种变量类型具有不同的实现，因此需要特化版本。</p><p>模板偏特化（Template Partitial Specialization）是模板特化的一种特殊情况，指显示指定部分模板参数而非全部模板参数，或者指定模板参数的部分特性而非全部特性，也称为模板部分特化。与模板偏特化相对的是模板全特化，指对所有的模板参数进行特化。模板全特化与模板偏特化共同组成模板特化。</p><p>模板偏特化主要分为两种，一种是指对部分模板参数进行全特化，另一种是对模板参数特性进行特化，包括将模板参数特化为指针、引用或是另外一个模板类。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="C++" scheme="https://dragonliu2022.github.io/categories/C/"/>
    
    
    <category term="面试" scheme="https://dragonliu2022.github.io/tags/面试/"/>
    
  </entry>
  
  <entry>
    <title>C++类</title>
    <link href="https://dragonliu2022.github.io/2022/04/19/C++%E7%B1%BB/"/>
    <id>https://dragonliu2022.github.io/2022/04/19/C++%E7%B1%BB/</id>
    <published>2022-04-19T05:57:56.000Z</published>
    <updated>2022-04-19T06:00:34.134Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><ul><li>《面向对象C++程序设计》皮德常 编著 清华大学出版社 2017</li><li>《C++ Primer Plus (第6版)中文版》Stephen Prata 著 张海龙 袁国忠 译 人民邮电出版社 2012</li></ul></blockquote><h1 id="1-构造函数与析构函数"><a class="markdownIt-Anchor" href="#1-构造函数与析构函数"></a> 1 构造函数与析构函数</h1><h2 id="11-构造函数定义或作用"><a class="markdownIt-Anchor" href="#11-构造函数定义或作用"></a> 1.1 构造函数定义或作用</h2><p><strong>初始化类对象的数据成员。</strong></p><p>即类的对象被创建的时候，编译系统对该对象分配内存空间，并自动调用构造函数，完成类成员的初始化。</p><p><strong>构造函数的特点：以类名作为函数名，无返回类型。</strong></p><p>常见的构造函数有三种写法：</p><ul><li><p>无参构造函数</p><ul><li><p>如果创建一个类，没有写任何构造函数，则系统会自动生成默认的无参构造函数，且此函数为空。</p><blockquote><p>默认构造函数（default constructor）就是在没有显式提供初始化式时调用的构造函数。如果定义某个类的变量时没有提供初始化时就会使用默认构造函数。</p></blockquote></li></ul></li><li><p>一般构造函数</p></li><li><p>复制构造函数</p><ul><li><p>复制构造函数，也称为拷贝构造函数。复制构造函数参数为类对象本身的引用，根据一个已存在的对象复制出一个新的对象，一般在函数中会将已存在对象的数据成员的值复制一份到新创建的对象中。</p></li><li><p>注意：若没有显示定义复制构造函数，则系统会默认创建一个复制构造函数，当类中有指针成员时，由系统默认创建的复制构造函数会存在“浅拷贝”的风险，因此必须显示定义复制构造函数。</p><blockquote><ul><li>浅拷贝指的是在对对象复制时，只对对象中的数据成员进行简单的赋值，若存在动态成员，就是增加一个指针，指向原来已经存在的内存。这样就造成两个指针指向了堆里的同一个空间。当这两个对象生命周期结束时，析构函数会被调用两次，同一个空间被两次free，造成野指针。</li><li>深拷贝就是对于对象中的动态成员，不是简单的赋值，而是重新分配空间。</li></ul></blockquote></li></ul></li></ul><p>C++的构造函数可以有多个，创建对象时编译器会根据传入的参数不同调用不同的构造函数。</p><h2 id="12-析构函数定义或作用"><a class="markdownIt-Anchor" href="#12-析构函数定义或作用"></a> 1.2 析构函数定义或作用</h2><p><strong>C++析构函数概述</strong></p><p>C++析构函数是一个特殊的成员函数，它的名字是类名的前面加一个～符号，作用与构造函数相反，当对象的生命期结束时，会自动执行析构函数。</p><p><strong>C++执行析构函数的情况</strong></p><p>如果在一个函数中定义了一个对象，当这个函数被调用结束时，对象应该释放，在对象释放前自动执行析构函数。</p><p>static局部对象在函数调用结束时对象并不释放，因此也不调用析构函数，只在main函数结束调用exit函数结束程序时，才调用static局部对象的析构函数。</p><p>如果定义了一个全局对象，则在程序的流程离开其作用域时，调用该全局对象的析构函数。</p><p>如果用new运算符动态地建立了一个对象，当用delete运算符释放该对象时，先调用该对象的析构函数。</p><p><strong>C++析构函数详解</strong></p><p>析构函数的作用并不是删除对象，而是在撤销对象占用的内存之前完成一些清理工作，使这部分内存可以被程序分配给新对象使用。</p><p>析构函数不返回任何值，没有函数类型，也没有函数参数，因此不能重载，一个类可以有多个构造函数，但只能有一个析构函数。</p><p>析构函数的作用并不仅限于释放资源方面，它还可以被用来执行程序员希望在最后一次使用对象之后所执行的任何操作。</p><p>如果没有定义析构函数，C++编译系统会自动生成一个析构函数，但它只是徒有析构函数的名称和形式，实际上什么都不执行，要想让析构函数执行，必须在定义的析构函数中指定。</p><h2 id="13-c类内静态成员的内存释放问题"><a class="markdownIt-Anchor" href="#13-c类内静态成员的内存释放问题"></a> 1.3 C++类内静态成员的内存释放问题</h2><p>C/C++中静态成员变量存放在全局内存的静态区域，因此，我们虽然delete掉了这个类，但是并不代表我们真的释放掉了类内静态成员的内存，这些静态成员的内存会在整个进程退出的时候由系统回收。</p><h2 id="14-构造析构顺序"><a class="markdownIt-Anchor" href="#14-构造析构顺序"></a> 1.4 构造析构顺序</h2><ol><li>存在继承关系时，先执行父类的构造函数，再执行子类的构造函数；析构的时候恰好相反：先调用派生类的析构函数、然后调用基类的析构函数。</li><li>当一个类中含有对象成员时，在启动本类的构造函数之前，先分配对象空间，按对象成员的声明顺序执行他们各自的构造函数，再执行本类的构造函数。</li><li>对于非静态的局部对象，他们的析构函数的执行顺序与构造函数相反。</li><li>构造：父类-&gt;对象成员&gt;子类</li></ol><h2 id="15-析构函数能抛出异常吗"><a class="markdownIt-Anchor" href="#15-析构函数能抛出异常吗"></a> 1.5 析构函数能抛出异常吗?</h2><p>C++标准指明析构函数不能、也不应该抛出异常。</p><ol><li>如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题。</li><li>通常异常发生时，c++的机制会调用已经构造对象的析构函数来释放资源，此时若析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃的问题。</li></ol><h2 id="16-调用拷贝构造函数的情况"><a class="markdownIt-Anchor" href="#16-调用拷贝构造函数的情况"></a> 1.6 调用拷贝构造函数的情况</h2><ul><li>用对象初始化同类的另一个对象</li><li>函数形参是对象，当进行参数传递时将调用copyconstruct</li><li>函数返回值是对象，函数执行结束时，将调用拷贝构造函数对无名临时对象初始化</li></ul><h1 id="2-多态与虚函数"><a class="markdownIt-Anchor" href="#2-多态与虚函数"></a> 2 多态与虚函数</h1><h2 id="21-多态性"><a class="markdownIt-Anchor" href="#21-多态性"></a> 2.1 多态性</h2><p>多态性指&quot;一个接口，多种方法&quot;。C++支持两种多态性：编译时多态性，运行时多态性。</p><ol><li><strong>编译时多态性(静态多态)</strong>：通过重载函数和泛型编程实现</li><li><strong>运行时多态性(动态多态)</strong>：通过虚函数实现</li></ol><blockquote><p>静态与动态的实质区别就是函数地址是早绑定还是晚绑定。</p><p>如果函数的调用，在编译器编译期间就可以确定函数的调用地址，并生产代码，是静态的，就是说地址是早绑定的。</p><p>而如果函数调用的地址不能在编译器期间确定，需要在运行时才确定，这就属于晚绑定。</p></blockquote><h2 id="22-动态绑定的概念"><a class="markdownIt-Anchor" href="#22-动态绑定的概念"></a> 2.2 动态绑定的概念</h2><p>动态绑定是指在运行时（非编译期）将过程调用与相应代码链接起来的过程称为动态绑定。</p><p>C<ins>中，通过基类的引用或指针调用虚函数时，发生动态绑定。C</ins>中动态绑定是通过虚函数实现的，而虚函数是通过一张虚函数表实现的。这个表中记录了虚函数的地址，保证动态绑定时能够根据对象的实际类型调用正确的函数。编译器必须保证虚函数表的指针存在于对象实例中最前面的位置（这是为了保证正确取到虚函数的偏移量）。这意味着我们通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。</p><h2 id="23-虚函数和纯虚函数"><a class="markdownIt-Anchor" href="#23-虚函数和纯虚函数"></a> 2.3 虚函数和纯虚函数</h2><p>用 virtual 关键字修饰的成员函数就是虚函数，虚函数的作用就是实现多态性。纯虚函数是一种特殊的虚函数，在基类中不能对虚函数给出有意义的实现，而把它的实现留给派生类去做。只含有虚函数的类可以被实例化，含有纯虚函数的类不能被实例化。</p><p><strong>注意</strong>：</p><ol><li>只有类的成员函数才能声明为虚函数，虚函数仅适用于有继承关系的类对象。普通函数不能声明为虚函数。</li><li>静态成员函数不能是虚函数，因为静态成员函数不受限于某个对象。</li><li>内联函数（inline）不能是虚函数，因为内联函数不能在运行中动态确定位置。</li><li>构造函数不能是虚函数。</li><li>析构函数可以是虚函数，而且建议声明为虚函数。</li></ol><h2 id="24-c类中定义虚函数和不定义在初始化的时候大小是不是一样"><a class="markdownIt-Anchor" href="#24-c类中定义虚函数和不定义在初始化的时候大小是不是一样"></a> 2.4 C++类中定义虚函数和不定义在初始化的时候大小是不是一样？</h2><p>定义了虚函数的类要大一些，因为要建立虚函数表</p><h2 id="25-构造函数能不能声明成虚函数"><a class="markdownIt-Anchor" href="#25-构造函数能不能声明成虚函数"></a> 2.5 构造函数能不能声明成虚函数？</h2><p>不能。</p><ol><li>当创建一个派生类对象时，会先调用基类的构造函数，但是派生类已经覆盖了基类的构造函数，所以也就无法进一步执行，导致程序出错。</li><li>在创建对象时，首先要调用构造函数，然后构造函数是虚函数，就需要用虚函数指针去调用，但是，对象都还没构造，也就没有虚函数指针，造成了一个循环调用的问题。</li></ol><h2 id="26-基类的析构函数不是虚函数会带来什么问题"><a class="markdownIt-Anchor" href="#26-基类的析构函数不是虚函数会带来什么问题"></a> 2.6 基类的析构函数不是虚函数，会带来什么问题？</h2><p>delete 指向派生类对象的基类指针时，只有基类的内存被释放，派生类的没有。这样就内存泄漏了。</p><h2 id="27-构造函数和析构函数中调用虚函数吗"><a class="markdownIt-Anchor" href="#27-构造函数和析构函数中调用虚函数吗"></a> 2.7 构造函数和析构函数中调用虚函数吗？</h2><p>从语法上讲，调用完全没有问题。但是从效果上看，往往不能达到多态的效果。<br>Effective C<ins>的解释是：派生类对象的基类成分会在派生类自身成分被构造之前先构造妥当，派生类对象构造期间会首先进入基类的构造函数，在基类构造函数执行时继承类的成员变量尚未初始化，对象类型是基类类型，而不是派生类类型，虚函数会被编译器解析为基类，若使用运行时类型信息，也会把对象视为基类类型，构造期间调用虚函数，会调用自己的虚函数，此时虚函数和普通函数没有区别了，达不到多态的效果。<br>同样，进入基类析构函数时，对象也是基类类型。C</ins>中派生类在构造时会先调用基类的构造函数再调用派生类的构造函数，析构时则相反，先调用派生类的析构函数再调用基类的析构函数。一旦派生类析构函数运行，这个对象的派生类数据成员就被视为未定义的值，所以 C++ 就将它们视为不再存在。假设一个派生类的对象进行析构，首先调用了派生类的析构，然后再调用基类的析构时，遇到了一个虚函数，这个时候有两种选择：</p><ol><li>编译器调用这个虚函数的基类版本，那么虚函数则失去了运行时调用正确版本的意义；</li><li>编译器调用这个虚函数的派生类版本，但是此时对象的派生类部分已经完成析构，“数据成员就被视为未定义的值”，这个函数调用会导致未知行为。</li></ol><h2 id="28-重载overload和重写overried有的书也叫做覆盖的区别"><a class="markdownIt-Anchor" href="#28-重载overload和重写overried有的书也叫做覆盖的区别"></a> 2.8 重载(overload)和重写(overried，有的书也叫做“覆盖”)的区别？</h2><ul><li><strong>重载</strong>：是指允许存在多个同名函数，而这些函数的参数列表不同</li><li><strong>重写</strong>：是指派生类重新定义基类虚函数的方法。</li></ul><h2 id="29-虚函数表存放的内容以及在内存中的位置"><a class="markdownIt-Anchor" href="#29-虚函数表存放的内容以及在内存中的位置"></a> 2.9 虚函数表存放的内容以及在内存中的位置</h2><ul><li>每个对象里有虚(函数表)指针，指向虚函数表，虚函数表里存放了虚函数的地址。虚函数表是顺序存放虚函数地址的，不需要用到链表。</li><li>还有类的类型信息，在《深度探索C++对象模型》中有提到</li><li>C<ins>中**虚函数表位于只读数据段（.rodata），也就是C</ins>内存模型中的常量区；而虚函数则位于代码段（.text），也就是C++内存模型中的代码区。**</li></ul><h2 id="210-如果虚函数非常有效我们是否可以把每个函数都声明为虚函数"><a class="markdownIt-Anchor" href="#210-如果虚函数非常有效我们是否可以把每个函数都声明为虚函数"></a> 2.10 如果虚函数非常有效，我们是否可以把每个函数都声明为虚函数？</h2><p>不行，这是因为虚函数是有代价的：</p><ul><li>由于每个虚函数的对象都必须维护一个虚函数表，因此在使用虚函数的时候会产生一个系统开销。如果仅是一个很小的类，且不想派生其他类，那么根本没必要使用虚函数。</li><li><strong>虚函数效率低</strong>。因为虚函数需要一次间接的寻址，而一般的函数可以在编译时定位到函数的地址。虚函数(动态类型调用)是要根据某个指针定位到函数的地址。多增加了一个过程，效率肯定会低一些，但带来了运行时的多态。</li></ul><h1 id="3-继承"><a class="markdownIt-Anchor" href="#3-继承"></a> 3 继承</h1><h2 id="31-继承的概念"><a class="markdownIt-Anchor" href="#31-继承的概念"></a> 3.1 继承的概念</h2><p>派生类可以具有基类的特性，共享基类的成员函数，使用基类的数据成员，还可以定义自己的数据成员和函数成员。从一个基类派生的称为单继承，从多个基类派生的称为多继承。</p><p><strong>C++中，继承方式有 3 种</strong>：</p><ol><li>公有继承：public、protected、private 权限均不变</li><li>私有继承：public、protected 权限变为 private</li><li>保护继承：public 变为 protected</li></ol><p><strong>实现的访问控制如下</strong>：</p><ol><li>public：自己、友元、派生类、外界均可访问</li><li>protected：自己、友元、派生类可以访问</li><li>private：自己、友元可以访问</li></ol><h2 id="32-多继承的优缺点"><a class="markdownIt-Anchor" href="#32-多继承的优缺点"></a> 3.2 多继承的优缺点</h2><p><strong>优点</strong></p><ol><li>**简单，清晰，更有利于复用。**不会因为基类一个小小的改变而大张旗鼓去改代码。</li></ol><p><strong>缺点</strong></p><ol><li>**二义性。**两个基类中有同名方法的时候，需要在子类的调用中指明此方法出自那个基类。</li><li><strong>使用父类指针指向子类对象变得复杂</strong>。你不得不用到C++中提供的dynamic_cast来执行强制转换。至于dynamic_cast，也是个麻烦的家伙，它是在运行期间而非编译期间进行转换的（因为编译期间它不能确定到底要转向一个什么类型），因此除了会带来一些轻微的性能损失，它要求编译器允许RTTI（Runtime Type Information，运行时类型信息），也就是要求编译器保存所有类在运行时的信息。</li><li><strong>使得子类的vtable变得不同寻常</strong>。单继承的vtable只是在父类vtable的表尾加上新的虚函数，子类对象的vtable中包含了有序的父类vtable。而对于多重继承，两个父类可能有完全不同的vtable，因此，子类的vtable中绝对不可能包含完整的有序的两个父类的vtable。子类的vtable中可能包含了两块不相连的父类vtable，因此每个父类都被迫追加了一个vtable，也就是，每个父类的对象都添加了一个指针。</li></ol><p>孰优孰劣，自己把握。没有永远最好的，只有当前适合的。Java中摒弃了多重继承可能也是出于太过复杂，可能有不可料知的结果的原因。</p><p>不要随意使用多重继承。大多数的情况，用容器（也就是类的组合法）会更好些。</p><p><a href="https://blog.csdn.net/woodforestbao/article/details/4500406" target="_blank" rel="noopener">https://blog.csdn.net/woodforestbao/article/details/4500406</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="C++" scheme="https://dragonliu2022.github.io/categories/C/"/>
    
    
    <category term="面试" scheme="https://dragonliu2022.github.io/tags/面试/"/>
    
  </entry>
  
  <entry>
    <title>C++基础</title>
    <link href="https://dragonliu2022.github.io/2022/04/19/C++%E5%9F%BA%E7%A1%80/"/>
    <id>https://dragonliu2022.github.io/2022/04/19/C++%E5%9F%BA%E7%A1%80/</id>
    <published>2022-04-19T05:57:29.000Z</published>
    <updated>2022-04-19T06:00:07.876Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><ul><li>《面向对象C++程序设计》皮德常 编著 清华大学出版社 2017</li><li>《C++ Primer Plus (第6版)中文版》Stephen Prata 著 张海龙 袁国忠 译 人民邮电出版社 2012</li></ul></blockquote><h1 id="1-c-和-c-的区别"><a class="markdownIt-Anchor" href="#1-c-和-c-的区别"></a> 1 c 和 c++ 的区别</h1><ul><li>C是一种结构化语言，重点在于算法和数据结构。C程序的设计首先考虑的是如何通过一个过程，对输入(或环境条件)进行运算处理得到输出(或实现过程(事务)控制)。</li><li>而对于C++，首先考虑的是如何构造一个对象模型，让这个模型能够契合与之对应的问题域，这样就可以通过获取对象的状态信息得到输出或实现过程(事务)控制。</li><li>C++中new和delete是对内存分配的运算符，取代了C中的malloc和free。</li><li>标准C++中的字符串类取代了标准C函数库头文件中的字符数组处理函数（C中没有字符串类型）。</li><li>C++中用来做控制态输入输出的iostream类库替代了标准C中的stdio函数库。</li><li>C++中的try/catch/throw异常处理机制取代了标准C中的setjmp()和longjmp()函数。</li><li>在C<ins>中，允许有相同的函数名，不过它们的参数类型不能完全相同，这样这些函数就可以相互区别开来。而这在C语言中是不允许的。也就是C</ins>可以重载，C语言不允许。</li><li>C<ins>语言中，允许变量定义语句在程序中的任何地方，只要在是使用它之前就可以；而C语言中，必须要在函数开头部分。而且C</ins>允许重复定义变量，C语言也是做不到这一点的</li><li>在C++中，除了值和指针之外，新增了引用。引用型变量是其他变量的一个别名，我们可以认为他们只是名字不相同，其他都是相同的。</li><li>C++相对与C增加了一些关键字，如：bool、using、dynamic_cast、namespace等等</li></ul><h1 id="2-newdelete-mallocfree"><a class="markdownIt-Anchor" href="#2-newdelete-mallocfree"></a> 2 new/delete、malloc/free</h1><h2 id="21-newdelete-mallocfree-区别"><a class="markdownIt-Anchor" href="#21-newdelete-mallocfree-区别"></a> 2.1 new/delete、malloc/free 区别</h2><table><thead><tr><th style="text-align:center">特征</th><th style="text-align:center">new/delete</th><th style="text-align:center">malloc/free</th></tr></thead><tbody><tr><td style="text-align:center">分配内存的位置</td><td style="text-align:center">自由存储区</td><td style="text-align:center">堆</td></tr><tr><td style="text-align:center">内存分配成功的返回值</td><td style="text-align:center">完整类型指针</td><td style="text-align:center">void*</td></tr><tr><td style="text-align:center">内存分配失败的返回值</td><td style="text-align:center">默认抛出异常</td><td style="text-align:center">返回 NULL</td></tr><tr><td style="text-align:center">分配内存的大小</td><td style="text-align:center">由编译器根据类型计算得出</td><td style="text-align:center">必须显式指定字节数</td></tr><tr><td style="text-align:center">处理数组</td><td style="text-align:center">有处理数组的 new 版本 new[]</td><td style="text-align:center">需要用户计算数组的大小后进行内存分配</td></tr><tr><td style="text-align:center">是否相互调用</td><td style="text-align:center">可以，看具体的 operator new/delete 实现</td><td style="text-align:center">不可调用 new</td></tr><tr><td style="text-align:center">函数重载</td><td style="text-align:center">允许</td><td style="text-align:center">不允许</td></tr><tr><td style="text-align:center">构造函数与析构函数</td><td style="text-align:center">调用</td><td style="text-align:center">不调用</td></tr></tbody></table><h2 id="22-c有了mallocfree为什么还需要newdelete"><a class="markdownIt-Anchor" href="#22-c有了mallocfree为什么还需要newdelete"></a> 2.2 C++有了malloc/free，为什么还需要new/delete?</h2><ul><li>malloc/free是C++/C语言的标准库函数，new/delete是C++的运算符。他们都可用于申请动态内存和释放内存。</li><li>对于非内部数据类型的对象而言，只用malloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。</li><li>因此C++需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete。new/delete不是库函数，是运算符。</li></ul><h2 id="23-delete-与-delete-区别"><a class="markdownIt-Anchor" href="#23-delete-与-delete-区别"></a> 2.3 delete 与 delete []区别</h2><p>delete 只会调用一次析构函数，而 delete[]会针对每一个成员都调用一次析构函数。</p><h2 id="24-内存泄漏与定位"><a class="markdownIt-Anchor" href="#24-内存泄漏与定位"></a> 2.4 内存泄漏与定位</h2><p>内存泄漏并非指的是内存在物理上的消失，而是分配某段内存后，失去了对该内存的控制，造成内存的浪费。比如 C++ new 之后没有 delete。</p><p><strong>定位内存泄露</strong>：</p><ol><li>在windows平台下通过CRT中的库函数进行检测；</li><li>在可能泄漏的调用前后生成块的快照，比较前后的状态，定位泄漏的位置</li><li>Linux下通过工具valgrind检测</li></ol><h1 id="3-结构体-联合体"><a class="markdownIt-Anchor" href="#3-结构体-联合体"></a> 3 结构体、联合体</h1><h2 id="31-结构体与联合有何区别"><a class="markdownIt-Anchor" href="#31-结构体与联合有何区别"></a> 3.1 结构体与联合有何区别</h2><ol><li>结构体和联合都是由多个不同的数据类型成员组成，但在任何同一时刻，联合中只存放了一个被选中的成员（所有成员共用一块地址空间），而结构体的所有成员都存在（不同成员的存放地址不同）。</li><li>对于联合的不同成员赋值，将会对其它成员重写，原来成员的值就不存在了。而对于结构体的不同成员赋值是互不影响的。</li></ol><h2 id="32-union的好处"><a class="markdownIt-Anchor" href="#32-union的好处"></a> 3.2 union的好处</h2><ol><li>节省内存空间</li><li>测大小端存储（大相反（低位存高位），小相同（低位存低位），叉八六（X86计算机)，必小端。）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">typedef union un&#123;</span><br><span class="line">   int i;</span><br><span class="line">   char ch[2];</span><br><span class="line">&#125; un;</span><br><span class="line">int main()&#123;</span><br><span class="line">    un u;</span><br><span class="line">    u.ch[0] = 10;</span><br><span class="line">    u.ch[1] = 1;</span><br><span class="line">    printf(&quot;%d&quot;, (short)u.i);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析： 10 相当于 0000 1010     低地址 1  相当于 0000 0001     高地址 如果是小端模式，低地址存放高位，高地址存放低位，那么该值按照正常顺序书写就是： 0000 0001 0000 1010，结果为266。</p><h2 id="33-struct可以有构造-析构等成员函数吗如果有那么与class还有区别吗"><a class="markdownIt-Anchor" href="#33-struct可以有构造-析构等成员函数吗如果有那么与class还有区别吗"></a> 3.3 struct可以有构造、析构等成员函数吗？如果有，那么与class还有区别吗？</h2><ul><li>struct可以有构造函数、析构函数，之间也可以继承。</li><li>C++中的struct其实和class意义一样，唯一不同的就是struct里面默认的访问控制是public，class中默认的访问控制是private。</li><li>C<ins>中存在struct关键字的唯一意义就是为了让C程序员有个归属感，是为了让C</ins>编译器兼容以前用C开发的项目。</li></ul><p><strong>相同点</strong></p><ul><li>两者都拥有成员函数、公有和私有部分</li><li>任何可以使用class完成的工作，同样可以使用struct完成</li></ul><p><strong>不同点</strong></p><ul><li>两者中如果不对成员不指定公私有，struct默认是公有的，class则默认是私有的</li><li>class默认是private继承，而struct模式是public继承</li><li>class可以作为模板类型，struct不行</li></ul><p><strong>引申</strong>：C++和C的struct区别</p><ul><li>C语言中：struct是用户自定义数据类型（UDT）；C<ins>中struct是抽象数据类型（ADT），支持成员函数的定义，（C</ins>中的struct能继承，能实现多态）</li><li>C中struct是没有权限的设置的，且struct中只能是一些变量的集合体，可以封装数据却不可以隐藏数据，而且成员不可以是函数</li><li>C++中，struct增加了访问权限，且可以和类一样有成员函数，成员默认访问说明符为public（为了与C兼容）</li><li>struct作为类的一种特例是用来自定义数据结构的。一个结构标记声明后，在C中必须在结构标记前加上struct，才能做结构类型名（除：typedef struct class{};）;C<ins>中结构体标记（结构体名）可以直接作为结构体类型名使用，此外结构体struct在C</ins>中被当作类的一种特例</li></ul><h1 id="4-c语言关键字及其对应的含义"><a class="markdownIt-Anchor" href="#4-c语言关键字及其对应的含义"></a> 4 C语言关键字及其对应的含义</h1><ul><li>数据类型关键字<ul><li>A基本数据类型（5个）<ul><li>void：声明函数无返回值或无参数，声明无类型指针，显式丢弃运算结果</li><li>char：字符型类型数据，属于整型数据的一种</li><li>int：整型数据，通常为编译器指定的机器字长</li><li>float：单精度浮点型数据，属于浮点数据的一种</li><li>double：双精度浮点型数据，属于浮点数据的一种</li></ul></li><li>B类型修饰关键字（4个）<ul><li>short：修饰int，短整型数据，可省略被修饰的int。</li><li>long：修饰int，长整形数据，可省略被修饰的int。</li><li>signed：修饰整型数据，有符号数据类型</li><li>unsigned：修饰整型数据，无符号数据类型</li></ul></li><li>C复杂类型关键字（5个）<ul><li>struct：结构体声明</li><li>union：共用体声明</li><li>enum：枚举声明</li><li>typedef：声明类型别名</li><li>sizeof：得到特定类型或特定类型变量的大小</li></ul></li><li>D存储级别关键字（6个）<ul><li>auto：指定为自动变量，由编译器自动分配及释放。通常在栈上分配</li><li>static：指定为静态变量，分配在静态变量区，修饰函数时，指定函数作用域为文件内部</li><li>register：指定为寄存器变量，建议编译器将变量存储到寄存器中使用，也可以修饰函数形参，建议编译器通过寄存器而不是堆栈传递参数</li><li>extern：指定对应变量为外部变量，即在另外的目标文件中定义，可以认为是约定由另外文件声明的对象的一个“引用“</li><li>const：与volatile合称“cv特性”，指定变量不可被当前线程/进程改变（但有可能被系统或其他线程/进程改变）</li><li>volatile：与const合称“cv特性”，指定变量的值有可能会被系统或其他进程/线程改变，强制编译器每次从内存中取得该变量的值</li></ul></li></ul></li><li>流程控制关键字<ul><li>A跳转结构（4个）<ul><li>return：用在函数体中，返回特定值（或者是void值，即不返回值）</li><li>continue：结束当前循环，开始下一轮循环</li><li>break：跳出当前循环或switch结构</li><li>goto：无条件跳转语句</li></ul></li><li>B分支结构（5个）<ul><li>if：条件语句</li><li>else：条件语句否定分支（与if连用）</li><li>switch：开关语句（多重分支语句）</li><li>case：开关语句中的分支标记</li><li>default：开关语句中的“其他”分治，可选。</li></ul></li><li>C循环结构（3个）：for、do、while</li></ul></li></ul><h1 id="5-变量存储类型"><a class="markdownIt-Anchor" href="#5-变量存储类型"></a> 5 变量存储类型</h1><h2 id="51-c语言支持的四种变量存储类型"><a class="markdownIt-Anchor" href="#51-c语言支持的四种变量存储类型"></a> 5.1 C语言支持的四种变量存储类型</h2><ol><li><p><strong>auto</strong>：auto称为自动变量（局部变量）</p></li><li><p>static</p><p>：static称为静态变量，根据变量的类型可以分为静态局部变量和静态全局变量。</p><ul><li><strong>静态局部变量</strong>：它与局部变量的区别在于，在函数退出时，这个变量始终存在，但不能被其它函数使用；当再次进入该函数时，将保存上次的结果。</li><li><strong>静态全局变量</strong>：只在定义它的源文件中可见而在其它源文件中不可见的变量。它与全局变量的区别是：全局变量可以被其它源文件使用，而静态全局变量只能被所在的源文件使用。</li></ul></li><li><p><strong>extern</strong>：extern称为外部申明。为了使变量或者函数除了在定义它的源文件中可以使用外，还可以被其它文件使用。因此通知每一个程序模块文件，此时可用extern来说明。</p></li><li><p><strong>register</strong>：register称为寄存器变量。它只能用于整型和字符型变量。定义符register说明的变量被存储在CPU的寄存器中，定义一个整型寄存器变量可写成: <code>register int a</code>;</p></li></ol><p>对于以上四种数据的存储位置：register变量存在CPU的寄存器中；auto类型变量存在内存的栈；static型的局部变量和全局变量以及extern型变量（即全局变量），存在于内存的静态区。</p><h2 id="52-static-的作用"><a class="markdownIt-Anchor" href="#52-static-的作用"></a> 5.2 static 的作用</h2><ol><li><p><strong>隐藏</strong>：当同时编译多个文件时，所有未加 static 前缀的全局变量和函数都具有全局可见性，其它的源文件也能访问。如果加了 static，就会对其它源文件隐藏。利用这一特性可以在不同的文件中定义同名函数和同名变量，而不必担心命名冲突。static 可以用作函数和变量的前缀，对于函数来讲，static 的作用仅限于隐藏。</p></li><li><p><strong>保持变量内容的持久</strong>：存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。如果作为 static 局部变量在函数内定义，它的生存期为整个源程序，但是其作用域仍与局部变量相同，只能在定义该变量的函数内使用该变量。退出该函数后，尽管该变量还继续存在，但不能使用它。</p></li><li><p>默认初始化为 0</p></li><li><p>在类中声明 static 变量或者函数时，初始化时使用作用域运算符来标明它所属类，因此，静态数据成员是类的成员，而不是对象的成员，这样就出现以下作用：</p><ol><li>类的静态成员函数是属于整个类而非类的对象，所以它没有 this 指针，这就导致了它仅能访问类的静态数据和静态成员函数。</li><li>不能将静态成员函数定义为虚函数。</li><li>静态成员变量地址是指向其数据类型的指针，静态成员函数地址类型是一个“非成员函数指针”。</li><li>static 并没有增加程序的时空开销，相反它还缩短了派生类对基类静态成员的访问时间，节省了派生类的内存空间。</li><li>静态数据成员是静态存储的，所以必须对它进行初始化。（程序员手动初始化，否则编译时一般不会报错，但是在链接时会报错误）</li><li>静态成员为基类和派生类共享，但在派生类中重复定义了基类中的静态成员，不会引起错误。</li></ol><p>注意，静态成员初始化与一般数据成员初始化不同:</p><ol><li>初始化在类体外进行，而前面不加 static，以免与一般静态变量或对象相混淆；</li><li>初始化时不加该成员的访问权限控制符 private，public 等；</li><li>初始化时使用作用域运算符来标明它所属类；</li></ol><p>所以我们得出静态数据成员初始化的格式：<code>&lt;数据类型&gt;&lt;类名&gt;::&lt;静态数据成员名&gt;=&lt;值&gt;</code></p></li></ol><h2 id="53-请说出-const-与define-相比有何优点"><a class="markdownIt-Anchor" href="#53-请说出-const-与define-相比有何优点"></a> 5.3 <strong>请说出 const 与#define 相比，有何优点？</strong></h2><p>const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，并且在字符替换可能会产生意料不到的错误。</p><p><strong>const还具有以下优点</strong>：</p><ol><li>提高代码安全性。</li><li>提高代码的可读性和可维护性。</li><li>提高程序的效率。</li><li>当 const 和 non-const 成员函数具有本质上相同的实现的时候，使用 non-const 版本调用 const 版本可以避免重复代码。</li></ol><h2 id="54-c中顶层-const-和底层-const"><a class="markdownIt-Anchor" href="#54-c中顶层-const-和底层-const"></a> 5.4 C++中顶层 const 和底层 const</h2><p>如果 const 右结合修饰的为类型或者*，那这个 const 就是一个底层 const，表示指针所指向的对象是个常量。</p><p>如果 const 右结合修饰的为标识符，那这个 const 就是一个顶层 const，表示指针本身是个常量。</p><h2 id="55-const-关键字的使用"><a class="markdownIt-Anchor" href="#55-const-关键字的使用"></a> 5.5 const 关键字的使用</h2><ol><li>阻止一个<strong>变量</strong>被改变，可以使用const关键字。在定义该const变量时，通常需要(必须)对它进行初始化，因为以后就没有机会再去改变它了；</li><li>对<strong>指针</strong>来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；</li><li>在一个<strong>函数声明</strong>中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；</li><li>对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量，类的常对象只能访问类的常成员函数；</li><li>对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”。</li><li>const成员函数可以访问非const对象的非const数据成员、const数据成员，也可以访问const对象内的所有数据成员；</li><li>非const成员函数可以访问非const对象的非const数据成员、const数据成员，但不可以访问const对象的任意数据成员；</li><li>一个没有明确声明为const的成员函数被看作是将要修改对象中数据成员的函数，而且编译器不允许它为一个const对象所调用。因此const对象只能调用const成员函数。</li><li>const类型变量可以通过类型转换符const_cast将const类型转换为非const类型；</li><li>const类型变量必须定义的时候进行初始化，因此也导致如果类的成员变量有const类型的变量，那么该变量必须在类的初始化列表中进行初始化；</li><li>对于函数值传递的情况，因为参数传递是通过复制实参创建一个临时变量传递进函数的，函数内只能改变临时变量，但无法改变实参。则这个时候无论加不加const对实参不会产生任何影响。但是在引用或指针传递函数调用中，因为传进去的是一个引用或指针，这样函数内部可以改变引用或指针所指向的变量，这时const 才是实实在在地保护了实参所指向的变量。因为在编译阶段编译器对调用函数的选择是根据实参进行的，所以，只有引用传递和指针传递可以用是否加const来重载。一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来。</li></ol><h2 id="56-volatile-关键字的使用"><a class="markdownIt-Anchor" href="#56-volatile-关键字的使用"></a> 5.6 volatile 关键字的使用</h2><ol><li>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。</li><li>当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。</li><li>volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。多线程中被几个任务共享的变量需要定义为volatile类型。</li><li>volatile 指针和 const 修饰词类似，const 有常量指针和指针常量的说法，volatile 也有相应的概念</li><li>可以把一个非volatile int赋给volatile int，但是不能把非volatile对象赋给一个volatile对象。</li><li>除了基本类型外，对用户定义类型也可以用volatile类型进行修饰。</li><li>C++中一个有volatile标识符的类只能访问它接口的子集，一个由类的实现者控制的子集。用户只能用const_cast来获得对类型接口的完全访问。此外，volatile向const一样会从类传递到它的成员。</li><li><strong>多线程下的volatile</strong>：有些变量是用volatile关键字声明的。当两个线程都要用到某一个变量且该变量的值会被改变时，应该用volatile声明，该关键字的作用是防止优化编译器把变量从内存装入CPU寄存器中。如果变量被装入寄存器，那么两个线程有可能一个使用内存中的变量，一个使用寄存器中的变量，这会造成程序的错误执行。volatile的意思是让编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的值。</li></ol><h2 id="57-一个参数可以既是const又是volatile吗解释为什么"><a class="markdownIt-Anchor" href="#57-一个参数可以既是const又是volatile吗解释为什么"></a> 5.7 一个参数可以既是const又是volatile吗？解释为什么</h2><ul><li>可以。一个例子就是只读的状态寄存器。它是volatile，因为他可能被意想不到地改变；她又是const，因为程序不应该试图去改变它。</li><li>尽管这并不很正常。一个例子就是当一个中断服务子程序修改一个指向一个buffer的指针时。</li></ul><h1 id="6-c-字符串和-c字符串的区别"><a class="markdownIt-Anchor" href="#6-c-字符串和-c字符串的区别"></a> 6 <strong>C 字符串和 C++字符串的区别</strong></h1><ol><li>C 字符串是基本数据类型，即字符数组；C++字符串是类 string</li><li>C 字符串函数是外部函数，字符串作为参数被传进来；C++字符串函数是字符串类内部定义的，用<code>.</code>来直接使用</li><li>C++字符串中对一些运算符进行了重载</li></ol><h1 id="7-引用和指针"><a class="markdownIt-Anchor" href="#7-引用和指针"></a> 7 引用和指针</h1><h2 id="71-引用与指针区别"><a class="markdownIt-Anchor" href="#71-引用与指针区别"></a> 7.1 引用与指针区别</h2><ol><li><p><strong>初始化区别</strong>：引用必须被初始化，指针不必。</p></li><li><p><strong>可修改区别</strong>：引用初始化以后不能被改变，指针可以改变所指的对象。</p></li><li><p><strong>非空区别</strong>：不存在指向空值的引用，但是存在指向空值的指针。</p></li><li><p><strong>合法性区别</strong>：在使用引用之前不需要测试他的合法性；相反，指针则应该总是被测试，防止其为空。</p></li><li><p>应用区别</p><p>：</p><ul><li>使用指针的情况<ul><li>考虑到存在不指向任何对象的可能(在这种情况下，能够设置指针为空)</li><li>需要能够在不同时刻指向不同对象(在这种情况下，能够改变指针的指向)</li></ul></li><li><strong>使用引用的情况</strong>：总是指向一个对象并且一旦指向一个对象后就不会改变指向</li></ul></li></ol><h2 id="72-在什么时候需要使用常引用"><a class="markdownIt-Anchor" href="#72-在什么时候需要使用常引用"></a> 7.2 <strong>在什么时候需要使用“常引用”？</strong></h2><p>如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改变，就应使用常引用。</p><h2 id="73-将引用作为函数返回值类型的优点和注意事项"><a class="markdownIt-Anchor" href="#73-将引用作为函数返回值类型的优点和注意事项"></a> 7.3 <strong>将“引用”作为函数返回值类型的优点和注意事项</strong></h2><p>好处：在内存中不产生被返回值的副本，提高效率</p><p><strong>注意事项</strong>：</p><ol><li>不能返回局部变量的引用。主要原因是局部变量会在函数返回后被销毁，因此被返回的引用就成为了&quot;无所指&quot;的引用，程序会进入未知状态。</li><li>不能返回函数内部 new 分配的内存的引用。原因是引用所指向的空间就无法释放，造成内存泄漏。</li><li>可以返回类成员的引用，但最好是 const。主要原因是如果其它对象可以获得该属性的非常量引用（或指针），那么对该属性的单纯赋值就会破坏业务规则的完整性。</li><li>流操作符和赋值操作符重载返回值申明为引用。</li><li>在另外的一些操作符中，却千万不能返回引用，例如四则运算符。</li></ol><h2 id="74-句柄和指针的区别与联系"><a class="markdownIt-Anchor" href="#74-句柄和指针的区别与联系"></a> 7.4 句柄和指针的区别与联系</h2><p>句柄和指针其实是两个截然不同的概念。</p><ul><li>Windows系统用句柄标记系统资源，隐藏系统的信息。只要知道有这个东西，然后去调用即可，他是一个32bit的uint。</li><li>指针则标记某个物理内存地址。</li></ul><h2 id="75-指针常量和常量指针"><a class="markdownIt-Anchor" href="#75-指针常量和常量指针"></a> 7.5 指针常量和常量指针</h2><ul><li>常量指针是一个指针，读成常量的指针，指向一个只读变量。如<code>int const *p</code>或<code>const int *p</code></li><li>指针常量是一个不能给改变指向的指针。指针是个常量，不能中途改变指向，如<code>int *const p</code></li></ul><p><strong>技巧</strong>：* 前面的是对被指向对象的修饰，* 后面的是对指针本身的修饰。</p><h1 id="8-递归的优缺点"><a class="markdownIt-Anchor" href="#8-递归的优缺点"></a> 8 <strong>递归的优缺点</strong></h1><ul><li><strong>优点</strong>：代码简洁，容易理解</li><li><strong>缺点</strong>：时间效率低，递归爆栈</li></ul><h1 id="9-c四种类型转换static_cast-dynamic_cast-const_cast-reinterpret_cast"><a class="markdownIt-Anchor" href="#9-c四种类型转换static_cast-dynamic_cast-const_cast-reinterpret_cast"></a> 9 C++四种类型转换：static_cast, dynamic_cast, const_cast, reinterpret_cast</h1><ol><li>static_cast 用的最多，能用于多态向上转化，如果向下转能成功但是不安全。</li><li>dynamic_cast 用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回 NULL，对于引用抛异常。</li><li>const_cast 用于将 const 变量转为非 const</li><li>reinterpret_cast 几乎什么都可以转，比如将 int 转指针，可能会出问题，尽量少用。</li></ol><p>C 的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。</p><h1 id="10-c是不是类型安全的"><a class="markdownIt-Anchor" href="#10-c是不是类型安全的"></a> 10 <strong>C++是不是类型安全的？</strong></h1><p>不是。<strong>两个不同类型的指针之间可以强制转换</strong></p><h1 id="11-内联函数与宏定义的区别"><a class="markdownIt-Anchor" href="#11-内联函数与宏定义的区别"></a> 11 <strong>内联函数与宏定义的区别</strong></h1><p>所谓的内联函数就是那些完整地定义在类内部的函数成员。</p><p>C++ 宏定义将一个标识符定义为一个字符串，源程序中的该标识符均以指定的字符串来代替。</p><ul><li>宏定义在预编译的时候就会进行宏替换；内联函数在编译阶段，在调用内联函数的地方进行替换，减少了函数的调用过程，但是使得编译文件变大。因此，内联函数适合简单函数，对于复杂函数，即使定义了内联，编译器可能也不会按照内联的方式进行编译。</li><li>内联函数相比宏定义更安全，内联函数可以检查参数，而宏定义只是简单的文本替换。因此推荐使用内联函数，而不是宏定义。</li></ul><hr><h1 id="补充1-c笔记"><a class="markdownIt-Anchor" href="#补充1-c笔记"></a> <strong>补充1 C笔记</strong></h1><ol><li>exe已停止工作：1)漏&amp;；2)分母为0</li><li>定义整型，输入实型：自动截取小数部分，eg:2.5-&gt;2(赋值亦是)。</li><li>输出数据出错：格式字符与变量类型未对应；为赋初值。特别注意除号“/”和等号“==”。</li><li>数据范围与补码：-1全1，正负0全0，负数min为“1+全0”;溢出取低位，小数对应21,22,23…小数转二进制数: x/2取整数部分直到小数为0。</li><li>else就近结合。</li><li>|| 和 &amp;&amp; 的短路特性。</li><li>数组a[]: scanf(&quot;%d&quot;, a)指对a[0]赋值。</li><li>字符串：scanf(&quot;%s&quot;, a)-&gt;遇’ ‘, ‘\0’, ‘\t’为截点(’\n’跳出)开始不计；puts()=printf(&quot;%s&quot;, a)-&gt;遇’\0’结束；gets()遇回车结束，前无截点。</li><li>x *= y+8 等价于 x = x + (y+8)</li><li>C语言的函数体中，可以调用但不能定义其他函数。</li><li>puts()自动换行，putchar()不自动换行。</li></ol><h1 id="补充2-c笔记"><a class="markdownIt-Anchor" href="#补充2-c笔记"></a> <strong>补充2 C++笔记</strong></h1><ol><li><p>endl = ‘\n’ + flush(刷新缓冲区)</p></li><li><p>cin跳过空白字符，cin.get()读取包含空白字符的字符</p></li><li><p>浮点数和整型注意转化中的除号</p></li><li><p>递归调用次数可用二叉树解决</p></li><li><p>C++, 字符串拷贝用&quot;=&quot;, 字符串比较&quot;==&quot;</p></li><li><p>汉字占两个字符，故name[0]无法输出，&quot;cout&lt;&lt;name[0]&lt;&lt;name[1]&quot;输出一个汉字</p></li><li><p>cin对象遇’\n’结束</p></li><li><p>nullptr能够避免在整数(0或NULL)和指针(nullptr)之间发生混淆</p></li><li><p><strong>函数传参</strong>：数据较小，按值传递，但修改时用引用；数组用指针；结构体用指针或引用；对象用引用</p></li><li><p><strong>缺省函数</strong>：声明函数(最先且一次)时为其参数指定默认值</p></li><li><p><strong>sizeof()</strong>: 测字节(包含’\0’)区分数组与指针<strong>strlen()</strong>: 不区分数组还是指针，读到’\0’为止返回长度(\t,\n不停)</p></li><li><p><strong>全局变量</strong>: int global -&gt; extern int global 声明到文件结尾<strong>局部变量</strong>: 从声明到函数结束<strong>静态变量</strong>: 函数退出保留值，下次调用</p></li><li><p>getline()读取换行符，但向数组存储时并不存储</p></li><li><p>初始化和赋值是不同概念</p></li><li><p>文本文件存储文件大小：char类型存储；二进制文件：&quot;01&quot;存储(内存大小)</p></li><li><p>引起缓存区刷新：缓存区满时(4K)；程序结束；flush语句；close语句；endl语句</p></li><li><p>解决<redefinition>：<em>#ifdef ``` #endif</em> 或 <em>#pragma once</em></redefinition></p></li><li><p>派生类的构造函数只能描述自己的成员和基类的初始化，不能去初始化基类的成员；基类的成员需要调用基类的构造函数初始化。</p></li><li><p>k = (a=1, b=2, a+b)逗号运算符</p></li><li><p>自身类的对象不能作为类的成员(存在无限初始化问题，构造成员变量-&gt;调用自身的构造函数)，而自身类对象的引用和指针可以。</p></li><li><p><strong>虚函数</strong>：特殊的成员函数，用来实现运行时的多态；动态决议(运行时才绑定)；基类说明virtual后，子类可缺省virtual<strong>静态成员函数</strong>：静态决议(编译时就绑定)，属于整个class，并不针对某个类的实例，为所有对象所共用，作用域为全局；不能直接使用this指针；virtual不能是static</p></li><li><p><strong>静态数据成员</strong>：class内声明：<em>static int num</em>; class外定义：<em>int className::num</em>(无static，默认0)</p></li><li><p><strong>继承中的析构函数</strong>：基类的指针可指向派生类对象(多态性); *if delete []p;*就会调用该指针指向的派生类析构函数，而其自动调用基类的析构函数，整个派生类的对象被完全释放。若析构函数不被声明成虚函数，则编译器是是静态绑定，再删除基类指针时，只会调用基类的析构函数而不调用派生类的析构函数，这样一来派生类对象析构不完全。</p></li><li><p>两个指针指向同一数组，可以相减，结果是两个指针之间的元素数目。</p></li><li><p><strong>函数模板</strong>：一个模板，专门用来生产函数的<strong>模板函数</strong>：是函数模板的实例化 <strong>注</strong>：类模板和模板类亦同</p></li><li><p>联编</p><p>：程序自身彼此关联的过程，确定程序中的操作调用与执行该操作的代码之间的关系。</p><ul><li><strong>静态联编</strong>：联编工作出现在联编阶段，用对象名或者类名来限定要调用的函数；</li><li><strong>动态联编</strong>：联编工作在程序运行时执行，在程序运行时才确定将要调用的函数。</li></ul></li><li><p>虚基类子对象是由最远派生类的构造函数通过调用虚基类的构造函数进行初始化的；初始化列表列出对虚基类调用，如未列出则用虚基类构造函数；先虚后非虚。</p></li><li><p><strong>虚基类</strong>：多条继承路径上有一个公共的基类，公共的基类会产生多个实例。<em>virtual class</em>是为了实例化一次基类存在的。eg: ios类是istream和ostream类的虚基类。</p></li><li><p>char = int + ‘0’</p></li><li><p><strong>指针数组</strong>：int *p[4]<strong>数组指针</strong>：int (*p)[4]</p></li><li><p><strong>Runtime Error</strong>: 除0操作；数组越界；栈溢出；未指定值的指针进行读写操作；已经释放空间的指针再次释放。</p></li><li><p>数组</p><p>：</p><ul><li><strong>int&amp;float&amp;double</strong>:初始化补零</li><li><strong>char</strong>: 初始化补’\0’</li><li><strong>对象</strong>：调用缺省构造函数</li></ul></li><li><p>常对象不能被更新，因此通过常对象只能调用他的常成员函数。</p></li><li><p>临时对象是在遇到其后第一个分号(语句结束处)析构的。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="C++" scheme="https://dragonliu2022.github.io/categories/C/"/>
    
    
    <category term="面试" scheme="https://dragonliu2022.github.io/tags/面试/"/>
    
  </entry>
  
  <entry>
    <title>卫语句</title>
    <link href="https://dragonliu2022.github.io/2022/04/18/%E5%8D%AB%E8%AF%AD%E5%8F%A5/"/>
    <id>https://dragonliu2022.github.io/2022/04/18/%E5%8D%AB%E8%AF%AD%E5%8F%A5/</id>
    <published>2022-04-18T08:32:06.000Z</published>
    <updated>2022-04-18T14:52:33.148Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p><strong>转载</strong>：<a href="https://blog.csdn.net/qq_36631379/article/details/107951535" target="_blank" rel="noopener">浅谈使用卫语句重构方法</a></p></blockquote><h1 id="1-卫语句定义"><a class="markdownIt-Anchor" href="#1-卫语句定义"></a> 1 卫语句定义</h1><p>如果条件语句极其复杂，就应该将条件语句拆解开，然后逐个检查，并在条件为真时立刻从函数中返回，这样的单独检查通常被称之为“卫语句”(Guard Clauses)。</p><p><strong>说人话就是</strong>：写方法时在合适的时候尽快return，少用else</p><h1 id="2-按卫语句对函数进行重构应遵循"><a class="markdownIt-Anchor" href="#2-按卫语句对函数进行重构应遵循"></a> 2 按卫语句对函数进行重构应遵循</h1><ol><li>及时return，if中能return就return。(一旦满足条件return后你根本无需关注后面的代码)</li><li>能够return的就尽量少使用else。(用else太多，读者需要维护大量的栈在大脑中)</li><li>减少嵌套，一般嵌套超过4层读者就会产生阅读恐惧感。</li></ol><h1 id="3-示例"><a class="markdownIt-Anchor" href="#3-示例"></a> 3 示例</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>（it == 活的）&#123;</span><br><span class="line">    <span class="keyword">if</span>（it == 人）&#123;</span><br><span class="line">        <span class="keyword">if</span>（it ！= 女人）&#123;</span><br><span class="line">            <span class="keyword">return</span> 不喜欢；</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> 喜欢；</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> 不喜欢；</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> 不喜欢；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码无非就是表达 <code>我只喜欢活的女人</code> 的意思，但是代码一层套一层明显妨碍了我在第一时间获取最核心信息的效率，使用卫语句来表达就是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> （it ！= 活的）&#123;<span class="keyword">return</span> 不喜欢&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>（it！=人）&#123;<span class="keyword">return</span> 不喜欢&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>（it！=女人）&#123;<span class="keyword">return</span> 不喜欢&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>（it == 女人 &amp;&amp; it == 活的） &#123;<span class="keyword">return</span> 喜欢&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> 不喜欢</span><br></pre></td></tr></table></figure><p>这样看起来，代码就更明晰易懂。</p><p>有点<strong>逆向思维</strong>的意思。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="未分类" scheme="https://dragonliu2022.github.io/categories/未分类/"/>
    
    
    <category term="重构" scheme="https://dragonliu2022.github.io/tags/重构/"/>
    
  </entry>
  
  <entry>
    <title>git vs svn</title>
    <link href="https://dragonliu2022.github.io/2022/04/18/git-vs-svn/"/>
    <id>https://dragonliu2022.github.io/2022/04/18/git-vs-svn/</id>
    <published>2022-04-18T08:28:44.000Z</published>
    <updated>2022-04-18T15:53:23.147Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p><strong>转载</strong>：<a href="https://www.cnblogs.com/Sungeek/p/9152223.html#sg3" target="_blank" rel="noopener">SVN与Git比较的优缺点差异</a></p></blockquote><h1 id="1-集中式-vs-分布式"><a class="markdownIt-Anchor" href="#1-集中式-vs-分布式"></a> 1 集中式 vs 分布式</h1><h2 id="11-subversion属于集中式的版本控制系统"><a class="markdownIt-Anchor" href="#11-subversion属于集中式的版本控制系统"></a> 1.1 <strong>Subversion属于集中式的版本控制系统</strong></h2><p>集中式的版本控制系统都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。</p><img src="https://s2.loli.net/2022/04/18/bqmSZKA6HNOGxyu.png" width="300" height="300" alt="图片名称" align="center" id="172"><p><strong>Subversion的特点概括起来主要由以下几条：</strong></p><ul><li>每个版本库有唯一的URL（官方地址），每个用户都从这个地址获取代码和数据；</li><li>获取代码的更新，也只能连接到这个唯一的版本库，同步以取得最新数据；</li><li>提交必须有网络连接（非本地版本库）；</li><li>提交需要授权，如果没有写权限，提交会失败；</li><li>提交并非每次都能够成功。如果有其他人先于你提交，会提示“改动基于过时的版本，先更新再提交”… 诸如此类；</li><li>冲突解决是一个提交速度的竞赛：手快者，先提交，平安无事；手慢者，后提交，可能遇到麻烦的冲突解决。</li></ul><p><strong>好处</strong>：每个人都可以一定程度上看到项目中的其他人正在做些什么。而管理员也可以轻松掌控每个开发者的权限。</p><p><strong>缺点</strong>：</p><ul><li>中央服务器的单点故障。若是宕机一小时，那么在这一小时内，谁都无法提交更新、还原、对比等，也就无法协同工作。如果中央服务器的磁盘发生故障，并且没做过备份或者备份得不够及时的话，还会有丢失数据的风险。最坏的情况是彻底丢失整个项目的所有历史更改记录，被客户端提取出来的某些快照数据除外，但这样的话依然是个问题，你不能保证所有的数据都已经有人提取出来。</li><li>Subversion原理上只关心文件内容的具体差异。每次记录有哪些文件作了更新，以及都更新了哪些行的什么内容。</li></ul><h2 id="12-git属于分布式的版本控制系统"><a class="markdownIt-Anchor" href="#12-git属于分布式的版本控制系统"></a> 1.2 Git属于分布式的版本控制系统</h2><img src="https://s2.loli.net/2022/04/18/uryM1ZCEP6b2NRF.png" width="300" height="300" alt="图片名称" align="center" id="171"><p>Git记录版本历史只关心文件数据的<strong>整体</strong>是否发生变化。Git 不保存文件内容前后变化的差异数据。</p><p>实际上，Git 更像是把变化的文件作快照后，记录在一个微型的文件系统中。每次提交更新时，它会纵览一遍所有文件的指纹信息并对文件作一快照，然后保存一个指向这次快照的索引。为提高性能，若文件没有变化，Git 不会再次保存，而只对上次保存的快照作一连接。</p><p>在分布式版本控制系统中，客户端并不只提取最新版本的文件快照，而是把原始的代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。这类系统都可以指定和若干不同的远端代码仓库进行交互。籍此，你就可以在同一个项目中，分别和不同工作小组的人相互协作。你可以根据需要设定不同的协作流程。</p><p>另外，因为Git在本地磁盘上就保存着所有有关当前项目的历史更新，并且Git中的绝大多数操作都只需要访问本地文件和资源，不用连网，所以处理起来速度飞快。用SVN的话，没有网络或者断开VPN你就无法做任何事情。但用Git的话，就算你在飞机或者火车上，都可以非常愉快地频繁提交更新，等到了有网络的时候再上传到远程的镜像仓库。换作其他版本控制系统，这么做几乎不可能，抑或是非常麻烦。</p><p><strong>Git具有以下特点：</strong></p><ul><li>Git中每个克隆(clone)的版本库都是平等的。你可以从任何一个版本库的克隆来创建属于你自己的版本库，同时你的版本库也可以作为源提供给他人，只要你愿意。</li><li>Git的每一次提取操作，实际上都是一次对代码仓库的完整备份。</li><li>提交完全在本地完成，无须别人给你授权，你的版本库你作主，并且提交总是会成功。</li><li>甚至基于旧版本的改动也可以成功提交，提交会基于旧的版本创建一个新的分支。</li><li>Git的提交不会被打断，直到你的工作完全满意了，PUSH给他人或者他人PULL你的版本库，合并会发生在PULL和PUSH过程中，不能自动解决的冲突会提示您手工完成。</li><li>冲突解决不再像是SVN一样的提交竞赛，而是在需要的时候才进行合并和冲突解决。</li><li>Git 也可以模拟集中式的工作模式</li><li>Git版本库统一放在服务器中</li><li>可以为 Git 版本库进行授权：谁能创建版本库，谁能向版本库PUSH，谁能够读取（克隆）版本库</li><li>团队的成员先将服务器的版本库克隆到本地；并经常的从服务器的版本库拉（PULL）最新的更新；</li><li>团队的成员将自己的改动推（PUSH）到服务器的版本库中，当其他人和版本库同步（PULL）时，会自动获取改变</li><li>Git 的集中式工作模式非常灵活</li><li>你完全可以在脱离Git服务器所在网络的情况下，如移动办公／出差时，照常使用代码库</li><li>你只需要在能够接入Git服务器所在网络时，PULL和PUSH即可完成和服务器同步以及提交</li><li>Git提供 rebase 命令，可以让你的改动看起来是基于最新的代码实现的改动</li><li>Git 有更多的工作模式可以选择，远非 Subversion可比</li></ul><h1 id="2-版本库与工作区"><a class="markdownIt-Anchor" href="#2-版本库与工作区"></a> 2 版本库与工作区</h1><p>Subversion的工作区和版本库是截然分开的，而Git的工作区和版本库是如影随形的。</p><h2 id="21-svn的版本库和工作区是分离的"><a class="markdownIt-Anchor" href="#21-svn的版本库和工作区是分离的"></a> 2.1 SVN的版本库和工作区是分离的</h2><ul><li>Subversion 的工作区和版本库物理上分开：Subversion的版本库和工作区是存储在不同路径下，一般是在不同的主机中</li><li>Subversion的企业级部署中，版本库在服务器上，只能通过 https, http, svn 等协议访问，而不能直接被用户接触到。</li><li>Subversion的工作区是一份版本库在某个历史状态下的快照，如：版本库最新的数据检出到工作区。</li><li>Subversion的工作区中每一个目录下都包含一个名为 .svn 的控制目录（隐藏的目录），该目录的作用是：<ul><li>标识工作区和版本库的对应关系。</li><li>包含一份该子目录下检出文件的原始拷贝。当文件改动的差异比较或者本地改动的回退时，可以直接参考原始拷贝而无须通过网络访问远程版本库。</li></ul></li><li>Subversion 的 .svn 控制目录会引入很多麻烦：<ul><li>.svn 下的文件原始考本，会导致在目录下按照文件内容搜索时，多出一倍的搜索时间和搜索结果。</li><li>.svn 很容易在集成时，引入产品中，尤其是 Web 应用，将 .svn 目录带入Web服务器会导致安全隐患。因为一个不允许目录浏览的Web目录，可以通过 .svn/entries 文件查看到该目录下可能存在的文件。</li></ul></li></ul><h2 id="22-git-的版本库和工作区如影随形"><a class="markdownIt-Anchor" href="#22-git-的版本库和工作区如影随形"></a> 2.2 Git 的版本库和工作区如影随形</h2><ul><li>Git 的版本库和工作区在同一个目录下，工作区的根目录有一个.git的子目录，这个名为 .git的目录就是版本库本身，它是Git 用来保存元数据和对象数据库的地方。该目录非常重要，每次克隆镜像仓库的时候，实际拷贝的就是这个目录里面的数据。所以千万要小心删除这个文件。</li><li>工作区中其他文件为工作区文件，可能是从 .git 中检出的，或者是要检入的，或者是运行产生的临时文件等。</li><li>版本库可以脱离工作区而存在，成为 bare（赤裸）版本库。可以用 –bare 参数来创建。但是工作区不能脱离版本库而存在，即工作区的根目录下必须有一个名为 .git 的版本库克隆文件。</li><li>Git 的版本库因为就在工作区中，能直接被用户接触到。<ul><li>用户可以编辑 .git/config 文件，修改配置，增添新的源</li><li>用户可以编辑 .git/info/exclude 文件，创建本地忽略…</li></ul></li><li>Git 的工作区中只在工作区的根目录下有一个 .git 目录，此外再无任何控制目录。Git 工作区下唯一的 .git 目录是版本库，并非 .svn 的等价物，如果删除了 .git 目录，而又没有该版本库的其他镜像（克隆）的话，你破坏了整个历史，版本库也永远的失去了。</li><li>Git 在本地的 .git 版本库，提供了完全的改动历史。除了和其他人数据交换外，任何版本库相关的操作都在本地完成，更多的本地操作，避免了冗长的网络延迟，大大节省了时间。例如：查看 log，切换到任何历史版本等操作都无须连接网络。</li><li>Git如何保证安全：本地创建一个Git库，因为工作区和库是在同一个目录中，如果工作区删除了，或者所在的磁盘分区格式化了，数据不是全都没有了么？其实我们可以这样做：<ul><li>在一个磁盘分区中创建版本库（最好是用 –bare 参数创建），然后在另外的磁盘分区中克隆一个新的作为工作区。在工作区的提交要不时的PUSH到另外分区的版本库，这样就实现了本地的数据镜像。你甚至可以在本地创建更多的版本库镜像，安全性要比Subversion的一个库加上一个工作区安全。</li><li>另一个办法：把你的版本库共享给他人，当他人克隆了你的版本库时，你就拥有了一个异地备份。</li></ul></li></ul><h1 id="3-全局版本号和全球版本号"><a class="markdownIt-Anchor" href="#3-全局版本号和全球版本号"></a> 3 全局版本号和全球版本号</h1><p>SVN的全局版本号和CVS的每个文件都独立维护一套版本号相比，是一个非常大的进步。在看似简单的全局版本号的背后，是Subversion提供对于事物处理的支持，每一个事物处理（即一次提交）都具有整个版本库全局唯一的版本号。</p><p>Git的版本号则更进一步，版本号是全球唯一的。Git 对于每一次提交，通过对文件的内容或目录的结构计算出一个SHA-1 哈希值，得到一个40位的十六进制字符串，Git将此字符串作为版本号。</p><h2 id="31-svn与git版本号比较"><a class="markdownIt-Anchor" href="#31-svn与git版本号比较"></a> 3.1 SVN与Git版本号比较</h2><ul><li>所有保存在Git 数据库中的数据都是用此40位的哈希值作索引的，而不是靠文件名。</li><li>使用哈希值作版本号的好处就是对于一个分布式的版本控制系统，每个人每次提交后形成的版本号都不会出现重复。另一好处是保证数据的完整性，因为哈希值是根据内容或目录结构计算出来的，所以我们还可以据此来判断数据内容是否被篡改。</li><li>SVN 的版本号是连续的，可以预判下一个版本号，而 Git 的版本号则不是。<ul><li>因为 subversion 是集中式版本控制，很容易实现版本号的连续性。</li><li>Git 是分布式的版本控制系统，而且 Git 采用 40 位长的哈希值作为版本号，每个人的提交都是各自独立完成的，没有先后之分（即使提交有先后之分，也由于PUSH/PULL的方向和时机而不同）。Git 的版本号虽然不连续，但是是有线索的，即每一个版本都有对应的父版本（一个或者两个），进而可以形成一个复杂的提交链</li></ul></li><li>Git 的版本号简化：Git 可以使用从左面开始任意长度的字串作为简化版本号，只要该简化的版本号不产生歧义。一般采用7位的短版本号（只要不会出现重复的，你也可以使用更短的版本号）。</li></ul><h1 id="4-部分检出"><a class="markdownIt-Anchor" href="#4-部分检出"></a> 4 部分检出</h1><p>Subversion可以将整个库检出到工作区，也可以将某个目录检出到工作区。对于要使用一个庞大、臃肿的版本库的用户来说，部分检出是非常方便和实际的。</p><p>但是Git只能全部检出，不支持按照目录进行的部分检出。</p><h2 id="41-svn的部分检出"><a class="markdownIt-Anchor" href="#41-svn的部分检出"></a> 4.1 SVN的部分检出</h2><ul><li>在SVN中，从仓库checkout的一个工作树，每个子目录下都维护着自己的.svn目录，记录着该目录中文件的修改情况以及和服务器端仓库的对应关系。所以SVN可以checkout部分路径下的内容（部分检出），而不用checkout整个版本库或分支。</li><li>Subversion 有一条命令：svn export ，可以将 subversion 版本库的一个目录下所有内容导出到指定的目录下。Subversion 需要 svn export 命令是因为该命令可以导出一个干净的目录，即不包含 .svn 目录（包含配置文件和文件原始拷贝）。</li></ul><h2 id="42-git的检出"><a class="markdownIt-Anchor" href="#42-git的检出"></a> 4.2 Git的检出</h2><ul><li>Git 没有部分检出，这并不是说只有将整个库克隆下来才能查看文件。有很多 git 工具，提供直接浏览git库的功能，例如 gitweb, trac 的 git 版本库浏览, redmine 的 git 版本库浏览。</li><li>Git-submodule 可以实现版本库的模块化：Git 通过子模块处理这个问题。子模块允许你将一个Git 仓库当作另外一个Git仓库的子目录。这允许你克隆另外一个仓库到你的项目中并且保持你的提交相对独立。</li><li>Git 为什么没有实现 svn export 的功能？由于git的本地仓库信息完全维护在project根目录的.git目录下，（不像svn一样，每个子目录下都有单独的.svn目录）。所以，只要clone，checkout然后删除.git目录就可以了。</li></ul><h1 id="5-更新和提交"><a class="markdownIt-Anchor" href="#5-更新和提交"></a> 5 更新和提交</h1><h2 id="51-更新操作"><a class="markdownIt-Anchor" href="#51-更新操作"></a> 5.1 更新操作</h2><p>在SVN中，因为只有一个中心仓库，所以所谓的远程更新，也就是svn update ,通过此命令来使工作区和版本库保持同步。</p><p>对于git来说，别人的改动是存在于远程仓库上的，所以git checkout命令尽管在某些功能上和svn中的update类似（例如取仓库特定版本的内容），但是在远程更新这一点上，还是不同的，不属于git checkout的功能涵盖范围。 Git使用git fetch和git pull来完成远程更新任务，fetch操作只是将远程数据库的object拷贝到本地，然后更新remotes head的refs，git pull 的操作则是在git fetch的基础上对当前分支外加merge操作。</p><blockquote><p>大致上 git pull = git fetch + git merge</p></blockquote><h2 id="52-svn中的commit命令"><a class="markdownIt-Anchor" href="#52-svn中的commit命令"></a> 5.2 SVN中的commit命令</h2><p>对于SVN来说，由于是中心式的仓库管理形式，所以并不存在特殊的远程提交的概念，所有的commit操作都可以认为是对远程仓库的更新动作。在工作区中对文件进行添加、修改、删除操作要同步到版本库，必须使用 commit命令。</p><ul><li>add 命令，是将未标记为版本控制状态的文件标记为添加状态，并在下次提交时入库。</li><li>delete命令，是通过SVN来删除文件，并在下次提交后有效。</li><li>Subversion 有提交列表功能，即将某些文件加入一个修改列表，提交可以只提交处于该列表的文件。</li></ul><h2 id="53-git中的暂存区域stage"><a class="markdownIt-Anchor" href="#53-git中的暂存区域stage"></a> 5.3 Git中的暂存区域（stage）</h2><p>Git 管理项目时，文件在三个工作区域中流转：Git 的本地数据目录，工作目录以及暂存区域。暂存区域（stage）是介于 workcopy 和 版本库 HEAD 版本的一种中间状态。所谓的暂存区域只不过是个简单的文件，一般都放在git 目录中。有时候人们会把这个文件叫做索引文件，不过标准说法还是叫暂存区域。</p><p>要将一个文件纳入版本管理的范畴，首先是要用git add将文件纳入stage的监控范围，只有更新到stage中的内容才会在commit的时候被提交。另外，文件本身的改动并不会自动更新到stage中，每次的任何修改都必须重新更新到stage中去才会被提交。对于工作区直接删除的文件，需要用 git rm 命令进行标记，在下次提交时，在版本库中删除。</p><ul><li>工作区的文件改动（新增文件，修改文件，删除文件），必须用 git add 或者 git rm 命令标识，使得改动进入 stage</li><li>提交只对加入 stage 的改动进行提交</li><li>如果一个文件改动加入 stage 后再次改动，则后续改动不改变 stage。即该文件的改动有两个状态，一个是标记到 stage 中并将在下次提交时入库的改动，另外的后续改动则不被提交，除非再次使用 git add 命令将改动加入到 stage 中。</li><li>Git的stag让你在提交的时候清楚的知道git将要提交哪些改动。除非提交的时候使用 -a 参数（不建议使用）。</li></ul><p>我们可以从文件所处的位置来判断其状态：如果是git目录中保存着的特定版本文件，就属于已提交状态；如果作了修改并已放入暂存区域，就属于已暂存状态；如果自上次取出后，作了修改但还没有放到暂存区域，就是已修改状态，如果取出后未进行修改则是未修改状态。</p><p>在git中，因为有本地仓库和remote仓库之分，所以也就区别于commit 操作，存在额外的push命令，用于将本地仓库的数据更新到远程仓库中去。git push 可以选择需要提交的、更新的分支以及制定该分支在远程仓库上的名字。</p><h1 id="6-分支和里程碑的实现"><a class="markdownIt-Anchor" href="#6-分支和里程碑的实现"></a> 6 分支和里程碑的实现</h1><p>几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。在很多版本控制系统中，这是个昂贵的过程，常常需要创建一个源代码目录的完整副本，对大型项目来说会花费很长时间。</p><p>轻量级分支/里程碑的含义是，创建分支/里程碑的复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>，不会因为版本库的愈加庞大而变得缓慢。在CVS中，创建分支的复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>的，导致大的版本库的的分支创建非常缓慢。</p><blockquote><p>CVS （代码版本控制软件）：<a href="https://baike.baidu.com/item/CVS/405463" target="_blank" rel="noopener">百度百科</a></p></blockquote><h2 id="61-subversion的分支里程碑"><a class="markdownIt-Anchor" href="#61-subversion的分支里程碑"></a> 6.1 Subversion的分支/里程碑</h2><p>Subversion轻量级分支和里程碑的实现是通过svn cp命令，即带历史的拷贝就是创建快速创建分支和里程碑的秘籍。Subversion的版本库有特殊的设计，当你复制一个目录，你不需要担心版本库会变得十分巨大—Subversion并不是拷贝所有的数据，相反，它只是建立了一个已存在目录树的入口。这种“廉价的拷贝”就是创建分支/里程碑是轻量级的原因。</p><p>由于Svn的分支和标签是来自目录拷贝，约定俗成是拷贝在 branches/和tags/目录下。所谓分支，tag等概念都只是仓库中不同路径上的一个对象或索引而已，和普通的路径并没有什么本质的区别，谁也不能阻止在一个提交中同时修改不同分支中的数据。</p><p>里程碑是对某个历史提交所起的一个别名，作为历史的标记，是不应该被更改的。svn的里程碑要建立到 tags/目录下，要求不要在tags/下的里程碑目录下进行提交。但是谁也阻止不了对未进行权限控制的里程碑的篡改。</p><h2 id="62-git-的轻量级分支和里程碑"><a class="markdownIt-Anchor" href="#62-git-的轻量级分支和里程碑"></a> 6.2 Git 的轻量级分支和里程碑</h2><p>Git中的分支实际上仅是一个包含所指对象校验和（40个字符长度SHA-1 哈希值）的文件，所以创建和销毁一个分支就变得非常廉价。说白了，新建一个分支就是向一个文件写入41个字节（版本号外加一个换行符）那么简单，自然速度就很快了。 Git的实现与项目复杂度无关，它永远可以在几毫秒的时间内完成分支的创建和切换。这和大多数版本控制系统形成了鲜明对比。</p><p>Git的分支是完全隔离的，而Subversion则没有。分支本来就应该是相对独立的命名空间，一个提交一般只能发生在一个分支中。在Git中，其内部的对象层级依赖关系或许和SVN类似，但是其工作树的视图表现形式和SVN完全不同。工作树永远是一个完整的分支，不同的分支由不同的head索引去构建，你不可能在工作树中同时获得多个分支的内容。</p><p>Git使用的标签有两种类型：轻量级的（lightweight）和含附注的（annotated）。</p><p>① 轻量级标签就像是个不会变化的分支，实际上它就是个指向特定提交对象的引用。</p><p>② 而含附注标签，实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，电子邮件地址和日期，以及标签说明，标签本身也允许使用GNU Privacy Guard (GPG) 来签署或验证。</p><p>Git的里程碑是只读的，Git完全遵守历史不可更改这一时空法则。用户不能向git的里程碑中提交，否则里程碑就不是标记，而成了一个分支。当然Git允许用户删除里程碑再重新创建指定到不同历史提交。</p><h2 id="63-多分支间的切换"><a class="markdownIt-Anchor" href="#63-多分支间的切换"></a> 6.3 多分支间的切换</h2><p>SVN中提供了一个功能switch，使用switch可以在同一个工作树上，在不同的分支中进行切换。</p><p>Git在分支中进行切换使用的命令是checkout。</p><h1 id="7-分支与合并"><a class="markdownIt-Anchor" href="#7-分支与合并"></a> 7 分支与合并</h1><p>Git 和 Svn 的分支实现机制完全的不同，这也直接导致了 SVN 在分支合并中困难重重。尽管在 SVN 1.5 之后，通过 svn:mergeinfo 属性引入了合并追踪机制，但是在特定情况下，合并仍会出现很多困难。</p><h2 id="71-svn的分支合并"><a class="markdownIt-Anchor" href="#71-svn的分支合并"></a> 7.1 SVN的分支合并</h2><p>当你在一个分支上工作数周或几个月之后，主干的修改也同时在进行着，两条线的开发会区别巨大，当你想合并分支回主干，可能因为太多冲突，已经无法轻易合并你的分支和主干的修改。</p><p>另一个问题，Subversion不会记录任何合并操作，当你提交本地修改，版本库并不能判断出你是通过svn merge还是手工修改得到这些文件。所以你必须手工记录这些信息（说明合并的特定版本号或是版本号的范围）。</p><p>要解决以上的问题只有通过有规律的将主干合并到分支来避免，制定这样一个政策：每周将上周的修改合并到分支，注意这样做时需要小心，你必须手工记录合并的过程，以避免重复的合并，你需要小心的撰写合并的日志信息，精确的描述合并包括的范围。这样做看起来有点像是胁迫。</p><p>SVN 的版本号是连续的版本号。每一次新的提交都会版本号+1 ，而无论这个提交是在哪个分支中进行的。SVN一个提交可以同时修改不同分支的不同文件，因为提交命令可以在 /trunk, /branches, /tags 的上一级目录执行。</p><ul><li>SVN 的提交是单线索的，每一个提交（最原始的提交0除外）都只有一个父节点（版本号小一个的提交节点）</li><li>SVN 的提交链只有一条，仅从版本号和提交说明，我们无法获得分支图</li><li>SVN 的分支图在某些工具（如乌龟SVN）可以提供，那是需要对提交内容进行检查，对目录拷贝动作视为分支，对 svn:mergeinfo 的改动视为合并，但这会由于目录管理的灵活性，导致千奇百怪的分支图表。</li></ul><h2 id="72-git的分支合并"><a class="markdownIt-Anchor" href="#72-git的分支合并"></a> 7.2 Git的分支合并</h2><p>在 git 版本库中创建分支的成本几乎为零，所以，不必吝啬多创建几个分支。当第一次执行git-init时，系统就会创建一个名为”master”的分支。 而其它分支则通过手工创建。下面列举一些常见的分支策略。</p><p>① 创建一个属于自己的个人工作分支，以避免对主分支 master 造成太多的干扰，也方便与他人交流协作。<br>② 当进行高风险的工作时，创建一个试验性的分支，扔掉一个烂摊子总比收拾一个烂摊子好得多。<br>③ 合并别人修改的时候，最好创建一个临时的分支用来合并，合并完成后再“fatch”到自己的分支。</p><p>Git分支相关的操作命令</p><h1 id="8-撤消操作"><a class="markdownIt-Anchor" href="#8-撤消操作"></a> 8 撤消操作</h1><h2 id="81-提交的撤销"><a class="markdownIt-Anchor" href="#81-提交的撤销"></a> 8.1 提交的撤销</h2><p>在Subversion中一旦完成向服务器的数据提交，你就没有办法再从客户端追回，只能在后续的提交中修正（回退或者修改）等。因为Subversion作为集中式的版本控制，不能允许个人对已提交的数据进行篡改。Subversion具有一个非常重要的特性就是它的信息从不丢失，即使当你删除了文件或目录，它也许从最新版本中消失了 ，但这个对象依然存在于历史的早期版本中。</p><p>Git则不同，Git是分布式版本控制系统，代码库是属于个人，允许任意修改。Git通过对提交建立数字摘要来保证提交的唯一性和不可更改性，通过版本库在多人之间的多份拷贝来保障数据的安全性。Git可以丢弃最新的一个或几个提交，使用 git reset –hard命令可以永远丢弃最新的一个或者几个提交。</p><h2 id="82-提交说明的修改"><a class="markdownIt-Anchor" href="#82-提交说明的修改"></a> 8.2 提交说明的修改</h2><p>提交后如果对提交说明不满意，如何实现对提交说明的修改：</p><ol><li>Git可以使用命令git commit –amend修改提交说明。<ul><li>Git可以修改最后一次提交说明，并不是说不能修改历史版本的提交说明，只是修改最后一个版本提交说明拥有最简单的命令；</li><li>Git修改提交说明，会改变提交的commit-id。即修改提交说明后，将产生一个新的提交；</li><li>Git可以通过git reset –hard ，git commit –amend，git rebase onto 等命令来实现对历史提交的修改；</li><li>使用stg工具可以更为简单的修改历史提交的提交说明，包括提交内容；</li></ul></li><li>Subversion也可以修改提交说明，是通过修改提交的svn:log版本属性实现的：<ul><li>不但可以修改最后一次提交的说明，并且可以修改历史提交的提交说明；</li><li>Subversion修改提交说明是不可逆的操作，可能会造成说明被恶意修改；</li><li>Subversion缺省关闭修改提交说明的功能。管理员在设置了提交说明更改的邮件通知后，才可以打开该功能。</li></ul></li></ol><h2 id="83-修改和重构历史提交"><a class="markdownIt-Anchor" href="#83-修改和重构历史提交"></a> 8.3 修改和重构历史提交</h2><p>Git可以修改和重构历史提交：使用Git本身的reset以及 rebase 命令可以修改或者重整/重构历史提交，非常灵活。使用强大的 stg 可以使得历史提交的重构更为简洁，如果您对 stg 或者 Hg/MQ 熟悉的话。</p><p>Subversion 修改历史提交，只能由管理员完成。</p><p>Subversion 是集中式版本控制系统，从客户端一旦完成提交，就没有办法从客户端撤销提交。但是管理员可以在服务器端完成提交的撤销和修改，但是操作过程和代价较大。</p><h1 id="9-权限管理"><a class="markdownIt-Anchor" href="#9-权限管理"></a> 9 权限管理</h1><p>Subversion通过对文件目录授权来实现权限管理，子目录默认继承父目录的权限。但是也有缺憾，即权限不能在分支中继承，不能对单个文件授权。例如为 /trunk及其子目录的授权，不能继承到分支或者标签中相应的目录下。</p><p>Git 的授权做不到Subversion那样精细。Git的授权模型只能实现非零即壹式的授权，要么拥有全部的写权限，要么没有写权限，要么拥有整个版本库的读权限，要么禁用。</p><p>从技术上将，Git可能永远也做不到类似SVN的路径授权（读授权）：</p><ul><li>如果允许按照路径授权，则各个克隆的关系将不再是平等的关系，有的内容多，有的内容少，分布式的理念被破坏</li><li>如果只有部分路径可读，则克隆出来的提交和原始提交的提交ID可能不同。因为提交ID是和提交内容有关的，克隆中提交的部分内容被丢弃，势必提交的ID也要重新计算</li><li>允许全部代码可读，只允许部分代码可写，在版本控制的管理下，是没有多大实际意义的，而且导致了提交的逻辑上的不完整。</li></ul><p>那么有什么办法来解决授权的问题？</p><ol><li>公司内部代码开放。即代码在公司内部，对项目组成员一视同仁的开放。</li><li>公司对代码库进行合理分解，对每个代码库分别授权。即某个代码库对团队成员完全开放，对其它团队完全封闭。</li><li>公司使用Subversion做集中式的版本控制，个人和/或团队使用 Git-svn。这样在无法改变公司版本控制策略时，程序员可以采用的变通之法。</li><li>Git服务器的部署实际上可以使用钩子对分支和路径进行写授权，即可以控制谁能够创建分支，能够写特定文件。</li></ol><h1 id="10-优缺点比较"><a class="markdownIt-Anchor" href="#10-优缺点比较"></a> 10 优缺点比较</h1><h2 id="101-svn优缺点"><a class="markdownIt-Anchor" href="#101-svn优缺点"></a> 10.1 SVN优缺点</h2><p><strong>优点</strong>：</p><ol><li>管理方便，逻辑明确，符合一般人思维习惯。</li><li>易于管理，集中式服务器更能保证安全性。</li><li>代码一致性非常高。</li><li>适合开发人数不多的项目开发。</li></ol><p><strong>缺点</strong>：</p><ol><li>服务器压力太大，数据库容量暴增。</li><li>如果不能连接到服务器上，基本上不可以工作，看上面第二步，如果服务器不能连接上，就不能提交，还原，对比等等。</li><li>不适合开源开发（开发人数非常非常多，但是Google app engine就是用svn的）。但是一般集中式管理的有非常明确的权限管理机制（例如分支访问限制），可以实现分层管理，从而很好的解决开发人数众多的问题。</li></ol><h2 id="102-git优缺点"><a class="markdownIt-Anchor" href="#102-git优缺点"></a> 10.2 Git优缺点</h2><p><strong>优点</strong>：</p><ol><li>适合分布式开发，强调个体。</li><li>公共服务器压力和数据量都不会太大。</li><li>速度快、灵活。</li><li>任意两个开发者之间可以很容易的解决冲突。</li><li>离线工作。</li></ol><p><strong>缺点</strong>：</p><ol><li>学习周期相对而言比较长。</li><li>不符合常规思维。</li><li>代码保密性差，一旦开发者把整个库克隆下来就可以完全公开所有代码和版本信息。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="环境与工具" scheme="https://dragonliu2022.github.io/categories/环境与工具/"/>
    
    
    <category term="Git" scheme="https://dragonliu2022.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>指针 vs 引用 vs 指针引用</title>
    <link href="https://dragonliu2022.github.io/2022/04/18/%E6%8C%87%E9%92%88-vs-%E5%BC%95%E7%94%A8-vs-%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8/"/>
    <id>https://dragonliu2022.github.io/2022/04/18/%E6%8C%87%E9%92%88-vs-%E5%BC%95%E7%94%A8-vs-%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8/</id>
    <published>2022-04-18T08:27:41.000Z</published>
    <updated>2022-04-18T11:40:19.443Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-引入"><a class="markdownIt-Anchor" href="#1-引入"></a> 1 引入</h1><p>待补充</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="C++" scheme="https://dragonliu2022.github.io/categories/C/"/>
    
    
    <category term="待补充" scheme="https://dragonliu2022.github.io/tags/待补充/"/>
    
  </entry>
  
  <entry>
    <title>函数打桩</title>
    <link href="https://dragonliu2022.github.io/2022/04/18/%E5%87%BD%E6%95%B0%E6%89%93%E6%A1%A9/"/>
    <id>https://dragonliu2022.github.io/2022/04/18/%E5%87%BD%E6%95%B0%E6%89%93%E6%A1%A9/</id>
    <published>2022-04-18T08:11:30.000Z</published>
    <updated>2022-04-18T15:58:48.152Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p><strong>转载</strong>：<a href="https://sim41.com/2019/11/28/stub/" target="_blank" rel="noopener">stub</a></p></blockquote><h1 id="1-定义"><a class="markdownIt-Anchor" href="#1-定义"></a> 1 定义</h1><p>函数打桩，就是将一个函数用另一个函数实现(桩代码)进行替换，以达到在原有函数入口的位置执行新的实现。函数打桩类似于Windows系统中的钩子Hook，不过Hook针对的是事件，这里针对的是函数，或者说是函数的入口。在做C的Cunit单元测试时，遇到了这样的概念，在此梳理一下。</p><h1 id="2-目的"><a class="markdownIt-Anchor" href="#2-目的"></a> 2 目的</h1><p>函数打桩的目的一般是隔离、占位和控制，这里是参考其他博主的文章进行的大概分类，其实也不是很严格。</p><p>隔离就是将复杂的函数从程序中隔离，比如一个复杂的嵌套函数，如果只想要知道前几步的运行结果，则可以在调用下一层函数时替换一个简单的实现，甚至直接return。在进行流程的测试时比较常见。</p><p>占位就是对一些未实现的函数进行占位，多见于协同开发中，对于其他人完成的函数可以先使用空函数进行占位。</p><p>控制就是将原本的函数功能进行替换，控制流程。如在测试中，替换函数部分内容得到需要的结果，以进行单元测试。或者对一些系统函数进行替换，实现自己的功能。如常见的将内存分配的函数替换为自己重写的内存池分配等，这里就是一个函数Hook。</p><h1 id="3-方法"><a class="markdownIt-Anchor" href="#3-方法"></a> 3 方法</h1><h2 id="31-编译时打桩"><a class="markdownIt-Anchor" href="#31-编译时打桩"></a> 3.1 编译时打桩</h2><p>用宏定义#define，在预处理时进行字符串替换，将原函数定义成桩函数的形式。同时可以使用条件编译来控制编译选项。</p><h2 id="32-链接时打桩"><a class="markdownIt-Anchor" href="#32-链接时打桩"></a> 3.2 链接时打桩</h2><p>将桩函数定义到新的库文件中，并在原代码基础上增加条件编译选项，屏蔽原有的库，采用桩函数库。</p><h2 id="33-运行时打桩"><a class="markdownIt-Anchor" href="#33-运行时打桩"></a> 3.3 运行时打桩</h2><p>运行时打桩是对内存的应用，我们知道程序的函数是在代码段中存储，一个函数的操作对应一个栈帧的存储地址，如果在调用函数时，在一旦访问这个栈帧，我们就使它跳转到我们需要的桩函数去，那么也就实现了函数的打桩。这种方法要复杂一点，但是不需要对原有的代码进行修改，而是额外增加了打桩和还原的操作，在进行单元测试时也常用。</p><p>简单来说，就是读取到原函数指令的地址，并读取桩函数的地址，并使用jmp命令从原函数跳转到桩函数去，以实现打桩。</p><p>一个完整的打桩流程应该分为装载和卸载，因此需要做到的是记录原函数的函数指针，记录桩函数的函数指针，计算地址差值，调用jmp指令，完成桩函数的装载。使用完成后，再删除jmp指令，恢复原函数。此间由于操作系统对于进程的保护机制，可能存在对于进程内存的解锁和权限设置，将指定内存区域设定为可读可写可操作的权限。</p><h3 id="331-数据结构"><a class="markdownIt-Anchor" href="#331-数据结构"></a> 3.3.1 数据结构</h3><p>设定一个链表用于存储原函数、桩函数之间的对应关系，使用链表是为了动态分配同时记录多个函数。数据结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stub</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stub</span> *<span class="title">node</span>;</span></span><br><span class="line"><span class="keyword">void</span> *orig_f;<span class="comment">//原函数的函数指针</span></span><br><span class="line"><span class="keyword">void</span> *stub_f;<span class="comment">//桩函数的函数指针</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> old_flg;<span class="comment">//存储原有内存的权限</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> assm[<span class="number">5</span>];<span class="comment">//用于暂存原函数起始的5字节指令，用于被jmp指令(0xE9 + 4bytes地址)覆盖后恢复</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="332-设置内存的保护属性"><a class="markdownIt-Anchor" href="#332-设置内存的保护属性"></a> 3.3.2 设置内存的保护属性</h3><p>在Linux下，mprotect()函数可以用于更改指定内存区域的保护属性。原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mprotect</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> prot)</span></span>;</span><br><span class="line"><span class="comment">//addr为内存起始地址，必须是内存页的起始地址</span></span><br><span class="line"><span class="comment">//len为内存区域长度,以字节为单位，必须是页大小的整数倍</span></span><br><span class="line"><span class="comment">//prot为权限值，类似于Linux的权限值</span></span><br></pre></td></tr></table></figure><p>同样，在Windows下，采用读取系统的页大小:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">long</span> pagesize = sysconf(_SC_PAGESIZE);</span><br></pre></td></tr></table></figure><p>计算内存页的起始地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">pageof</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">void</span> *)((<span class="keyword">unsigned</span> <span class="keyword">long</span>)p &amp; ~(pagesize - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="333-安装桩函数"><a class="markdownIt-Anchor" href="#333-安装桩函数"></a> 3.3.3 安装桩函数</h3><p>计算原函数与桩函数地址的偏移量，将原函数的入口5字节指令替换为jmp [offset]，同时缓存原本的5字节，用于后续的恢复。</p><p>jmp指令对应0xE9，后续为4字节的偏移量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">install_stub</span><span class="params">(<span class="keyword">void</span> *orig_f, <span class="keyword">void</span> *stub_f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//初始化stub数据结构</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stub</span> *<span class="title">pstub</span> = <span class="title">calloc</span>(1, <span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">stub</span>));</span></span><br><span class="line">  pstub-&gt;orig_f = orig_f;</span><br><span class="line">  pstub-&gt;stub_f = stub_f;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//设置内存保护属性</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="number">-1</span> == mprotect(pageof(orig_f), pagesize * <span class="number">2</span>, PROT_READ | PROT_WRITE | PROT_EXEC))</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"mprotect to w+r+x faild"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(errno);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//缓存原函数orig_f头部的5字节指令</span></span><br><span class="line">  <span class="built_in">memcpy</span>(pstub-&gt;assm, pstub-&gt;orig_f, <span class="keyword">sizeof</span>(pstub-&gt;assm));</span><br><span class="line">  <span class="comment">//将头部重写为jmp [offset]</span></span><br><span class="line">  *((<span class="keyword">char</span>*)pstub-&gt;orig_f) = <span class="number">0xE9</span>;</span><br><span class="line">  offset = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)((<span class="keyword">long</span>)pstub-&gt;stub_f - ((<span class="keyword">long</span>)pstub-&gt;orig_f + <span class="number">5</span>));</span><br><span class="line">  *((<span class="keyword">unsigned</span> <span class="keyword">int</span>*)((<span class="keyword">char</span>*)pstub-&gt;orig_f + <span class="number">1</span>)) = offset;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//如果有多线程同时操作，加锁</span></span><br><span class="line">  <span class="comment">//lock()；</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//如果对多个函数打桩，维护struct stub 链表</span></span><br><span class="line">  <span class="comment">//list_add(&amp;ptsub-&gt;node, &amp;head)；</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//unlock();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="334-卸载桩函数"><a class="markdownIt-Anchor" href="#334-卸载桩函数"></a> 3.3.4 卸载桩函数</h3><p>将原函数开始的5字节恢复，并释放stub结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uninstall_stub</span><span class="params">(<span class="keyword">void</span> *stub_f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//从桩函数链表中找到要释放的桩函数对应的数据结构</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stub</span> *<span class="title">pstub</span> = <span class="title">NULL</span>:</span></span><br><span class="line">  pstub = find_pstub(stub_f);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//设置内存保护属性</span></span><br><span class="line">  mprotect(pageof(pstub-&gt;orig_f), pagesize * <span class="number">2</span>, PROT_READ | PROT_WRITE | PROT_EXEC);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//恢复原函数的初始5字节指令</span></span><br><span class="line">  <span class="built_in">memcpy</span>(pstub-&gt;orig_f, pstub-&gt;assm, <span class="keyword">sizeof</span>(pstub-&gt;assm));</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//删除节点</span></span><br><span class="line">  del_node(pstub)；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码只包含了关键代码，部分声明省略，并未对异常情况进行处理。</p><h1 id="4-进程内存安全"><a class="markdownIt-Anchor" href="#4-进程内存安全"></a> 4 进程内存安全</h1><p>这里的函数打桩利用jmp指令将原有的函数入口跳转到了我们指定的桩函数入口，自然会想到在非法情况下，也利用jmp将原本的函数跳转到指定的函数去。其实这也是一些病毒的做法，跳转到非法代码；或者一些软件破解的方法，将原本的验证机制跳转屏蔽。只不过我们打桩时是在同一进程内部进行了跳转，且是在获取源码到情况下进行的。而在破解和攻击时，一般只有可执行文件的二进制代码，此时可以通过反汇编得到程序的汇编指令，并找到需要修改的函数入口。在攻击时，也存在另外一个问题，就是跨进程的权限，在进程外对进程的内存进行修改。</p><p>操作系统对内存的保护，采取了虚拟地址空间（进程独立的虚拟内存），内存起点的随机偏移量（不能找到代码段段入口）等方式。而且mprotect()仅可以对同一进程的内存块进行修改。如果想要修改其他进程的内存块的保护属性，就要从两个方面下手，一是变成同一个进程，另一个则是对mprotect()动手脚。</p><p>当成同一个进程，可以使用代码注入，让我们的攻击代码从进程自身发出，则我们的代码就有了通过mprotect改变进程保护属性的权限。</p><p>而对mprotect()做手脚，即实现我们自己的mprotect()函数，让其模仿内核函数的行为，但是却拥有跨进程的能力。这就要编写一个类似于mprotect()函数功能的内核模块。</p><p>具体的操作暂时还没有深入了解，原理如上述所示。</p><h1 id="5-cunit的使用"><a class="markdownIt-Anchor" href="#5-cunit的使用"></a> 5 Cunit的使用</h1><p>CUnit是一个C语言的单元测试框架，以静态链接库的形式，连接到用户代码中。提供了语义丰富的断言和多种测试结果输出接口，可以方便地生成测试报告。可以结合 gcov/lcov等生成测试覆盖度报表。</p><h2 id="51-结构"><a class="markdownIt-Anchor" href="#51-结构"></a> 5.1 结构</h2><p>Cunit的结构基本如下图所示，分为三层，第一层是总的测试入口，第二层是测试包，第三层是测试用例。然后通过一系列的断言展示测试结果。</p><img src="https://s2.loli.net/2022/04/18/mIGRBMVLqA9Urha.jpg" width="500" height="400" alt="图片名称" align="center" id="164"><h2 id="52-基本流程"><a class="markdownIt-Anchor" href="#52-基本流程"></a> 5.2 基本流程</h2><ol><li>编写待测函数对应的测试函数（如果必要，需要写suite的init/cleanup函数）</li><li>初始化Test Registry - CU_initialize_registry()</li><li>把测试包（Test Suites）加入到Test Registry - CU_add_suite()</li><li>把测试用例（Test Case）加入到测试包当中 - CU_add_test()</li><li>使用适当的接口来运行测试测试程序，例如 CU_console_run_tests()</li><li>清除Test Registry - CU_cleanup_registry()</li></ol><h1 id="6-参考"><a class="markdownIt-Anchor" href="#6-参考"></a> 6 参考</h1><p><a href="https://blog.csdn.net/wangwencong/article/details/8189778" target="_blank" rel="noopener">wangwencong-认识单元测试中的打桩</a></p><p><a href="https://www.yanbinghu.com/2019/07/28/59484.html" target="_blank" rel="noopener">守望-库打桩机制-偷梁换柱</a></p><p><a href="https://m.2cto.com/kf/201708/667113.html" target="_blank" rel="noopener">一种C语言”打桩”的源码实现</a></p><p><a href="https://www.freebuf.com/articles/system/191865.html" target="_blank" rel="noopener">Covfefe-深入Linux | 如何在任意进程中修改内存保护（含PoC）</a></p><p><a href="https://promisechen.github.io/kbase/cunit.html" target="_blank" rel="noopener">陈令祥-CUnit测试工具</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="未分类" scheme="https://dragonliu2022.github.io/categories/未分类/"/>
    
    
    <category term="待补充" scheme="https://dragonliu2022.github.io/tags/待补充/"/>
    
  </entry>
  
  <entry>
    <title>华为实习任务-codecheck</title>
    <link href="https://dragonliu2022.github.io/2022/04/18/%E5%8D%8E%E4%B8%BA%E5%AE%9E%E4%B9%A0%E4%BB%BB%E5%8A%A1-codecheck/"/>
    <id>https://dragonliu2022.github.io/2022/04/18/%E5%8D%8E%E4%B8%BA%E5%AE%9E%E4%B9%A0%E4%BB%BB%E5%8A%A1-codecheck/</id>
    <published>2022-04-18T05:40:01.000Z</published>
    <updated>2022-04-18T16:50:22.812Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-引入"><a class="markdownIt-Anchor" href="#1-引入"></a> 1 引入</h1><p>在华为实习的三个月(2021.9-2021.11)中有两个月(9&amp;11月)都在做codecheck的工作，重复性操作，&quot;毫无&quot;技术含量可言。</p><p>令我惊讶的是：2022年4月份在实习答辩时，我说做了codecheck的工作。一位老师说（具体咋说的忘了，大致意思是：你是实习生，才三个月，华为不会让你改代码的（指核心代码？），你不要吹过头了），当时我愣住了，哈哈哈哈🥦。</p><p>答辩结束后仔细想了下，应该这样说：“实习期间，部门正好有codecheck的任务，我在其中做了一部分工作（包括xxx），改完代码后有检视人员保障代码质量。”</p><p>值得肯定的是：面对老师的奇怪语气+奇怪问法，没有进行反驳，毕竟到时间了（答辩每人10min），而且老师也没有听的意思。</p><p>总而言之，答辩时表达要得体（本次实习答辩自己多多少少存在这方面的问题，可能真是吹的口吻，只是自己没察觉）；认真听取老师的意见，一些情况下没必要进行反驳。还有就是要努力🥦🥦🥦</p><blockquote><p><a href="https://www.bookstack.cn/read/openharmony-1.0-zh-cn/contribute-OpenHarmony-cpp-coding-style-guide.md" target="_blank" rel="noopener">华为c++语言编程规范</a></p></blockquote><h1 id="2-冗余代码"><a class="markdownIt-Anchor" href="#2-冗余代码"></a> 2 冗余代码</h1><p><strong>规则4.4.3 不用的代码段直接删除，不要注释掉</strong></p><p>被注释掉的代码，无法被正常维护；当企图恢复使用这段代码时，极有可能引入易被忽略的缺陷。 正确的做法是，不需要的代码直接删除掉。若再需要时，考虑移植或重写这段代码。</p><p>这里说的注释掉代码，包括用 <code>/* */</code>和 <code>//</code>，还包括 <code>#if 0， #ifdef NEVER_DEFINED</code> 等等。</p><h1 id="3-圈复杂度cyclomatic-complexity"><a class="markdownIt-Anchor" href="#3-圈复杂度cyclomatic-complexity"></a> 3 圈复杂度（Cyclomatic complexity）</h1><p>详见 博客：<code>圈复杂度</code></p><p>定义：软件源码某部分的圈复杂度就是这部分代码中<a href="https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E6%97%A0%E5%85%B3/4705660" target="_blank" rel="noopener">线性无关</a>路径的数量。<a href="https://baike.baidu.com/item/%E5%9C%88%E5%A4%8D%E6%9D%82%E5%BA%A6/828737?fr=aladdin" target="_blank" rel="noopener">百度百科</a></p><p>含huge_cyclomatic_complexity和huge_cca_cyclomatic_complexity两个指标；cyclomatic_complexity和cca_cyclomatic_complexity的计算差异：</p><ul><li>cca_cyclomatic_complexity：不管switch里面有多少个case，圈复杂度只加1</li><li>cyclomatic_complexity：switch里面有多少个case，圈复杂度就加多少</li></ul><p>精髓：覆盖所有的可能情况最少使用的测试用例个数</p><ol><li>?: 三元运算符 +1</li><li>case +1</li><li>default +1</li><li>else +1</li></ol><p>华为规则：圈复杂度改到15以下</p><h1 id="4-超大目录"><a class="markdownIt-Anchor" href="#4-超大目录"></a> 4 超大目录</h1><p>华为规则：超大目录门槛50</p><p>拆分标准：根据数据库表，PDMReader</p><h1 id="5-降低文件重复率"><a class="markdownIt-Anchor" href="#5-降低文件重复率"></a> 5 降低文件重复率</h1><p><strong>问题</strong>：采用抽离函数的方式降DT重复率，但是cpp文件中重复代码过多且存在不同，所以会导致函数参数过多；抽离的函数中使用的if-else也会过多，导致圈复杂度上升；</p><p><strong>解决</strong>：将抽离函数按照功能块再拆分</p><h1 id="6-llvmclang-tidy"><a class="markdownIt-Anchor" href="#6-llvmclang-tidy"></a> 6 llvm(clang-tidy)</h1><p>llvm原生的，华为版本的</p><p>重新下库后需要执行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir cmake_build</span><br><span class="line"><span class="built_in">cd</span>  cmake_build</span><br><span class="line">cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=1 -DCMAKE_TOOLCHAIN_FILE=../cmake/scripts/gcc_all_toolchain.cmake ..</span><br><span class="line">cp ./compile_commands.json ..</span><br><span class="line"><span class="built_in">cd</span> ..</span><br></pre></td></tr></table></figure><p>在01_RB下执行命令，工具路径替换成自己的：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr1/dragon/llvm/tools/clang/tools/extra/clang-tidy/tool/run-clang-tidy.py -check=-*,modernize-use-nullptr,modernize-use-using,modernize-use-override -clang-tidy-binary=<span class="string">'/usr1/dragon/llvm/build/bin/clang-tidy'</span> -clang-apply-replacements-binary=<span class="string">'/usr1/dragon/llvm/build/bin/clang-apply-replacements'</span> -header-filter=./rating_charging/cppcode/tools/* -fix ./rating_charging/cppcode/tools</span><br></pre></td></tr></table></figure><p>自动化修复：</p><ul><li>modernize-use-nullptr</li><li>modernize-use-using：typedef-&gt;using</li><li>modernize-use-override</li></ul><h1 id="7-c类型风格转换"><a class="markdownIt-Anchor" href="#7-c类型风格转换"></a> 7 c++类型风格转换</h1><ul><li>先去了解清楚C++11类型转换的语法</li><li>几种转换使用的场景</li></ul><h1 id="8-超大函数huge-method"><a class="markdownIt-Anchor" href="#8-超大函数huge-method"></a> 8 超大函数（huge method）</h1><p>代码行大于阈值（阈值由产品CMC根据自身情况决策、定义）的函数</p><h1 id="9-gexp35-cpp-使用nullptr作为空指针常量"><a class="markdownIt-Anchor" href="#9-gexp35-cpp-使用nullptr作为空指针常量"></a> 9 G.EXP.35-CPP 使用<code>nullptr</code>作为空指针常量</h1><p><strong>【级别】</strong> 要求</p><p><strong>【描述】</strong></p><p>C++11开始引入了nullptr关键字代表空指针，在此之前使用NULL宏来表示空指针常量，导致出现如下问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL ((void*)0)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* str = <span class="literal">NULL</span>; <span class="comment">// 编译错误: void* 不能自动转换为 char*</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>(C::*pmf)() = &amp;C::Func;</span><br><span class="line"><span class="keyword">if</span> (pmf == <span class="literal">NULL</span>) &#123; <span class="comment">// 编译错误: void* 不能自动转换为指向成员函数的指针</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果把<code>NULL</code>被定义为<code>0</code>或<code>0L</code>。可以解决上面的问题。或者在需要空指针的地方直接使用<code>0</code>。</p><p>但这引入另一个问题，代码不清晰，特别是使用<code>auto</code>自动推导时更为突出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> result =Find(id);</span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">0</span>) &#123;<span class="comment">// Find() 返回的是 指针 还是 整数?</span></span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>0</code>字面上是<code>int</code>类型(<code>0L</code>是<code>long</code>)，所以<code>NULL</code>和<code>0</code>都不是指针类型。</p><p>当重载指针和整数类型的函数时，传递<code>NULL</code>或<code>0</code>都调用到整数类型重载的函数:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line">F(<span class="number">0</span>);<span class="comment">// 调用 F(int)，而非 F(int*)</span></span><br><span class="line">F(<span class="literal">NULL</span>);<span class="comment">// 调用 F(int)，而非 F(int*)</span></span><br></pre></td></tr></table></figure><p>另外，<code>sizeof(NULL) == sizeof(void*)</code>并不一定总是成立的，直接使用<code>0</code>或<code>0L</code>，代码不清晰，且无法做到类型安全；使用<code>NULL</code>无法做到类型安全。这些都是潜在的风险。</p><p><code>nullptr</code>的优势不仅仅是在字面上代表了空指针，使代码清晰，而且它不再是一个整数类型。</p><p><code>nullptr</code>是<code>std::nullptr_t</code>类型，而<code>std::nullptr_t</code>可以隐式的转换为所有的原始指针类型，这使得<code>nullptr</code>可以表现成指向任意类型的空指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span>*)</span></span>;</span><br><span class="line">F(<span class="literal">nullptr</span>);<span class="comment">// 调用 F(int*)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> result =Find(id);</span><br><span class="line"><span class="keyword">if</span> (result ==<span class="literal">nullptr</span>) &#123; <span class="comment">// Find() 返回的是 指针</span></span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="10-gexp03-cpp-使用using定义类型别名"><a class="markdownIt-Anchor" href="#10-gexp03-cpp-使用using定义类型别名"></a> 10 G.EXP.03-CPP 使用using定义类型别名</h1><p>**【级别】**建议</p><p><strong>【描述】</strong></p><p>类型的别名实际是对类型的封装。而通过封装，可以让代码更清晰，同时在很大程度上避免类型变化带来的散弹式修改。</p><p>在<code>C++11</code>之前，可以通过<code>typedef</code>定义类型的别名：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">uint32_t</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; SomeType;</span><br></pre></td></tr></table></figure><p>在<code>C++11</code>之后，提供<code>using</code>，实现<code>声明别名(alias declarations)</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> SomeType = <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">uint32_t</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;;</span><br></pre></td></tr></table></figure><p>对比两者的格式，使用using更容易理解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Type Alias; <span class="comment">// Type 在前，还是 Alias 在前，不宜历届</span></span><br><span class="line"><span class="keyword">using</span> Alias = Type; <span class="comment">// 符合'赋值'的用法，容易理解，不易出错</span></span><br></pre></td></tr></table></figure><p>如果觉得这点还不足以切换到<code>using</code>，我们接着看看<code>模板别名(alias template)</code>更简洁:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义模板的别名，一行代码</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; // <span class="title">template</span></span></span><br><span class="line"><span class="class"><span class="title">using</span> <span class="title">MyAllocatorVector</span> = <span class="title">std</span>:</span>:<span class="built_in">vector</span>&lt;T,MyAllocator&lt;T&gt;&gt;;</span><br><span class="line"></span><br><span class="line">MyAllocatorVector&lt;<span class="keyword">int</span>&gt; data;<span class="comment">// 使用 using 定义的别名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; // <span class="title">template</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        MyAllocatorVector&lt;<span class="keyword">int</span>&gt; data_;<span class="comment">// 模板类中使用 using 定义的别名</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而<code>typedef</code>不支持带模板参数的别名，只能”曲线救国”:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过模板包装 typedef，需要实现一个模板类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">MyAllocatorVector</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T,MyAllocator&lt;T&gt;&gt; type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyAllocatorVector&lt;<span class="keyword">int</span>&gt;::type data; <span class="comment">// 使用 typedef 定义的别名，多写 ::type</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typename</span> MyAllocatorVector&lt;<span class="keyword">int</span>&gt;::type data_; <span class="comment">// 模板类中使用，除了 ::type，还需要加上 typename</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实习中遇到的实例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">typedef</span> TChar NumArray[<span class="number">24</span>];</span><br><span class="line"><span class="keyword">using</span> NumArray = TChar[<span class="number">24</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体c++中，定义变量无需加关键字struct</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    TUInt4 uiAVPcode;</span><br><span class="line">    TUChar ucAVPflag_r : <span class="number">5</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125; AVPHEAD;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AVPHEAD</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数指针</span></span><br><span class="line"><span class="comment">// typedef 返回类型(*新类型)(参数表)</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">RETCODE</span> <span class="params">(*FnFmtFunc)</span><span class="params">(<span class="keyword">const</span> TChar* cdrBuff, TUInt4 cdrLen)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">using</span> FnFmtFunc = RETCODE (*)(<span class="keyword">const</span> TChar* cdrBuff, TUInt4 cdrLen) <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure><h1 id="10-gcls12-cpp-在重写虚函数时应明确指定override或final"><a class="markdownIt-Anchor" href="#10-gcls12-cpp-在重写虚函数时应明确指定override或final"></a> 10  G.CLS.12-CPP 在重写虚函数时应明确指定<code>override</code>或<code>final</code></h1><p>**【级别】**要求</p><p><strong>【描述】</strong></p><p>在重写虚函数时明确指定override或final，能保证该函数是重写了基类的虚函数，并且无需再添加virtual关键字。如果派生类函数与基类函数原型不一致，则产生编译错误。<code>final</code>还保证虚函数不会再被派生类重写。</p><ul><li>virtual 表示一个新的虚函数</li><li>override 表示重写了基类中的虚函数，可以再被派生类重写</li><li>final 表示重写了基类中的虚函数，不能再被派生类重写</li></ul><p>使用<code>override</code>或<code>final</code>关键字后，如果修改了基类虚函数原型，但忘记修改子类重写的虚函数，在编译期就可以发现。也可以避免有多个子类时，重写虚函数的修改遗漏。</p><p><strong>【正例】</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base();</span><br><span class="line">    <span class="keyword">virtual</span> ~Base();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Foo</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Foo</span><span class="params">(<span class="keyword">int</span> var)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Bar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">class <span class="title">Derived</span><span class="params">()</span>: <span class="keyword">public</span> Base </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived();</span><br><span class="line">    ~Derived() <span class="keyword">override</span>; <span class="comment">// 符合：析构函数添加override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">(<span class="keyword">int</span> var)</span> <span class="keyword">final</span></span>; <span class="comment">// 符合：重写基类函数，且Derived的派生类不能再重写此函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">()</span> <span class="keyword">override</span></span>;<span class="comment">// 符合：重写基类函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;<span class="comment">// 编译失败: Derived::Foo 和 Base::Foo 原型不一致，</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Bar</span><span class="params">()</span> <span class="keyword">override</span></span>;<span class="comment">// 编译失败: Base::Bar 不是虚函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><ol><li>基类首次定义虚函数，使用<code>virtual</code>关键字</li><li>子类重写基类虚函数（包括析构函数），使用<code>override</code>或<code>final</code>关键字（但不要两者一起使用），并且不使用<code>virtual</code>关键字</li><li>非虚函数，<code>virtual</code>、<code>override</code>和<code>final</code>都不使用</li></ol><p>【实习实例】</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_SERVICE_PLUGIN(CBypassMsgController);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_SERVICE_PLUGIN(CLASS_NAME) \</span></span><br><span class="line">DECLARE_SERVICE_COMPONET(CLASS_NAME); \</span><br><span class="line"><span class="keyword">protected</span>: \</span><br><span class="line">virtual const TChar* MyName() const \</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> #CLASS_NAME; \</span><br><span class="line">    &#125; \</span><br><span class="line">        </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_SERVICE_PLUGIN(CLASS_NAME) \</span></span><br><span class="line">DECLARE_SERVICE_COMPONET(CLASS_NAME); \</span><br><span class="line"><span class="keyword">protected</span>: \</span><br><span class="line">virtual const TChar* MyName() const override \</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> #CLASS_NAME; \</span><br><span class="line">    &#125; \</span><br></pre></td></tr></table></figure><h1 id="11-gexp29-cpp-比较两个表达式左侧倾向于变化右侧倾向于不变"><a class="markdownIt-Anchor" href="#11-gexp29-cpp-比较两个表达式左侧倾向于变化右侧倾向于不变"></a> 11 G.EXP.29-CPP 比较两个表达式，左侧倾向于变化，右侧倾向于不变</h1><p>**【级别】**建议</p><p><strong>【描述】</strong></p><p>当变量与常量比较时，如果常量放左边，如 if (MAX == v) 不符合阅读习惯，而 if (MAX &gt; v) 更是难于理解。 应当按人的正常阅读、表达习惯，将常量放右边。写成如下方式：</p><p><strong>【正例】</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (value == MAX) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (value &lt; MAX) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也有特殊情况，如：<code>if (MIN &lt; value &amp;&amp; value &lt; MAX)</code> 用来描述区间时，前半段是常量在左的。</p><p>不用担心将 <code>==</code> 误写成 <code>=</code>，因为<code>if (value = MAX)</code> 会有编译告警，其他静态检查工具也会报错。让工具去解决笔误问题，代码要符合可读性第一。</p><p><strong>【脚本误报】</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 逻辑或</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">'N'</span> == cSIPChgSubsNoType || <span class="string">'\0'</span> == cSIPChgSubsNoType) </span><br><span class="line"><span class="keyword">if</span> (cSIPChgSubsNoType == <span class="string">'N'</span> == cSIPChgSubsNoType || <span class="string">'\0'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 逻辑并</span></span><br><span class="line">TBool bContinue = <span class="number">0</span> &gt;= lSecUnpaid &amp;&amp; bSingle;</span><br><span class="line">TBool bContinue = lSecUnpaid &amp;&amp; bSingle &lt;= <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h1 id="12-其他"><a class="markdownIt-Anchor" href="#12-其他"></a> 12 其他</h1><ul><li>G.FMT.02-CPP 使用空格进行缩进，每次缩进4个空格</li><li>G.CMT.03-CPP 文件头注释包含版权说明</li><li>G.CMT.02-CPP 代码注释置于对应代码的上方或右边</li><li>G.FMT.06-CPP 换行时将操作符留在行末，新行缩进一层或进行同类对齐</li><li>G.FMT.09-CPP 构造函数初始化列表放在同一行或按4空格缩进并排多行</li><li>G.FMT.13-CPP case/default语句相对于switch缩进一层</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="未分类" scheme="https://dragonliu2022.github.io/categories/未分类/"/>
    
    
    <category term="重构" scheme="https://dragonliu2022.github.io/tags/重构/"/>
    
  </entry>
  
</feed>
