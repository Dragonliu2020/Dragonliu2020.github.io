<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dragon Liu</title>
  
  
  <link href="https://dragonliu2018.github.io/atom.xml" rel="self"/>
  
  <link href="https://dragonliu2018.github.io/"/>
  <updated>2021-09-21T15:41:26.691Z</updated>
  <id>https://dragonliu2018.github.io/</id>
  
  <author>
    <name>Dragon Liu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hexo迁移到新电脑</title>
    <link href="https://dragonliu2018.github.io/2021/09/21/Hexo%E8%BF%81%E7%A7%BB%E5%88%B0%E6%96%B0%E7%94%B5%E8%84%91/"/>
    <id>https://dragonliu2018.github.io/2021/09/21/Hexo%E8%BF%81%E7%A7%BB%E5%88%B0%E6%96%B0%E7%94%B5%E8%84%91/</id>
    <published>2021-09-21T15:28:58.000Z</published>
    <updated>2021-09-21T15:41:26.691Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="0-情景导入"><a href="#0-情景导入" class="headerlink" title="0 情景导入"></a>0 情景导入</h1><p>换了一台电脑，将旧电脑的hexo博客写作环境迁移到新电脑上。</p><h1 id="1-Git下载及配置"><a href="#1-Git下载及配置" class="headerlink" title="1 Git下载及配置"></a>1 Git下载及配置</h1><ol><li>从官网Git下载git并安装，下面设置无密push+pull；</li><li>打开git bash，在用户主目录(其他目录也可)下运行：<code>ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</code> 把其中的邮件地址换成自己的邮件地址，然后一路回车；</li><li>最后完成后，会在用户主目录下生成.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH key密钥对，id_rsa是私钥，千万不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人；</li><li>登陆GitHub，打开「Settings」-&gt;「SSH and GPG keys」，然后点击「new SSH key」，填上任意Title，在Key文本框里粘贴公钥id_rsa.pub文件的内容（千万不要粘贴成私钥了！），最后点击「Add SSH Key」，你就应该看到已经添加的Key。 </li><li>注意：不要在git版本库中运行ssh，然后又将它提交，这样就把密码泄露出去了</li></ol><h1 id="2-安装Node-js"><a href="#2-安装Node-js" class="headerlink" title="2 安装Node.js"></a>2 安装Node.js</h1><ol><li>Hexo基于Node.js，Node.js下载地址：<a href="https://link.zhihu.com/?target=https%3A//nodejs.org/en/download/" target="_blank" rel="noopener">Download | Node.js</a> 下载安装包，注意安装Node.js会包含环境变量及npm的安装，安装后，检测Node.js是否安装成功，在命令行中输入 <code>node -v</code>；</li><li>检测npm是否安装成功，在命令行中输入<code>npm -v</code></li></ol><h1 id="3-安装Hexo"><a href="#3-安装Hexo" class="headerlink" title="3 安装Hexo"></a>3 安装Hexo</h1><p>新建文件夹，在此文件夹内使用npm命令全局安装Hexo，输入：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>输入<code>hexo -v</code>检查是否安装成功。</p><blockquote><p>npm加速：</p><ol><li><p>装cnpm</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;    npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ol></blockquote><p>&gt;</p><blockquote><ol><li><p>使用cnpm</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;    cnpm install xxx</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ol></blockquote><p>&gt;</p><blockquote><p>参考：<a href="https://cloud.tencent.com/developer/article/1372949" target="_blank" rel="noopener">npm使用国内镜像加速的几种方法</a></p></blockquote><h1 id="4-复制原电脑上的数据"><a href="#4-复制原电脑上的数据" class="headerlink" title="4 复制原电脑上的数据"></a>4 复制原电脑上的数据</h1><h2 id="4-1-需要复制的"><a href="#4-1-需要复制的" class="headerlink" title="4.1 需要复制的"></a>4.1 需要复制的</h2><ul><li>_config.yml：站点配置</li><li>package.json：说明使用那些包</li><li>scaffolds：文章的模板</li><li>source：自己写的博客文件</li><li>themes：主题</li><li>.gitignore：限定在提交的时候哪些文件可以忽略</li></ul><h2 id="4-2-需要删除的"><a href="#4-2-需要删除的" class="headerlink" title="4.2 需要删除的"></a>4.2 需要删除的</h2><ul><li>.git：无论是在站点根目录下，还是主题目录下的.git文件，都可以删掉。</li><li>node_modules：在用<code>npm install</code>会重新生成</li><li>public：<code>hexo g</code>会重新生成</li><li>.deploy_git：在使用hexo d时也会重新生成</li><li>db.json文件</li></ul><p>其实上面这些文件也就是.gitignore文件里面记载的可以忽略的内容。</p><h1 id="5-npm-install"><a href="#5-npm-install" class="headerlink" title="5 npm install"></a>5 npm install</h1><p>在git bash中切换目录到新拷贝的文件夹里，使用<code>npm install</code> 命令，进行模块安装。很明显我们这里<font color="red">没用hexo init初始化</font>，因为有的文件我们已经拷贝生成过来了，所以不必用hexo init去整体初始化，如果不慎在此时用了hexo init，则站点的配置文件_config.yml里面内容会被清空使用默认值，所以这一步一定要慎重，不要用hexo init。</p><h1 id="6-安装其他必要组件"><a href="#6-安装其他必要组件" class="headerlink" title="6 安装其他必要组件"></a>6 安装其他必要组件</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save <span class="comment"># 为了使用hexo d来部署到git上 </span></span><br><span class="line">npm install hexo-generator-feed --save <span class="comment"># 为了建立RSS订阅</span></span><br><span class="line">npm install hexo-generator-sitemap --save <span class="comment"># 为了建立站点地图</span></span><br></pre></td></tr></table></figure><p>插件安装后，有的需要对配置文件_config.yml进行配置，具体怎么配置，可以参考上面插件在github主页上的具体说明</p><h1 id="7-验证"><a href="#7-验证" class="headerlink" title="7 验证"></a>7 验证</h1><p>首先本地执行，在博客根目录下执行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>此时可访问浏览器：<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> ，查看是否转移成功。</p><p>接下来验证部署，执行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><p>在线访问出错，无法访问。开始排查：</p><ol><li><p>.deploy_git文件夹内的文件大小均为0kb，也就是生成了一些空文件；</p></li><li><font color="pink">public文件夹内的文件大小均为0kb，但是本地可以正常访问，不知道为啥</font></li><li><p>其实在执行<code>hexo s</code>时，后台存在报错</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">INFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</span><br><span class="line">(node:23336) Warning: Accessing non-existent property <span class="string">'lineno'</span> of module exports inside circular dependency</span><br><span class="line">(Use `node --trace-warnings ...` to show <span class="built_in">where</span> the warning was created)</span><br><span class="line">(node:23336) Warning: Accessing non-existent property <span class="string">'column'</span> of module exports inside circular dependency</span><br><span class="line">(node:23336) Warning: Accessing non-existent property <span class="string">'filename'</span> of module exports inside circular dependency</span><br><span class="line">(node:23336) Warning: Accessing non-existent property <span class="string">'lineno'</span> of module exports inside circular dependency</span><br><span class="line">(node:23336) Warning: Accessing non-existent property <span class="string">'column'</span> of module exports inside circular dependency</span><br><span class="line">(node:23336) Warning: Accessing non-existent property <span class="string">'filename'</span> of module exports inside circular dependency</span><br></pre></td></tr></table></figure><p>解决方法：Node版本太高，切换一个低版本Node可以（我这里是14.17.6切换成12.5.0就没有这个问题了）</p></li><li><p>问题已解决，可以在线访问博客了。</p></li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/26625249" target="_blank" rel="noopener">GitHub+Hexo 搭建个人网站详细教程</a></li><li><a href="https://www.zhihu.com/question/21193762" target="_blank" rel="noopener">使用hexo，如果换了电脑怎么更新博客？</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="未定义" scheme="https://Dragonliu2018.github.io/categories/未定义/"/>
    
    
  </entry>
  
  <entry>
    <title>TopK问题</title>
    <link href="https://dragonliu2018.github.io/2021/07/24/TopK%E9%97%AE%E9%A2%98/"/>
    <id>https://dragonliu2018.github.io/2021/07/24/TopK%E9%97%AE%E9%A2%98/</id>
    <published>2021-07-24T08:57:42.000Z</published>
    <updated>2021-09-21T13:44:44.773Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。</p><p>请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><blockquote><p>参考：<a href="https://zhuanlan.zhihu.com/p/76734219" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/76734219</a></p></blockquote><h2 id="思路1-排序"><a href="#思路1-排序" class="headerlink" title="思路1 排序"></a>思路1 排序</h2><p>将n个数排序之后，取出第k大的数即可。</p><p>时间复杂度：$O(n*log(n))$</p><p>分析：明明只需要TopK，却将全局都排序了，这也是这个方法复杂度非常高的原因。那能不能不全局排序，而只局部排序呢？</p><h2 id="思路2-局部排序"><a href="#思路2-局部排序" class="headerlink" title="思路2 局部排序"></a>思路2 局部排序</h2><p>不再全局排序，只对最大的k个排序。冒泡是一个很常见的排序方法，每冒一个泡，找出最大值，冒k个泡，就得到TopK。</p><p>时间复杂度：$O(n*k)$</p><p>分析：冒泡，将全局排序优化为了局部排序，非TopK的元素是不需要排序的，节省了计算资源。不少朋友会想到，需求是TopK，是不是这最大的k个元素也不需要排序呢？</p><h2 id="思路3-堆"><a href="#思路3-堆" class="headerlink" title="* 思路3 堆"></a>* 思路3 堆</h2><p>思路：只找到TopK，不排序TopK。先用前k个元素生成一个小顶堆，这个小顶堆用于存储，当前最大的k个元素。接着，从第k+1个元素开始扫描，和堆顶（堆中最小的元素）比较，如果被扫描的元素大于堆顶，则替换堆顶的元素，并调整堆，以保证堆内的k个元素，总是当前最大的k个元素。直到，扫描完所有n-k个元素，最终堆中的k个元素，就是TopK。</p><p>时间复杂度：$O(n*log(k))$</p><p>画外音：n个元素扫一遍，假设运气很差，每次都入堆调整，调整时间复杂度为堆的高度，即$lg(k)$，故整体时间复杂度是$n*lg(k)$。</p><p>分析：堆，将冒泡的TopK排序优化为了TopK不排序，节省了计算资源。堆，是求TopK的经典算法，那还有没有更快的方案呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="思路4-Partition"><a href="#思路4-Partition" class="headerlink" title="思路4 Partition"></a>思路4 Partition</h2><p>除了用来进行快速排序，partition 还可以用 $O(N)$ 的平均时间复杂度解决TopK问题。和快排一样，这里也用到了分而治之的思想。首先用 partition 将数组分为两部分，得到分界点下标 pos，然后分三种情况：</p><ul><li>pos == k-1，则找到第 K 大的值，arr[pos]；</li><li>pos &gt; k-1，则第 K 大的值在左边部分的数组。</li><li>pos &lt; k-1，则第 K 大的值在右边部分的数组。</li></ul><p>下面给出基于迭代的实现（这里寻找第 k 小的数字）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[low];</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">while</span> (low &lt; high &amp;&amp; nums[high] &lt;= pivot) high--;</span><br><span class="line">            nums[low] = nums[high];</span><br><span class="line">            <span class="keyword">while</span> (low &lt; high &amp;&amp; nums[low] &gt;= pivot) low++;</span><br><span class="line">            nums[high] = nums[low];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[low] = pivot;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>, end = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (begin &lt; end) &#123;</span><br><span class="line">            <span class="keyword">int</span> pos = partition(nums, begin, end);</span><br><span class="line">            <span class="keyword">if</span> (pos == k - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[pos];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pos &lt; k - <span class="number">1</span>) &#123;</span><br><span class="line">                begin = pos + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                end = pos - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[begin];<span class="comment">//数组长度为1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：考虑最坏情况下，每次 partition 将数组分为长度为 $N-1$ 和 $1$ 的两部分，然后在长的一边继续寻找第 K 大，此时时间复杂度为 $O(N^2 )$。不过如果在开始之前将数组进行随机打乱，那么可以尽量避免最坏情况的出现（随机选择算在是《算法导论》中一个经典的算法，其时间复杂度为O(n)，是一个线性复杂度的方法。）。而在最好情况下，每次将数组均分为长度相同的两半，运行时间 $T(N) = N + T(N/2)$，时间复杂度是 $O(N)$。</p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><ol><li><a href="https://leetcode-cn.com/problems/smallest-k-lcci/" target="_blank" rel="noopener">leetcode——面试题 17.14. 最小K个数</a></li><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="面试篇" scheme="https://Dragonliu2018.github.io/categories/面试篇/"/>
    
    <category term="数据结构和算法" scheme="https://Dragonliu2018.github.io/categories/数据结构和算法/"/>
    
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="https://dragonliu2018.github.io/2021/07/23/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>https://dragonliu2018.github.io/2021/07/23/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2021-07-23T01:41:17.000Z</published>
    <updated>2021-09-21T16:09:48.477Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-最大子序和"><a href="#1-最大子序和" class="headerlink" title="1 最大子序和"></a>1 最大子序和</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>链接：<a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-subarray/</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li><strong>状态</strong>：$dp[i]$ 代表以$nums[i]$结尾的最大和</li><li><strong>状态转移方程</strong>：$dp[i] = max(dp[i-1]+nums[i], nums[i])$</li><li><strong>答案</strong>：$max(dp[0…n-1])$</li></ol><ul><li><strong>时间复杂度</strong>：循环执行 n 次，每次花费常数的时间代价，故渐进时间复杂度为 $O(n)$。</li><li><strong>空间复杂度</strong>：$O(n)$，可用滚动数组优化到$O(1)$。</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> pre = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> ans = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            pre = max(nums[i], pre + nums[i]);</span><br><span class="line">            ans = max(ans, pre);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="2-最长上升子序列"><a href="#2-最长上升子序列" class="headerlink" title="2 最长上升子序列"></a>2 最长上升子序列</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><p>链接：<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-increasing-subsequence/</a></p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><ol><li><strong>状态</strong>：$dp[i]$ 代表以$nums[i]$结尾的最长严格递增子序列的长度</li><li><strong>状态转移方程</strong>：$dp[i] = max(dp[j]+1,dp[i])$，$j<i$且$nums[i]>nums[j]$</i$且$nums[i]></li><li><strong>答案</strong>：$max(dp[0…n-1])$</li></ol><ul><li><strong>时间复杂度</strong>： $O(n^2)$</li><li><strong>空间复杂度</strong>： $O(n)$</li></ul><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> dp[n];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                    dp[i] = max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *max_element(dp, dp + n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构和算法" scheme="https://Dragonliu2018.github.io/categories/数据结构和算法/"/>
    
    
    <category term="dp" scheme="https://Dragonliu2018.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>双指针</title>
    <link href="https://dragonliu2018.github.io/2021/07/22/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    <id>https://dragonliu2018.github.io/2021/07/22/%E5%8F%8C%E6%8C%87%E9%92%88/</id>
    <published>2021-07-22T11:52:41.000Z</published>
    <updated>2021-09-21T13:41:44.310Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-无重复字符的最长子串"><a href="#1-无重复字符的最长子串" class="headerlink" title="1 无重复字符的最长子串"></a>1 无重复字符的最长子串</h1><p>题目来源：<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">leetcode-3 无重复字符的最长子串</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先区分子串与子序列：子串必须连续，子序列可以不连续。</p><p>两层循环$O(n^2)$不太行，减少重复查询，可以用<strong>双指针</strong>维护一个<strong>滑动窗口</strong>，同时用一个数组标记滑动窗口内出现的字符。</p><ul><li><strong>时间复杂度</strong>：$O(N)$，其中 $N$ 是字符串的长度。左指针和右指针分别会遍历整个字符串一次。</li><li><strong>空间复杂度</strong>：$O(|\Sigma|)$，其中 $\Sigma$ 表示字符集（即字符串中可以出现的字符），$|\Sigma|$ 表示字符集的大小。在本题中没有明确说明字符集，因此可以默认为所有 ASCII 码在 $[0, 128)$ 内的字符，即 $|\Sigma| = 128$。</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">128</span>;<span class="comment">//字符范围</span></span><br><span class="line">        <span class="keyword">int</span> foot[maxn] = &#123;<span class="number">0</span>&#125;;<span class="comment">//标记滑动窗口中已经有的字符</span></span><br><span class="line">        <span class="keyword">int</span> len = s.size();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;<span class="comment">//空串</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;<span class="comment">//双指针维护窗口</span></span><br><span class="line">        foot[s[start]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; len - <span class="number">1</span>) &#123;</span><br><span class="line">            end++;<span class="comment">//后面的指针前进</span></span><br><span class="line">            <span class="keyword">while</span> (end &lt; len) &#123;</span><br><span class="line">                <span class="keyword">if</span> (foot[s[end]] == <span class="number">0</span>) &#123;</span><br><span class="line">                    foot[s[end]] = <span class="number">1</span>;</span><br><span class="line">                    end++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            end--;<span class="comment">//后面的指针回退</span></span><br><span class="line">            ans = max(ans, end - start + <span class="number">1</span>);</span><br><span class="line">            foot[s[start]] = <span class="number">0</span>;<span class="comment">//前面的指针前移</span></span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><ol><li><a href></a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构和算法" scheme="https://Dragonliu2018.github.io/categories/数据结构和算法/"/>
    
    
  </entry>
  
  <entry>
    <title>STL</title>
    <link href="https://dragonliu2018.github.io/2021/07/22/STL/"/>
    <id>https://dragonliu2018.github.io/2021/07/22/STL/</id>
    <published>2021-07-22T03:54:23.000Z</published>
    <updated>2021-09-21T13:44:26.319Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-vector-向量"><a href="#1-vector-向量" class="headerlink" title="1 vector(向量)"></a>1 vector(向量)</h1><p>vector是与数组相关的序列式容器，set模版类的定义在头文件\<vector\>中。当我们在程序中需要使用动态数组时， vector将会是理想的选择， vector可以在使用过程中动态地增长存储空间。</vector\></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; s;<span class="comment">// 定义⼀个空的vector对象，存储的是int类型的元素</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">s</span><span class="params">(n)</span></span>;<span class="comment">// 定义⼀个含有n个int元素的vector对象</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">s</span><span class="params">(first, last)</span></span>;<span class="comment">// 从由迭代器first和last定义的序列[first, last)中复制初值初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本操作</span></span><br><span class="line">s[i] <span class="comment">// 直接以下标⽅式访问容器中的元素，编号从0开始</span></span><br><span class="line">s.front() <span class="comment">// 返回⾸元素</span></span><br><span class="line">s.back() <span class="comment">// 返回尾元素</span></span><br><span class="line">s.push_back(x) <span class="comment">// 向表尾插⼊元素x</span></span><br><span class="line">s.pop_back() <span class="comment">// 删除表尾元素</span></span><br><span class="line">s.size() <span class="comment">// 返回表⻓</span></span><br><span class="line">s.empty() <span class="comment">// 表为空时，返回真，否则返回假</span></span><br><span class="line">s.begin() <span class="comment">// 返回指向⾸元素的随机存取迭代器</span></span><br><span class="line">s.end() <span class="comment">// 返回指向尾元素的下⼀个位置的随机存取迭代器</span></span><br><span class="line">s.insert(it, val) <span class="comment">// 向迭代器it指向的元素前插⼊新元素val</span></span><br><span class="line">s.insert(it, n, val) <span class="comment">// 向迭代器it指向的元素前插⼊n个新元素val</span></span><br><span class="line">s.insert(it, first, last)<span class="comment">// 向迭代器it指向的元素前插⼊迭代器first和last所指定的序列[first, last)</span></span><br><span class="line">s.erase(it) <span class="comment">// 删除由迭代器it所指向的元素</span></span><br><span class="line">s.erase(first, last) <span class="comment">// 删除由迭代器first和last所指定的序列[first, last)</span></span><br><span class="line">s.reserve(n) <span class="comment">// 预分配缓冲空间，使存储空间至少可容纳n个元素</span></span><br><span class="line">s.resize(n) <span class="comment">// 改变序列长度，超出的元素将会全部被删除，需要扩展(原空间小于n)的用元素默认值填满</span></span><br><span class="line">s.resize(n, val) <span class="comment">// 改变序列长度，超出的元素将会全部被删除，需要扩展(原空间小于n)的用元素val填满</span></span><br><span class="line">s.clear() <span class="comment">// 删除容器中的所有元素。resize和clear是对表的有效元素进行的操作，但不⼀定改变缓冲空间的⼤小</span></span><br><span class="line">s.swap(v) <span class="comment">// 将s与另⼀个vector对象进行交换</span></span><br><span class="line">s.assign(first, last)<span class="comment">// 将序列替换成由迭代器指示的[first, last)，不能是原序列中的⼀部分</span></span><br><span class="line"><span class="keyword">operator</span>: &gt; &lt; &gt;= &lt;= == != <span class="comment">//按照字典序⽐较两个序列</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 组合操作</span></span><br><span class="line">s.insert(s.begin(), x) <span class="comment">// 向表头插⼊元素x</span></span><br><span class="line">s.erase(s.begin()) <span class="comment">// 删除表头元素</span></span><br><span class="line">reverse(s.begin(), s.end()) <span class="comment">// 反转向量</span></span><br><span class="line">sort(s.begin(), s.end()) <span class="comment">// 排序</span></span><br></pre></td></tr></table></figure><h1 id="2-pair-二元组"><a href="#2-pair-二元组" class="headerlink" title="2 pair(二元组)"></a>2 pair(二元组)</h1><p>pair用来表示一个二元组或元素对，定义在头文件\<utility\>中。pair模版类需要两个参数：首元素的数据类型和尾元素的数据类型。 pair模版类对象有两个成员： first和second，分别表示首元素和尾元素。  </utility\></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line">pair&lt;<span class="keyword">double</span>, <span class="keyword">double</span>&gt; p;</span><br><span class="line">p = make_pair(<span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本操作</span></span><br><span class="line"><span class="keyword">operator</span>: &lt; &gt; &lt;= &gt;= == != <span class="comment">// 其规则是先⽐较first， first相等时再比较second，这符合⼤多数应⽤的逻辑</span></span><br></pre></td></tr></table></figure><h1 id="3-set-集合"><a href="#3-set-集合" class="headerlink" title="3 set(集合)"></a>3 set(集合)</h1><p>set是与集合相关的关联式容器，set模版类的定义在头文件\<set\>中。在set中每个元素的值都唯一，而且系统能根据元素的值自动进行排序(默认升序)。set中元素的值不能直接被改变。</set\></p><p>标准库提供set关联容器分为：</p><ol><li>按关键字有序保存元素：set(关键字即值，即只保存关键字的容器)；multiset(关键字可重复出现的set)；</li><li>无序集合：unordered_set(用哈希函数组织的set)；unordered_multiset(哈希组织的set，关键字可以重复出现)。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="built_in">set</span>&lt;T&gt; s;</span><br><span class="line"><span class="built_in">set</span>&lt;T&gt;::iterator it;<span class="comment">//迭代器</span></span><br><span class="line"><span class="keyword">int</span> arr[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="function"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ss</span><span class="params">(arr, arr+<span class="number">4</span>)</span></span>;<span class="comment">//数组初始化</span></span><br><span class="line"><span class="function"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ss</span><span class="params">(s)</span></span>;<span class="comment">//集合初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本操作</span></span><br><span class="line">s.begin() <span class="comment">// 返回指向第⼀个元素的迭代器，如果set为空则返回的迭代器不能解引用</span></span><br><span class="line">s.clear() <span class="comment">// 清除所有元素</span></span><br><span class="line">s.count(T) <span class="comment">// 返回某个元素的个数，多重集合也是返回个数</span></span><br><span class="line">s.empty() <span class="comment">// 如果集合为空，返回true(真）</span></span><br><span class="line">s.end() <span class="comment">// 返回指向最后⼀个元素之后的迭代器，不是最后⼀个元素</span></span><br><span class="line">s.equal_range(T) <span class="comment">// 返回集合中与给定值相等的上下限的两个迭代器(pair)</span></span><br><span class="line">s.erase(T) <span class="comment">// 删除迭代器指定位置的元素或与对象匹配的元素</span></span><br><span class="line">s.find(T) <span class="comment">// 返回⼀个指向被查找到元素的迭代器</span></span><br><span class="line">s.get_allocator() <span class="comment">// 返回集合的分配器</span></span><br><span class="line">s.insert(T) <span class="comment">// 在集合中插⼊元素</span></span><br><span class="line">s.lower_bound(T) <span class="comment">// 返回指向⼤于（或等于）某值的第⼀个元素的迭代器</span></span><br><span class="line">s.key_comp() <span class="comment">// 返回⼀个⽤于元素间值⽐较的函数，默认operator&lt;</span></span><br><span class="line">s.max_size() <span class="comment">// 返回集合能容纳的元素的最⼤限值</span></span><br><span class="line">s.rbegin() <span class="comment">// 返回指向集合中最后⼀个元素的反向迭代器</span></span><br><span class="line">s.rend() <span class="comment">// 返回指向集合中第⼀个元素的反向迭代器</span></span><br><span class="line">s.size() <span class="comment">// 集合中元素的数⽬</span></span><br><span class="line">s.swap(<span class="built_in">set</span>&lt;T&gt;) <span class="comment">// 交换两个集合变量</span></span><br><span class="line">s.upper_bound(T) <span class="comment">// 返回⼤于某个值元素的迭代器</span></span><br><span class="line">s.value_comp() <span class="comment">// 返回⼀个⽤于⽐较元素间的值的函数</span></span><br><span class="line"><span class="comment">//遍历输出</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> ptr = s.begin(); ptr != s.end(); ptr++) &#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; *ptr&lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 修改排序</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; u, <span class="keyword">const</span> <span class="keyword">int</span>&amp; v)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(u - v) &lt;= k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> u &lt; v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>, cmp&gt; se;</span><br></pre></td></tr></table></figure><h1 id="4-string-字符串"><a href="#4-string-字符串" class="headerlink" title="4 string(字符串)"></a>4 string(字符串)</h1><p>string类的定义在头文件$<string>$中。string类其实可以看作是一个字符的vector， vector上的各种操作都可以适用于string，另外，string类对象还支持字符串的拼合、转换等操作。  </string></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本操作</span></span><br><span class="line"><span class="keyword">operator</span> + <span class="comment">// 拼合</span></span><br><span class="line"><span class="comment">//string转char指针</span></span><br><span class="line"><span class="keyword">char</span> *p=(<span class="keyword">char</span>*)str.c_str();</span><br><span class="line"><span class="keyword">char</span>*p=(<span class="keyword">char</span>*)str.data();</span><br><span class="line"><span class="comment">// 关于输入</span></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt; str;<span class="comment">//接受空、回车格结尾的字符串</span></span><br><span class="line"><span class="built_in">cin</span>.ignore();<span class="comment">//配合使用，清除以回车结束的输入缓冲区的内容 </span></span><br><span class="line">getline(<span class="built_in">cin</span>, str);<span class="comment">//读取一行</span></span><br><span class="line"><span class="comment">//字串型的串流，用于按空格间隔的字串分割</span></span><br><span class="line"><span class="built_in">stringstream</span> ss;</span><br><span class="line">ss&lt;&lt; str;<span class="comment">//输入str到ss(屏幕)，看方向</span></span><br><span class="line">ss&gt;&gt; str;<span class="comment">//ss(屏幕)输入到str</span></span><br><span class="line"><span class="comment">//@brief: 指定单个分隔符（单个字符或子串）分割字符串</span></span><br><span class="line"><span class="comment">//@param: src 原字符串；delimiter 分隔符，单个字符或子串</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">splitStr</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; src, <span class="keyword">const</span> <span class="built_in">string</span>&amp; delimiter)</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vetStr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入参检查</span></span><br><span class="line"><span class="comment">// 1.原字符串为空或等于分隔符，返回空 vector</span></span><br><span class="line"><span class="keyword">if</span> (src == <span class="string">""</span> || src == delimiter) &#123;</span><br><span class="line"><span class="keyword">return</span> vetStr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2.分隔符为空返回单个元素为原字符串的 vector</span></span><br><span class="line"><span class="keyword">if</span> (delimiter == <span class="string">""</span>) &#123;</span><br><span class="line">vetStr.push_back(src);</span><br><span class="line"><span class="keyword">return</span> vetStr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span>::size_type startPos = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> index = src.find(delimiter);</span><br><span class="line"><span class="keyword">while</span> (index != <span class="built_in">string</span>::npos) &#123;</span><br><span class="line"><span class="keyword">auto</span> str = src.substr(startPos, index - startPos);</span><br><span class="line"><span class="keyword">if</span> (str != <span class="string">""</span>) &#123;</span><br><span class="line">vetStr.push_back(str);</span><br><span class="line">&#125;</span><br><span class="line">startPos = index + delimiter.length();</span><br><span class="line">index = src.find(delimiter, startPos);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 取最后一个子串</span></span><br><span class="line"><span class="keyword">auto</span> str = src.substr(startPos);</span><br><span class="line"><span class="keyword">if</span> (str != <span class="string">""</span>) &#123;</span><br><span class="line">vetStr.push_back(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> vetStr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//char字符处理</span></span><br><span class="line"><span class="built_in">isalpha</span>(ch);<span class="comment">//字母（不区分大小写）</span></span><br><span class="line"><span class="built_in">isupper</span>(ch);<span class="comment">//大写字母</span></span><br><span class="line"><span class="built_in">islower</span>();<span class="comment">//小写字母</span></span><br><span class="line"><span class="built_in">isdigit</span>();<span class="comment">//数字</span></span><br><span class="line"><span class="built_in">isalnum</span>();<span class="comment">//字母或数字</span></span><br><span class="line"><span class="built_in">toupper</span>();<span class="comment">//转大写</span></span><br><span class="line"><span class="built_in">tolower</span>();<span class="comment">//转小写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//string转int等类型</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stoi</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;  str, <span class="keyword">size_t</span>* idx = <span class="number">0</span>, <span class="keyword">int</span> base = <span class="number">10</span>)</span></span>;<span class="comment">//*idx是指向size_t类型对象的指针，其值由函数设置为数值后str中下一个字符的位置；base是指str的基数，默认十进制</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">stol</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;  str, <span class="keyword">size_t</span>* idx = <span class="number">0</span>, <span class="keyword">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">stoul</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;  str, <span class="keyword">size_t</span>* idx = <span class="number">0</span>, <span class="keyword">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">stoll</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;  str, <span class="keyword">size_t</span>* idx = <span class="number">0</span>, <span class="keyword">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">stoull</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;  str, <span class="keyword">size_t</span>* idx = <span class="number">0</span>, <span class="keyword">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">stof</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;  str, <span class="keyword">size_t</span>* idx = <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">stod</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;  str, <span class="keyword">size_t</span>* idx = <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">double</span> <span class="title">stold</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;  str, <span class="keyword">size_t</span>* idx = <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//int等类型转string</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span> <span class="params">(T)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//find函数</span></span><br><span class="line">str.find(tmp_str);<span class="comment">//返回下标位置，没有则返回str.npos</span></span><br><span class="line">str.find_first_of(tmp_str);<span class="comment">//第一次出现的位置</span></span><br><span class="line">str.find_last_of(tmp_str);<span class="comment">//最后一次出现的位置</span></span><br><span class="line">str.find(tmp_str, pos);<span class="comment">//从下标pos开始查找</span></span><br><span class="line">str.rfind(tmp_str);<span class="comment">//反向查找，与正向查找结合确定子串的唯一性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//取子串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">substr</span> <span class="params">(<span class="keyword">size_t</span> pos = <span class="number">0</span>, <span class="keyword">size_t</span> len = npos)</span> <span class="keyword">const</span></span>;<span class="comment">//在字符位置pos开始，跨越len个字符（或直到字符串的结尾，以先到者为准）对象的部分</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串大小写转化</span></span><br><span class="line">transform(s.begin(),s.end(),s.begin(),::<span class="built_in">tolower</span>);</span><br><span class="line">transform(s.begin(),s.end(),s.begin(),::<span class="built_in">toupper</span>);</span><br></pre></td></tr></table></figure><h1 id="5-list-列表"><a href="#5-list-列表" class="headerlink" title="5 list(列表)"></a>5 list(列表)</h1><p>list是由双向链表实现的，因此内存空间是不连续的。只能通过指针访问数据，所以list的随机存取非常没有效率，时间复杂度为$O(n)$；但由于链表的特点，能高效地进行插入和删除。</p><p>使用：</p><ul><li>需要高效的随机存取，而不在乎插入和删除的效率，使用vector;</li><li>如果需要大量的插入和删除，而不关心随机存取，则应使用list</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; l;<span class="comment">//声明一个空列表</span></span><br><span class="line"><span class="function"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">l</span><span class="params">(n)</span></span>;<span class="comment">//声明一个有n个元素的列表，每个元素都是由其默认构造函数T()构造出来的</span></span><br><span class="line"><span class="function"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">l</span><span class="params">(n,val)</span></span>;<span class="comment">//声明一个由n个元素的列表，每个元素都是由其复制构造函数T(val)得来的</span></span><br><span class="line"><span class="function"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">l</span><span class="params">()</span></span>;<span class="comment">//声明一个空列表</span></span><br><span class="line"><span class="function"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">l</span><span class="params">(first,last)</span></span>;<span class="comment">//声明一个列表，其元素的初始值由区间所指定的序列中的元素;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本操作</span></span><br><span class="line">l.begin() <span class="comment">// 得到一个指向容器起始位置的iterator</span></span><br><span class="line">l.end() <span class="comment">//返回list末端下一位置，如a[n]中的第n+1个位置a[n]，实际是不存在，经常作为循环结束判断条件使用</span></span><br><span class="line">l.push_back(x) <span class="comment">//list的末端插入x</span></span><br><span class="line">l.push_front(x) <span class="comment">// 从list的头部插入x</span></span><br><span class="line">l.empty() <span class="comment">// 利用empty() 判断list是否为空，空返回true</span></span><br><span class="line">l.resize(n) <span class="comment">//将l的长度改为n，超出的元素将被删除，如果需要扩展那么调用默认构造函数T()将元素加到list末端</span></span><br><span class="line">l.resize(n, val)<span class="comment">//扩展元素要调用构造函数T(val)函数进行元素构造，其余部分与resize相同</span></span><br><span class="line">l.clear() <span class="comment">//清空list中的所有元素</span></span><br><span class="line">l.front() <span class="comment">//获得list容器中的头部元素</span></span><br><span class="line">l.back() <span class="comment">//可以获得list容器的最后一个元素</span></span><br><span class="line">l.pop_back <span class="comment">// 删除最后一个元素</span></span><br><span class="line">l.pop_front() <span class="comment">// 删除第一个元素；序列必须不为空，当list为空时调用pop_back和pop_front会使程序崩掉</span></span><br><span class="line">l.assign() <span class="comment">//具体和vector中的操作类似</span></span><br><span class="line">l.swap(ll) <span class="comment">//交换两个链表，swap(l ,ll)也可</span></span><br><span class="line">merge() <span class="comment">//合并两个链表并使之默认升序(也可改)，l1.merge(l2，greater&lt;int&gt;()); 调用结束后l2变为空，l1中元素包含原来l1 和 l2中的元素，并且排好序，升序。其实默认是升序，greater&lt;int&gt;()可以省略，另外greater&lt;int&gt;()是可以变的，也可以不按升序排列。</span></span><br></pre></td></tr></table></figure><h1 id="6-stack-栈"><a href="#6-stack-栈" class="headerlink" title="6 stack(栈)"></a>6 stack(栈)</h1><p>stack模版类的定义在\<stack\>头文件中，stack模版类需要两个模版参数，一个是元素类型，另一个是容器类型，但是只有元素类型是必要的，在不指定容器类型时，默认容器的类型为deque。</stack\></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本操作</span></span><br><span class="line">s.push(x); <span class="comment">// ⼊栈</span></span><br><span class="line">s.pop(); <span class="comment">// 出栈，不返回值</span></span><br><span class="line">x = s.top(); <span class="comment">// 访问栈顶，</span></span><br><span class="line">s.empty(); <span class="comment">// 当栈空时，返回true</span></span><br><span class="line">s.size(); <span class="comment">// 访问栈中元素个数</span></span><br></pre></td></tr></table></figure><h1 id="7-queue-队列"><a href="#7-queue-队列" class="headerlink" title="7 queue(队列)"></a>7 queue(队列)</h1><p>queue模版类的定义在头文件\<queue\>中。queue与stack相似， queue模版类也需要两个模版参数，一个元素类型，一个容器类型，元素类型是必须的，容器类型是可选的。  </queue\></p><p>标准库提供queue分为：</p><ol><li>queue(队列)：queue从队首弹出，先入先出，并且queue只能从队首删除元素，但是两端都能访问。</li><li>deque(双向队列)：可以访问两端并且可以在队首和队尾删除和插入元素</li><li>priority_queue(优先队列)：优先队列与队列的差别在于优先队列不是按照入队的顺序出队，而是按照队列中元素的优先权出队列（默认为大者优先，也可以通过指定算子来指定自己的优先顺序）；priority_queue模版类有三个模版参数，第一个是元素类型，第二个是容器类型，第三个是比较算子。其中后两者都可以忽略，默认容器为vector，默认算子为less，即小的往前排，大的往后排（出队列时列尾元素先出队）。  </li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 队列定义</span></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列基本操作</span></span><br><span class="line">q.push(x); <span class="comment">// 从队尾⼊队列</span></span><br><span class="line">q.pop(); <span class="comment">// 从队首出队列</span></span><br><span class="line">q.front(); <span class="comment">// 访问队首元素</span></span><br><span class="line">q.back(); <span class="comment">// 访问队尾元素</span></span><br><span class="line">q.empty(); <span class="comment">// 如果队列为空，则返回true，否则返回false</span></span><br><span class="line">q.size(); <span class="comment">// 访问队列中的元素个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向队列定义</span></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; dq; <span class="comment">//创建一个int双端队列dq</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向队列基本操作</span></span><br><span class="line">dq.empty(); <span class="comment">//判断队列是否为空，为空返回true</span></span><br><span class="line">dq.push_front(s); <span class="comment">//将s从队头入队</span></span><br><span class="line">dq.push_back(s); <span class="comment">//将s从队尾入队，和普通队列方式一样</span></span><br><span class="line">dq.front(); <span class="comment">//只返回队头元素</span></span><br><span class="line">dq.back(); <span class="comment">//只返回队尾元素</span></span><br><span class="line">dq.pop_front(); <span class="comment">//将队头元素弹出</span></span><br><span class="line">dq.pop_back(); <span class="comment">//将队尾元素弹出</span></span><br><span class="line">dq.clear(); <span class="comment">//将队列清空</span></span><br><span class="line"><span class="comment">//组合操作</span></span><br><span class="line"><span class="comment">//C++中的queue自身是不支持clear操作的，但是双端队列deque是支持clear操作的。</span></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; empty;</span><br><span class="line">swap(empty, q);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优先队列定义</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; qq; <span class="comment">// 注意在两个尖括号之间⼀定要留空格，防止误判</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; qqq; <span class="comment">// 定义小的先出队列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 优先队列基本操作</span></span><br><span class="line">q.empty() <span class="comment">// 如果队列为空，则返回true，否则返回false</span></span><br><span class="line">q.size() <span class="comment">// 返回队列中元素的个数</span></span><br><span class="line">q.pop() <span class="comment">// 删除队首元素，但不返回其值</span></span><br><span class="line">q.top() <span class="comment">// 返回具有最高优先级的元素值，但不删除该元素</span></span><br><span class="line">q.push(x) <span class="comment">// 在基于优先级的适当位置插⼊新元素x</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 算子实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> x, y, z;</span><br><span class="line">T(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c) : x(a), y(b), z(c) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> T &amp;tOne, <span class="keyword">const</span> T &amp;tTwo)&#123;</span><br><span class="line"><span class="keyword">return</span> tOne.z &lt; tTwo.z; <span class="comment">// 按照z的顺序来决定tOne和tTwo的顺序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">priority_queue&lt;T&gt; q;</span><br><span class="line">q.push(T(<span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>));</span><br><span class="line">q.push(T(<span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>));</span><br><span class="line">q.push(T(<span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>));</span><br><span class="line">q.push(T(<span class="number">3</span>, <span class="number">3</span>, <span class="number">6</span>));</span><br><span class="line"><span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">T t = q.top();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; t.x &lt;&lt; <span class="string">" "</span> &lt;&lt; t.y &lt;&lt; <span class="string">" "</span> &lt;&lt; t.z &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8-map-字典"><a href="#8-map-字典" class="headerlink" title="8 map(字典)"></a>8 map(字典)</h1><p>map是与字典相关的关联式容器，map模版类的定义在头文件$<map>$中，用有序二叉树表存储类型为pair<const key, t>的元素对序列。  序列中的元素以const Key部分作为标识， map中所有元素的Key值必须是唯一的，multimap则允许有重复的Key值。unordered_map是无序 map 容器。</const></map></p><p>将map可以通过一个Key值来快速决定一个元素，因此非常适合于需要按照Key值查找元素的容器。map模版类需要四个模版参数，第一个是键值类型，第二个是元素类型，第三个是比较算子，第四个是分配器类型。其中键值类型和元素类型是必要的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字典定义</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字典基本操作</span></span><br><span class="line"><span class="comment">/* 向map中插⼊元素 */</span></span><br><span class="line">m[key] = value; <span class="comment">// [key]操作是map很有特色的操作,如果在map中存在键值为key的元素对, 则返回该元素对的值域部分,否则将会创建⼀个键值为key的元素对,值域为默认值。所以可以⽤该操作向map中插⼊元素对或修改已经存在的元素对的值域部分。</span></span><br><span class="line">m.insert(make_pair(key, value)); <span class="comment">// 也可以直接调用insert方法插⼊元素对,insert操作会返回⼀个pair,当map中没有与key相匹配的键值时,其first是指向插⼊元素对的迭代器,其second为true;若map中已经存在与key相等的键值时,其first是指向该元素对的迭代器,second为false，并且不会更新value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查找元素 */</span></span><br><span class="line"><span class="keyword">int</span> i = m[key]; <span class="comment">// key不存在时,会创建键值为key(当另⼀个元素是整型时m[key]=0)的元素对</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator it = m.find(key); <span class="comment">// 如果map中存在与key相匹配的键值时,find操作将返</span></span><br><span class="line"><span class="comment">//回指向该元素对的迭代器,否则,返回的迭代器等于map的end()(参见vector中提到的begin()和end()操作)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 删除元素 */</span></span><br><span class="line">m.erase(key); <span class="comment">// 删除与指定key键值相匹配的元素对,并返回被删除的元素的个数</span></span><br><span class="line">m.erase(it); <span class="comment">// 删除由迭代器it所指定的元素对,并返回指向下⼀个元素对的迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 其他操作 */</span></span><br><span class="line">m.size(); <span class="comment">// 返回元素个数</span></span><br><span class="line">m.empty(); <span class="comment">// 判断是否为空，空返回true</span></span><br><span class="line">m.clear(); <span class="comment">// 清空所有元素</span></span><br><span class="line"><span class="function">size_type <span class="title">count</span> <span class="params">(<span class="keyword">const</span> key_type&amp; k)</span> <span class="keyword">const</span></span>;<span class="comment">//按key搜索</span></span><br></pre></td></tr></table></figure><h1 id="9-bitset"><a href="#9-bitset" class="headerlink" title="9 bitset()"></a>9 bitset()</h1><p>bitset模版类的定义在\<bitset\>头文件中，用来方便地管理一系列的bit位类。 bitset除了可以访问指定下标的bit位以外，还可以把它们作为一个整数来进行某些统计。bitset模板类需要一个模版参数，用来明确指定含有多少位。  </bitset\></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">32</span>;</span><br><span class="line"><span class="built_in">bitset</span>&lt;MAXN&gt; bt; <span class="comment">// bt 包括 MAXN 位，下标 0 ~ MAXN - 1，默认初始化为 0</span></span><br><span class="line"><span class="function"><span class="built_in">bitset</span>&lt;MAXN&gt; <span class="title">bt1</span><span class="params">(<span class="number">0xf</span>)</span></span>; <span class="comment">// 0xf 表示十六进制数 f，对应二进制 1111，将 bt1 低 4 位初始化为 1</span></span><br><span class="line"><span class="function"><span class="built_in">bitset</span>&lt;MAXN&gt; <span class="title">bt2</span><span class="params">(<span class="number">012</span>)</span></span>; <span class="comment">// 012 表示八进制数 12，对应二进制 1010，即将 bt2 低 4 位初始化为 1010</span></span><br><span class="line"><span class="function"><span class="built_in">bitset</span>&lt;MAXN&gt; <span class="title">bt3</span><span class="params">(<span class="string">"1010"</span>)</span></span>; <span class="comment">// 将 bt3 低 4 位初始化为 1010</span></span><br><span class="line"><span class="function"><span class="built_in">bitset</span>&lt;MAXN&gt; <span class="title">bt4</span><span class="params">(s, pos, n)</span></span>; <span class="comment">// 将 01 字符串 s 的 pos 位开始的 n 位初始化 bt4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本操作</span></span><br><span class="line">bt.any() <span class="comment">// bt 中是否存在置为 1 的二进制位</span></span><br><span class="line">bt.none() <span class="comment">// bt 中不存在置为 1 的二进制位</span></span><br><span class="line">bt.count() <span class="comment">// bt 中置为 1 的二进制位的个数</span></span><br><span class="line">bt.size() <span class="comment">// bt 中二进制位的个数</span></span><br><span class="line">bt[pos] <span class="comment">// 访问 bt 中在 pos 处的二进制位</span></span><br><span class="line">bt.test(pos) <span class="comment">// bt 中在 pos 处的二进制位是否为 1</span></span><br><span class="line">bt.<span class="built_in">set</span>() <span class="comment">// 把 bt 中所有二进制位都置为 1</span></span><br><span class="line">bt.<span class="built_in">set</span>(pos) <span class="comment">// 把 bt 中在 pos 处的二进制位置为 1</span></span><br><span class="line">bt.reset() <span class="comment">// 把 bt 中所有二进制位都置为 0</span></span><br><span class="line">bt.reset(pos) <span class="comment">// 把 bt 中在pos处的二进制位置为0</span></span><br><span class="line">bt.flip() <span class="comment">// 把 bt 中所有二进制位逐位取反</span></span><br><span class="line">bt.flip(pos) <span class="comment">// 把 bt 中在 pos 处的二进制位取反</span></span><br><span class="line">bt[pos].flip() <span class="comment">// 同上</span></span><br><span class="line">bt.to_ulong() <span class="comment">// ⽤用 bt 中同样的二进制位返回⼀个 unsigned long 值</span></span><br><span class="line">bt.to_string()<span class="comment">//转字符串</span></span><br><span class="line">os &lt;&lt; bt <span class="comment">// 把 bt 中的位集输出到 os 流</span></span><br></pre></td></tr></table></figure><h1 id="10-iterator-迭代器"><a href="#10-iterator-迭代器" class="headerlink" title="10 iterator(迭代器)"></a>10 iterator(迭代器)</h1><p>iterator（迭代器）是用于访问容器中元素的指示器，从这个意义上说， iterator（迭代器）相当于数据结构中所说的“遍历指针”，也可以把iterator（迭代器）看作是一种泛化的指针。每种STL容器都有自己的iterator（迭代器）子类。</p><h1 id="11-algorithm"><a href="#11-algorithm" class="headerlink" title="11 algorithm"></a>11 algorithm</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">max_element(v.begin(),v.end()); <span class="comment">//返回容器最大值的迭代器</span></span><br><span class="line">min_element(v.begin(),v.end()); <span class="comment">//返回容器最小值的迭代器</span></span><br><span class="line">sort(v.begin(), v.end(), cmp); <span class="comment">//cmp可以自定义，默认升序排序</span></span><br><span class="line">reverse(v.begin(), v.end()); <span class="comment">//反转容器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">memset</span> <span class="params">( <span class="keyword">void</span> * ptr, <span class="keyword">int</span> value, <span class="keyword">size_t</span> num )</span></span>;<span class="comment">//将ptr所指向的某一块内存中的前num个字节的内容全部设置为ch指定的ASCII值， 第一个值为指定的内存地址，块的大小由第三个参数指定，这个函数通常为新申请的内存做初始化工作， 其返回值为指向s的指针，它是对较大的结构体或数组进行清零操作的一种最快方法。</span></span><br><span class="line">fill(begin, last, val);<span class="comment">//将[begin, last)赋值为val</span></span><br><span class="line"><span class="built_in">memcpy</span>(target, source, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*k);<span class="comment">//复制source数组的前k个到target</span></span><br><span class="line"><span class="built_in">memcpy</span>(target, source, <span class="keyword">sizeof</span>(source));<span class="comment">//复制source数组到target</span></span><br><span class="line">lower_bound(a, a+n, x);<span class="comment">//查找&gt;=x的第一个位置</span></span><br><span class="line">__gcd(<span class="keyword">int</span> x, <span class="keyword">int</span> y)<span class="comment">//求x与y的最大公约数</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构和算法" scheme="https://Dragonliu2018.github.io/categories/数据结构和算法/"/>
    
    
  </entry>
  
  <entry>
    <title>哈希表</title>
    <link href="https://dragonliu2018.github.io/2021/07/22/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <id>https://dragonliu2018.github.io/2021/07/22/%E5%93%88%E5%B8%8C%E8%A1%A8/</id>
    <published>2021-07-22T02:30:22.000Z</published>
    <updated>2021-09-21T13:41:08.779Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p>散列表（Hash Table），又称哈希表。是一种数据结构，特点是：数据元素的关键字与其存储地址直接相关，通过“散列函数（哈希函数）”：$Addr=H(key)$。</p><p>若不同的关键字通过散列函数映射到同一个值，则称它们为“同义词”</p><p>通过散列函数确定的位置已经存放了其他元素，则称这种情况为“冲突”</p><h1 id="常见的散列函数"><a href="#常见的散列函数" class="headerlink" title="常见的散列函数"></a>常见的散列函数</h1><ol><li>除留余数法——$H(key)=key\%p$，散列表表长为$m$，取一个不大于$m$但最接近或等于$m$的质数$p$</li><li>直接定址法——$H(key)=key$ 或$H(key)=a*key +b$，其中，a和b是常数。这种方法计算最简单，且不会产生冲突。它适合关键字的分布基本连续的情况，若关键字分布不连续，空位较多，则会造成存储空间的浪费。</li><li>数字分析法——选取数码分布较为均匀的若干位作为散列地址，如手机号码。</li><li>平方取中法——取关键字的平方值的中间几位作为散列地址。具体取多少位要视实际情况而定。这种方法得到的散列地址与关键字的每位都有关系，因此使得散列地址分布比较均匀，适用于关键字的每位取值都不够均匀或均小于散列地址所需的位数。如身份证号。</li></ol><h1 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h1><ol><li>拉链法：把所有“同义词”存储在一个链表中，Java中的HashMap、HashSet</li><li>开放定址法：可存放新表项的空闲地址既向它的同义词表项开放，又向它的非同义词表项开放。其数学递推公式为：$H<em>{i}=\left(H(k e y)+d</em>{i}\right) \% m$，$i=0,1,2, \ldots, k \quad(k \leqslant m-1)$，其中$m$表示散列表表长；$d_i$为增量序列；$i$可理解为“第$i$次发生冲突”<ul><li>线性探测法：$d_{i}=0,1,2,3, \ldots, m-1$; 即发生冲突时，每次往后探测相邻的下一个单元是否为空<ul><li>线性探测法很容易造成同义词、非同义词的“聚集（堆积）”现象，严重影响查找效率</li><li>产生原因——冲突后再探测一定是放在某个连续的位置</li></ul></li><li>平方探测法：当 $\mathrm{d}_{\mathrm{i}}=\mathbf{0}^{2}, \mathbf{1}^{2},-\mathbf{1}^{2}, \mathbf{2}^{2},-\mathbf{2}^{2}, \ldots, \mathbf{k}^{2},-\mathbf{k}^{2}$ 时，称为平方探测法，又称二次探测法其中 $\mathbf{k} \leq \mathbf{m} / \mathbf{2}$<ul><li>比起线性探测法更不易产生“聚集（堆积）”问题</li><li>散列表长度m必须是一个可以表示成$4j+3$的素数，才能探测到所有位置</li></ul></li><li>伪随机序列法：$\mathbf{d}<em>{\mathrm{i}}$ 是一个伪随机序列，如 $\mathrm{d}</em>{\mathrm{i}}=\mathbf{0 , 5 , 2 4 , 1 1 , \ldots}$</li></ul></li><li>再散列法：除了原始的散列函数$H(key)$之外，多准备几个散列函数，当散列函数冲突时，用下一个散列函数计算一个新地址，直到不冲突为止：$\mathrm{H}<em>{\mathrm{i}}=\mathrm{RH}</em>{\mathrm{i}}(\mathrm{Key}) \quad \mathrm{i}=1,2,3 \ldots ., \mathrm{k}$</li></ol><h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><ul><li>无序集合：unordered_set</li><li>无序字典：unordered_map</li></ul><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><ol><li><a href="https://www.luogu.com.cn/problem/P4305" target="_blank" rel="noopener">洛谷——P4305 [JLOI2011]不重复数字</a>：需要加快读</li><li><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">leetcode-1 两数之和 (简单)</a></li><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构和算法" scheme="https://Dragonliu2018.github.io/categories/数据结构和算法/"/>
    
    
    <category term="数据结构" scheme="https://Dragonliu2018.github.io/tags/数据结构/"/>
    
  </entry>
  
  <entry>
    <title>KMP算法</title>
    <link href="https://dragonliu2018.github.io/2021/04/10/KMP%E7%AE%97%E6%B3%95/"/>
    <id>https://dragonliu2018.github.io/2021/04/10/KMP%E7%AE%97%E6%B3%95/</id>
    <published>2021-04-10T09:18:30.000Z</published>
    <updated>2021-09-21T15:53:36.104Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-算法思想"><a href="#1-算法思想" class="headerlink" title="1 算法思想"></a>1 算法思想</h1><h2 id="1-1-思路"><a href="#1-1-思路" class="headerlink" title="1.1 思路"></a>1.1 思路</h2><p><strong>解决问题</strong>：当主串中第 i 个字符与模式中第 j 个字符失配（即比较不相等）时，主串中第 i 个字符（i 指针不回溯）应与模式中哪个字符再比较。</p><ol><li><p>$next[j]$：模式中第 j 个字符失配时，在模式中重新与主串比较的字符位置（最长公共前后缀长度+1，下标从 1 开始）</p><p>$\text { next }[j]=\left{\begin{array}{ll}<br>0 &amp; \text { 当 } j=1 \text { 时 } \<br>\operatorname{Max}\left{k \mid 1&lt;k&lt;j \text { 且 }^{\prime} p<em>{1} \cdots p</em>{k-1}^{\prime}={ }^{\prime} p<em>{j-k+1} \cdots p</em>{j-1}{ }^{\prime}\right} &amp;<br>\text { 当此集合不空时 } \<br>1 &amp; \text { 其他情况 }<br>\end{array}\right.$</p></li><li><p>计算next数组：仅取决于模式串本身而和相匹配的主串无关</p><ul><li>仿照kmp算法，如果$p[j] != p[next[j]]$，那么$next[j+1]$的可能次大值为$next[next[j]] + 1$，依次类推即可高效求出$next[j+1]$</li></ul></li><li><p>若在匹配过程中$s_i=p_j$，则 i 与 j 分别增 1；</p></li><li><p>否则，i 不变，j 退至 next[j] 的位置再比较；若 j 退到值为 0（即模式串的第一个字符失配），则从主串的下一个字符$s_{i+1}$起与模式串重新开始匹配；</p></li><li><p>重复执行step3、step4，直至结束。</p></li></ol><h2 id="1-2-优化"><a href="#1-2-优化" class="headerlink" title="1.2 优化"></a>1.2 优化</h2><p>修正next数组，$next[j]=k$，若模式中$p[j]=p[k]$，则$next[j] = next[k]$</p><h2 id="1-3-算法分析"><a href="#1-3-算法分析" class="headerlink" title="1.3 算法分析"></a>1.3 算法分析</h2><ul><li><strong>时间复杂度</strong>：$O(m+n)$</li><li><strong>空间复杂度</strong>：next数组，$O(m)$</li></ul><h1 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2 代码实现"></a>2 代码实现</h1><h2 id="2-1-C"><a href="#2-1-C" class="headerlink" title="2.1 C++"></a>2.1 C++</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">// string、next数组下标从1开始</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span>;</span><br><span class="line"><span class="keyword">int</span> next2[maxn];</span><br><span class="line"><span class="keyword">int</span> nextval[maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算next数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_next</span><span class="params">(<span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">    next2[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; p.size()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || p[i] == p[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            next2[i] = j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = next2[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算nextval数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_nextval</span><span class="params">(<span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">    nextval[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; p.size()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || p[i] == p[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">if</span> (p[i] != p[j])</span><br><span class="line">                nextval[i] = j;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                nextval[i] = nextval[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            j = nextval[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// KMP算法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//get_next(p);//计算next数组</span></span><br><span class="line">    get_nextval(p);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>;<span class="comment">//主串从第i个字符之后匹配</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; s.size() &amp;&amp; j &lt; p.size()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || s[i] == p[j]) &#123;<span class="comment">//模式串首字符失配或相同继续匹配</span></span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//失配</span></span><br><span class="line">            j = nextval[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &gt;= p.size())<span class="comment">//找到</span></span><br><span class="line">        <span class="keyword">return</span> i - p.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">string</span> s = <span class="string">" acabaabaabcacaabc"</span>, t = <span class="string">" abaabcac"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; kmp(s, t);</span><br><span class="line">    <span class="comment">/*for (int i = 1; i &lt; t.size(); i++) &#123;</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; next2[i] &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-Java"><a href="#2-2-Java" class="headerlink" title="2.2 Java"></a>2.2 Java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KMP</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxn = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[maxn];</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] nextval = <span class="keyword">new</span> <span class="keyword">int</span>[maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">KMP</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算next数组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get_next</span><span class="params">(String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">        next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; p.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span> || p.charAt(i) == p.charAt(j)) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">                next[i] = j;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算nextval数组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">get_nextval</span><span class="params">(String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">        nextval[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; p.length() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span> || p.charAt(i) == p.charAt(j)) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">                <span class="keyword">if</span> (p.charAt(i) != p.charAt(j))</span><br><span class="line">                    nextval[i] = j;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    nextval[i] = nextval[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                j = nextval[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// KMP算法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kmp</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//get_next(p);//计算next数组</span></span><br><span class="line">        get_nextval(p);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>;<span class="comment">//主串从第i个字符之后匹配</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; s.length() &amp;&amp; j &lt; p.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span> || s.charAt(i) == p.charAt(j)) &#123;<span class="comment">//模式串首字符失配或相同继续匹配</span></span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//失配</span></span><br><span class="line">                j = nextval[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= p.length())<span class="comment">//找到</span></span><br><span class="line">            <span class="keyword">return</span> i - p.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO自动生成的方法存根</span></span><br><span class="line">    KMP test = <span class="keyword">new</span> KMP();</span><br><span class="line">        String s = <span class="string">" acabaabaabcacaabc"</span>, t = <span class="string">" abaabcac"</span>;</span><br><span class="line">        System.out.println(test.kmp(s, t));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-参考"><a href="#3-参考" class="headerlink" title="3 参考"></a>3 参考</h1><ul><li><a href="https://www.bilibili.com/video/BV16X4y137qw?from=search&amp;seid=428213560995313343" target="_blank" rel="noopener">KMP算法之求next数组代码讲解</a></li><li></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构和算法" scheme="https://Dragonliu2018.github.io/categories/数据结构和算法/"/>
    
    
    <category term="字符串" scheme="https://Dragonliu2018.github.io/tags/字符串/"/>
    
  </entry>
  
  <entry>
    <title>搜索</title>
    <link href="https://dragonliu2018.github.io/2021/04/10/%E6%90%9C%E7%B4%A2/"/>
    <id>https://dragonliu2018.github.io/2021/04/10/%E6%90%9C%E7%B4%A2/</id>
    <published>2021-04-10T09:18:30.000Z</published>
    <updated>2021-09-21T13:41:49.133Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-DFS"><a href="#1-DFS" class="headerlink" title="1 DFS"></a>1 DFS</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(参数)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(满足条件)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> step)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        判断边界</span><br><span class="line">        &#123;</span><br><span class="line">            相应操作</span><br><span class="line">        &#125;</span><br><span class="line">        尝试每一种可能</span><br><span class="line">        &#123;</span><br><span class="line">               满足check条件</span><br><span class="line">               标记</span><br><span class="line">               继续下一步dfs(step+<span class="number">1</span>)</span><br><span class="line">               恢复初始状态（回溯的时候要用到）</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-BFS"><a href="#2-BFS" class="headerlink" title="2 BFS"></a>2 BFS</h1><p>BFS使用队列，把每个还没有搜索到的点一次放入队列，然后再弹出队列的头部元素当做当前遍历点。当不需要确定当前遍历层数时：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>.push(s)<span class="comment">//压入起点，初始队列可能有多个起点</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">queue</span> 不空：</span><br><span class="line">    cur = <span class="built_in">queue</span>.pop()</span><br><span class="line">    <span class="keyword">for</span> 节点 in cur的所有相邻节点：</span><br><span class="line">        <span class="keyword">if</span> 该节点有效且未访问过：</span><br><span class="line">            <span class="built_in">queue</span>.push(该节点)</span><br></pre></td></tr></table></figure><p>当需要确定遍历层数时，这里增加了level表示当前遍历到二叉树中的哪一层了，也可以理解为在一个图中，现在已经走了多少步了。size表示在开始遍历新的一层时，队列中有多少个元素，即有多少个点需要向前走一步。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>.push(s)<span class="comment">//压入起点</span></span><br><span class="line">level = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">queue</span> 不空：</span><br><span class="line">    size = <span class="built_in">queue</span>.size()</span><br><span class="line">    <span class="keyword">while</span> (size --) &#123;</span><br><span class="line">        cur = <span class="built_in">queue</span>.pop()</span><br><span class="line">        <span class="keyword">for</span> 节点 in cur的所有相邻节点：</span><br><span class="line">            <span class="keyword">if</span> 该节点有效且未被访问过：</span><br><span class="line">                <span class="built_in">queue</span>.push(该节点)</span><br><span class="line">    &#125;</span><br><span class="line">    level ++</span><br></pre></td></tr></table></figure><h1 id="3-二分"><a href="#3-二分" class="headerlink" title="3 二分"></a>3 二分</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在[l, h)范围内查找值v(l&gt;=0),返回下标,假设a数组已经按从⼩到⼤排序,失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bs</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> l, <span class="keyword">int</span> h, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="keyword">while</span> (l &lt; h)&#123;</span><br><span class="line">m = (l + h) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (a[m] == v)&#123;</span><br><span class="line"><span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a[m] &lt; v)&#123;</span><br><span class="line">l = m + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">h = m;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-双向搜索"><a href="#4-双向搜索" class="headerlink" title="4 双向搜索"></a>4 双向搜索</h1><p>起点是给出的，终点也是已知的，需要确定能否从起点到达终点，如果可以，需要多少步。</p><p>如果我们用常规的搜索方法，从起点开始往下搜，那得到的解答树可能非常庞大，这样漫无目的的搜索就像<strong>大海捞针</strong>。让我们切换一下思路，既然终点是已知的，我们何必让它闲着呢？我们完全可以<strong>分别</strong>从起点和终点出发，看它们能否<strong>相遇</strong>。</p><p>如果原本的解答树规模是 <img alt="[公式]" data-src="https://www.zhihu.com/equation?tex=a%5En" class="lozad"> ，使用双向搜索后，规模立刻缩小到了约 <img alt="[公式]" data-src="https://www.zhihu.com/equation?tex=2a%5E%7Bn%2F2%7D" class="lozad"> ，当 <img alt="[公式]" data-src="https://www.zhihu.com/equation?tex=n" class="lozad"> 较大时优化非常可观。</p><p>双向搜索主要有两种，双向BFS和双向迭代加深。</p><h2 id="4-1-双向BFS"><a href="#4-1-双向BFS" class="headerlink" title="4.1 双向BFS"></a>4.1 双向BFS</h2><p>与普通的BFS不同，双向BFS维护两个而不是一个队列，然后<strong>轮流</strong>拓展两个队列。同时，用<strong>数组</strong>（如果状态可以被表示为较小的整数）或<strong>哈希表</strong>记录当前的搜索情况，给从两个方向拓展的节点以不同的标记。当某点被两种标记同时标记时，搜索结束。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;T&gt; Q[<span class="number">3</span>]; <span class="comment">// T要替换为用来表示状态的类型，可能为int，string还有bitset等</span></span><br><span class="line"><span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">Q[<span class="number">1</span>].push(st); <span class="comment">// st为起始状态</span></span><br><span class="line">Q[<span class="number">2</span>].push(ed); <span class="comment">// ed为终止状态</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; D + <span class="number">2</span>; ++d) <span class="comment">// D为最大深度，最后答案为d-1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> dir = (d &amp; <span class="number">1</span>) + <span class="number">1</span>, sz = Q[dir].size(); <span class="comment">// 记录一下当前的搜索方向，1为正向，2为反向</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> x = Q[dir].front();</span><br><span class="line">        Q[dir].pop();</span><br><span class="line">        <span class="keyword">if</span> (H[x] + dir == <span class="number">3</span>) <span class="comment">// H是数组或哈希表，若H[x]+dir==3说明两个方向都搜到过这个点</span></span><br><span class="line">            found = <span class="literal">true</span>;</span><br><span class="line">        H[x] = dir;</span><br><span class="line">        <span class="comment">// 这里需要把当前状态能够转移到的新状态压入队列</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (found)</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-双向迭代加深"><a href="#4-2-双向迭代加深" class="headerlink" title="4.2 双向迭代加深"></a>4.2 双向迭代加深</h2><p>迭代加深算法是那种，听名字非常高端，思想和实现却都很简单的算法。就是控制dfs的最大深度，如果深度超过最大深度就返回。某个深度搜完后没有得到答案便令最大深度+1，然后重新开始搜索。</p><p>这听起来好像效果跟广搜差不多啊？还重复搜索了很多次。但是，由于搜索的时间复杂度几乎完全由解答树的最后一层确定（看上面第一张图就能感悟到），所以它与BFS在时间上只有常数级别的差距，以此换来的优势是：空间占用很小，有时候方便剪枝、方便传参等。</p><p>双向迭代加深就是相应地，从两个方向迭代加深搜索。先从起点开始搜0层，再从终点开始搜0层，然后从起点开始搜1层……</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> D;</span><br><span class="line"><span class="keyword">bool</span> found;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">dfs</span>(<span class="title">T</span> <span class="title">x</span>, <span class="title">int</span> <span class="title">d</span>, <span class="title">int</span> <span class="title">dir</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">if</span> (H[x] + dir == <span class="number">3</span>)</span><br><span class="line">        found = <span class="literal">true</span>;</span><br><span class="line">    H[x] = dir;</span><br><span class="line">    <span class="keyword">if</span> (d == D)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 这里需要递归搜索当前状态能够转移到的新状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在main函数中...</span></span><br><span class="line"><span class="keyword">while</span> (D &lt;= MAXD / <span class="number">2</span>) <span class="comment">// MAXD为题中要求的最大深度</span></span><br><span class="line">&#123;</span><br><span class="line">    dfs(st, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">// st为起始状态</span></span><br><span class="line">    <span class="keyword">if</span> (found)</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 题中所给最大深度为奇数时这里要判断一下</span></span><br><span class="line">    dfs(ed, <span class="number">0</span>, <span class="number">2</span>); <span class="comment">// ed为终止状态</span></span><br><span class="line">    <span class="keyword">if</span> (found)</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    D++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://zhuanlan.zhihu.com/p/119349440" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/119349440</a></p><h1 id="5-极大极小值搜索算法"><a href="#5-极大极小值搜索算法" class="headerlink" title="5 极大极小值搜索算法"></a>5 极大极小值搜索算法</h1><p>简单的对抗搜索</p><p>评估函数的返回值直接设定成题目中的评估得分即可</p><p>在博弈树搜索时，先手返回能向下递归所得的最大值，后手反之返回最小值</p><p>如果某种状态已经分出胜负或者平手，就说明该种状态就是博弈树中的叶子节点，需要计算评估得分进行返回</p><p>数据很小可以不用alpha-beta剪枝</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(x,a,b) for(int x=(a);x&lt;=(b);x++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn][maxn];<span class="comment">//棋盘 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//计算评估分数，-2000代表还能继续进行棋局</span></span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">    rep(i,<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">        rep(j,<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">            x+=(a[i][j]==<span class="number">0</span>);</span><br><span class="line">    rep(i,<span class="number">0</span>,<span class="number">2</span>)&#123;<span class="comment">//A或B获胜 </span></span><br><span class="line">        <span class="keyword">if</span>(a[i][<span class="number">0</span>]==<span class="number">1</span>&amp;&amp;a[i][<span class="number">1</span>]==<span class="number">1</span>&amp;&amp;a[i][<span class="number">2</span>]==<span class="number">1</span>) <span class="keyword">return</span> x+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[i][<span class="number">0</span>]==<span class="number">2</span>&amp;&amp;a[i][<span class="number">1</span>]==<span class="number">2</span>&amp;&amp;a[i][<span class="number">2</span>]==<span class="number">2</span>) <span class="keyword">return</span> -x<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">0</span>][i]==<span class="number">1</span>&amp;&amp;a[<span class="number">1</span>][i]==<span class="number">1</span>&amp;&amp;a[<span class="number">2</span>][i]==<span class="number">1</span>) <span class="keyword">return</span> x+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">0</span>][i]==<span class="number">2</span>&amp;&amp;a[<span class="number">1</span>][i]==<span class="number">2</span>&amp;&amp;a[<span class="number">2</span>][i]==<span class="number">2</span>) <span class="keyword">return</span> -x<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//A或B获胜 </span></span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">0</span>][<span class="number">0</span>]==<span class="number">1</span>&amp;&amp;a[<span class="number">1</span>][<span class="number">1</span>]==<span class="number">1</span>&amp;&amp;a[<span class="number">2</span>][<span class="number">2</span>]==<span class="number">1</span>) <span class="keyword">return</span> x+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">0</span>][<span class="number">2</span>]==<span class="number">1</span>&amp;&amp;a[<span class="number">1</span>][<span class="number">1</span>]==<span class="number">1</span>&amp;&amp;a[<span class="number">2</span>][<span class="number">0</span>]==<span class="number">1</span>) <span class="keyword">return</span> x+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">0</span>][<span class="number">0</span>]==<span class="number">2</span>&amp;&amp;a[<span class="number">1</span>][<span class="number">1</span>]==<span class="number">2</span>&amp;&amp;a[<span class="number">2</span>][<span class="number">2</span>]==<span class="number">2</span>) <span class="keyword">return</span> -x<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">0</span>][<span class="number">2</span>]==<span class="number">2</span>&amp;&amp;a[<span class="number">1</span>][<span class="number">1</span>]==<span class="number">2</span>&amp;&amp;a[<span class="number">2</span>][<span class="number">0</span>]==<span class="number">2</span>) <span class="keyword">return</span> -x<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//平局 </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-2000</span>;<span class="comment">//棋局未结束 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> dep)</span></span>&#123;</span><br><span class="line">    <span class="comment">//dep=0代表先手，1代表后手</span></span><br><span class="line">    <span class="keyword">int</span> res=check();</span><br><span class="line">    <span class="keyword">if</span>(res!=<span class="number">-2000</span>)<span class="comment">//棋局结束 </span></span><br><span class="line"><span class="keyword">return</span> res;<span class="comment">//叶子节点返回</span></span><br><span class="line">    <span class="keyword">int</span> Res = dep==<span class="number">0</span> ? <span class="number">-1000</span>:<span class="number">1000</span>;</span><br><span class="line">    rep(i,<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">        rep(j,<span class="number">0</span>,<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!a[i][j])&#123;</span><br><span class="line">                a[i][j] = dep==<span class="number">0</span> ? <span class="number">1</span>:<span class="number">2</span>;<span class="comment">//打标签 </span></span><br><span class="line">                <span class="keyword">if</span>( dep==<span class="number">0</span> )<span class="comment">//先手找最大</span></span><br><span class="line">Res = max(Res, dfs(dep^<span class="number">1</span>));<span class="comment">//按位异或实现01轮流下棋</span></span><br><span class="line">                <span class="keyword">else</span><span class="comment">//后手找最小</span></span><br><span class="line">Res = min(Res, dfs(dep^<span class="number">1</span>));</span><br><span class="line">                a[i][j] = <span class="number">0</span>;<span class="comment">//去标签 </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> Res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> T;<span class="comment">//测试组数 </span></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        rep(i,<span class="number">0</span>,<span class="number">2</span>)<span class="comment">//输入当前棋盘 </span></span><br><span class="line">            rep(j,<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">                <span class="built_in">cin</span>&gt;&gt; a[i][j];</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; dfs(<span class="number">0</span>)&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用用alpha-beta剪枝：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(x,a,b) for(int x=(a);x&lt;=(b);x++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn][maxn];<span class="comment">//棋盘 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//计算评估分数，-2000代表还能继续进行棋局</span></span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">    rep(i,<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">        rep(j,<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">            x+=(a[i][j]==<span class="number">0</span>);</span><br><span class="line">    rep(i,<span class="number">0</span>,<span class="number">2</span>)&#123;<span class="comment">//A或B获胜 </span></span><br><span class="line">        <span class="keyword">if</span>(a[i][<span class="number">0</span>]==<span class="number">1</span>&amp;&amp;a[i][<span class="number">1</span>]==<span class="number">1</span>&amp;&amp;a[i][<span class="number">2</span>]==<span class="number">1</span>) <span class="keyword">return</span> x+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[i][<span class="number">0</span>]==<span class="number">2</span>&amp;&amp;a[i][<span class="number">1</span>]==<span class="number">2</span>&amp;&amp;a[i][<span class="number">2</span>]==<span class="number">2</span>) <span class="keyword">return</span> -x<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">0</span>][i]==<span class="number">1</span>&amp;&amp;a[<span class="number">1</span>][i]==<span class="number">1</span>&amp;&amp;a[<span class="number">2</span>][i]==<span class="number">1</span>) <span class="keyword">return</span> x+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">0</span>][i]==<span class="number">2</span>&amp;&amp;a[<span class="number">1</span>][i]==<span class="number">2</span>&amp;&amp;a[<span class="number">2</span>][i]==<span class="number">2</span>) <span class="keyword">return</span> -x<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//A或B获胜 </span></span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">0</span>][<span class="number">0</span>]==<span class="number">1</span>&amp;&amp;a[<span class="number">1</span>][<span class="number">1</span>]==<span class="number">1</span>&amp;&amp;a[<span class="number">2</span>][<span class="number">2</span>]==<span class="number">1</span>) <span class="keyword">return</span> x+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">0</span>][<span class="number">2</span>]==<span class="number">1</span>&amp;&amp;a[<span class="number">1</span>][<span class="number">1</span>]==<span class="number">1</span>&amp;&amp;a[<span class="number">2</span>][<span class="number">0</span>]==<span class="number">1</span>) <span class="keyword">return</span> x+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">0</span>][<span class="number">0</span>]==<span class="number">2</span>&amp;&amp;a[<span class="number">1</span>][<span class="number">1</span>]==<span class="number">2</span>&amp;&amp;a[<span class="number">2</span>][<span class="number">2</span>]==<span class="number">2</span>) <span class="keyword">return</span> -x<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">0</span>][<span class="number">2</span>]==<span class="number">2</span>&amp;&amp;a[<span class="number">1</span>][<span class="number">1</span>]==<span class="number">2</span>&amp;&amp;a[<span class="number">2</span>][<span class="number">0</span>]==<span class="number">2</span>) <span class="keyword">return</span> -x<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//平局 </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-2000</span>;<span class="comment">//棋局未结束 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> dep, <span class="keyword">int</span> lval)</span></span>&#123;</span><br><span class="line"><span class="comment">//dep=0代表先手，1代表后手</span></span><br><span class="line">    <span class="comment">//lval表示如果父亲是先手就是父亲的alpha，否则是父亲的beta</span></span><br><span class="line">    <span class="keyword">int</span> res=check();</span><br><span class="line">    <span class="keyword">if</span>(res!=<span class="number">-2000</span>)<span class="comment">//棋局结束  </span></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">if</span>(dep==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> alpha=<span class="number">-1e9</span>;<span class="comment">//alpha表示先手能找到的最大值</span></span><br><span class="line">        rep(i,<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">            rep(j,<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">                <span class="keyword">if</span>(!a[i][j])&#123;</span><br><span class="line">                    a[i][j]=<span class="number">1</span>;</span><br><span class="line">                    alpha=max(alpha,dfs(dep^<span class="number">1</span>,alpha));</span><br><span class="line">                    a[i][j]=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span>(alpha&gt;lval) <span class="keyword">return</span> alpha;</span><br><span class="line">                    <span class="comment">//如果先手能找到的最大值比后手父亲能找到的最小值还大，后手父亲就肯定不选当前的子树，直接返回进行剪枝</span></span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">return</span> alpha;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> beta=<span class="number">1e9</span>;<span class="comment">//beta表示后手能找到的最小值</span></span><br><span class="line">        rep(i,<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">            rep(j,<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">                <span class="keyword">if</span>(!a[i][j])&#123;</span><br><span class="line">                    a[i][j]=<span class="number">2</span>;</span><br><span class="line">                    beta=min(beta,dfs(dep^<span class="number">1</span>,beta));</span><br><span class="line">                    a[i][j]=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span>(beta&lt;lval) <span class="keyword">return</span> beta;</span><br><span class="line">                    <span class="comment">//反之同理</span></span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">return</span> beta;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> T;<span class="comment">//测试组数 </span></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        rep(i,<span class="number">0</span>,<span class="number">2</span>)<span class="comment">//输入当前棋盘 </span></span><br><span class="line">            rep(j,<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">                <span class="built_in">cin</span>&gt;&gt; a[i][j];</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; dfs(<span class="number">0</span>, <span class="number">1e9</span>)&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p>1. </p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构和算法" scheme="https://Dragonliu2018.github.io/categories/数据结构和算法/"/>
    
    
    <category term="DFS" scheme="https://Dragonliu2018.github.io/tags/DFS/"/>
    
    <category term="BFS" scheme="https://Dragonliu2018.github.io/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="https://dragonliu2018.github.io/2021/04/10/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://dragonliu2018.github.io/2021/04/10/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2021-04-10T00:35:53.000Z</published>
    <updated>2021-09-21T13:41:32.386Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="table-container"><table><thead><tr><th style="text-align:center">排序算法</th><th style="text-align:center">最好时间复杂度</th><th style="text-align:center">平均时间复杂度</th><th style="text-align:center">最坏时间复杂度</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">直接插入排序</td><td style="text-align:center">有序：$O(n)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">逆序：$O(n^2)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">希尔排序</td><td style="text-align:center">复杂度未得到证明</td><td style="text-align:center">$O(n^{1.3-2})$</td><td style="text-align:center">d=1：$O(n^2)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">冒泡排序</td><td style="text-align:center">有序：$O(n)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">逆序：$O(n^2)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">快速排序</td><td style="text-align:center">划分均匀：$O(nlog_2n)$</td><td style="text-align:center">$O(nlog_2n)$</td><td style="text-align:center">有序：$O(n^2)$</td><td style="text-align:center">$O(log_2n\sim n)$</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">简单选择排序</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">堆排序</td><td style="text-align:center">$O(nlog_2n)$</td><td style="text-align:center">$O(nlog_2n)$</td><td style="text-align:center">$O(nlog_2n)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">归并排序</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">$O(nlog_2n)$</td><td style="text-align:center">$O(n)$</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">基数排序</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">$O(d(r+n))$</td><td style="text-align:center">$O(r)$</td><td style="text-align:center">稳定</td></tr></tbody></table></div><h1 id="1-直接插入排序（Insertion-Sort）"><a href="#1-直接插入排序（Insertion-Sort）" class="headerlink" title="1 直接插入排序（Insertion Sort）"></a>1 直接插入排序（Insertion Sort）</h1><p>插入排序的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><p>优化：先用折半查找找到应该插入的位置，再移动元素。</p><h1 id="2-希尔排序（Shell-Sort）"><a href="#2-希尔排序（Shell-Sort）" class="headerlink" title="2 希尔排序（Shell Sort）"></a>2 希尔排序（Shell Sort）</h1><p>先将待排序表分割成若干形如$L[i,i+d,i+2d,…,i+kd]$的特殊子表，对各个子表分别进行直接插入排序。缩小增量d，重复上述过程，直到d=1为止。（希尔本人建议：d初始值为n，然后每次将增量缩小一半）</p><p>适用性：仅适用于顺序表，不适用于链表</p><h1 id="3-冒泡排序（Bubble-Sort）"><a href="#3-冒泡排序（Bubble-Sort）" class="headerlink" title="3 冒泡排序（Bubble Sort）"></a>3 冒泡排序（Bubble Sort）</h1><p><strong>冒泡排序</strong>是一种交换排序，它的思路就是在待排序的数据中，两两比较相邻元素的大小，看是否满足大小顺序的要求，如果满足则不动，如果不满足则让它们互换。然后继续与下一个相邻元素的比较，一直到一次遍历完成。一次遍历的过程就被成为一次冒泡，一次冒泡的结束至少会让一个元素移动到了正确的位置。所以要想让所有元素都排序好，一次冒泡还不行，我们得重复N次去冒泡，这样最终就完成了N个数据的排序过程。</p><p>对一个长度为 $n$ 的排列 $p[i]$ 进行一轮冒泡排序的伪代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i = <span class="number">1</span> to n<span class="number">-1</span>:</span><br><span class="line"><span class="keyword">if</span> p[i] &gt; p[i + <span class="number">1</span>]:</span><br><span class="line">swap(p[i], p[i + <span class="number">1</span>])</span><br></pre></td></tr></table></figure><h1 id="4-快速排序（Quck-Sort）"><a href="#4-快速排序（Quck-Sort）" class="headerlink" title="4 快速排序（Quck Sort）"></a>4 快速排序（Quck Sort）</h1><p>快速排序是一种交换排序，它的思路：在待排序表$L[1…n]$中任取一个元素 pivot 作为枢轴（或基准，通常取首元素），通过一趟排序表划分为独立的两部分$L[1…k-1]$和$L[k+1…n]$，使得$L[1…k-1]$中的所有元素小于 pivot，$L[k+1…n]$中的所有元素大于等于 pivot，则 pivot放在了其最终位置$L[k]$上，这个过程称为一次“划分”。然后分别递归地对两个子表重复上述过程，直至每部分内只有一个元素或空为止，即所有元素放在了其最终位置上。</p><p>若每一次选中的“枢轴”将待排序序列划分为均匀的两个部分，则递归深度最小，算法效率最高。</p><p>优化：</p><ol><li>选头、中、尾、三个位置的元素，取中间值作为枢轴元素；</li><li>随机选一个元素作为枢轴元素。</li></ol><h1 id="5-简单选择排序（Selection-Sort）"><a href="#5-简单选择排序（Selection-Sort）" class="headerlink" title="5 简单选择排序（Selection Sort）"></a>5 简单选择排序（Selection Sort）</h1><p>选择排序：每一趟在待排序元素中选取关键字最小（或最大）的元素加入有序子序列。</p><p>适用性：既可以用于顺序表，也可用于链表</p><h1 id="6-堆排序（Heap-Sort）"><a href="#6-堆排序（Heap-Sort）" class="headerlink" title="6 堆排序（Heap Sort）"></a>6 堆排序（Heap Sort）</h1><p>堆排序是选择排序的一种，思路：每一趟将堆顶元素加入到有序子序列（与待排序序列中的最后一个元素交换），并将待排序元素序列再次调整为大根堆（小元素不断下坠）</p><p><strong>什么是堆？</strong></p><p>若$n$个关键字序列$L[1..n]$满足下面某一条性质，则称为堆（Heap）：</p><ol><li>若满足：$L(i)≥L(2i)$且$L(i)≥L(2i+1)$，$(1 \leq i \leq n / 2)$——大根堆（大顶堆）</li><li>若满足：$L(i)≤L(2i)$且$L(i)≤L(2i+1)$，$(1 \leq i \leq n / 2)$——小根堆（小顶堆）</li></ol><p><strong>建立大根堆</strong>：</p><ol><li>把所有非终端结点都检查一遍，是否满足大根堆的要求，如果不满足则进行调整</li><li>检查当前结点是否满足<code>根节点&gt;=左、右</code>，若不满足，将当前结点与更大的一个孩子互换</li><li>若元素互换破坏了下一级的堆，则采用相同的方法继续往下调整（小元素不断“下坠”）</li></ol><p>建堆$O(n)$，排序$O(nlogn)$</p><p><strong>在堆中插入新元素</strong>：</p><ol><li>对于大根堆，新元素放到表尾，与父结点相比，若新元素比父节点更大，则将二者互换。新元素就这样一路上升，直到无法继续上升。</li></ol><p><strong>在堆中删除元素</strong>：</p><ol><li>被删除元素用堆底元素代替，然后让该元素不断下坠，直到无法下坠为止。</li></ol><h1 id="7-归并排序（Merge-Sort）"><a href="#7-归并排序（Merge-Sort）" class="headerlink" title="7 归并排序（Merge Sort）"></a>7 归并排序（Merge Sort）</h1><p>把两个或多个已经有序的序列合并成一个。</p><p>核心操作：把数组内的两个有序序列归并为一个。</p><h1 id="8-基数排序（Radix-Sort）"><a href="#8-基数排序（Radix-Sort）" class="headerlink" title="8 基数排序（Radix Sort）"></a>8 基数排序（Radix Sort）</h1><p>假设长度为$n$的线性表中每个结点$a$的关键字由$d$元组$\left(k<em>{j}^{d-1}, k</em>{j}^{d-2}, k<em>{j}^{d-3}, \ldots, k</em>{j}^{1}, k<em>{j}^{0}\right)$组成，其中，$0 \leq k</em>{j}^{i} \leq r-1 \quad(0 \leq j&lt;n, 0 \leq i \leq d-1)$，$r$称为基数。</p><p><strong>基数排序得到递减序列的过程如下</strong>：</p><ol><li>初始化：设置$r$个空队列，$Q<em>{r-1}，Q</em>{r-2}…Q_0$</li><li>按照各个关键字位权重递增的次序（个、十、百），对$d$个关键字位分别做“分配”和“收集”</li><li>分配：顺序扫描各个元素，若当前处理的关键字位=x，则将元素插入$Q_x$队尾</li><li>收集：把$Q<em>{r-1}，Q</em>{r-2}…Q_0$各个队列中的结点依次出队并链接</li></ol><p><strong>注意</strong>：</p><ol><li>基数排序不是基于比较的排序算法；基数排序通常基于链式存储实现。</li><li>需要$r$个辅助队列，空间复杂度为$O(r)$，其中$r$为基数；</li><li>一趟分配$O(n)$，一趟收集$O(r)$，总共$d$趟分配、收集，总的时间复杂度=$O(d(n+r))$</li></ol><p><strong>基数排序擅长解决的问题</strong>：</p><ol><li>数据元素的关键字可以方便地拆分成$d$组，且$d$较小；</li><li>每组的关键字的取值范围不大，即$r$较小</li><li>数据元素个数$n$较大</li></ol><h1 id="9-外部排序"><a href="#9-外部排序" class="headerlink" title="9 外部排序"></a>9 外部排序</h1><p><strong>外部排序原理</strong>：</p><p>外部排序：数据元素太多，无法一次全部读入内存进行排序。</p><p>使用归并排序的方法，最少只需在内存中分配3块大小的缓冲区即可对任意一个大文件进行排序。</p><p><strong>步骤</strong>：</p><ol><li>构造初始归并段：归并排序要求各个子序列有序，每次读入两个块的内容，进行内部排序后写回磁盘；</li><li>第一趟归并：将两个归并段归并为一个，缓冲区1/2空了就要立即用归并段1/2的下一块补上</li><li>第二趟归并：与第一趟类似…</li></ol><p><strong>时间开销分析</strong>：</p><ol><li>外部排序时间开销=读写外存时间+内部排序所需时间+内部归并所需时间</li></ol><p><strong>优化</strong>：</p><ol><li>多路归并：采用多路归并可以减少归并趟数，从而减少磁盘I/O(读写)次数</li><li>减少初始归并段数量：生成初始归并段的“内存工作区”越大，初始归并段越长，则可减少初始归并段数量r</li></ol><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> arr[maxn] = &#123;<span class="number">0</span>, <span class="number">53</span>, <span class="number">17</span>, <span class="number">78</span>, <span class="number">9</span>, <span class="number">45</span>, <span class="number">65</span>, <span class="number">87</span>, <span class="number">32</span>&#125;;<span class="comment">//下标从1开始 </span></span><br><span class="line"><span class="keyword">int</span> n;<span class="comment">//数组长度 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//直接插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j, tmp;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">tmp = arr[i];</span><br><span class="line"><span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j] &gt; tmp) &#123;</span><br><span class="line">arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">arr[j + <span class="number">1</span>] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//希尔排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j, tmp, d;</span><br><span class="line"><span class="keyword">for</span> (d = n / <span class="number">2</span>; d &gt;= <span class="number">1</span>; d /= <span class="number">2</span>) &#123;<span class="comment">//增量 </span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> + d; i &lt;= n; i++) &#123;</span><br><span class="line">tmp = arr[i];</span><br><span class="line"><span class="keyword">for</span> (j = i - d; j &gt;= d; j -= d) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j] &gt; tmp) &#123;</span><br><span class="line">arr[j + d] = arr[j];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">arr[j + d] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//冒泡排序 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n - i; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">swap(arr[j], arr[j + <span class="number">1</span>]);</span><br><span class="line">flag = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag == <span class="literal">false</span>) &#123;<span class="comment">//无交换，表已经有序 </span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//快速排序——用arr[low]将子表划分</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> pivot = arr[low];<span class="comment">//第一个元素作为枢轴元素 </span></span><br><span class="line"><span class="keyword">while</span> (low &lt; high) &#123;<span class="comment">//用low、high搜索枢轴的最终位置 </span></span><br><span class="line"><span class="keyword">while</span> (low &lt; high &amp;&amp; arr[high] &gt;= pivot) &#123;</span><br><span class="line">high--;</span><br><span class="line">&#125; </span><br><span class="line">arr[low] = arr[high];<span class="comment">//比枢轴小的元素移动到左边 </span></span><br><span class="line"><span class="keyword">while</span> (low &lt; high &amp;&amp; arr[low] &lt;= pivot) &#123;</span><br><span class="line">low++;</span><br><span class="line">&#125; </span><br><span class="line">arr[high] = arr[low];<span class="comment">//比枢轴大的元素移动到左边 </span></span><br><span class="line">&#125;</span><br><span class="line">arr[low] = pivot;<span class="comment">//枢轴元素存放的最终位置</span></span><br><span class="line"><span class="keyword">return</span> low;<span class="comment">//返回存放枢轴的最终位置 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quck_sort</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line"><span class="keyword">int</span> pivot_pos = partition(low, high);</span><br><span class="line">quck_sort(low, pivot_pos - <span class="number">1</span>);</span><br><span class="line">quck_sort(pivot_pos + <span class="number">1</span>, high);</span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//简单选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">select_sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;<span class="comment">//进行n-1趟 </span></span><br><span class="line"><span class="keyword">int</span> mini = i;<span class="comment">//记录最小元素位置 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++) &#123;<span class="comment">//在arr[i+1...n]中选择最小元素 </span></span><br><span class="line"><span class="keyword">if</span> (arr[j] &lt; arr[mini]) &#123;</span><br><span class="line">mini = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mini != i) &#123;</span><br><span class="line">swap(arr[i], arr[mini]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//堆排序——将以 k 为根的子树调整为大根堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_adjust</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">arr[<span class="number">0</span>] = arr[k];<span class="comment">//arr[0]暂存子树的根节点 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> * k; i &lt;= len; i *= <span class="number">2</span>) &#123;<span class="comment">//沿key较大的子节点向下筛选 </span></span><br><span class="line"><span class="keyword">if</span> (i &lt; len &amp;&amp; arr[i] &lt; arr[i + <span class="number">1</span>]) &#123;<span class="comment">//比较左右孩子结点大小 </span></span><br><span class="line">i++;<span class="comment">//取key较大的子节点下标 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (arr[<span class="number">0</span>] &gt;= arr[i]) &#123;<span class="comment">//筛选结束 </span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">arr[k] = arr[i];<span class="comment">//将arr[i]调整到双亲结点上 </span></span><br><span class="line">k = i;<span class="comment">//修改k，以便继续向下筛选 </span></span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">arr[k] = arr[<span class="number">0</span>];<span class="comment">//被筛选节点的值放入最终位置 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//堆排序——建立大根堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_max_heap</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = len / <span class="number">2</span>; i &gt; <span class="number">0</span>; i--) &#123;<span class="comment">//从后往前调整非终端结点 </span></span><br><span class="line">heap_adjust(i, len);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">build_max_heap(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt; <span class="number">1</span>; i--) &#123;</span><br><span class="line">swap(arr[i], arr[<span class="number">1</span>]);</span><br><span class="line">heap_adjust(<span class="number">1</span>, i - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *b = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));<span class="comment">//辅助数组 </span></span><br><span class="line"><span class="comment">//归并排序——arr[low...mid]与arr[mid+1...high]各自有序，将两者合并</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j, k;</span><br><span class="line"><span class="keyword">for</span> (k = low; k &lt;= high; k++) &#123;<span class="comment">//将arr中所有元素复制到b </span></span><br><span class="line">b[k] = arr[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//合并 </span></span><br><span class="line"><span class="keyword">for</span> (i = low, j = mid + <span class="number">1</span>, k = low; i &lt;= mid &amp;&amp; j &lt;= high; k++) &#123;</span><br><span class="line"><span class="keyword">if</span> (b[i] &lt; b[j]) &#123;</span><br><span class="line">arr[k] = b[i++];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">arr[k] = b[j++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//没有归并完的部分复制到尾部 </span></span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid) arr[k++] = b[i++];</span><br><span class="line"><span class="keyword">while</span> (j &lt;= high) arr[k++] = b[j++]; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;<span class="comment">//从中间拆开 </span></span><br><span class="line">merge_sort(low, mid);<span class="comment">//对左半部分归并排序 </span></span><br><span class="line">merge_sort(mid + <span class="number">1</span>, high);<span class="comment">//对右半部分归并排序 </span></span><br><span class="line">merge(low, mid, high);<span class="comment">//归并 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//cin&gt;&gt; n;</span></span><br><span class="line">n = <span class="number">8</span>;</span><br><span class="line">merge_sort(<span class="number">1</span>, n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; arr[i]&lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><ol><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构和算法" scheme="https://Dragonliu2018.github.io/categories/数据结构和算法/"/>
    
    
  </entry>
  
  <entry>
    <title>欧拉路</title>
    <link href="https://dragonliu2018.github.io/2021/04/10/%E6%AC%A7%E6%8B%89%E8%B7%AF/"/>
    <id>https://dragonliu2018.github.io/2021/04/10/%E6%AC%A7%E6%8B%89%E8%B7%AF/</id>
    <published>2021-04-10T00:35:53.000Z</published>
    <updated>2021-09-21T13:41:24.718Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><ul><li><strong>欧拉回路</strong>：每条边只经过一次，而且回到起点</li><li><strong>欧拉路径</strong>：每条边只经过一次，不要求回到起点  </li><li><strong>欧拉回路判断</strong>：<ul><li><strong>无向图</strong>：连通(不考虑度为 0 的点)，没有奇度顶点</li><li><strong>有向图</strong>：强连通，每个顶点出度等于入度</li><li><strong>混合图(有无向边和有向边)</strong>：首先是基图连通(不考虑度为 0 的点)，然后需要借助网络流判定。<ol><li>首先给原图中的每条无向边随便指定一个方向（称为初始定向），将原图改为有向图 G’，然后的任务就是改变 G’ 中某些边的方向（当然是无向边转化来的，原混合图中的有向边不能动）使其满足每个点的入度等于出度。</li><li>设 $D[i]$ 为 $G’$ 中 (点 $i$ 的出度 - 点 $i $的入度）。可以发现，在改变 $G’$ 中边的方向的过程中，任何点的 $D$ 值的奇偶性都不会发生改变（设将边 $<i, j>$ 改为 $<j, i>$，则 $i $入度加 1 出度减 1，$j$ 入度减 1 出度加 1，两者之差加 2 或减 2，奇偶性不变）！而最终要求的是每个点的入度等于出度，即每个点的 $D$ 值都为 0，是偶数，故可得：若初始定向得到的 $G’$ 中任意一个点的$D$值是奇数，那么原图中一定不存在欧拉环！</j,></i,></li><li>若初始 $D$ 值都是偶数，则将 $G’$ 改装成网络：设立源点 $S$ 和汇点 $T$，对于每个 $D[i]&gt;0$ 的点$i$，连边 $<s, i>$，容量为 $D[i]/2$；对于每个 $D[j]<0$ 的点 $j$，连边 $<j, t>$，容量为 $-D[j]/2$； $G’$中的每条边在网络中仍保留，容量为 1（表示该边最多只能被改变方向一次）。求这个网络的最大流，若 $S$ 引出的所有边均满流，则原混合图是欧拉图，将网络中所有流量为 1 的中间边（就是不与 $S$ 或 $T$关联的边）在 $G’$ 中改变方向，形成的新图 $G”$ 一定是有向欧拉图；若 $S$ 引出的边中有的没有满流，则原混合图不是欧拉图。</0$></s,></li></ol></li></ul></li><li><strong>欧拉路径的判断</strong>：<ul><li><strong>无向图</strong>：连通(不考虑度为 0 的点)，没有奇度顶点或恰有两个奇度顶点</li><li><strong>有向图</strong>：基图连通(把边当成无向边，同样不考虑度为 0 的点)，每个顶点出度等于入度或<br>者有且仅有一个点的出度比入度多 1，有且仅有一个点的出度比入度少 1，其余出度等于入<br>度。</li><li><strong>混合图</strong>：如果存在欧拉回路，一定存在欧拉路径了。否则如果有且仅有两个点的（出度 -入<br>度）是奇数，那么给这个两个点加边，判断是否存在欧拉回路。  </li></ul></li></ul><p><a href="https://blog.csdn.net/richenyunqi/article/details/80382450/" target="_blank" rel="noopener">https://blog.csdn.net/richenyunqi/article/details/80382450/</a></p><h1 id="欧拉路径模板"><a href="#欧拉路径模板" class="headerlink" title="欧拉路径模板"></a>欧拉路径模板</h1><h2 id="1-递归"><a href="#1-递归" class="headerlink" title="1 递归"></a>1 递归</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无向图的欧拉路径</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;graph[maxn],path;<span class="comment">//图、欧拉路径的倒序</span></span><br><span class="line"><span class="keyword">int</span> N, M;<span class="comment">//顶点数、边数</span></span><br><span class="line"><span class="keyword">bool</span> visit[maxn][maxn];<span class="comment">//表示边是否已被访问</span></span><br><span class="line"><span class="comment">//顶点v的度数是否为奇数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">f</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v.size()%<span class="number">2</span>==<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//深度优先遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;graph[v].size();++i)&#123;<span class="comment">//遍历该点能到达的结点</span></span><br><span class="line">        <span class="keyword">int</span> w=graph[v][i];</span><br><span class="line">        <span class="keyword">if</span>(!visit[v][w])&#123;<span class="comment">//该边没有被访问过</span></span><br><span class="line">            visit[v][w]=visit[w][v]=<span class="literal">true</span>;<span class="comment">//该边已被访问</span></span><br><span class="line">            DFS(w);<span class="comment">//递归遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    path.push_back(v);<span class="comment">//加入欧拉路径中</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;M);<span class="comment">//输入点数、边数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;++i)&#123;<span class="comment">//输入边，无向图</span></span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">        graph[a].push_back(b);</span><br><span class="line">        graph[b].push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;++i)<span class="comment">//排序、题目要求输出字典序最小的一种方案</span></span><br><span class="line">        sort(graph[i].begin(),graph[i].end());</span><br><span class="line">    DFS(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> k=count_if(graph+<span class="number">1</span>,graph+N+<span class="number">1</span>,f);<span class="comment">//度数为奇数的顶点个数</span></span><br><span class="line">    <span class="comment">//连通、没有奇度顶点或恰有两个奇度顶点且起点为奇度顶点</span></span><br><span class="line">    <span class="keyword">if</span>(path.size()==M+<span class="number">1</span>&amp;&amp;(k==<span class="number">0</span>||(k==<span class="number">2</span>&amp;&amp;f(graph[<span class="number">1</span>]))))</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=path.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)<span class="comment">//反向输出路径</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,path[i]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-1"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-非递归"><a href="#2-非递归" class="headerlink" title="2 非递归"></a>2 非递归</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无向图的欧拉路径</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;graph[maxn],path;<span class="comment">//图、欧拉路径的倒序</span></span><br><span class="line"><span class="keyword">int</span> N, M;<span class="comment">//顶点数、边数</span></span><br><span class="line"><span class="keyword">bool</span> visit[maxn][maxn];<span class="comment">//表示边是否已被访问</span></span><br><span class="line"><span class="comment">//顶点v的度数是否为奇数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">f</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v.size()%<span class="number">2</span>==<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;M);<span class="comment">//输入点数、边数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;++i)&#123;<span class="comment">//输入边，无向图</span></span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">        graph[a].push_back(b);</span><br><span class="line">        graph[b].push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;++i)<span class="comment">//排序、题目要求输出字典序最小的一种方案</span></span><br><span class="line">        sort(graph[i].begin(),graph[i].end());</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;s;</span><br><span class="line">    s.push(<span class="number">1</span>);<span class="comment">//1号顶点(起点)入栈</span></span><br><span class="line">    <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> v=s.top(),i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;graph[v].size();++i)&#123;<span class="comment">//遍历该点能到达的结点</span></span><br><span class="line">            <span class="keyword">int</span> w=graph[v][i];</span><br><span class="line">            <span class="keyword">if</span>(!visit[v][w])&#123;<span class="comment">//该边没有被访问过</span></span><br><span class="line">                s.push(w);<span class="comment">//顶点w入栈</span></span><br><span class="line">                visit[v][w]=visit[w][v]=<span class="literal">true</span>;<span class="comment">//该边已被访问</span></span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//跳出循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i==graph[v].size())&#123;<span class="comment">//没有还未访问的边</span></span><br><span class="line">            path.push_back(v);<span class="comment">//顶点v加入欧拉序列</span></span><br><span class="line">            s.pop();<span class="comment">//出栈</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k=count_if(graph+<span class="number">1</span>,graph+N+<span class="number">1</span>,f);<span class="comment">//度数为奇数的顶点个数</span></span><br><span class="line">    <span class="comment">//连通、没有奇度顶点或恰有两个奇度顶点且起点为奇度顶点</span></span><br><span class="line">    <span class="keyword">if</span>(path.size()==M+<span class="number">1</span>&amp;&amp;(k==<span class="number">0</span>||(k==<span class="number">2</span>&amp;&amp;f(graph[<span class="number">1</span>]))))</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i=path.rbegin();i!=path.rend();++i)<span class="comment">//倒序输出</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,*i);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-1"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构和算法" scheme="https://Dragonliu2018.github.io/categories/数据结构和算法/"/>
    
    
    <category term="图论" scheme="https://Dragonliu2018.github.io/tags/图论/"/>
    
  </entry>
  
  <entry>
    <title>背包dp</title>
    <link href="https://dragonliu2018.github.io/2021/04/10/%E8%83%8C%E5%8C%85dp/"/>
    <id>https://dragonliu2018.github.io/2021/04/10/%E8%83%8C%E5%8C%85dp/</id>
    <published>2021-04-10T00:35:53.000Z</published>
    <updated>2021-09-21T13:38:42.119Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>转载：<a href="https://www.cnblogs.com/jbelial/articles/2116074.html" target="_blank" rel="noopener">dd大牛的《背包九讲》</a>、<a href="https://www.kancloud.cn/kancloud/pack/70124" target="_blank" rel="noopener">背包问题九讲</a>、<a href="https://zhuanlan.zhihu.com/p/139368825" target="_blank" rel="noopener">知乎转载</a></p></blockquote><h1 id="P01-01背包"><a href="#P01-01背包" class="headerlink" title="P01: 01背包"></a>P01: 01背包</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>有N件物品和一个容量为V的背包。第i件物品的费用/体积是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的体积总和不超过背包容量，且价值总和最大。</p><h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>这是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放。</p><p>用子问题定义状态：即$f[i][v]$表示前i件物品恰放入一个容量为v的背包可以获得的最大价值。则其状态转移方程便是：$f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]}$。</p><p>这个方程非常重要，基本上所有跟背包相关的问题的方程都是由它衍生出来的。所以有必要将它详细解释一下：“将前i件物品放入容量为v的背包中”这个子问题，若只考虑第i件物品的策略（放或不放），那么就可以转化为一个只牵扯前i-1件物品的问题。如果不放第i件物品，那么问题就转化为“前i-1件物品放入容量为v的背包中”；如果放第i件物品，那么问题就转化为“前i-1件物品放入剩下的容量为v-c[i]的背包中”，此时能获得的最大价值就是$f [i-1][v-c[i]]$再加上通过放入第i件物品获得的价值$w[i]$。</p><p>注意$f[i][v]$有意义当且仅当存在一个前i件物品的子集，其费用总和为v。所以按照这个方程递推完毕后，最终的答案并不一定是$f[N] [V]$，而是$f[N][0…V]$的最大值。如果将状态的定义中的“恰”字去掉，在转移方程中就要再加入一项$f[i][v-1]$，这样就可以保证$f[N] [V]$就是最后的答案。</p><h2 id="优化——空间复杂度"><a href="#优化——空间复杂度" class="headerlink" title="优化——空间复杂度"></a>优化——空间复杂度</h2><p>以上方法的时间和空间复杂度均为$O(N*V)$，其中时间复杂度基本已经不能再优化了，但空间复杂度却可以优化到$O(V)$。</p><p>先考虑上面讲的基本思路如何实现，肯定是有一个主循环$i=1…N$，每次算出来二维数组$f[i][0..V]$的所有值。那么，如果只用一个数组$f [0..V]$，能不能保证第$i$次循环结束后$f[v]$中表示的就是我们定义的状态$f[i][v]$呢？$f[i][v]$是由$f[i-1][v]$和$f[i-1] [v-c[i]]$两个子问题递推而来，能否保证在推$f[i][v]$时（也即在第$i$次主循环中推$f[v]$时）能够得到$f[i-1][v]$和$f[i-1][v -c[i]]$的值呢？事实上，这要求在每次主循环中我们以$v=V..0$的顺序推$f[v]$，这样才能保证推$f[v]$时$f[v-c[i]]$保存的是状态$f[i -1][v-c[i]]$的值。伪代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i=<span class="number">1.</span>.N</span><br><span class="line"><span class="keyword">for</span> v=V.<span class="number">.0</span></span><br><span class="line">f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;;</span><br></pre></td></tr></table></figure><p>其中的$f[v]=max{f[v],f[v-c[i]]+w[i]}$一句恰就相当于我们的转移方程$f[i][v]=max{f[i-1][v],f[i- 1][v-c[i]]+w[i]}$，因为现在的$f[v-c[i]]$就相当于原来的$f[i-1][v-c[i]]$。如果将v的循环顺序从上面的逆序改成顺序的话，那么则成了$f[i][v]$由$f[i][v-c[i]]$推知，与本题意不符，但它却是另一个重要的背包问题P02最简捷的解决方案，故学习只用一维数组解01背包问题是十分必要的。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">5</span>;<span class="comment">//物品最大数量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv = <span class="number">1e3</span> + <span class="number">5</span>;<span class="comment">//背包最大体积</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[maxv];<span class="comment">//背包</span></span><br><span class="line"><span class="keyword">int</span> volume[maxn], value[maxn];<span class="comment">//每个物品的体积和价值</span></span><br><span class="line"><span class="keyword">int</span> n, v;<span class="comment">//总物品数、背包体积</span></span><br><span class="line"><span class="comment">//01背包 每种物品仅有一件，可以选择放或不放</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zero_one_park</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> vol)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = v; j &gt;= vol; j--) &#123;</span><br><span class="line">        dp[j] = max(dp[j], dp[j - vol] + val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt; n&gt;&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt; volume[i]&gt;&gt; value[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        zero_one_park(value[i], volume[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; dp[v]&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>01背包问题是最基本的背包问题，它包含了背包问题中设计状态、方程的最基本思想，另外，别的类型的背包问题往往也可以转换成01背包问题求解。故一定要仔细体会上面基本思路的得出方法，状态转移方程的意义，以及最后怎样优化的空间复杂度。</p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol><li><a href="https://www.acwing.com/problem/content/2/" target="_blank" rel="noopener">acwing模板题——01背包问题</a></li></ol><h1 id="P02-完全背包问题"><a href="#P02-完全背包问题" class="headerlink" title="P02: 完全背包问题"></a>P02: 完全背包问题</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</p><h2 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a>基本思路</h2><p>这个问题非常类似于01背包问题，所不同的是每种物品有无限件。也就是从每种物品的角度考虑，与它相关的策略已并非取或不取两种，而是有取0件、取1件、取2件……等很多种。如果仍然按照解01背包时的思路，令$f[i][v]$表示前$i$种物品恰放入一个容量为$v$的背包的最大权值。仍然可以按照每种物品不同的策略写出状态转移方程，像这样：$f[i][v]=max{f[i-1][v-k<em>c[i]]+k</em>w[i]|0&lt;=k<em>c[i]&lt;= v}$。这跟01背包问题一样有$O(N</em>V)$个状态需要求解，但求解每个状态的时间则不是常数了，求解状态$f[i][v]$的时间是$O(v/c[i])$，总的复杂度是超过$O(VN)$的。</p><p>将01背包问题的基本思路加以改进，得到了这样一个清晰的方法。这说明01背包问题的方程的确是很重要，可以推及其它类型的背包问题。但我们还是试图改进这个复杂度。</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="一个简单有效的优化"><a href="#一个简单有效的优化" class="headerlink" title="一个简单有效的优化"></a>一个简单有效的优化</h3><p>完全背包问题有一个很简单有效的优化，是这样的：若两件物品$i、j$满足$c[i]&lt;=c[j]$且$w[i]&gt;=w[j]$，则将物品$j$去掉，不用考虑。这个优化的正确性显然：任何情况下都可将价值小费用高的$j$换成物美价廉的$i$，得到至少不会更差的方案。对于随机生成的数据，这个方法往往会大大减少物品的件数，从而加快速度。然而这个并不能改善最坏情况的复杂度，因为有可能特别设计的数据可以一件物品也去不掉。</p><h3 id="转化为01背包问题求解"><a href="#转化为01背包问题求解" class="headerlink" title="转化为01背包问题求解"></a>转化为01背包问题求解</h3><p>既然01背包问题是最基本的背包问题，那么我们可以考虑把完全背包问题转化为01背包问题来解。最简单的想法是，考虑到第i种物品最多选$V/c [i]$件，于是可以把第$i$种物品转化为$V/c[i]$件费用及价值均不变的物品，然后求解这个01背包问题。这样完全没有改进基本思路的时间复杂度，但这毕竟给了我们将完全背包问题转化为01背包问题的思路：将一种物品拆成多件物品。</p><p>更高效的转化方法是：把第i种物品拆成费用为$c[i]<em>2^k$、价值为$w[i]</em>2^k$的若干件物品，其中$k$满足$c[i]*2^k&lt;V$。这是二进制的思想，因为不管最优策略选几件第$i$种物品，总可以表示成若干个$2^k$件物品的和。这样把每种物品拆成$O(log(V/c[i]))$件物品，是一个很大的改进。但我们有更优的$O(VN)$的算法。 </p><h3 id="O-VN-的算法"><a href="#O-VN-的算法" class="headerlink" title="$O(VN)$的算法"></a>$O(VN)$的算法</h3><p>这个算法使用一维数组，先看伪代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i=<span class="number">1.</span>.N </span><br><span class="line">    <span class="keyword">for</span> v=<span class="number">0.</span>.V </span><br><span class="line">        f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;;</span><br></pre></td></tr></table></figure><p>你会发现，这个伪代码与P01的伪代码只有v的循环次序不同而已。为什么这样一改就可行呢？首先想想为什么P01中要按照$v=V..0$的逆序来循环。这是因为要保证第$i$次循环中的状态$f[i][v]$是由状态$f[i-1][v-c[i]]$递推而来。换句话说，这正是为了保证每件物品只选一次，保证在考虑“选入第$i$件物品”这件策略时，依据的是一个绝无已经选入第$i$件物品的子结果$f[i-1][v-c[i]]$。而现在完全背包的特点恰是每种物品可选无限件，所以在考虑“加选一件第$i$种物品”这种策略时，却正需要一个可能已选入第$i$种物品的子结果$f[i][v-c[i]]$，所以就可以并且必须采用$v= 0..V$的顺序循环。这就是这个简单的程序为何成立的道理。</p><p>这个算法也可以以另外的思路得出。例如，基本思路中的状态转移方程可以等价地变形成这种形式：$f[i][v]=max{f[i-1][v],f[i][v-c[i]]+w[i]}$，将这个方程用一维数组实现，便得到了上面的伪代码。</p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">5</span>;<span class="comment">//物品最大数量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv = <span class="number">1e3</span> + <span class="number">5</span>;<span class="comment">//背包最大体积</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[maxv];<span class="comment">//背包</span></span><br><span class="line"><span class="keyword">int</span> volume[maxn], value[maxn];<span class="comment">//每个物品的体积和价值</span></span><br><span class="line"><span class="keyword">int</span> n, v;<span class="comment">//总物品数、背包体积</span></span><br><span class="line"><span class="comment">//完全背包 每种物品都有无限件可用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">complete_park</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> vol)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = vol; j &lt;= v; j++) &#123;</span><br><span class="line">        dp[j] = max(dp[j], dp[j - vol] + val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt; n&gt;&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt; volume[i]&gt;&gt; value[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        complete_park(value[i], volume[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; dp[v]&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>完全背包问题也是一个相当基础的背包问题，它有两个状态转移方程，分别在“基本思路”以及“O(VN)的算法“的小节中给出。希望你能够对这两个状态转移方程都仔细地体会，不仅记住，也要弄明白它们是怎么得出来的，最好能够自己想一种得到这些方程的方法。事实上，对每一道动态规划题目都思考其方程的意义以及如何得来，是加深对动态规划的理解、提高动态规划功力的好方法。</p><h2 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h2><ol><li><a href="https://www.acwing.com/problem/content/3/" target="_blank" rel="noopener">acwing模板题——完全背包问题</a></li></ol><h1 id="P03-多重背包问题"><a href="#P03-多重背包问题" class="headerlink" title="P03: 多重背包问题"></a>P03: 多重背包问题</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>有N种物品和一个容量为V的背包。第i种物品最多有n[i]件可用，每件费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</p><h2 id="基本思路-2"><a href="#基本思路-2" class="headerlink" title="基本思路"></a>基本思路</h2><p>这题目和完全背包问题很类似。基本的方程只需将完全背包问题的方程略微一改即可，因为对于第$i$种物品有$n[i]+1$种策略：取0件，取1件……取 $n[i]$件。令$f[i][v]$表示前$i$种物品恰放入一个容量为$v$的背包的最大权值，则：$f[i][v]=max{f[i-1][v-k<em>c[i]]+ k</em>w[i]|0&lt;=k&lt;=n[i]}$。复杂度是$O(V*∑n[i])$。</p><h2 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h2><h3 id="转化为01背包问题"><a href="#转化为01背包问题" class="headerlink" title="转化为01背包问题"></a>转化为01背包问题</h3><p>另一种好想好写的基本方法是转化为01背包求解：把第$i$种物品换成$n[i]$件01背包中的物品，则得到了物品数为$∑n[i]$的01背包问题，直接求解，复杂度仍然是$O(V*∑n[i])$。</p><p>但是我们期望将它转化为01背包问题之后能够像完全背包一样降低复杂度。仍然考虑二进制的思想，我们考虑把第$i$种物品换成若干件物品，使得原问题中第i种物品可取的每种策略——取$0..n[i]$件——均能等价于取若干件代换以后的物品。另外，取超过$n[i]$件的策略必不能出现。</p><p>方法是：将第$i$种物品分成若干件物品，其中每件物品有一个系数，这件物品的费用和价值均是原来的费用和价值乘以这个系数。使这些系数分别为 $1,2,4,…,2^{k-1},n[i]-2^k+1$，且$k$是满足$n[i]-2^k+1&gt;0$的最大整数。例如，如果$n[i]$为$13$，就将这种物品分成系数分别为$1,2,4,6$的四件物品。</p><p>分成的这几件物品的系数和为$n[i]$，表明不可能取多于$n[i]$件的第i种物品。另外这种方法也能保证对于$0..n[i]$间的每一个整数，均可以用若干个系数的和表示，这个证明可以分$0..2^{k-1}$和$2^k..n[i]$两段来分别讨论得出，并不难，希望你自己思考尝试一下。</p><p>这样就将第$i$种物品分成了$O(log n[i])$种物品，将原问题转化为了复杂度为$O(V*∑log n[i])$的01背包问题，是很大的改进。</p><h3 id="O-VN-的算法-1"><a href="#O-VN-的算法-1" class="headerlink" title="* $O(VN)$的算法"></a>* $O(VN)$的算法</h3><p>多重背包问题同样有$O(VN)$的算法。这个算法基于基本算法的状态转移方程，但应用单调队列的方法使每个状态的值可以以均摊$O(1)$的时间求解。由于用单调队列优化的DP已超出了NOIP的范围，故本文不再展开讲解。我最初了解到这个方法是在楼天成的“男人八题”幻灯片上。</p><h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">5</span>;<span class="comment">//物品最大数量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv = <span class="number">1e3</span> + <span class="number">5</span>;<span class="comment">//背包最大体积</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[maxv];<span class="comment">//背包</span></span><br><span class="line"><span class="keyword">int</span> volume[maxn], value[maxn], c[maxn];<span class="comment">//每个物品的体积和价值、数量</span></span><br><span class="line"><span class="keyword">int</span> n, v;<span class="comment">//总物品数、背包体积</span></span><br><span class="line"><span class="comment">//01背包 每种物品仅有一件，可以选择放或不放</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zero_one_park</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> vol)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = v; j &gt;= vol; j--) &#123;</span><br><span class="line">        dp[j] = max(dp[j], dp[j - vol] + val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//完全背包 每种物品都有无限件可用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">complete_park</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> vol)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = vol; j &lt;= v; j++) &#123;</span><br><span class="line">        dp[j] = max(dp[j], dp[j - vol] + val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//多重背包 每种物品都有限件可用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multiple_park</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> vol, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vol * amount &gt;= v) &#123;<span class="comment">//该种物品足以装满背包，转化为完全背包</span></span><br><span class="line">        complete_park(val, vol);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//转化为01背包，将第i种物品分成若干件物品</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; amount) &#123;</span><br><span class="line">            zero_one_park(k * val, k * vol);</span><br><span class="line">            amount -= k;</span><br><span class="line">            k &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (amount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            zero_one_park(amount * val, amount * vol);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt; n&gt;&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt; volume[i]&gt;&gt; value[i]&gt;&gt; c[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        multiple_park(value[i], volume[i], c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; dp[v]&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><p>这里我们看到了将一个算法的复杂度由$O(V<em>∑n[i])$改进到$O(V</em>∑log n[i])$的过程，还知道了存在应用超出NOIP范围的知识的O(VN)算法。希望你特别注意“拆分物品”的思想和方法，自己证明一下它的正确性，并用尽量简洁的程序来实现。</p><h2 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h2><ol><li><a href="https://www.acwing.com/problem/content/4/" target="_blank" rel="noopener">acwing模板题——多重背包问题 I</a></li><li><a href="https://www.acwing.com/problem/content/5/" target="_blank" rel="noopener">acwing模板题——多重背包问题 II</a>：本题考查多重背包的二进制优化方法。</li></ol><h1 id="P04-混合三种背包问题"><a href="#P04-混合三种背包问题" class="headerlink" title="P04: 混合三种背包问题"></a>P04: 混合三种背包问题</h1><h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h2><p>如果将P01、P02、P03混合起来。也就是说，有的物品只可以取一次（01背包），有的物品可以取无限次（完全背包），有的物品可以取的次数有一个上限（多重背包）。应该怎么求解呢？</p><h2 id="01背包与完全背包的混合"><a href="#01背包与完全背包的混合" class="headerlink" title="01背包与完全背包的混合"></a>01背包与完全背包的混合</h2><p>考虑到在P01和P02中最后给出的伪代码只有一处不同，故如果只有两类物品：一类物品只能取一次，另一类物品可以取无限次，那么只需在对每个物品应用转移方程时，根据物品的类别选用顺序或逆序的循环即可，复杂度是$O(VN)$。伪代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i=<span class="number">1.</span>.N</span><br><span class="line"><span class="keyword">if</span> 第i件物品是<span class="number">01</span>背包</span><br><span class="line"><span class="keyword">for</span> v=V.<span class="number">.0</span></span><br><span class="line">f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> 第i件物品是完全背包</span><br><span class="line"><span class="keyword">for</span> v=<span class="number">0.</span>.V</span><br><span class="line">f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;;</span><br></pre></td></tr></table></figure><h2 id="再加上多重背包"><a href="#再加上多重背包" class="headerlink" title="再加上多重背包"></a>再加上多重背包</h2><p>如果再加上有的物品最多可以取有限次，那么原则上也可以给出$O(VN)$的解法：遇到多重背包类型的物品用单调队列解即可。但如果不考虑超过NOIP范围的算法的话，用P03中将每个这类物品分成$O(log n[i])$个01背包的物品的方法也已经很优了。</p><h2 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h2><p>有人说，困难的题目都是由简单的题目叠加而来的。这句话是否公理暂且存之不论，但它在本讲中已经得到了充分的体现。本来01背包、完全背包、多重背包都不是什么难题，但将它们简单地组合起来以后就得到了这样一道一定能吓倒不少人的题目。但只要基础扎实，领会三种基本背包问题的思想，就可以做到把困难的题目拆分成简单的题目来解决。</p><h2 id="练习-3"><a href="#练习-3" class="headerlink" title="练习"></a>练习</h2><ol><li><a href="acwing.com/problem/content/7/">acwing模板题——混合背包问题</a></li></ol><h1 id="P05-二维费用的背包问题"><a href="#P05-二维费用的背包问题" class="headerlink" title="P05: 二维费用的背包问题"></a>P05: 二维费用的背包问题</h1><h2 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h2><p>二维费用的背包问题是指：对于每件物品，具有两种不同的费用；选择这件物品必须同时付出这两种代价；对于每种代价都有一个可付出的最大值（背包容量）。问怎样选择物品可以得到最大的价值。设这两种代价分别为代价1和代价2，第i件物品所需的两种代价分别为$a[i]$和$b[i]$。两种代价可付出的最大值（两种背包容量）分别为$V$和$U$。物品的价值为$w[i]$。</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>费用加了一维，只需状态也加一维即可。设$f[i][v][u]$表示前$i$件物品付出两种代价分别为$v$和$u$时可获得的最大价值。状态转移方程就是：$f [i][v][u]=max{f[i-1][v][u],f[i-1][v-a[i]][u-b[i]]+w[i]}$。如前述方法，可以只使用二维的数组：当每件物品只可以取一次时变量$v$和$u$采用逆序的循环，当物品有如完全背包问题时采用顺序的循环。当物品有如多重背包问题时拆分物品。</p><h2 id="物品总个数的限制"><a href="#物品总个数的限制" class="headerlink" title="物品总个数的限制"></a>物品总个数的限制</h2><p>有时，“二维费用”的条件是以这样一种隐含的方式给出的：最多只能取$M$件物品。这事实上相当于每件物品多了一种“件数”的费用，每个物品的件数费用均为$1$，可以付出的最大件数费用为$M$。换句话说，设$f[v][m]$表示付出费用$v$、最多选$m$件时可得到的最大价值，则根据物品的类型（01、完全、多重）用不同的方法循环更新，最后在$f[0..V][0..M]$范围内寻找答案。</p><p>另外，如果要求“恰取M件物品”，则在$f[0..V][M]$范围内寻找答案。</p><h2 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">5</span>;<span class="comment">//物品最大数量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv = <span class="number">1e2</span> + <span class="number">5</span>;<span class="comment">//背包最大体积</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxw = <span class="number">1e2</span> + <span class="number">5</span>;<span class="comment">//背包最大承受重量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[maxv][maxw];<span class="comment">//背包</span></span><br><span class="line"><span class="keyword">int</span> volume[maxn], value[maxn], weight[maxn];<span class="comment">//每个物品的体积和价值、重量</span></span><br><span class="line"><span class="keyword">int</span> n, v, w;<span class="comment">//总物品数、背包体积、背包承受重量</span></span><br><span class="line"><span class="comment">//二维01背包</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">two_dimension_park</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> wei, <span class="keyword">int</span> vol)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = v; j &gt;= vol; j--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = w; k &gt;= wei; k--) &#123;</span><br><span class="line">            dp[j][k] = max(dp[j][k], dp[j - vol][k - wei] + val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt; n&gt;&gt; v&gt;&gt; w;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt; volume[i]&gt;&gt; weight[i]&gt;&gt; value[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        two_dimension_park(value[i], weight[i],volume[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; dp[v][w]&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h2><p>事实上，当发现由熟悉的动态规划题目变形得来的题目时，在原来的状态中加一维以满足新的限制是一种比较通用的方法。希望你能从本讲中初步体会到这种方法。</p><h2 id="练习-4"><a href="#练习-4" class="headerlink" title="练习"></a>练习</h2><ol><li><a href="https://www.acwing.com/problem/content/8/" target="_blank" rel="noopener">acwing模板题——二维费用的背包问题</a></li></ol><h1 id="P06-分组背包问题"><a href="#P06-分组背包问题" class="headerlink" title="P06: 分组背包问题"></a>P06: 分组背包问题</h1><h2 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h2><p>有$N$件物品和一个容量为$V$的背包。第$i$件物品的费用是$c[i]$，价值是$w[i]$。这些物品被划分为若干组，每组中的物品互相冲突，最多选一件。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</p><h2 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h2><p>这个问题变成了每组物品有若干种策略：是选择本组的某一件，还是一件都不选。也就是说设$f[k][v]$表示前$k$组物品花费费用$v$能取得的最大权值，则有$f[k][v]=max{f[k-1][v],f[k-1][v-c[i]]+w[i]|物品i属于第k组}$。</p><p>使用一维数组的伪代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 所有的组k</span><br><span class="line">    <span class="keyword">for</span> v=V.<span class="number">.0</span></span><br><span class="line">        <span class="keyword">for</span> 所有的i属于组k</span><br><span class="line">            f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;</span><br></pre></td></tr></table></figure><p>注意这里的三层循环的顺序，“for v=V..0”这一层循环必须在“for 所有的i属于组k”之外。这样才能保证每一组内的物品最多只有一个会被添加到背包中。</p><p>另外，显然可以对每组中的物品应用P02中“一个简单有效的优化”。</p><h2 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e2</span> + <span class="number">5</span>;<span class="comment">//物品最大数量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv = <span class="number">1e2</span> + <span class="number">5</span>;<span class="comment">//背包最大体积</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[maxv];<span class="comment">//背包</span></span><br><span class="line"><span class="keyword">int</span> volume[maxn], value[maxn];<span class="comment">//每个物品的体积和价值</span></span><br><span class="line"><span class="keyword">int</span> n, v;<span class="comment">//物品组数、背包体积</span></span><br><span class="line"><span class="comment">//分组背包 物品被划分为若干组，每组最多选一件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">group_park</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> vol)</span> </span>&#123;<span class="comment">//物品组数、背包最大容量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t;<span class="comment">//每组的个数</span></span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt; t;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; i++) &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt; volume[i]&gt;&gt; value[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从前k组中选</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = vol; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= t; l++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (volume[l] &lt;= j) &#123;</span><br><span class="line">                    dp[j] = max(dp[j], dp[j - volume[l]] + value[l]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt; n&gt;&gt; v;</span><br><span class="line">    group_park(n, v);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; dp[v]&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h2><p>分组的背包问题将彼此互斥的若干物品称为一个组，这建立了一个很好的模型。不少背包问题的变形都可以转化为分组的背包问题（例如P07），由分组的背包问题进一步可定义“泛化物品”的概念，十分有利于解题。</p><h2 id="练习-5"><a href="#练习-5" class="headerlink" title="练习"></a>练习</h2><ol><li><a href="acwing.com/problem/content/9/">acwing模板题——分组背包问题</a></li><li><a href="https://ac.nowcoder.com/acm/problem/14602" target="_blank" rel="noopener">牛客——xinjun与阴阳师</a></li></ol><h1 id="P07-有依赖的背包问题"><a href="#P07-有依赖的背包问题" class="headerlink" title="* P07: 有依赖的背包问题"></a>* P07: 有依赖的背包问题</h1><h2 id="简化的问题"><a href="#简化的问题" class="headerlink" title="简化的问题"></a>简化的问题</h2><p>这种背包问题的物品间存在某种“依赖”的关系。也就是说，$i$依赖于$j$，表示若选物品$i$，则必须选物品$j$。为了简化起见，我们先设没有某个物品既依赖于别的物品，又被别的物品所依赖；另外，没有某件物品同时依赖多件物品。</p><h2 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h2><p>这个问题由NOIP2006金明的预算方案一题扩展而来。遵从该题的提法，将不依赖于别的物品的物品称为“主件”，依赖于某主件的物品称为“附件”。由这个问题的简化条件可知所有的物品由若干主件和依赖于每个主件的一个附件集合组成。</p><p>按照背包问题的一般思路，仅考虑一个主件和它的附件集合。可是，可用的策略非常多，包括：一个也不选，仅选择主件，选择主件后再选择一个附件，选择主件后再选择两个附件……无法用状态转移方程来表示如此多的策略。（事实上，设有$n$个附件，则策略有$2^n+1$个，为指数级）</p><p>考虑到所有这些策略都是互斥的（也就是说，你只能选择一种策略），所以一个主件和它的附件集合实际上对应于 P06 中的一个物品组，每个选择了主件又选择了若干个附件的策略对应于这个物品组中的一个物品，其费用和价值都是这个策略中的物品的值的和。但仅仅是这一步转化并不能给出一个好的算法，因为物品组中的物品还是像原问题的策略一样多。</p><p>再考虑P06中的一句话： <em>可以对每组中的物品应用P02中“一个简单有效的优化”</em>。 这提示我们，对于一个物品组中的物品，所有费用相同的物品只留一个价值最大的，不影响结果。所以，我们可以对主件$i$的“附件集合”先进行一次01背包，得到费用依次为$0..V-c[i]$所有这些值时相应的最大价值$f’[0..V-c[i]]$。那么这个主件及它的附件集合相当于$V-c[i]+1$个物品的物品组，其中费用为$c[i]+k$的物品的价值为$f’[k]+w[i]$。也就是说原来指数级的策略中有很多策略都是冗余的，通过一次01背包后，将主件$i$转化为$V-c[i]+1$个物品的物品组，就可以直接应用P06的算法解决问题了。</p><h2 id="较一般的问题"><a href="#较一般的问题" class="headerlink" title="较一般的问题"></a>较一般的问题</h2><p>更一般的问题是：依赖关系以图论中“森林”的形式给出（森林即多叉树的集合），也就是说，主件的附件仍然可以具有自己的附件集合，限制只是每个物品最多只依赖于一个物品（只有一个主件）且不出现循环依赖。</p><p>解决这个问题仍然可以用将每个主件及其附件集合转化为物品组的方式。唯一不同的是，由于附件可能还有附件，就不能将每个附件都看作一个一般的01背包中的物品了。若这个附件也有附件集合，则它必定要被先转化为物品组，然后用分组的背包问题解出主件及其附件集合所对应的附件组中各个费用的附件所对应的价值。</p><p>事实上，这是一种树形DP，其特点是每个父节点都需要对它的各个儿子的属性进行一次DP以求得自己的相关属性。这已经触及到了“泛化物品”的思想。看完P08后，你会发现这个“依赖关系树”每一个子树都等价于一件泛化物品，求某节点为根的子树对应的泛化物品相当于求其所有儿子的对应的泛化物品之和。</p><h2 id="具体思路"><a href="#具体思路" class="headerlink" title="具体思路"></a>具体思路</h2><p>dfs在遍历到 $x$ 结点时，先考虑一定选上根节点 $x$ ，因此初始化 $f[x][v[x]…m] = w[x]$<br>在分组背包部分：<br>$j$ 的范围 $[ m , v[x] ] $小于$v[x]$则没有意义因为连根结点都放不下；<br>$k$的范围$ [ 0 , j-v[x] ]$，当大于$j-v[x]$时分给该子树的容量过多，剩余的容量连根节点的物品都放不下了；</p><h2 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">5</span>;<span class="comment">//物品最大数量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv = <span class="number">1e2</span> + <span class="number">5</span>;<span class="comment">//背包最大体积</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxv];<span class="comment">//dp[x][v]表达选择以x为子树的物品，在容量不超过v时所获得的最大价值</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tree[maxn];<span class="comment">//树，存放依赖关系</span></span><br><span class="line"><span class="keyword">int</span> volume[maxn], value[maxn];<span class="comment">//每个物品的体积和价值</span></span><br><span class="line"><span class="keyword">int</span> n, v, root;<span class="comment">//总物品数、背包容量、树根结点</span></span><br><span class="line"><span class="comment">//有依赖的背包</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = volume[x]; i &lt;= v; i++) dp[x][i] = value[x];<span class="comment">//点x必须选，所以初始化dp[x][value[x] ~ v]= value[x]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tree[x].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> son = tree[x][i];</span><br><span class="line">        dfs(son);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = v; j &gt;= volume[x]; j--) &#123;<span class="comment">//j的范围为value[x]~v, 小于value[x]无法选择以x为子树的物品</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= j - volume[x]; k++) &#123;<span class="comment">//分给子树son的空间不能大于j-value[x],不然都无法选根物品x</span></span><br><span class="line">                dp[x][j] = max(dp[x][j], dp[x][j - k] + dp[son][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt; n&gt;&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> fa;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt; volume[i]&gt;&gt; value[i]&gt;&gt; fa;</span><br><span class="line">        <span class="keyword">if</span> (fa == <span class="number">-1</span>)</span><br><span class="line">            root = i;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tree[fa].push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; dp[root][v];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h2><p>NOIP2006的那道背包问题我做得很失败，写了上百行的代码，却一分未得。后来我通过思考发现通过引入“物品组”和“依赖”的概念可以加深对这题的理解，还可以解决它的推广问题。用物品组的思想考虑那题中极其特殊的依赖关系：物品不能既作主件又作附件，每个主件最多有两个附件，可以发现一个主件和它的两个附件等价于一个由四个物品组成的物品组，这便揭示了问题的某种本质。</p><p>我想说：失败不是什么丢人的事情，从失败中全无收获才是。</p><h2 id="练习-6"><a href="#练习-6" class="headerlink" title="练习"></a>练习</h2><ol><li><a href="https://www.acwing.com/problem/content/10/" target="_blank" rel="noopener">acwing模板题——有依赖的背包问题</a></li></ol><h1 id="P08-泛化物品"><a href="#P08-泛化物品" class="headerlink" title="* P08: 泛化物品"></a>* P08: 泛化物品</h1><h2 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h2><h2 id="算法-3"><a href="#算法-3" class="headerlink" title="算法"></a>算法</h2><h2 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h2><h2 id="练习-7"><a href="#练习-7" class="headerlink" title="练习"></a>练习</h2><h1 id="P09-背包问题问法的变化"><a href="#P09-背包问题问法的变化" class="headerlink" title="P09: 背包问题问法的变化"></a>P09: 背包问题问法的变化</h1><h2 id="输出方案"><a href="#输出方案" class="headerlink" title="输出方案"></a>输出方案</h2><h2 id="输出字典序最小的最优方案"><a href="#输出字典序最小的最优方案" class="headerlink" title="输出字典序最小的最优方案"></a>输出字典序最小的最优方案</h2><p>这里“字典序最小”的意思是$1…N$号物品的选择方案排列出来以后字典序最小。以输出01背包最小字典序的方案为例。</p><p>题目要求输出字典序最小的解，假设存在一个包含第1个物品的最优解，为了确保字典序最小那么我们必然要选第一个。那么问题就转化成从$2～N$这些物品中找到最优解。之前的$f(i,j)$记录的都是前$i$个物品总容量为$j$的最优解，那么我们现在将$f(i,j)$定义为从第$i$个元素到最后一个元素总容量为$j$的最优解。接下来考虑状态转移：</p><p>$f(i,j)=max{f(i+1,j),f(i+1,j−v[i])+w[i]}$<br>两种情况，第一种是不选第$i$个物品，那么最优解等同于从第$i+1$个物品到最后一个元素总容量为$j$的最优解；第二种是选了第$i$个物品，那么最优解等于当前物品的价值$w[i]$加上从第$i+1$个物品到最后一个元素总容量为$j−v[i]$的最优解。</p><p>计算完状态表示后，考虑如何的到最小字典序的解。首先$f(1,m)$肯定是最大价值，那么我们便开始考虑能否选取第1个物品呢。</p><p>如果$f(1,m)=f(2,m−v[1])+w[1]$，说明选取了第1个物品可以得到最优解。</p><p>如果$f(1,m)=f(2,m)$，说明不选取第一个物品才能得到最优解。</p><p>如果$f(1,m)=f(2,m)=f(2,m−v[1])+w[1]$，说明选不选都可以得到最优解，但是为了考虑字典序最小，我们也需要选取该物品。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">5</span>;<span class="comment">//物品最大数量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv = <span class="number">1e3</span> + <span class="number">5</span>;<span class="comment">//背包最大体积</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxv];<span class="comment">//从第i个元素到最后一个元素总容量为j的最优解</span></span><br><span class="line"><span class="keyword">int</span> volume[maxn], value[maxn];<span class="comment">//每个物品的体积和价值</span></span><br><span class="line"><span class="keyword">int</span> n, v;<span class="comment">//总物品数、背包体积</span></span><br><span class="line"><span class="comment">//01背包 每种物品仅有一件，可以选择放或不放</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">optimal_park</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> vol, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= v; j++) &#123;</span><br><span class="line">        dp[i][j] = dp[i + <span class="number">1</span>][j];</span><br><span class="line">        <span class="keyword">if</span>(j &gt;= vol)</span><br><span class="line">            dp[i][j] = max(dp[i][j], dp[i + <span class="number">1</span>][j - vol] + val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt; n&gt;&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt; volume[i]&gt;&gt; value[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        optimal_park(value[i], volume[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出</span></span><br><span class="line">    <span class="keyword">int</span> cur_v = v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++) &#123;   </span><br><span class="line">        <span class="keyword">if</span> (i == n &amp;&amp; cur_v &gt;= volume[i]) &#123;<span class="comment">//如果是最后一个元素，特判一下，防止越界即可</span></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt; i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur_v &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//判断下标是否越界</span></span><br><span class="line">        <span class="keyword">if</span> (cur_v - volume[i]&gt;=<span class="number">0</span> &amp;&amp; dp[i][cur_v] == dp[i + <span class="number">1</span>][cur_v - volume[i]] + value[i]) &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt; i&lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            cur_v = cur_v - volume[i];<span class="comment">//选了第i个物品，剩余容量就要减小。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求方案总数"><a href="#求方案总数" class="headerlink" title="求方案总数"></a>求方案总数</h2><h2 id="最优方案的总数"><a href="#最优方案的总数" class="headerlink" title="最优方案的总数"></a>最优方案的总数</h2><p>这里的最优方案是指物品总价值最大的方案。以01背包为例。</p><p>时间复杂度 $O(nm)$<br>定义两个数组：$f[maxv]$，$cnt[maxv]$：$f[i]$ 用来存储背包容积为 $i$ 时的最佳方案的总价值，$cnt[i]$为背包容积为 $i$ 时总价值为最佳的方案数。</p><p>先初始化所有的 $cnt[i]$ 为 1，因为背包里什么也不装也是一种方案。</p><p>外层循环 $n$ 次，每次读入新物品的 $v,w$</p><p>求出装新物品时的总价值，与不装新物品时作对比</p><p>如果装新物品的方案总价值更大，那么用 $f[j−v]+w$ 来更新 $f[j]$，用 $cnt[j−v]$ 更新 $cnt[j]$<br>如果总价值相等，那么最大价值的方案数就多了 $cnt[j−v]$ 种。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">5</span>;<span class="comment">//物品最大数量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv = <span class="number">1e3</span> + <span class="number">5</span>;<span class="comment">//背包最大体积</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod  = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[maxv], cnt[maxv];<span class="comment">//背包，最优方案总数</span></span><br><span class="line"><span class="keyword">int</span> volume[maxn], value[maxn];<span class="comment">//每个物品的体积和价值</span></span><br><span class="line"><span class="keyword">int</span> n, v;<span class="comment">//总物品数、背包体积</span></span><br><span class="line"><span class="comment">//01背包 求解最优方案总数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">optimal_sum_park</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> vol)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = v; j &gt;= vol; j--) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = dp[j - vol] + val;</span><br><span class="line">        <span class="keyword">if</span> (tmp &gt; dp[j]) &#123;</span><br><span class="line">            dp[j] = tmp;</span><br><span class="line">            cnt[j] = cnt[j - vol];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tmp == dp[j]) &#123;</span><br><span class="line">            cnt[j] = (cnt[j] + cnt[j - vol]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt; n&gt;&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt; volume[i]&gt;&gt; value[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= v; i++) &#123;</span><br><span class="line">        cnt[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        optimal_sum_park(value[i], volume[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; cnt[v]&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结-8"><a href="#小结-8" class="headerlink" title="小结"></a>小结</h2><p>显然，这里不可能穷尽背包类动态规划问题所有的问法。甚至还存在一类将背包类动态规划问题与其它领域（例如数论、图论）结合起来的问题，在这篇论背包问题的专文中也不会论及。但只要深刻领会前述所有类别的背包问题的思路和状态转移方程，遇到其它的变形问法，只要题目难度还属于NOIP，应该也不难想出算法。</p><p>触类旁通、举一反三，应该也是一个OIer应有的品质吧。</p><h2 id="练习-8"><a href="#练习-8" class="headerlink" title="练习"></a>练习</h2><ol><li><a href="https://www.acwing.com/problem/content/11/" target="_blank" rel="noopener">acwing模板题——背包问题求方案数</a></li><li><a href></a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构和算法" scheme="https://Dragonliu2018.github.io/categories/数据结构和算法/"/>
    
    
    <category term="dp" scheme="https://Dragonliu2018.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>最短路</title>
    <link href="https://dragonliu2018.github.io/2021/04/09/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    <id>https://dragonliu2018.github.io/2021/04/09/%E6%9C%80%E7%9F%AD%E8%B7%AF/</id>
    <published>2021-04-09T11:06:45.000Z</published>
    <updated>2021-09-21T13:42:35.580Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>　　最短路问题分为两类：<strong>单源最短路</strong>和<strong>多源最短路</strong>。前者只需要求一个<strong>固定的起点</strong>到各个顶点的最短路径，后者则要求得出<strong>任意两个顶点</strong>之间的最短路径。</p><ul><li><strong>单源 Dijkstra算法</strong>：<ul><li><strong>优点</strong>：时间复杂度稳定$O(n^2)$，堆优化能达到$O(ElogE)$；也可解决多源最短路，总的时间复杂度也是$O(n^3)$</li><li><strong>缺点</strong>：不能处理负边</li></ul></li><li><strong>单源 Bellman-Ford算法</strong>：<ul><li><strong>优点</strong>：其优于Dijkstra算法的方面是边的权值可以为负数、实现简单</li><li><strong>缺点</strong>：时间复杂度过高，高达$O(V*E)$；但算法可以进行若干种优化，提高了效率。</li></ul></li><li><strong>单源 SPFA算法</strong>：<ul><li><strong>优点</strong>：快于Bellman-Ford，据说随机数据下期望时间复杂度是$O(m+nlogn)$</li><li><strong>缺点</strong>：时间复杂度<strong>不稳定</strong>，最坏情况可以被卡成Bellman-Ford，也就是$O(V*E)$</li></ul></li><li><strong>全源 Floyd算法</strong>：<ul><li><strong>优点</strong>：算法简洁，可以解决负权图</li><li><strong>缺点</strong>：时间复杂度为$O(n^3)$，空间复杂度为$O(n^2)$，都比较高，所以只适用于数据规模较小的情形；不能解决负环图</li></ul></li><li><strong>全源 Johnson算法</strong>：<ul><li><strong>优点</strong>：相对于Floyd算法时间复杂度低，$O(nmlogm)$；</li><li><strong>缺点</strong>：无负环图、算法较繁琐</li></ul></li><li><strong>BFS算法</strong>：<ul><li><strong>优点</strong>：</li><li><strong>缺点</strong>：只能解决无权图</li></ul></li></ul><h1 id="1-单源-Dijkstra算法"><a href="#1-单源-Dijkstra算法" class="headerlink" title="1 单源 Dijkstra算法"></a>1 单源 Dijkstra算法</h1><p><strong>贪心</strong>的思想，不断取出<strong>离顶点最近</strong>而<strong>没有被访问过</strong>的点，松弛它和它能到达的所有点。</p><blockquote><p>对于每个顶点v∈V，都设置一个属性d[v]，用来描述从源点s到v的最短路径上权值的上界，称为最短路径估计（shortest-pathestimate）。</p><p>π[v]代表S到v的当前最短路径中v点之前的一个点的编号,我们用下面的Θ(V)时间的过程来对最短路径估计和前趋进行初始化。</p><p>在松弛一条边(u,v)的过程中，要测试是否可以通过u，对迄今找到的v的最短路径进行改进；如果可以改进的话，则更新d[v]和π[v]。一次松弛操作可以减小最短路径估计的值d[v]，并更新v的前趋域$π[v]$(S到v的当前最短路径中v点之前的一个点的编号)。</p></blockquote><p><strong>打印路径</strong>：只需要用一个pre[]数组存储每个点的<strong>父节点</strong>即可。（单源最短路的起点是固定的，所以每条路有且仅有一个祖先节点，一步步溯源上去的路径是唯一的。相反，这里不能存<strong>子节点</strong>，因为从源点下去，有很多条最短路径）</p><p>参考：<a href="https://zhuanlan.zhihu.com/p/96621396" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/96621396</a></p><p><strong>朴素Dijkstra</strong>：时间复杂度是 $O(n^2+m)$, $n$ 表示点数，$m$ 表示边数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e2</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g[maxn][maxn];  <span class="comment">// 存储每条边</span></span><br><span class="line"><span class="keyword">int</span> dist[maxn];  <span class="comment">// 存储1号点到每个点的最短距离</span></span><br><span class="line"><span class="keyword">bool</span> st[maxn];   <span class="comment">// 存储每个点的最短路是否已经确定</span></span><br><span class="line"><span class="keyword">int</span> n;<span class="comment">//点数</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 求1号点到n号点的最短路，如果不存在则返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ ) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">-1</span>;     <span class="comment">// 在还未确定最短路的点中，寻找距离最小的点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用t更新其他点的距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            dist[j] = min(dist[j], dist[t] + g[t][j]);</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>堆优化Dijkstra</strong>：时间复杂度 $O(mlogn)$, $n$ 表示点数，$m$ 表示边数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1.5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;      <span class="comment">// 点的数量</span></span><br><span class="line"><span class="keyword">int</span> h[maxn], w[maxn], e[maxn], ne[maxn], idx;  <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="keyword">int</span> dist[maxn];        <span class="comment">// 存储所有点到1号点的距离</span></span><br><span class="line"><span class="keyword">bool</span> st[maxn];     <span class="comment">// 存储每个点的最短距离是否已确定</span></span><br><span class="line"><span class="comment">//加边</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    w[idx] = c; <span class="comment">// 有重边也不要紧，假设1-&gt;2有权重为2和3的边，再遍历到点1的时候2号点的距离会更新两次放入堆中</span></span><br><span class="line">    e[idx] = y; <span class="comment">// 这样堆中会有很多冗余的点，但是在弹出的时候还是会弹出最小值2+x（x为之前确定的最短路径），并</span></span><br><span class="line">    ne[idx] = h[x]; <span class="comment">// 标记st为true，所以下一次弹出3+x会continue不会向下执行。</span></span><br><span class="line">    h[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 求1号点到n号点的最短距离，如果不存在，则返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;PII, <span class="built_in">vector</span>&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;</span><br><span class="line">    heap.push(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;);      <span class="comment">// first存储距离，second存储节点编号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (heap.size()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.top();</span><br><span class="line">        heap.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ver = t.second, distance = t.first;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[ver]; i != <span class="number">-1</span>; i = ne[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; distance + w[i]) &#123;</span><br><span class="line">                dist[j] = distance + w[i];</span><br><span class="line">                heap.push(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-单源-Bellman-Ford算法"><a href="#2-单源-Bellman-Ford算法" class="headerlink" title="2 单源 Bellman-Ford算法"></a>2 单源 Bellman-Ford算法</h1><p>一维数组dist[]来存储每个点到起点的距离，初始化dist[S]  = 0，其他初始化为INF。</p><p>找到从起点到某个点的最短路，设起点为S，终点为D，那这条最短路一定是$S-&gt;P_1-&gt;P_2-&gt;…-&gt;D$的形式，假设<strong>没有负权环</strong>，那这条路径上的点的总个数一定<strong>不大于n</strong>。</p><p>定义对点x, y的松弛操作是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dist[y] = min(dist[y], dist[x] + e[x][y]);<span class="comment">//这里的e[x][y]表示x、y之间的距离，具体形式可能根据存图方法不同而改变</span></span><br></pre></td></tr></table></figure><p>松弛操作就相当于考察能否<strong>经由x点</strong>使<strong>起点到y点</strong>的距离变短。</p><p>所以要找到最短路，只需要进行以下步骤：</p><ol><li>先松弛$S$, $P_1$，此时$dist[P_1]$必然等于$e[S][P_1]$</li><li>再松弛$P_1, P_2$，因为$S-&gt;P_1-&gt;P_2$是最短路的一部分，<strong>最短路的子路也是最短路</strong>（这是显然的），所以$dist[P_2]$不可能小于$dist[P_1]+e[P_1][P_2]$，因此它会被更新为$dist[P1]+e[P1][P2]$，即$e[S][P1]+e[P1][P2]$。</li><li>再松弛$P2, P3$，……以此类推，最终$dist[D]$必然等于$e[S][P1]+e[P1][P2]+…$，这恰好就是最短路径。</li></ol><p><strong>把所有边松弛n-1遍！</strong></p><p><a href="https://zhuanlan.zhihu.com/p/96621396" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/96621396</a></p><p><a href="https://blog.csdn.net/luomingjun12315/article/details/50377525" target="_blank" rel="noopener">https://blog.csdn.net/luomingjun12315/article/details/50377525</a></p><h1 id="3-单源-SPFA算法"><a href="#3-单源-SPFA算法" class="headerlink" title="3 单源 SPFA算法"></a>3 单源 SPFA算法</h1><p><strong>SPFA算法</strong>，也就是<strong>队列优化</strong>的Bellman-Ford算法，维护一个队列。</p><h1 id="4-全源-Floyd算法"><a href="#4-全源-Floyd算法" class="headerlink" title="4 全源 Floyd算法"></a>4 全源 Floyd算法</h1><p>求出每一对顶点之间的最短路径。Floyd本质上是一个<strong>动态规划</strong>的思想，每一次循环更新<strong>经由k点，i到j的最短路径</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算法结束后，d[a][b]表示a到b的最短距离，path存放路径信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//初始化：</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (i == j) d[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> d[i][j] = inf;</span><br><span class="line">    <span class="comment">//memset(path, -1, sizeof path);</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//dp </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k ++ ) &#123;<span class="comment">//考虑以k为中转点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ ) &#123;</span><br><span class="line">                <span class="keyword">if</span> (d[i][j] &gt; d[i][k] + d[k][j]) &#123;<span class="comment">//以k为中转点的路径更短</span></span><br><span class="line">                d[i][j] = d[i][k] + d[k][j];<span class="comment">//更新最短路径长度</span></span><br><span class="line">                    <span class="comment">//path[i][j] = k;//中转点</span></span><br><span class="line">                &#125;     </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-全源-Johnson算法"><a href="#5-全源-Johnson算法" class="headerlink" title="5 全源 Johnson算法"></a>5 全源 Johnson算法</h1><h1 id="6-BFS算法"><a href="#6-BFS算法" class="headerlink" title="6 BFS算法"></a>6 BFS算法</h1><p>该算法求单源最短路径只适用于无权图，或所有边的权值都相同的图。</p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><ol><li><a href="https://www.acwing.com/problem/content/851/" target="_blank" rel="noopener">acwing模板题目——Dijkstra求最短路 I</a></li><li><a href="https://www.acwing.com/problem/content/852/" target="_blank" rel="noopener">Dijkstra求最短路 II</a></li><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构和算法" scheme="https://Dragonliu2018.github.io/categories/数据结构和算法/"/>
    
    
    <category term="图论" scheme="https://Dragonliu2018.github.io/tags/图论/"/>
    
  </entry>
  
  <entry>
    <title>并查集</title>
    <link href="https://dragonliu2018.github.io/2021/04/09/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>https://dragonliu2018.github.io/2021/04/09/%E5%B9%B6%E6%9F%A5%E9%9B%86/</id>
    <published>2021-04-09T10:04:48.000Z</published>
    <updated>2021-09-21T13:39:31.377Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="简介"><a href="#简介" class="headerlink" title="简介　　"></a>简介　　</h1><p>英文：Disjoint Set，即“不相交集合”。将编号分别为$1…N$的$N$个对象划分为不相交集合，在每个集合中，选择其中某个元素代表所在集合。常见两种操作：</p><ol><li>合<strong>并</strong>两个集合；</li><li><strong>查</strong>找某元素属于哪个集合。</li></ol><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="1-无优化"><a href="#1-无优化" class="headerlink" title="1 无优化"></a>1 无优化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>;</span><br><span class="line"><span class="keyword">int</span> node[maxn];<span class="comment">//每个节点的父节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n; i++ )&#123;</span><br><span class="line">        node[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找当前元素所在树的根节点(代表元素)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == node[x])</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> find(node[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//合并x和y所在的集合</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> root_x = find(x);<span class="comment">//找到根节点</span></span><br><span class="line">    <span class="keyword">int</span> root_y = find(y);</span><br><span class="line">    <span class="keyword">if</span> (root_x == root_y)<span class="comment">//两者根节点相同</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    node[root_x] = root_y;<span class="comment">//将x的根节点与y的根节点相连</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断xy是否属于一个集合</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">same</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> find(x) == find(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-优化-路径压缩-按秩合并"><a href="#2-优化-路径压缩-按秩合并" class="headerlink" title="2 优化(路径压缩+按秩合并)"></a>2 优化(路径压缩+按秩合并)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>;</span><br><span class="line"><span class="keyword">int</span> node[maxn];<span class="comment">//每个节点的父节点</span></span><br><span class="line"><span class="keyword">int</span> Rank[maxn];<span class="comment">//树的高度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        node[i] = i;</span><br><span class="line">        Rank[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//路径压缩</span></span><br><span class="line"><span class="comment">//查找当前元素所在树的根节点(代表元素)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == node[x])</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> node[x] = find(node[x]);<span class="comment">//在第一次查找时，将节点直连到根节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按秩合并</span></span><br><span class="line"><span class="comment">//合并x和y所在的集合</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> root_x = find(x);<span class="comment">//找到根节点</span></span><br><span class="line">    <span class="keyword">int</span> root_y = find(y);</span><br><span class="line">    <span class="keyword">if</span> (root_x == root_y)<span class="comment">//两者根节点相同</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="comment">//判断两棵树的高度，然后在决定谁为子树</span></span><br><span class="line">    <span class="keyword">if</span> (Rank[root_x] &lt; Rank[root_y])</span><br><span class="line">        node[root_x] = root_y;<span class="comment">//将x的根节点接到y的根节点下</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        node[root_y] = root_x;<span class="comment">//将y的根节点与x的根节点下</span></span><br><span class="line">        <span class="keyword">if</span> (Rank[root_x] == Rank[root_y])<span class="comment">//树的高度相同</span></span><br><span class="line">            Rank[root_x]++;<span class="comment">//root_x树高度+1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断xy是否属于一个集合</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">same</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> find(x) == find(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>直接实现的话，时间复杂度最坏可以到$O(n)$。<br>两个常见优化，启发式合并，路径压缩。</p><ul><li>启发式合并：把大小较小的集合挂在较大的集合上。（有的写法是考虑深度而不是大小）</li><li>路径压缩：询问过的点到根节点的路径，都直接挂在根节点上。</li></ul><p>实现其中任意一个时间复杂度变为$O(\log n)$。<br>实现其中两个，时间复杂度变为$O(\alpha(n))$，其中$\alpha(n)$是阿克曼函数的反函数，可以认为非常小。</p><p>多数情况下为了简单，都实现路径压缩（只需要一句赋值）而不实现启发式合并（需要记录大小）</p><p>在某些题目中由于会爆栈，需要使用非递归的find函数。</p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><ol><li><a href="https://www.luogu.com.cn/problem/P3367" target="_blank" rel="noopener">洛谷——P3367 【模板】并查集</a></li><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构和算法" scheme="https://Dragonliu2018.github.io/categories/数据结构和算法/"/>
    
    
    <category term="数据结构" scheme="https://Dragonliu2018.github.io/tags/数据结构/"/>
    
  </entry>
  
  <entry>
    <title>关键路径</title>
    <link href="https://dragonliu2018.github.io/2021/04/09/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/"/>
    <id>https://dragonliu2018.github.io/2021/04/09/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/</id>
    <published>2021-04-09T09:13:18.000Z</published>
    <updated>2021-09-21T16:08:59.128Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><strong>概念</strong>：</p><ol><li>AOE网（Activity On Edge Network，用顶点表示活动的网）：在带权有向图中，以顶点表示事件，以有向边表示活动，以边上的权值表示完成该活动的开销（如完成活动所需的时间），称之为用边表示活动的网络。</li><li>在AOE网中仅有一个入度为0的顶点，称为开始顶点（源点），它表示整个工程的开始；也仅有一个出度为0的顶点，称为结束顶点（汇点），它表示整个工程的结束。</li><li>从源点到汇点的有向路径可能有多条，所有路径中，具有最大路径长度的路径称为关键路径，而把关键路径上的活动称为关键活动。</li><li>完成整个工程的最短时间就是关键路径的长度，若关键活动不能按时完成，则整个工程的完成时间就会延长。</li></ol><p><strong>性质</strong>：</p><ol><li>只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始；</li><li>只有在进入某顶点的各有向边所代表的活动都已结束时，该顶点所代表的事件才能发生。另外，有些活动是可以并行进行的。</li></ol><p><strong>求解关键路径的一些定义</strong>：</p><ul><li>事件$v_k$的最早发生时间$ve{(k)}$——决定了所有以$v_k$开始的活动能够开工的最早时间</li><li>活动$a_i$的最早开始时间$e(i)$——指该活动弧的起点所表示的事件的最早发生时间</li><li>事件$v_k$的最迟发生时间$vl(k)$——它是指在不推迟整个工程完成的前提下，该事件最迟必须发生的时间。</li><li>活动$a_i$的最迟开始时间$l(i)$——它是指该活动弧的终点所表示事件的最迟发生时间与该活动所需时间之差。</li><li>活动$a_i$的时间余量$d(i)=l(i)-e(i)$，表示在不增加完成整个工程所需总时间的情况下，活动$a_i$可以拖延的时间</li><li>若一个活动的时间余量为零，则说明该活动必须要如期完成，$d(i)=0$的活动$a_i$是关键活动；由关键活动组成的路径就是关键路径。</li></ul><p><strong>求解关键路径的步骤</strong>：</p><ol><li><p>求所有事件的最早发生时间$ve()$</p><ul><li>按拓扑排序序列，依次求各个顶点的 $v e(k)$ :<br>$v e($ 源点 $)=0$<br>$v e(k)=\operatorname{Max}\left{v \mathrm{e}(j)+\operatorname{Weight}\left(v<em>{j}, v</em>{k}\right)\right}, \quad v<em>{j}$ 为 $v</em>{k}$ 的任意前驱</li></ul></li><li><p>求所有事件的最迟发生时间$vl()$</p><ul><li><p>按逆拓扑排序序列，依次求各个顶点的 $v l(\boldsymbol{k})$ :<br>$v l($ 汇点 $)=v e( 汇点)$ </p><p>$v l(k)=\operatorname{Min}\left{v l(j)-\operatorname{Weight}\left(v<em>{k}, v</em>{j}\right)\right}, v<em>{j}$ 为 $v</em>{k}$ 的任意后继</p></li></ul></li><li><p>求所有活动的最早发生时间$e()$</p><ul><li>若边 $<v_{k}, v_{j}>$ 表示活动 $a_{i}$, 则有 $e(i)=v e(k)$</v_{k},></li></ul></li><li><p>求所有活动的最迟发生时间$l()$</p><ul><li>若边 $<v_{k}, v_{j}>$ 表示活动 $a<em>{i}$, 则有 $l(i)=v l(j)-$ Weight $\left(v</em>{k}, v_{j}\right)$</v_{k},></li></ul></li><li><p>求所有活动的时间余量$d()$</p><ul><li>$d(i)=l(i)-e(i)$</li></ul></li></ol><p><strong>关键活动、关键路径的特性</strong>：</p><ol><li>若关键活动耗时增加，则整个工程的工期将增长</li><li>缩短关键活动的时间，可以缩短整个工程的工期</li><li>当缩短到一定程度时，关键活动可能会变成非关键活动</li><li>可能有多条关键路径，只提高一条关键路径上的关键活动速度并不能缩短整个工程的工期，只有加快那些包括在所有关键路径上的关键活动才能达到缩短工期的目的。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构和算法" scheme="https://Dragonliu2018.github.io/categories/数据结构和算法/"/>
    
    
    <category term="图论" scheme="https://Dragonliu2018.github.io/tags/图论/"/>
    
  </entry>
  
  <entry>
    <title>拓扑排序</title>
    <link href="https://dragonliu2018.github.io/2021/04/09/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    <id>https://dragonliu2018.github.io/2021/04/09/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</id>
    <published>2021-04-09T09:13:18.000Z</published>
    <updated>2021-09-21T13:41:58.695Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>有向无环图：若一个有向图中不存在环，则称为有向无环图，简称DAG图（Directed Acyclic Graph）</p><p>AOV网（Activity On Vertex Network，用顶点表示活动的网）：用DAG表示一个工程，顶点表示活动，有向边$<v_i,v_j>$表示活动$V_i$必须先于$V_j$进行。</v_i,v_j></p><p>拓扑排序是一个有向无环图(DAG)的所有顶点的线性序列，且该序列必须满足下面两个条件：</p><ol><li>每个顶点出现且只出现一次。</li><li>若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。</li></ol><p><strong>实现</strong>：</p><ol><li>从AOV网中选择一个没有前驱（入度为0）的顶点并输出；</li><li>从网中删除该顶点和所有以它为起点的有向边；</li><li>重复1和2直到当前的AOV网为空或当前网中不存在无前驱的顶点为止（说明有回路）。</li></ol><p><strong>逆拓扑序</strong>：</p><ol><li>从AOV网中选择一个没有后继（出度为0）的顶点并输出；</li><li>从网中删除该顶点和所有以它为终点的有向边；</li><li>重复1和2直到当前的AOV网为空。</li></ol><p><strong>思路</strong>：</p><ol><li>用一种容器（比如栈，队列，集合）维护当前所有入度为0的点。</li><li>每次从容器中取出一个点，删掉他和他的出边，这可能导致一些点入度为0，将新的入度为0的点加入容器。</li></ol><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>邻接表：时间复杂度 $O(n+m)$, $n$ 表示点数，$m$ 表示边数</p><p>邻接矩阵：时间复杂度 $O(n^2)$</p><p>也可以使用dfs实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxe = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;      <span class="comment">// 点的数量</span></span><br><span class="line"><span class="keyword">int</span> h[maxn], e[maxe], ne[maxe], idx;  <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="keyword">int</span> d[maxn];<span class="comment">//每个点的入度 </span></span><br><span class="line"><span class="keyword">int</span> print[maxn];<span class="comment">//拓扑序列 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//加边</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    e[idx] = y; <span class="comment">// 这样堆中会有很多冗余的点，但是在弹出的时候还是会弹出最小值2+x（x为之前确定的最短路径），并</span></span><br><span class="line">    ne[idx] = h[x]; <span class="comment">// 标记st为true，所以下一次弹出3+x会continue不会向下执行。</span></span><br><span class="line">    h[x] = idx++;</span><br><span class="line">    d[y]++;<span class="comment">//入度 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拓扑排序 </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">topsort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;<span class="comment">//存储入度为0的点 </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// d[i] 存储点i的入度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!d[i])<span class="comment">//将所有入度为0的点入栈 </span></span><br><span class="line">            s.push(i);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;<span class="comment">//记录当前已经输出的顶点数 </span></span><br><span class="line">    <span class="keyword">while</span> (!s.empty()) &#123;<span class="comment">//栈不空，存在入度为0的顶点 </span></span><br><span class="line">        <span class="keyword">int</span> t = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        print[cnt++] = t; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (-- d[j] == <span class="number">0</span>)</span><br><span class="line">                s.push(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。</span></span><br><span class="line">    <span class="keyword">return</span> cnt == n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><ol><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构和算法" scheme="https://Dragonliu2018.github.io/categories/数据结构和算法/"/>
    
    
    <category term="图论" scheme="https://Dragonliu2018.github.io/tags/图论/"/>
    
  </entry>
  
  <entry>
    <title>最小生成树</title>
    <link href="https://dragonliu2018.github.io/2021/04/09/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    <id>https://dragonliu2018.github.io/2021/04/09/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</id>
    <published>2021-04-09T09:13:18.000Z</published>
    <updated>2021-09-21T15:59:49.681Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>　　 给定一个无向图，如果它任意两个顶点都联通并且是一棵树，那么我们就称之为生成树(Spanning Tree)。如果是带权值的无向图，那么权值之和最小的生成树，我们就称之为最小生成树(MST, Minimum Spanning Tree)。</p><p>　　常见求解最小生成树的算法有Kruskal算法和Prim算法，两者都是运用贪心的思路。两者区别：Prim在稠密图中比Kruskal优，在稀疏图(一般我们认为满足$E &lt; V*(V-1)/4$)中比Kruskal劣；Prim是以更新过的节点的连边找最小值，Kruskal是直接将边排序。</p><p><strong>注意</strong>：</p><ol><li>最小生成树可能有多个，但边的权值之和总是唯一且最小的</li><li>最小生成树的<code>边数=顶点数-1</code>。砍掉一条则不连通，增加一条边则会出现回路</li><li>如果一个连通图本身就是一棵树，则其最小生成树就是它本身</li><li>只有连通图才有生成树，非连通图只有生成森林</li></ol><h1 id="1-Kruskal算法"><a href="#1-Kruskal算法" class="headerlink" title="1 Kruskal算法"></a>1 Kruskal算法</h1><p>　　Kruskal算法是基于贪心的思想得到的。首先我们把所有的边按照权值先从小到大排列，接着按照顺序选取每条边，如果这条边的两个端点不属于同一集合（两点是否连通），那么就将它们合并，直到所有的点都属于同一个集合为止（所有结点连通）。</p><p>　　<strong>时间复杂度</strong>：Kruskal算法每次要从都要从剩余的边中选取一个最小的边。通常我们要先对边按权值从小到大排序，这一步的时间复杂度为$O(ElogE)$。Kruskal算法的实现通常使用并查集，来快速判断两个顶点是否属于同一个集合。最坏的情况可能要枚举完所有的边，此时要循环$E$次，所以这一步的时间复杂度为$O(E*α(V))$，其中$α$为Ackermann函数，其增长非常慢，我们可以视为常数。所以Kruskal算法的时间复杂度为$O(ElogE)$。</p><ul><li>参考：<a href="https://blog.csdn.net/luomingjun12315/article/details/47700237/" target="_blank" rel="noopener">https://blog.csdn.net/luomingjun12315/article/details/47700237/</a></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">int</span> n, v;       <span class="comment">// n是点数，v是边数</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span><span class="comment">// 存储边</span></span><br><span class="line">    <span class="keyword">int</span> a, b, w;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> Edge &amp;W)<span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; W.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edges[maxv];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> node[maxn];<span class="comment">//并查集的父节点数组</span></span><br><span class="line"><span class="keyword">int</span> Rank[maxn];<span class="comment">//树的高度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        node[i] = i;</span><br><span class="line">        Rank[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//路径压缩</span></span><br><span class="line"><span class="comment">//查找当前元素所在树的根节点(代表元素)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == node[x])</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> node[x] = find(node[x]);<span class="comment">//在第一次查找时，将节点直连到根节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按秩合并</span></span><br><span class="line"><span class="comment">//合并x和y所在的集合</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> root_x = find(x);<span class="comment">//找到根节点</span></span><br><span class="line">    <span class="keyword">int</span> root_y = find(y);</span><br><span class="line">    <span class="keyword">if</span> (root_x == root_y)<span class="comment">//两者根节点相同</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="comment">//判断两棵树的高度，然后在决定谁为子树</span></span><br><span class="line">    <span class="keyword">if</span> (Rank[root_x] &lt; Rank[root_y])</span><br><span class="line">        node[root_x] = root_y;<span class="comment">//将x的根节点接到y的根节点下</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        node[root_y] = root_x;<span class="comment">//将y的根节点与x的根节点下</span></span><br><span class="line">        <span class="keyword">if</span> (Rank[root_x] == Rank[root_y])<span class="comment">//树的高度相同</span></span><br><span class="line">            Rank[root_x]++;<span class="comment">//root_x树高度+1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断xy是否属于一个集合</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">same</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> find(x) == find(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sort(edges, edges + v);</span><br><span class="line"></span><br><span class="line">    init(n);  <span class="comment">// 初始化并查集</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; i ++ ) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;</span><br><span class="line"></span><br><span class="line">        a = find(a), b = find(b);</span><br><span class="line">        <span class="keyword">if</span> (a != b) &#123;<span class="comment">// 如果两个连通块不连通，</span></span><br><span class="line">            merge(a, b);<span class="comment">//则将这两个连通块合并</span></span><br><span class="line">            res += w;</span><br><span class="line">            cnt ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>) <span class="keyword">return</span> inf;<span class="comment">//原图不连通 </span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-Prim算法"><a href="#2-Prim算法" class="headerlink" title="2 Prim算法"></a>2 Prim算法</h1><p><strong>思想</strong>：</p><p>从某一个顶点开始构建生成树；每次将代价最小的新顶点纳入生成树，直到所有顶点都纳入为止。</p><p><strong>时间复杂度</strong>：</p><div class="table-container"><table><thead><tr><th style="text-align:center">最小边、权的数据结构</th><th style="text-align:center">时间复杂度（总计）</th></tr></thead><tbody><tr><td style="text-align:center">邻接矩阵、搜索</td><td style="text-align:center">$O(V^2)$</td></tr><tr><td style="text-align:center">二叉堆、邻接表</td><td style="text-align:center">$O((V + E) log(V)) = O(E log(V))$</td></tr><tr><td style="text-align:center">斐波那契堆、邻接表</td><td style="text-align:center">$O(E + V log(V))$</td></tr></tbody></table></div><p><strong>流程</strong>：</p><p>输入：一个加权连通图，其中顶点集合为$V$，边集合为$E$<br>输出：使用集合$Vnew$和$Enew$来描述所得到的最小生成树</p><p>从单一顶点开始，Prim算法按照以下步骤逐步扩大树中所含顶点的数目，直到遍及连通图的所有顶点。</p><ol><li>初始化：$Vnew = {x}$，其中$x$为集合$V$中的任一节点(起始点)，$Enew = {}$；</li><li>重复下列操作，直到$Vnew = V$:<ol><li>在集合$E$中选取权值最小的边$(u, v)$，其中$u$为集合$Vnew$中的元素，而$v$则是$V$中没有加入$Vnew$的顶点（如果存在有多条满足前述条件即具有相同权值的边，则可任意选取其中之一）；</li><li>将$v$加入集合$Vnew$中，将$(u, v)$加入集合$Enew$中。</li></ol></li></ol><ul><li>参考：<a href="https://blog.csdn.net/luomingjun12315/article/details/47859993" target="_blank" rel="noopener">https://blog.csdn.net/luomingjun12315/article/details/47859993</a></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;      <span class="comment">// n表示点数</span></span><br><span class="line"><span class="keyword">int</span> g[maxn][maxn]; <span class="comment">// 邻接矩阵，存储所有边，编号从1开始 </span></span><br><span class="line"><span class="keyword">int</span> dist[maxn];    <span class="comment">// 存储其他点到当前最小生成树的距离</span></span><br><span class="line"><span class="keyword">bool</span> st[maxn];     <span class="comment">// 存储每个点是否已经在生成树中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) &#123;</span><br><span class="line">    <span class="comment">//寻找代价最小的新顶点 </span></span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line"><span class="comment">//原图不连通 </span></span><br><span class="line">        <span class="keyword">if</span> (i &amp;&amp; dist[t] == inf) <span class="keyword">return</span> inf;</span><br><span class="line"><span class="comment">//加点 </span></span><br><span class="line">        <span class="keyword">if</span> (i) res += dist[t];</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//更新dist </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ ) dist[j] = min(dist[j], g[t][j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><ol><li><a href="https://ac.nowcoder.com/acm/problem/15108" target="_blank" rel="noopener">牛客——道路建设</a></li><li><a href="https://ac.nowcoder.com/acm/problem/17509" target="_blank" rel="noopener">牛客——挖沟</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构和算法" scheme="https://Dragonliu2018.github.io/categories/数据结构和算法/"/>
    
    
    <category term="图论" scheme="https://Dragonliu2018.github.io/tags/图论/"/>
    
  </entry>
  
  <entry>
    <title>202104华为招聘面试流程</title>
    <link href="https://dragonliu2018.github.io/2021/04/07/202104%E5%8D%8E%E4%B8%BA%E5%AE%9E%E4%B9%A0%E6%B5%81%E7%A8%8B/"/>
    <id>https://dragonliu2018.github.io/2021/04/07/202104%E5%8D%8E%E4%B8%BA%E5%AE%9E%E4%B9%A0%E6%B5%81%E7%A8%8B/</id>
    <published>2021-04-07T14:06:04.000Z</published>
    <updated>2021-09-21T13:38:07.181Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误！请检查后重试~" data-whm="解密出现了一点问题，你仍可以看一看。">  <script id="hbeData" type="hbeData" data-hmacdigest="12c0d60781b1b22badb4bd17704d5b688aa3714361c29f2dee328273c43a8f5a">fb82b35931811eccec5218a1e0a6c69cdf52456ba616b4a099f400e13646b7eb1fa751f1a81931be1917117835adcdb2aa299c5cbac9ac5e10c58bc33dc312a27e3a62a287d3e12c8e505f42d268c3da452267a1c4f158663a29c91e905ce86d9eeb41ce28daef3cb7a0617db8cff5497950d75378fddc503598f82a7a44bdae7cec19e9320f1ed9941e440f96960ad9afbc58bd4652a51523ab2b8553cce3a9397c449152ad17cfbb0191daae1fa57ac2dfe9d814e924e13643d696332be883b60a31e18a9bb1067334b60d35a60d9126315bbf36b47049913fe041d5595dc258b31f1667ca9cb075aac3a3d5561f6c2e0eb6fbd4c68e645ffb6ed24803c8f2aa8fbe2cfbb180ff6e3ad5d60a44569f50b517e45eaee538a8066f747b95a44375feff7585808e5aa4310b18ea93b5b3e71d67428313181c7e629fb9d0f470e329819e5f9ba7ea8684f945786eaee96a0c08e4931d88a02187d8f38b1dc7eef7a1c63c7558a740ad425207b1b3df3005a51517ff23caf78b57735f537fa3b6f4367b8a73eea861341828d7e943fec6d48d64d1d7dde96803232338fe698e496e19a4403ac1f58619419ee34e35473cb24f0043206740f20125b9fe94a0684bcdbb179c633304a8e3b7831c9a2fa1aaf100e86d9865b987c9cbed4617a0f098436ab4e551c7ca931e827b1cf0099e18b0db64c4ca9c3ae829ec115320d98cc05beb365fce940b100a43dfb129a53787a69879748c3608071f712856f4a03fd95fefac71ce1f4c6df088f477fb92c3e7afd1ee0912d79589bdc2bf61f2cea1f1d648d15e9e7306a0720bc2210d6cf48825ff186b2f4a6a76ee498d62f9514bd1a32bf55f8747af8018c3e49b2ad694aaa3470e6ab854c501fc087726ba3e4c83283829eb53951db734b7ff183fcd5980ee3528146ff556878c53268149a0ed903ddff1b3c464c4c6bcdc9c22effd31d5b1556802f6b380afd5e93a9210eea50492a73c47d07880a4257b07289952ca76a84a78e9d5a6a7e757f90db5f3ae6e46ac348c501eec0ea71d2a5e587916bf039dba7e1a3b26b0d1ac945fec05f68123e3139bcf08880abfbbeab6e47e7c08c7009c6c7fad7e54c80def0003fea2a7b4a365200b474ad97f6b87d1cb6a70a1e8422698ee8b4a98111ce569a90ca08b2af6d7ff5d83dd9f2915f61d38980f671e0edbfea7a55a0672414cabca3d45ed763318fd6a2e5722001e7058e164c3d07fee17799699fd9a002d581bc9155eb431773fd7176e39dfe1eb3192084826d9277ab778cc01993146f05539c41c2e03aeb7f78de69d7c746ccb77f9d2a2ffe4867d75ff713aae84892301178a3428b5a7d943dca824c4a41c725f5b5273e7a3ffe0909b13c12f72c72f57218d4d2d4f95bdf77d5b0d458a9d2824cb501923004f59432db80201154cb3b86a2c1ee30fa5ced29b352d78f986f67a46ff24cd585157f5a2b891cb6db463a865878edf19bfb4d72fcf7df2081419af5919857247f8f5fa7d0449d28e0877a66235334bbd33dcaed4fe926bf74d1817116f7d7c9f183bc3a4a52fe6e6bf7002c8b1af0c49217a1f991a74138e00014225d5feacbcb41f65774bbf612053658962c6c6afd7a5d42905c3337abb26a9c6453fd466da1df4f26acc28e264df00fe3f32c3b4f6f3a8ca78cb61f53fe0e886b3cdc4ef7306b1a4b4e4845314e27413095e953273a83e1176e6e20a9a9b4f8f7f40468c8b7d6a38b223d81fc4e7a85829caa0d2dc907f9e5f4bcc3d833b794cae6f3e498d0695cf6f563829494f566d7305c819334e24152a87d0aa15662da13e0387c0d11c7ebcfa23be57e6d4fe104c6a5a7ac7693bd1555ef1a8570503c7d841278de76cdedf3008665080a165bc3134af383e202fe8032a2d6e7c79298f74b003c6f515871695c2a68e4772740fce014e4fa9eaec0fef4838020e1ee5b1ebe5fb0ab48487003f5ca324b1a9b5478ffa2638bff15cbb0e37cd1824cd84adc519b102f9784ff277cbcd5bdec12a762f9aeef0143d5c4bdc5540b997fe525e9ae632a1fe3ba2c6377ca19ab026b61ff84feaa4ae25a6b1402199cffadf8b2fac20693b8b052f2ff6020d388e7031d8bfe39167658906a106a12b76d288532fd0689641f03255b35670e33c5ce721352e25d3a77fe3c237599b2595888b35c3f3a62eb1137781e6577ffbb1273f026a7551e253c570ff8f288a229663f4e866cf4b7e929573c65ed29e98aac95b75e5abf8f69dbf97e1fef727f7ad8d1b340734adc7f2774860d7d1a8c761792dcc9ce812e50e6bdf9ffdce2e6b489720a139bf4071256f5e5064d3fc0f7ad409272cd4bd51cf9b8ec62fa5e95c4842c3e0c6da1a9fc676075e3f912fb2172c9999b6595625e991291d1302e6308e469e5ff97ce11530d91b7c654894d89c955229b9f04da7ae861f4660abff625d61af77970177adff7265a72d9d98f6018f1f8d3e3ee85251398bba7fb71477419677cade5af5e13fe9c0432124d2a7c98979d55ebb543eda96f63202f17ca2a9cd0bf1c188ef6f29885c99c211afca6b5a446c22d6d2688aded2975ac5d734787e9e2a281b119859595e3a01605a48c7932d36e62ab136f4064607f085eba05e0818e54b0cc96ab326bafebaa9402e55f16c9b72a1c003aac7c84158913192cb1372e376785849f0da9ec5d7ab62d17bfbbe80259b71a043cfe68ca2e0acfde96f257c55d2262e581b484e94d4689cd8e39100209764863766d0734fcce7bf87e99e36644be755f6325aab355a420c0fe5e727f94823303f6dd6a55e19eddfec825ffc92d054f871b9f0f3f5e96c898873057bf852a5f855f859dd32b4b136257ea1ed99bdefd316145bcccbed27546b4eb4332ce8ffbbd20cc812d1ec6b2efea4878826816df40d45d58683a08ef289591fe434808f05dda7b3890de6068d85dc06791647d59366daf7caf6582a26fbe2d7912a4c4f4043d4ca6e43b47b1a20836915c875ba3735f79eba07879de8c20e6d9c31ac550421f4eaa10a01898e4d7619e4dac51743734b1d8bba0df7465bc5ab33544c0e6eb083e9ce518a67920e82814d0783355f9d41aa48976f4db9f929542f5ea9868cbba390632168659662f412ada8c570c09ad1d56794c59fc18614888cb39f0a5d4122f14225e1b36a54c4128d2075faf51115528aecf8f8b82ba11fd8dded88350ff2f89730a49a9972d1ab11501b346e81b807cf6be91fc1af16cd9bb20aeac4f085ed4cc85899f0fcc6744507007f5fd373ea05b7e98f1b1af11ad55a591237675e80a5fd379ebc47fa16a6087c8d33a4710cb470109bd9f2dc4984f8bad694a26af100ad8f1107b919cedd923340ab37bffabf80ac6f9d7f00643a4de0b5b252c3081a14e8a1804a3878ea3f33ab4a0d6984c186545947bd9222d269f49301bcd9147b616cdb0660d4c36e32d4d93b4909fd61ed851b647855196f2b3311f0ef3c4898b7581d17694ee102e882504d3588688471d352ef6efd4a321e23e68182ff56bac5c6adf73cee03d702672e94bf6230160a7b3b0be0b7a007c7c45d8d08fdad1e1c7ff3e9843cd0a6ffae68ce739c2446053f2086670da63812cc7f7042df8a311ebb3ca5132a368975fa7d03321ba7f7068a7fd3790919218cdb19b18248a904d85e0949afd34eaa4927ba868fe943711e7aedfc9b61752449938155c8df6a6763043fc3fbb8367a13aa06ba93258617a7f48b9244cd511596cc9e4c7d34998f7abcf42f616a6932285a17a4fcc448c499fd712b40ada1515602770d93ef57313e4a8b26c4db77ba8966e7bc139934f3310e55be60e2e9b7ce45ddb4200b6b4b0ddc0798748d0bf987bde63c540603a667d4b54f853caeb4d9e20bee21c476125efce47f83e60041b6abccd2629fb6eed158f0153b6580a2bd677655378487473aa83d98351610fa6e8fa7df1387aeb5163902fabb380b396bd089f7d63f29cc4cd1e790d65bd3346e6e731b5ca5d4fce44cc2dc4b0b138d2f1445c0ca5e6d2ad929388b9e6ffe594ea84d62a657d6100198f407ee5e80270bb52d77f81a1c930d96457464626b10bf2aa4bcf2a09b9a58e8f83c5df0f64a5060631eab13cffc76c0e573e459ed39fbd120280c961a6e27432a49b60af98b0d12531df0894db29f7293ea66294f5dad7a18a86eb5acae5e48f93928564ec1b53da94bfa623f79a7e0e16f44c5e9d89f4a29b73a78a2d7a01fff1c2f54ddd2f20a7fd252eab152cb6018deb11c97bb01858ddaf8bd2bd25858a30f44f9d820a7a8408a23bf7e553a3b789bb1ae1674028b2b8a580411ddcb7a62ccdf1c68889d0f7f62600b1f9630747a4b5b62548db973d28a8dedd4292fd7a3a3b7e3c178460fe1a79d168e275b5b1a491caa7f79dd8d22d635f61956603f95ef63b045ce9f2fde76e2f9ab950d2670cc407fd84e6220f7278598cc82606d2049dc4c3757a52017ad3b77d83e242bd21fe689a8b7d047bc48cabea088a46d66116d46cf9d3dd06b88d7ac846964a5d7929a08b03d6ce4a1059bd10132c194b87e44fdd06a6115e4253b14b30df8064e0e9c9dfdea829a6269274541c10eab4d2d3cf5ec411453c9f88161b84c02fb48411ee5697641413a24e214654f895415c7e34a120c7dff4e5652d4c89af61e9697ecc193e2e3f24fda6f85338b9444abd2bcdb211c95a5ce611b4bb802c4ae79aa5f9df34dff8d8f623f0cf3fde0c339de8b419639954f15bf60d092694fda2c429c5d07947852463792ece9976a9a172f0110fea1b739c2c5f239bf3ab34d8778b43c44b00d7ea2daad49c5110ffbaab4c6380005ee2930fa788936da1e9c4301a7de17ac72e590a5e5f774d560f75891d3dc313f5369ebdd652a0ea7c9c0918f15b03136abda84fad804d1fd54c67c26193f759da03732bf17236993219bb26e10e2719a11c84182ff7f91fd80eeed307354c7403ece61ea4ad70702b77cf349024e4076059f6b54491ace5f97fafd227fc3be4005b9fa386670a2bf61b21a41bb1c4144c1378ca0a39e3a94e8cca77ed6b9b0ccf9bcdf882af083e3cc4e57ebcc77e5b8e77b51498f3c319544ccac69b9cb6b677da36639bce5ed79ebb8cf2816dfc9f66890d4c3c86544ab8a8f44d0dd441f7f2745b2e3ff005aa741719849448bf2824de096c9d47ba4c1a942beaf366bfb94ee478dfd8050755796951076758d391b4f8c058319014b8b73e801d57ef8ff437a6cf9c759dbb0525f46e410f27d9816266a66207fca0d2b03b6e2e2a4abed1a760992a2d3bad8ef90e7e655ad94baf381218d0c21d8f8f1948a6ba90329a6901dfbe276a6307baabcdd455d4a718ae14000d8597fffc8902bfac6e06c1004fd33aaecfe027eeaab201d0efc5b30273c7bb26c527919c83a0dcb8c3ba1fe0aef929a0f4ddd79b40544f460bf75158b6fab6d85438b2356f249fd2c5d2329f5e778131bf75730d51d111a1324831cba8dcbf48e93722b4a8db0687bb0aa31ba15bb59858f9b11cbf461b8db00cddb4c49411648e59dade83cfa0bc50834cf9762f3ae1fb3af19265fec87e715caf55baf015c8c9f4d947f90c3cb381eebb9de440518c63b76dd5b15dd24a48922587f91c3320e1eca6a07837e7a945b82e3d115087d2a254a38b1cf90ef92cce6ebab81ddb8e020a645938e556bfbf212976dd34eacda4994e9b8b72023eb88faa1c5ef405a81435786fc2018703e05a3d205c112e34da1310af353f1622e0ab3216ca6bd16f76df7d5182fa5594578ca1b1ff5c88d16d09a6e0b9b040c7c899fc1d5aa0319616eef64bcb398098a1acdd9f984e36b8de6a3d80d90fe1d5d67ed9115556f926061c63047a73cdd7b215bc9a257d872565519c8b711d762497194cf633247a2c6d07e25658d137759a727251dcb6106496f8fe7c1445b822f3282dacdb26b9a8ee41f128cf852a53c15190393227a7f9eeffb1f2fc3b05ca06778142526c7c1b56f82d986c18c3f36ad34f3067a0d0292eddf42f8658f19ef5a412c2aef2fe698c558f17e17ade73afb8824dc7e158df100dfe7e4b545d7b4f41bc759d251e8e00cd2269322d56a2139a1d02ddcf99cd397779dd38ecf07039d0b3e5680da57bd403bd134c388c9931fc03b3bc27f7b82dab2c142e434bcd92353107e4de0c98e9ce9a6afc6a18452e19316277d61e0565bb35655cf964a9ebb3988c6571ce320f8ce82331f25ab91d5daae82bfebc3586675061dd7c890bb3470ce9566c7f045b050a317f05345fde2e8a478be7448ab062d421dc37c59a480b29f43ba526e8237b433c5fe52542700240c5050ae92f205dc65aed25001796ea8528ed628599e93afb7d5b2117bb6485e76c61e78a2addd6cd5b9799e9280857ffbac829dc2461fcd87642ec9bf38db867fb13477040350875e9ec343b6e88b3b3970cd2d6bc6c0eb9fb26b72decb0b30e99926c9f54c84a832c1b47fb9a3aacce054755bee65e3abc5ef39dedf9975c3181bdbb4a42200b8436a69c7ec80c1a1757a4f6a8361d4632d9be700d49591411315f098118d0a0e009ef1eb706c94443e575b6f735315a7a729ad911b0dd7430da67bba2138ac9823e03cecf39691499d7e74eb8aea3f13400d8302c95cb8753243a904898ff004da4e63f8a90cf25258d9dc713c8573e521bcb3d56909cb0b73a83cec309980a9492b576e37130abcf0c28e0cfd0860dd208dc825820415264b1e6e85257aeb0efb3a95030876f5d65b086ab3582b80cbcfcbdf72de2ab6af4fba270def3af63571fd424883c271314116e7a1f31c2f9e448d74d3b9be4f6218a282d9572f1b79d95ed9c25e54b2f04bf699a3afe1104dc22074bba4c86ae1c3144860ea2c054db28997c212039ed7edab49747ef18bbbdf5299e50e9e3aadb1c89ec3fb2864720fdf9b98b15192ee003db5e0d7753177be0a022e3e2e0b92e2244fa66c0cf4a4139c85b3155d40d850cac5160c060cc2581d6dea3d71e6c61c160c49066b89e9569a313286415cde6e3fc869a537afcf13fd0523604bc84295f51faa99b0c9768e708241aeab7b0dbba8a171c088259e3596e0006eec51d02385068ea35557ed501c9e2ed5b9f60c590166be70203cbcadec383dbcc103ade3e6d48aabc3c519c18e443038351f9a103b78b27a4232a2293cb762b1ea532bfdfdf1006b0669255b497584c71bbe458b48e2dd9614e9e93a0bbd4aaf079237e9ccb8f7de6bb80d7ec916ae52aed7abc41b5c4523db082212c6b738c86b5eb32ac9faed9cd63d8c962efe975aa47aabb35fe109e94a83924dbc6b42761eb309dd4a4ecf92fc533f66e3728c0de9f1a967e3e936cde671640347d5fea9f3a122a498b03b812aa35cfa4b4a0895169dffac35f1c28f3de458b98c31c6806eb9d538c848e76fb173ef4ef7c2bcaaddaa33b1bd45e979906361ebbc98824ddab5b406d9a3af6ff103ff34c3c4d1c4bbba227dd8ab84d3642feee62c37defb577f4a4a2eccb23efc0083a1993c8e54765c14aa7c42187e2ddb439f2be1eb248a3737c8c06c5fa4dff4d342b6d47334db1bab0bfe6a643dfb19340774c2ee167429896490e06d6666197bae6b83c237da26f9d68b70bbca911c753beb922b1999b6299b6315de0890a6218b33c58e441dc19508d41999280e781fee0abd94344ec9fbab7f76bb6d05fe6af5061514bddbf5e549380a6313a4ff405092be4aa33e867eca1996d608b0180f5280eeeb8362f9a65bb3a659c62217e50fff064c49947161fdb4192209450c6b8a1f5c7dd0704643a4a787a62304df225a3c3a042755eea80bd5d6f2eb7311dd55d73e99f921323c1db65ac6138da3fefd9f68596defe987060f0bb50c399a9ee7b3377718925114a32003ba83939c7a6a4c736f521b8f3a770abbe0f7c55989dd98e3a3f4659a7c91a84111b79a7504e2fb3248d0c0f9c6ec100ce07d8d5d1db8b1ea0e036077c50ceb49e6584fd15e59ed961af2bfa008bc98b0c27a72f3df78e7085d828cda2f72633cc5095c8c18cdf5e4ddc3e783ff68e99d271f41256e02c5f88e90130436ac49d206be4aa248ce81e28759d0eb10911f0b2d1a204474b739088fe4d80115a2d95122872fc1f8d567ada91ee00e950063e6880b8d1b7209ee983e44760bbb0eb525a54b9d903be0538553766f26e1e2aeb41909ae369187275cc223b892d97ac6aae156adf5665a9ff4c2d4e916854382242d39e686ca4cdff00429573a67eb6a4c6cebb5174aec48897eafa1edf4e93932637b2c420d8fe5ce9fa3f7446686c059595c9bde344b1f46659093a8051d4b79116d465990ef8a522c7194ea95347b4a2bca39a7c4ec979d87e5f62b86b5165210c15e6bf1ba1d447349271e77c7d84fbd82999e2e090665fadfaf01f6300328b4e9aad2e0184f72caf9cf674eec9ca0fa5241de186c80e89ca157946d5323ff02477bdd89e0e9d405a821e2d09dee9eb5d601cb1c3162c733faa16fe8989e6d5269712a84e9a172c6cb7a11b149516ce47e83b33e43779d058354b9c9fe0e6ac9d467d1a01450516db0921ab81f4bed12da321ad6182a3fe0810c1e4d196a1c055cc6207ac0a64c5eb80cf485e6d1c37f4a92e941be1434f68726edf9840630715e64f8ab086ce6fe995766da59ab1cca92042febc7143900d68138d6ec02a6695ba480da886eb22f914bfb7d8a84914d1a3548c6bac8ef58b4c74f32ccfb7400cd4fc6052ad9c44bbd56c36bf28fdf289ef4da6deaaeb93645bdd422e4d5426d453751ea8b0ba662947bb95c5bd8da547016a6cf4eb40567fbb282248623c94ef2e820855dea7f6a4e5d801d7247eefe6caa3b2acd220226aeb0441c4ae3aad1f6bc0d6abef3ea800b5690399f184fd39ee09b04b20af7845dd1e515d22ffddd98fd441e1260ecf6dcad02d3978100899b13e221e91fc29fc6b4efc8d897bfce6dc231a66e73e76a6e690a728e13d598c15e2ba72034a7c6897e2ab162310528e513e6b00874770550af2e378863c1c59e073b24df327c04e9f75db5cc9ae9817a1839dcfbd9c26c67d5d5e4b093e6c910919746ef6d0303fc635c30accea081451e1427d8023c6e479aff12a18a501e38a6883ee2acf835fbb6cc405da5deaca4fa8b55e9a7bed14b015c5d5397f207598a87404fbba0c774af7491fe0171ca9ed2e29cdfef373f21ff9cfe8288911383251870a38e6b6d454900107004fb1826effe31e920b26a48efaa133df1d38941fe14a26ebf71ed8383c332d44bcc4866df7ab442aa6eeec88d33428eec4bec54590aeaf6d48bf0ea5d7760b646d17b1db24eab4e7b170f455b13415cba3ab6e77a03d5e088c0b1ddfd56e1456487d6cd24167fa95099fa89de60b5ff259bd4097f68cd23b23ec836d7483ebe2646b73db9b0e22d72b588e2bca7d4d9e4edd6999a08b841d60e32842b91b29b0fa643c8f0c3c6930d89f9aa4e015ecdb0adef1b78949852c87e180570286a6e68c087f1ed04108ef003aa2626f3d402465c96918a82943e90d9d44b7bb6069b416ec3cb44aef549666c0f00a42f60c09104255008b95085071c5f79897175ae9673336d3e40dd678102dd800c9512c0e26a09fb8553ed22e64027c418862fe9c792eaeedf1a3ab83fcb09dadb0112fbc51c6aefa6109a3f51c3d6ad13b0a9c3af7f4d6c8756aa65e48f49d4b0f3c193f02bef1e8d95b22acd9b7219a1fe493b7218b7014d0e52e1edd95ac6478d91e9002d14de2033bd7e064c37bfd5dd76dedde99381dbb66d189ac61baeaa8b03e57e5e35b5dc605991930b61613d8520b3826ce5a524f93d3eb0733385c28a23ecd1ef11dc2acccde92376c6c58310ee982c89f5dad2d1224719bef8be8d2a9acf8eab2fb998f4543ddc0872704a74db5a036bfe63be425ca84fc9d76644a18f87b21246fd559139adc0cfd0f2575f40b16e0c74277cec389a88a04936b512ad1aa895ebbc8f9b32b94c062371ed3e1c1c1139a90c11ad379f8911702f85d9c4f27fc557a84ad71050654540deae3b559c6a261640bbdbca741cd51bcc82bc03e25481e7d8af58b6f4a19e60b7e2a2870cb9c4891fb9d97c37a2001687ff2a06b1ebdd4ae688bb64607c35a733b576c07deec80999096fad7c23c0a6ab642cf711050e8f16fa701897e216caff77a7951645f845721c8016aa05b2b3c4375f491ae34c4dc5650dda0435c1f192a1214707b551513ae8539f7ab362a4b015cbe46c20c22f818aae1b61f2b001acbf71ca2ae4b07d8e3ad4cc564a58b7547d6354f22444168f08b3db18ce52c1190a6ede5fca9534007c91fa6abb7e547839590fa34ba88ba5b93de840cb02ee8b275910a579865b4717cbbe40250bea05edcb5bb31bada8210f5f6fb223eedc20995ad0d9ac7f1bb4b8007ee358b95b052ca92d32900743ac4c6d03b46765efdc3d44f5c66ed1faaa18fd706ab0ef5d7ef7f339f70b683060c15d2c02c3ce8eec211a781192b9501ebd0d8cbd3b0b545cb097a27cc6b8d4fc6666012bad9565ee839233674996d7fae941bb567330b10d9ac29729cafa297afa3f61417aba8f376e05ebbe401cac13662c30b542a056c062005327ff16fa353e54fbcb3fa54b64afd5d3bfcdc891048313f96fe4ba7106a289b755f9bfc57c195f1389dd8a9c7c45d1dafdd35259b8277fe9782e2ab61174c13f9f504b654cecf4930b045a51d1dac31efa9edc7268b42f9eeecfdc200ea83d8210673d78f07f9db4c5c026042499f2f42ad79026bb2beae3f81dfa7c947f43280f4111ea728ea3f1abb8342b80c12c44ca263ef6bd6da3cd39ecb96744e4e93b43ca0b8d27a1b43f200f1cccd0267498036006b3321c06e890cb6b0152bd8715e2d25d75a411c100df4b2960c41ad79492974fc7af008e4786d57e5d5211ea1db2ebfc6c973e79ef9590deadaeaa106a614dda69ed28ac4d2bd3474472bcb0224298fc639913dc676a93714753734c76bfee1434df3bd652fdb895726ac732fdaed3cfe341749b811e10961dad2c20aaced73ffe2099f7feb75420c57981a654c99a7481486ddea1bdcfcdc8dbf6bb073cce879f2ce575db98145fe820be92217054d8b378c01f8d2acf0a7fd100848ce7a93b19022e7549eb8368728328fda258e97cd768ea1723b6ad2aa0f2de52a1b534bbf12aee8c22be41e2cc4fcfa411a0bd5da9ebdcaa897d7005a7114265d028f4fdfa17455fb0165a8136d0613a11222f06b0d30f7e0d49631336f75eb8c8fac97ee752921611001a30c7cf73d3479abfd7de667a3aa961257515520f2882deb6482e35c4608fdad6d935f7ed069e09da6d557eb2bc67e81cb300896c163906692964892bc91a5dcc286e3b1c4bcc810069989737854708791333db638c4e50cfd7cd6504950f263194b032d798cfb421b711c56820c9cccfabddd83efb92ca95f4c3eaafdddd42e3740b69f58f6bf0fe21355fb13ab107d91b95821382b265019954e6ac1c8b82fc065e6188f9c8982a9e8162b1fe01c24d47b05a852a3551ab78bc189ca26f11621bfbefae0f2091f21600e48e93e97f651ed0113c7a7302eaa422b8d01e7597343d329acf1684df6dff3b5c53a006c9692a723944428f63c635a1c1ae5ddca3c7c99a015b12079fe1b6365c71f6865c0344b79a1e7a91a0b0ca359106c13353eece7490e5d75e2752530ee173f308b78e9549e8576376f1556639020b5e7095de64126200f04389c6f6485df495f72ceeaa530e703156d90a7c1e6035b6a43c9bcbc33bab481c089db40d2224e4c23e5ea46f35ca5e83c38d303d93ee2ac42e362f20bc4251959ff2e9ba7793acef726404d4c43aa9a3e8f461920047b2d6a2f1d92652e420875015251a593a6f2bbd2a6226a965dd750888a993aa7cffb4dbebd62a6a9eceabead5ecbdc987b35109b5b228213385b5db1f93062467c3435ae1b5b0a29b1251383a41dde9002326fba4522649c7bd1ba2ff8df488ff2eaf597274e49c11a4630afea93ae9c2aa8521a332793a177d28df4e5bce3a85323973a836762f21ea36521d3dc76eae5c11bc7525e6c2ef61568bde3ff14acde40bdb26c3280a9fa09e77d8c42638f241c99c16c4e2ffd11206715d1b591dc35fe3bc555a98cc312697473732531db817329bc8ec151218241dbb2e750aa5e002bec2d588775a4fdb9a989069902444a95284b42bb03a7fce79089b33b342326135ef5e4a3b0dd532b3b7f668df38efb9fafe6608c2ce3eee115847337487d425995b3b9f8265bb789a2f4fb24d7ccbe0f25ac13ea5f8e482713ab00cc47e413a1ec8d6efc5e32293f7030c4f6f6e9f7577877ce463716af33732b74a8281ee36f9c98835df31fb54c66aa0f31eac2428537e17289cd23b2593fb9c87bcbe749e692289b6b31b64ea939f243be91d0a0d7d3ea0a8f6686303f7e207c450d0a6a4eddeaad631ffab08091f6cb9c3573981940f05001b04a0f06ca42939a941245e1278dc18d282cb78d22dd522a5252c9da87a08647b2d1255e0e3f1bf130d57694c7519bfc245c21cf6f8bb989409f773b4d3b02d94e2c19492ea1c1a58f28cf5f319ad145c7a9be10d929d011d1928559c86b1f56ac22a10449c00b6a0ace712726b07bff4bac36b890c8ff1f8ef19d56e2539318fc583e31711e1d507e65442390818f1ccbfb22f9e5fa0a79a73f7b7fc234b22dee81e784131a5ea8814e44698d9b8815f3be7c6bd3cdf3ed8714e5759413084124c4bdcba338c5b8995ac80365894bb91357421fd7b35585a4ba769edd42643953fea2c5b4c3b2acdbbf2d33df5396b45a11cd3689d7d6b0a5c22c524e5a96f823ede14c41a193bb2bd61306747139bfa98caa9203b16858bfcf4091ec7363093284a32ee4d0fc080cbaacb187eddbe77e5ec76cc999ad3e8f8ff8476ba814bb89d25564bef55339f6d2250670309175e1b15b20cc3e1e651c8b6a996000fc76e42e6d187c3787bc1ed9e3bbb09ea4f050488a707db0c46f3651000dadc16301938a64a1008b8e1dafea243cc5b4117c871e300664a5aa3e19428ef7a28489b1f85ad7e16d2554840ffc13ad79f5e68ff3ef309a8587f02b50b14b06ca51f9f1e192a6350e3878795b5cd4e275f9f4c9afbb8ae4432892a8e05b17e5d33819b6fc496d732add7aff3817602d099db0adb5695bc836679264943da9973c54fe9ece290553f70d737dbc4ede36a279e40c61ca38eb47b6d6a1059230bd42c39009948eb353a100c3a2f73457b6da6b96b</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码以阅读这篇私密文章。</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">此文章已被加密，需要输入密码访问。</summary>
    
    
    
    <category term="面试篇" scheme="https://Dragonliu2018.github.io/categories/面试篇/"/>
    
    
    <category term="华为" scheme="https://Dragonliu2018.github.io/tags/华为/"/>
    
  </entry>
  
  <entry>
    <title>MAC地址泛洪与欺骗</title>
    <link href="https://dragonliu2018.github.io/2021/03/04/MAC%E5%9C%B0%E5%9D%80%E6%AC%BA%E9%AA%97/"/>
    <id>https://dragonliu2018.github.io/2021/03/04/MAC%E5%9C%B0%E5%9D%80%E6%AC%BA%E9%AA%97/</id>
    <published>2021-03-04T13:47:39.000Z</published>
    <updated>2021-09-21T15:50:01.471Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-理论"><a href="#1-理论" class="headerlink" title="1 理论"></a>1 理论</h1><h2 id="1-1-原理"><a href="#1-1-原理" class="headerlink" title="1.1 原理"></a>1.1 原理</h2><p>　　MAC地址欺骗是数据链路层攻击，它是利用<strong>交换机端口学习的漏洞</strong>，通过客户端向交换机发送欺骗报文、攻击交换机的CAM表的方式，使交换机CAM表的记录与真实的主机对应MAC地址不一致，从而使交换机将报文错误转发给攻击者。</p><p>　　MAC地址泛洪攻击，每台交换机的CAM表都有最大记录条数，当交换机端口学习得到的记录大于交换机CAM表条数上限时，交换机收到一个网络帧，只要其目标主机的MAC地址不存在于该交换机CAM表中，那么该帧会以广播的方式发向交换机的每一个端口，此时的交换机就相当于一个集线器HUB，我们就可以监听网络中的所有通讯报文。</p><p>　　与ARP攻击不同：MAC地址欺骗改变的是端口/MAC地址映射关系，ARP攻击改变的是IP/MAC地址映射关系。</p><p>　　MAC地址泛洪攻击针对路由器不行，原因是路由器仅仅转发特定地址的数据包，不传送不支持路由协议的数据包传送和未知目标网络数据包的传送，从而可以防止广播风暴。参考：<a href="https://www.cnblogs.com/Lynn-Zhang/articles/5754336.html" target="_blank" rel="noopener">交换机和路由器的区别在哪里 一针见血通俗解答</a></p><p>　　实验网络拓扑如下：</p><p><img data-src="https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/Snipaste_2021-03-05_11-19-37.jpg" class="lozad"></p><h2 id="1-2-知识储备"><a href="#1-2-知识储备" class="headerlink" title="1.2 知识储备"></a>1.2 知识储备</h2><ul><li><strong>MAC地址</strong>：它是一个用来确认网络设备位置的位址。在<a href="https://baike.baidu.com/item/OSI模型" target="_blank" rel="noopener">OSI模型</a>中，第三层网络层负责<a href="https://baike.baidu.com/item/IP地址" target="_blank" rel="noopener">IP地址</a>，第二层数据链路层则负责MAC位址。MAC地址用于在网络中唯一标示一个<a href="https://baike.baidu.com/item/网卡" target="_blank" rel="noopener">网卡</a>，一台设备若有一或多个网卡，则每个网卡都需要并会有一个唯一的MAC地址。由网络设备制造商生产时烧录在网卡(Network lnterface Card)的<a href="https://baike.baidu.com/item/EPROM/1690813" target="_blank" rel="noopener">EPROM</a>(一种闪存芯片，通常可以通过程序擦写)。<a href="https://baike.baidu.com/item/IP地址/150859" target="_blank" rel="noopener">IP地址</a>与MAC地址在计算机里都是以<a href="https://baike.baidu.com/item/二进制/361457" target="_blank" rel="noopener">二进制</a>表示的，IP地址是32位的，而MAC地址则是48位的，通常表示为12个16进制数，如：00-16-EA-AE-3C-40就是一个MAC地址。</li><li><strong>交换机</strong>：主要功能是在局域网内的主机之间转发数据帧，工作核心是<strong>端口/MAC地址映射表</strong>，这张表里记录了交换机每个端口同与之相连的主机MAC地址之间的对应关系。交换机接收从主机上传来的比特流之后，要先将其缓存成数据帧，然后通过分析帧头中的MAC地址，交换机就可以判断出数据的发送方和接收方，在映射表里查找与数据帧的目的MAC地址相对应的端口。若找到则发给目的主机；若找不到则以广播的方式将这个数据帧向除了源端口以外的其它所有端口转发，从而将数据发送给了目的主机，并记录端口与MAC地址的对应关系。</li></ul><h1 id="2-实战"><a href="#2-实战" class="headerlink" title="2 实战"></a>2 实战</h1><h2 id="2-1-MAC地址欺骗"><a href="#2-1-MAC地址欺骗" class="headerlink" title="2.1 MAC地址欺骗"></a>2.1 MAC地址欺骗</h2><ol><li><strong>准备</strong>：没有交换机物理设备，vmware中桥接模式中有虚拟交换机(但是无法登陆后台)，所以只能利用路由器测试(也无法进入后台)，只能查看现象了。</li><li>此处未进行实践，可参考：<a href="https://blog.csdn.net/redwand/article/details/105388491?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-0&amp;spm=1001.2101.3001.4242" target="_blank" rel="noopener">MAC地址欺骗与MAC地址泛洪攻击（eNSP环境演示）</a></li></ol><h2 id="2-2-MAC地址泛洪攻击"><a href="#2-2-MAC地址泛洪攻击" class="headerlink" title="2.2 MAC地址泛洪攻击"></a>2.2 MAC地址泛洪攻击</h2><ol><li>以<code>kali</code>为攻击机，使用<code>macof</code>命令向网络中发送大量网络不存在的源mac地址，堵塞交换机(路由器)的CAM表；</li><li>攻击前，<code>Win物理机</code>可以ping通kali、node01、node02、node03；</li><li>攻击后，按道理此时的路由器中的CAM表中存在大量陌生MAC地址记录，但是目前无法查看；现象为：请求超时或间断ping通，但可以ping通外网及局域网内其它主机。</li></ol><h1 id="3-存在问题"><a href="#3-存在问题" class="headerlink" title="3 存在问题"></a>3 存在问题</h1><ul><li>没有物理交换机，虚拟交换机无法登陆后台</li><li>用路由器测试，但是无法登录后台查看CAM表，可参考：<a href="https://cloud.tencent.com/developer/article/1482014" target="_blank" rel="noopener">小米路由器开启SSH</a></li></ul><h1 id="4-参考"><a href="#4-参考" class="headerlink" title="4 参考"></a>4 参考</h1><ul><li><a href="https://baike.baidu.com/item/MAC%E5%9C%B0%E5%9D%80/1254181?fr=aladdin" target="_blank" rel="noopener">百度百科-MAC地址</a></li><li><a href="https://blog.csdn.net/weixin_34234829/article/details/85088965?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.baidujs&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.baidujs" target="_blank" rel="noopener">MAC泛洪<em>*</em>的实施与防御</a></li><li><a href="https://blog.csdn.net/redwand/article/details/105388491?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-0&amp;spm=1001.2101.3001.4242" target="_blank" rel="noopener">MAC地址欺骗与MAC地址泛洪攻击（eNSP环境演示）</a></li><li><a href="https://www.youtube.com/watch?v=FiDq8g0gBsI" target="_blank" rel="noopener">亁颐堂现任明教教主CCNA Security 2019 7 第三天 2 MAC泛洪MAC欺骗</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="网络安全" scheme="https://Dragonliu2018.github.io/categories/网络安全/"/>
    
    
    <category term="MAC" scheme="https://Dragonliu2018.github.io/tags/MAC/"/>
    
  </entry>
  
  <entry>
    <title>ARP攻击</title>
    <link href="https://dragonliu2018.github.io/2021/02/17/ARP%E6%AC%BA%E9%AA%97-%E6%96%AD%E7%BD%91%E6%94%BB%E5%87%BB/"/>
    <id>https://dragonliu2018.github.io/2021/02/17/ARP%E6%AC%BA%E9%AA%97-%E6%96%AD%E7%BD%91%E6%94%BB%E5%87%BB/</id>
    <published>2021-02-17T04:03:04.000Z</published>
    <updated>2021-09-21T13:42:59.576Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-理论"><a href="#1-理论" class="headerlink" title="1 理论"></a>1 理论</h1><h2 id="1-1-原理"><a href="#1-1-原理" class="headerlink" title="1.1 原理"></a>1.1 原理</h2><p><img data-src="https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/Snipaste_2021-02-18_14-20-42.jpg" class="lozad"></p><p>　　ARP攻击主要是通过伪造IP地址和MAC地址进行欺骗。假设A、B、C位于<code>同一局域网</code>内，A是PC主机，B是攻击主机，C是路由器。攻击过程如下：</p><ol><li>A将包含目标IP地址(10.0.1.1)信息的ARP Request，广播到网络中的所有主机，源主机A的IP地址和MAC地址都包括在ARP请求中；</li><li>C确定ARP请求中的IP地址与自己的IP地址匹配，则将主机A的IP地址和MAC地址<a href="https://baike.baidu.com/item/映射" target="_blank" rel="noopener">映射</a>添加到本地ARP缓存中；并将包含其MAC地址的ARP回复消息直接发送回主机A；</li><li>当主机A收到从C发来的ARP回复消息时，会用C的IP和MAC地址映射更新ARP缓存；</li><li>攻击主机B向A发送伪造的ARP应答包，在这个伪造的应答包中，IP地址为C的IP地址，而MAC地址为B的MAC地址；</li><li>A在接收到这个应答包后，会刷新它的ARP缓存，这样在A的ARP缓存表中就出现了IP-C与MAC-B的映射；</li><li>攻击主机B向C发送伪造的ARP应答包，在这个伪造的应答包中，IP地址为A的IP地址，而MAC地址为B的MAC地址；</li><li>C在接收到这个应答包后，会刷新它的ARP缓存，这样在C的ARP缓存表中就出现了IP-A与MAC-B的映射。</li></ol><p>　　这样一来，A与C之间的流量交换都会经过B，可以进行<code>监听、篡改信息、断网攻击</code>。</p><h2 id="1-2-知识储备"><a href="#1-2-知识储备" class="headerlink" title="1.2 知识储备"></a>1.2 知识储备</h2><ul><li><p><strong>网关</strong>：网关(Gateway)在网络层以上实现网络互连。由于历史的原因，许多有关TCP/IP的文献曾经把网络层使用的路由器称为网关，在今天很多局域网采用路由来接入网络，因此通常指的网关就是路由器的IP！</p></li><li><p><strong>Bridged(桥接模式)</strong>：将主机网卡与虚拟机虚拟的网卡利用虚拟网桥进行通信。其网络结构如下图所示：</p><p><img data-src="https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/v2-0e29e8f13495c269f3fdc723aa2255c2_r.jpg" class="lozad"></p></li></ul><h1 id="2-实战"><a href="#2-实战" class="headerlink" title="2 实战"></a>2 实战</h1><h2 id="2-1-断网攻击"><a href="#2-1-断网攻击" class="headerlink" title="2.1 断网攻击"></a>2.1 断网攻击</h2><ol><li><p><strong>准备</strong>：<code>kali</code>虚拟机，设置桥接模式，否则断网无效；</p></li><li><p><strong>查看自己的网卡信息</strong></p><p><img height="300" width="600" data-src="https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/Snipaste_2021-02-17_22-40-47.jpg" class="lozad"></p></li><li><p><strong>找到目标IP</strong>：<code>nmap</code>扫描内网(命令<code>nmap -sP 192.168.1.*</code>)或使用安卓端的<code>Net Analyzer</code>进行<code>LAN Scan</code>；</p><p><img height="300" width="600" data-src="https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/Snipaste_2021-02-17_22-04-15.jpg" class="lozad"></p></li><li><p><strong>arpspoof进行攻击</strong>：执行下面命令后目的主机无法上网；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arpspoof -i 自己网卡信息 -t 目标IP -r 网关</span><br><span class="line">例：arpspoof -i eth0  -t  192.168.1.7 -r 192.168.1.1</span><br></pre></td></tr></table></figure></li></ol><h2 id="2-2-窃听"><a href="#2-2-窃听" class="headerlink" title="2.2 窃听"></a>2.2 窃听</h2><ol><li><strong>开启IP转发</strong>：<code>echo 1 &gt;/proc/sys/net/ipv4/ip_forward</code></li><li><strong>arp攻击</strong>：<code>arpspoof -i eth0 -t targetIP -r gateway（具体参考上面）</code></li><li><strong>窃听</strong>：<code>driftnet -i eth0（你的网卡）</code>或<code>wireshark</code></li></ol><h1 id="3-存在问题"><a href="#3-存在问题" class="headerlink" title="3 存在问题"></a>3 存在问题</h1><ul><li>攻击局域网其他系统时，kali虚拟机可以上网，但是其宿主机(物理机win10)无法上网；<font color="#008000">开启IP转发可以解决</font></li><li>窃听时目标主机虽然可以ping通，当时网速太慢且不稳定；driftnet无法正确抓取图片；</li></ul><h1 id="4-参考"><a href="#4-参考" class="headerlink" title="4 参考"></a>4 参考</h1><ul><li><a href="https://baike.baidu.com/item/ARP/609343" target="_blank" rel="noopener">百度百科-ARP</a></li><li><p><a href="https://baike.baidu.com/item/ARP%E6%94%BB%E5%87%BB#:~:text=ARP%20%E7%97%85%E6%AF%92%E6%94%BB%E5%87%BB%E6%98%AF%E5%B1%80%E5%9F%9F%E7%BD%91,%E6%AD%A3%E5%B8%B8%E4%B8%8A%E7%BD%91%E5%92%8C%E9%80%9A%E4%BF%A1%E5%AE%89%E5%85%A8%E3%80%82" target="_blank" rel="noopener">百度百科-ARP攻击</a></p></li><li><p><a href="https://baike.baidu.com/item/ARP%E6%AC%BA%E9%AA%97" target="_blank" rel="noopener">百度百科-ARP欺骗</a></p></li><li><a href="https://baike.baidu.com/item/%E7%BD%91%E5%85%B3" target="_blank" rel="noopener">百度百科-网关</a></li><li><p><a href="https://zhuanlan.zhihu.com/p/56658358#:~:text=%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E5%B0%B1%E6%98%AF%E5%B0%86%E4%B8%BB%E6%9C%BA,%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AE%E8%80%8C%E4%B8%8D%E5%B9%B2%E6%89%B0%E3%80%82" target="_blank" rel="noopener">vmware 虚拟机三种网络模式—“桥接、NAT 、仅主机”区别？</a></p></li><li><p><a href="https://blog.csdn.net/weixin_43343144/article/details/102679135" target="_blank" rel="noopener">Kali Linux使用arpspoof命令进行断网攻击（ARP欺骗）【VMware一定要设置桥接模式，否则断网会无效】</a></p></li><li><p><a href="https://blog.csdn.net/weixin_44839457/article/details/108333653?utm_source=app&amp;app_version=4.5.2" target="_blank" rel="noopener">使用kali进行ARP攻击与欺骗</a></p></li><li><a href="https://blog.csdn.net/qq_42039946/article/details/112968942?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control" target="_blank" rel="noopener">使用kali进行局域网ARP欺骗攻击与监听</a></li><li><a href="https://www.youtube.com/watch?v=ko4VvZuO4rs" target="_blank" rel="noopener">秦柯-ARP攻击</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="网络安全" scheme="https://Dragonliu2018.github.io/categories/网络安全/"/>
    
    
    <category term="ARP" scheme="https://Dragonliu2018.github.io/tags/ARP/"/>
    
  </entry>
  
  <entry>
    <title>2020年终总结</title>
    <link href="https://dragonliu2018.github.io/2021/02/11/2020%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>https://dragonliu2018.github.io/2021/02/11/2020%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</id>
    <published>2021-02-11T00:48:40.000Z</published>
    <updated>2021-09-21T13:16:58.913Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误！请检查后重试~" data-whm="解密出现了一点问题，你仍可以看一看。">  <script id="hbeData" type="hbeData" data-hmacdigest="6e100be63972fc508ad2ca1eee4b73c10c79f6869f561f7e8f629d89f73cbc59">a1edaa97922bb2ec7906d4ab82b474d6d8aa50d47dfcc79a7863314b6f8ebdcc5e963f9cf1da89f851d21298076f8fe899a407018269516a7430d6ea6f1e8a44acda1ade9a52a21f69cc2493bdc26a1a61ed126fdfe3ac93069c32f21a9d42a673cb1a47536d70574a33cf548b7c4557460f4517927dd21c1f458a4df0ec6fdf29ccd7d25ed9ff5a2ad2bc167a591f81ac2520bccedbdc5d60bd836898acb50181db84a82b23ce2b9915638fd14ec799badb2fa956341e0efac431e18a52df03806976124d19670aecda4dd6f1d7c1f07a4ae6ee789a25fd553e851c8e63d0725381a17958f0ece7a16ba348044d896b379651f29fbe17957736401d2ae0a4b419157ffb4a61cf9886938f524925a8d6adc9ee74d1116216986591807d5bc5017cd29ce69b882e43e4b945fec8a4608f2a3c5c6d28aee151fdf11221ad7166890ca2838d780b541bd17f2b6de41fe72cc5c6976c67e2d77e2167f3b6671261a12ffe094f28a546f821c0bb32fb3af488c07381022602c00ecb12461804f84863128a1563c345f060bab3483adc75df60335967cfc66ec00e6ef2cc9c6e4c5485258942ac1cd3cb7abd3d6c018b1e29f2ed592f2579350f2a039a002388532371619ae995a922a8f0643222e818caf521c1a5e03ed7f31022e9da0a4e471aac558566cb117831f2fb9bee4588b41b6799eaac2b4f31f661033742187746cd2a85c074ca7a36feb6f744f31164fff600430c942def243a96b44743da8fa488cba80dc5feff3f2e9721fb0ef8661da764dd935eb3460f27c5829669d8f5a2db5f086a899a07c2457154f59aaab8612f48201cc726c2c4810c8822d265a423b6b33fff2b5260f766a4164375855ccb2ff5981a5d1ae17097a92f4ab82ad5ef8dfbde38c9236b031ebd45d437d5ccd68967e01bfe5b419d0186e053a26ecbbb3483c4cbe49f5ab28319ba57a25ac0175a107ecd5dc7b622690f86f6019de33097be5d4c47562eeb45f1e90b4d1a512993d4b90cc771e9c8bf20582142d12c3230326475d704b2ea05e2a43ac413cf87639fa2dad97e21bc69ce2d116aaa2f67a4ee1e1084ee3b0910bda21578eee53b3a8c63be6ee2abf1a6820cc57b6443684ce1665a6521b9ec9bb89b255571c58c71d9561a1ee9afd4a87055c844aa227f6fa0c90d6ead8aacfedc1eae12823d212981dfa10213db53547324bc471ace20d416095f77748436f77658f3e00bff7c6681193c5838f6b782f11291a9beeed00b114c421534230e3bf6ccd4c145f91ff8b4db66c383f3691648e9edd261c11094ca9572b23fe5a2cc93363cad806aac3761a5207bea7c437ba5bbb4da8a0f4816a25948021c28eab29014b81cdcd76f72a5890b18d36cc079faa4989862fc55640ad704d4673c7ced237287723c83e5564c4f563e03e35130d27e80a944538c57773b234ee915dc89ada781562bbbf8437b01f32fe5ca2a5c3358faf7df63cf14fc189674d63996106f76edc5aa8b4e5071fc4f32727ec487f464a0527521ccca8b5e7401b17161543dabce931c4733b7236a7035cea464d95f082de0ef62bfa624a2c731eb138556c26dc333fb9be5715ddeea40f7d59247d5f347f6da861090b059fe43cfa3555670c732b9048c0c2f8047724135f38a8546e08e24f4e7681ddf9da56a70629babd76b56e8efc52999ec96774d06b5e770f2a0511800811a3d2f469e2fb29201c27d7bd6ad609474ab8ab8780da7f439bb742533eb05eb0f00eed79dcc620b898803625f0f4aa7b48928ff09fedde449747ab1d413150dbabdf6f8f86e4f2bd8d148cd1a3e650617af980aa6810918686f3c37e0a314f7b18ff9a1ab6a066959172037f9a55049ed22edfea5cc2791d4bc11473c839564ee8b85a869a5439acd8b3bd15871efc0661494b0d9f4049c0fe68d976e020ad1cd8a0825ab2c6cc9cbb888375f99875e06a0458635e15ea84233202fa7ae2657e0eb68728b5948881ec1bfc1d51a3e18a0d6852f8ae7a087c3c9807892acfe3dc8344471327a67eca8c8a0f3002b6b19f8318fa776cdf85ed067d9f1dc96a573b9fa528ce5c707ac64064786f9cec4a96113b755a63368044357e1084d5f13d7d35e97ef8da99fc0d265938a1c150830977c7ba7fcdc72509ac86c313c1a5633e5ce87a1b489f657b90065219ab921685eacd545b00e5008317ce2568440906e9bbad4df8e92b7ddc7d98e0d6997ec40f0cf39c7d1a098873241f09ee5f6e7221a0f268ef26522079f668469677fb80c9c924b8b92c5f3692bddb7e9a5a7ac91d178619867229baf33bae458e0fc6ea98c430090f3ba4e733ed674006b3da6f30e496f63156f2f8eb506b2eee6994e5703c9dcd4b51677d709a7798d77f34d8c98830dcf764281ae7adc89318d6813c0206f62757a3566cf81c14b6e8a21777cdaf76fc5ef73c36c2a55930f1ce2f723a990dc7a75dcd9f1e10c17ea08a7b23c5a54deb75a26e4401cc8b574656681dee28fb1e8e86167dd485a0a4387b2302b02bb6f3268419800c2e50b6658700343a954a39d9eb1bdf2d124875b2e0b23f9ecb6a3c814d67e49163c0d26f7da8535675d889ca536de80f1432c95b486b85dd933d52c79bf75faa6c0d3548d73a691a1bbe93004cd73a3e9174ac2de3114d42f75a71c885bb0c714678a25bc8632fb4ac3042d3071db466286f46b07d83d1ddf7847456bc6c48055eb7472c4732d61d57247f9ab296f7ff2aad0f0a158496fa9fe35cd704fc7dfd92497c298cbd6f4924413815968553e8a63b53d6ec12ddbff27d6e3b30cd6aab677e166fe5766a67cbf72e679f92be7dcf3f7a5decbc6fd55ca48941dac32fa2c57d11e6bb1e010a0685a25a7ef0027dbbdf66918f3f7f3ab8de19037632e9ef6f0418cccbd894a3e536fdedfcebd8ab45a7983caa88738ddb3fc50fd2967d20c8a78f9819cf5c82ab2ceb66089b567eee17ce4d3945116638f9d6ddbc5c3855a48541a5a3bac92e809af789f571fdb7d7b0deb1186857b1506ef7a904686d8d0ed67c5946dd0bcc504edf05c8d664434f05b4874b900d9019443a68a332e450f474308c96d94969b674c43805d61fb4a083cc27092a76106e90a408fb0cffe708516cec5b0d187db3f3b042ad25ddecf53bcdd8cdf424be95cfe8589dfb5476a9a872314436699b0fb0a5c25cf6f0ae58ed4f4ad47614e7f3d95fb99c13a906d5750cd23160602a1944c61ff2ccb412ccea43344b5e077fee1e45181b4a21e9c7f23c27ae396e19c305c643c8c96ea2b700348c86860190904401bd313cba21849eab6dcd429664b4400e4fb705d741b53f8f71e1b50fb3d1f2369092a73729c83d70909e3fbaa2428d1f06a102482c23af2bdd4df75fdd0aec16de1f1d39afa0e3dab14756e4000c60772f39efd0bc9177cdee2a79211c3730fb094bb4333bf95d9edd16eb96494b19ea112eee86cae6ecebdd1b26eae9d815392b41289ab9872e2f55952e06b71978bf6f9a8f0bee53dcaf437720f6911394bc7b14b6da54fdafdb0b57986025f6d39b3e4c0dd2e433e5251bb314781697c32efc69d60df44044fc0bc51aedf27f0b29e3d5de01eb4e9eed0e5227e4e4f5eed46d21dd3d128285a7333acdd73f8c951fd5a4abd09b3c7a0a39ddf61bb17f3a084d8687deff13af9df79b527ffa8b876be66d25d08d22738c17d0368eda398df01c2446f11dc3f1088cb678a51e9c452bd93820344a686c275341fa1b29cc6040f7e037dad33ab7b8b370a810de7ecbfe801cedcf5aecbbe75874006ab9b5ed21b21f6c51842b7fce794143999a1aaea7693f6e8e42604b7bd1c89c5b28cb9dda2c76712cc847642da0db9b1e9621a17327b02b6fa003501df85869c935bfba12ac18eb2e36a48cb5c0d35143012e5e756c466888f823f71854400e2b686fdf8525fc5712b87d2e553b58a7c9fafcf64027e50432435f6b588a0ef18bfc8fb81e0724a91fb85a28ca9dc9edc86900e0ceb68b8197bf1d746e2677a2d473f37c67d31f0460a345babaa8ba62dcdb47e29a09c2ea657bbe2eb7fe0d8d55bf10714df225ba0395ddbad01ad5a056a11a5567ea3b60e05ce3a68fc59f05091a057c2c5a9de52f99e3fa6733aee3de1d17119f93c0d2f6277569cd58980a8a972d1912a5a584a140756554a6cb548108e0492f7f2b6eff5a89cd603c32d75d94811f8ea6d2f0c74934f9adca70badbabc1d234e06e3875911ac1b3db5268064c87e4dd02fe2ae841ad4db35025de007173ffbc19757f68955f7e2ed83a049eef5a84550f704905b390d26e8b438b8e3d898dd861e10eb620723a47dd195cd1e27106c0e76222b112e66ad8f66da6e524ff4e849faaa5817d66231f78bbeb7a8bdb214dc39124cbcfcb60dc4d1b8feccef74db798097057f26fa77c638b40deb9810a10badb8fa302756b3a81f2332d368008d4dbff833177f0d60fcd3ae7f55e956f0c885ec7e8a33ccf816283834338f9c5e937572f2da7cd48a489ee2571174fe99c475ef8bb0ad56d55f6b626dca6a7bea444d020d090eb3709c67688a5602bd914dc22c93ca016a1e980d3bc50648ed7be840a57410af4a2e0770ae19dd3b0e0175158eddbf075005c3981ef3c5769519b6717cf673fc7b5d3d150697ce3465454a52cf15833c14a7ce67c50c98372b93ccb0e3cf77793c4e7d212d9d79b75c834097d4dd70be1c9a4715a344d7c397a594a71d3c8fc766491b607b7b2dd473ccd58dbcb0ef82aa0983c2b2927c5d454da208d6ee06eaf26996107a8b765fea0addbc5fcf877c8c2ea37127a3a0d706d4831441e64abc38b0d5de74a125bfed1203d44bd5c9d16a7e60e7eb547b34f94a3fc4e7f7e995c57061a010339316a8ae6a9397b29f0fcbf59be1ab58fe1f1754b08bdcaa6a2f669686f2cad52a71f8e1d3f64cd5ed630abcf1c350c4b829ad63149b5d6f5bb64c6e9d2b8e3e7ecda93d8049ed92183d4f2ce7b059b78e20d90335b607d03b85e81ab9b6405a430b402830e2e5611711c2a6739ce5145b35206c921bf3a390b68afd1a26c24bd9eef45014e1a1d71635ba911b04d0a21ce70bbd99b2f01377093ba577af702222f9ac2849ce86306b6dc7757b907c43fc77a8aa5a3ff9fb6c3da0f4402ca7a888aa7b34b4ebd6d5412d3df1635062342774ce7a2e00cbb76834ac00c8033646d2d0bbb7d5e242ed686a1d7a3d1a4714996a944ee5ae81ce90ee41f357d54324b51378ac94799105a3ca8dbb684e4991895189483c0a7237dbc4a8cd91005ee027111ae1b4327624dcd65db154618bb02219a6c0ecb19307f48136514e7d2c176d5249c4b145ededd72c6a28a48b6a9ba6639159ff85f38e13ac7916b4496fc9258986f6f505e0bce1a4cf58b49eee29dda9ef800f0c38ee2fa5ee04fa89e77629c61625fdf5f0751ee8f45bfb0efea9ed0785ad0d8fdd48f9e76600c60bc86cd67783acfaa0849bed12659a88bc9330dd1ab027efaf42edd60d2605a6db1371fb64d7935942ecb899b0dbd943a514765db390afa0eed74588e7e151c1ac3c899bd3a48a62c9dbdf61ca3f6644dcef8704110b366153446332343d3ba2eb2e1d304bcb060f5241bd0a60808fac1773b95cc5364d5fafe4b5e8471ed283704eb4b8bada2d80115839be4aaddf7087e5e80d4033bd39e243454d02a290d0723a47b6e97b7ae8c8963267bfd42873086178fb5bc9e1398e0b4728d4a90f69023519ade4ce9b38c762e1a17c6447807afdc3c96f565e27e9342815a24a144c20101ec4c94ff8a7c47e72a0d00c09396185e524bcda9d9ef9ed9550eb6663696af8465db6d6a78a1e0003ec3e4495fe5fccc4c8a6ee961fb47cf695b8a6f3aecf1062ad2b29a9aa5b53310f86b868a715f5a6893ab925532fbb124f8a9a7e32c94ca2f39abcf7a622199279f1985c114ec2eb5583cb3172bd43411851f28181f7ecaf15149dcaec8a36889b9e390f7cd14e87bc1b28e0210de319e974b0080604e5e2e7f79f51a34cb90b061031e265a63bce0b89adfd78988de4cf66547f0863f689563f5f3536cc32d4dbe9e2aaaf643aecd7419db33f20ed323caeabc28e6bb582998d1eda5d7a2f4e21d73a0027bf238bb2d95015e3017f1412d83b4eb4e52a056356ee1dcc0cfcd796ac3e4e6b43c02975fae698bde11b350c8ab2f2d53486613b8b48c12afe68fb134ac19dc55a62209add59b5e47f39adb85935fbc9ca0c74d5788cde109e9f5996cc7c793c9a58fe53e4b6a0547966420179e436b21347fdb7330d0c2d2171d58a03caeed0f294c41eaf12f6983b0880b8fa72ea964fa3978ecb4af8dba9e0211ff14f078b73a60738035eb264436029e5c09d0d3fe0770f1643310be88513e8e2874e8eb6b36ea0ddbb32c30cf3ba68853106de1d1042756bc0617348f275e42c4673c907faf60bdea2c36faeb64b687a866b1b08f934ae20a48b802959c6d0c609c7d04eee6ba729ae4b45c28fab9e86a2687f63174e07c9d1eb7fe53450299a56ad8409f8a0fd5c3e949044fa97d031b69af010332c10235a114641fbc266d4ab51c9692ece318b0969cd550933095dfc4ae3da64106ec16c563322a1f381ada80325e9cd10a80f2176da15907c82dfcae961af31b291e2db23b84deefd158174c524c31ce32a43bee04875fbd8d40b528105a2a2985f9288c5d814c754b8823b442d0a91e7056923dc99dc476ce7685b2d7f96aab9c5e8d1f92132b9b0aaa1686808a341f06240fd6fcde6b8b603795f12c1e7625ca74e9e676b0256f8547e266997ce89c2835208ffa7b964c8476c841c62bddf75c0095e9498f6fb54cb56fa1281e5f2fee7adc576e3718315a409b5bd5e4046daf029683885f4f48210cfcb3ff36cf1b63104b2ba04732188e102b57906204a27802db235ad5b014317b425f299e871ccec10c89930f8339a8e2746d88e889ac4abf4b4ca6829c59230f4edd8e3d40341118f3edc86349f9278a39bcd0e555f90322a8a91539e25a16990533ea681d6e94497f4a806f5a909bc2937d67202c7a7c4e04f24d4550e12bb2b40f77eff57754d6adb7f1d9e412dcb50b40699e51c1d4a8335fd8ee50dc0519746d7037ff30232dd6d4b6444c9176d044d05b21f33ebc2fb51a656796a93f41b5fc2b7f8a532c86e15f4358d66ea0b6de564923bd64d3c5d61f447f829d92c26aac5aa9dc5a36f23787324854e4361a7c1b1fecabbc3087186aceebe4fe824fd1011655f0ada4f55206bca6fa63a13bce85ee209663e93540efd5a51446f4883247599bd9d561446d988bb4a392d8f74f2b37f93632b2a0170d674cae7eb34897065a4cf70177ff5a3a7dceabd0b8192d258e0e465b230146e7d24ef5d76cf64904927094ec760410a76c1aa084a52f4c8a97ec272cadb96441d2ec9e1b867546367cc8bd526781558a1bca5a5fdf97b2325a1d93bc17c8c403825eb4ceca712da8c7ce0d1e69c03baff72040262ff69976a85a666c3337c305eacc4a67ddc17d859e4f7356c8169b9b3b5d7d4df394913cc9210a5376718813efba01cc0133b040fc4e56e2571e42a288f7bbddef060ea2c3678e63dcda41e229a267812e3a4c8e4f6debc0418a043e3f0e8933ce8e976ddfc196d3782cf14cea430b17f02badf8634a81bc7cdd7b32c2a317f6e6728af08a86d072634907f0e5cfccc1ec4b21f0532ff8361e4bf8f3dc2aa6f5cb40bd060385bf31259a328c1479066cbaf5b2ecf1f48a425d7a9f060521b085f93e8843b9f023b55e53752c2f13422e7a03c1ccd5bedd82dc718b38cfa1583574723d16198378c3cc482552ecb0b2b801c224e60a58e055c5c8b4d04192d4abef9f45753af5db60fe2db4ed6b281243a0da0f13a71d417182cd0b9027b722f8cf1e985036305a54af4a03fb438e1acf06331cd3b78acc4e0369adad2f00afa6de8b41698c522a00f244e3cb2a44755a082407d2726459c6368b97c57bbbf3637d30297163a4308ae2b86e4bcc09f089702e45ee655d53331682ad08f93c699b372de1715c7c7ceca8fb7dc8541c7bfa2fc42838b59868bd0058f3e90bc0ca43dca019ca61ea591a0b368e33546116b5ab7269e849e888414cac0d922c7abf31df8658be9b753c472ab692b5c566f9bba2a52a20fb23c91c4a78b7de546319cb8a3c93cef0253ea5814921c5c77d4674e251e1ed215c28bdc2bebb5c1fc5e28d67f016fe1b38bdaad6cf89844d9a3e8195f96b991d6c9a258d215c0fb1b51c76dfc21fe30912dcce6f5c0f6f4db1f5ffbdba078e02cad24c17d985cd8bbe71ba9d1995436bb72c40f90de545bf3b1c5006df6b2fa620108d729f96486bdabcff172646a3ae2dd79e2f39652187672e627c7cb0bd0a09587952fffed56bed0963f6443d02397bff9420fa0b879e97f36c4757874ae0480da5a123d2deb481cd7885ad4278c285543759138bbc328f09d25bd9f71ce333866713415eaae4a7292998ccd7279e56abd783456176dce6fd13d8fbfb28d3ea0fc63a16a604271fb55eb7134947c70c1bb2c7ebd32611043d8870e9effc29b67d5af61827a8889f7a5b4156fcbea0d81df83e7b76193621764e35e93bd25114eff1c8750babfbb3ebb7ab2f50bc91c8a27ea8a2ed814e5373caa3dcc29ea64032e981a52837a31c51f78c6f58d1c68f3461945495523f870988fcb86afd00f0bc81a568ed54dc16820ef730ebbd9b94502b52e78b3ca9943d009d0691abf2108c3050f066dceadc5894204b61c849f6422f4be1b2630a2fb0c68574c6c2b4c8a86a4c234eb642a77751991fb4f85b50a842bc96a43f358acc4fbafbd19bed60e54ed506e64fddf116e5a05278195dd4c74000fa7f262f153f0628512450d12cba44ce104f55da6e549421b26c3c336cc92baa6b87913814fd2a1869e4d9fdd900fcdf2273f323a51864d91a19c5d3742202671e875060c5160ef8725566eb53b7a95412ea2a93a086dc96eb64de383599b34f6d3f6562e9d15ac92d0800843096fdbc6bead67bd308b5eeb03fd4c2383c77f38f306081f4d93cd41aaed302a942b16bc0178e2f66aebfb9ca5b86d066f8bd1d79b1c81fd74093125908f433f975be9326ab4c9144917eae8261536063a0b21116e710bb26510b1312334b6a0f69391e278b553a1a0514ad8997895f6b59e7f594a8734d8955ad9b98d506c71477c004c9f9493b81f4e71fc22677a38b913d202063f178d83c8e2792204708926c87c39a9a2df43e8f19aba9336ea064cfaddac1b3e219e2692f17aeff5cfc1af49caab23eb4e912d4f23fad0b7b9c48481d865eb974cf87c80eb4d474835755f50ef50d1def312a3bad67ebbcc45e80eaf06349490c98123ed59c18a268a1fce4676568d6155f4a2e266a7c9b9700558a3afd06a8f44d4111c003f019c1a2ddf4577ca03fc8c0112c9f9a79de31c9be93cf10482b2aa3240cd6d91fe6f90362bdf66c8dc9a75b8a7bba0be6ff1d742f4423bf0e80d2cf34d4c5a7653fa3e6ad5fb05589cfc8dd85532eb48c1d1a5741c81ff43bf9642a3d7ef82dc4c89988ef47ad5701127bafff8688bb132b61b3557e27f2149ac5be19a7bb95cda146d568e3a45e27171a162226545baf309fd05d781e5fc54be81abc47d6ed73381fb04f90a63b52511a631f94810cac3e5247564a4ef3fef1fa7073addd68890b1201130f04f3a6d043f2da895098a1e3cda4121e363cea2915a45b353734246320f6ed1c04c9d74f87ceaa6be5548baede649627dc9f06cd0f1ab3505a645a9c09bcd2eefb524a8ba529aadcfed8ebf8c4c3ae6d265b52f86559373706073ec989b7ebd1164137a16f4a756d51e1c250d0151b01647f871fcb6291a089a29fe62ab15a9cacfe1db74d7ab06795c2813b62344fd5096fba61d67383968476e4d5e3747c12946eacb567ff11c4a71593e8305a6b685e227bee7c81668cba9cd163bc3efe31fbc751002a476dfd5eb8f1ae9135059048c9a855b06f78a4e82e6b7a22acc646fe520c51e9cfac277663e069703c05cfdf85ba07291eea0a64f3490668facf899b4993cba7ab67868419cfdf2e5d930ac41f2a5a956f1f5f8ec90bb42ce6d35a156a647e1761ec8c5707ad7c89c47d9bf81e2e732e5abdb255bf788b20f0249683193f2eb51910fcf0c39a58e74aeb35bb2636dc9abf99967247bdf6dd1b7ca6ec7a756fa072d9112230b2e8eafb229553a916c0315aa4a3e3de90489bc239a95bcc0084ceb861e067ea72efc6dbca7e4ccaf085cf2b76bb478d6c7a65e21fff17d4181a9c5f69db11fb9def0b6edfe62288288be539d69aee193491644625675f3753a547d557f1bfdf7dccbc4d86fe2aff7f727c0f2c5f14e1e7b8797f63f5cb8799471d5c781f82dee84429b3cb5618206edabef8cec7134a1f813edcfefe4bc4fc1f930eb19b9800046d18e4e24bb44425b6afc8b0cad2c64a6cfd6434fcec9367d68e579db0798a6e77614ec5dc3f885a6636a0d4e27d310b3371138f0976f826132782998f3a1017e2fbb78427c64c0e53485a6e3eddf0e9f7276a500acc070f8bab7166597c27126260f10d796aadb9107e9d608fe820b1e9fce41214f4390c45d709028782b0aeee2a186b214f6791fe72a5d0e1b49536ae06eadd040b4650afcf94042018ba864a043b7a3db989dcc64d716b9e334fa7ffb54370e876db16901c1d12904b49fe10d25236bd487c2a95db16a0c608ee2a7e886b58895c76372cd3e071e59eda6fefa7fef42fa9ed355fb90f566d2b434b8efb44c21e215f52d6bb06005c9e0dd144976a9172de907849fe4884d530e53b073906996db66901eda1e79a6999579140b9cf9e094501599b19f196180008f5a9576499a10b66657c2e11e9b48bfcbea2803607de5f95e1cd1078a0e1346fdb1e913fddcb82b7d264bb03bcbb8d0b352bb00cb723c8d6a636cbb51dd980440ab7022e2e62d2e48e8a0662b147522339560fa45338ddc945f04aa6648a2250ef541b8b9f15090459d0bbddc46581b4fb05d58e78d42e890e590f0b098e739df73c9b242a96102bb1005a9cfe98ff769aecb47a54e7f3051adc0c3063a5d5a5224ba7e87549d4fbdd791c4ae528b554473fa12cea0740a8f01be742f98298f7b3a052be5d4d76c07a461ff0e5622c106844ffabec15dd8a201f089da060ff79d1b8c76b760582309b0854d7548f317dc12022138a345cfdc7c9e462bafcc276356fa0a348cae1c57a9d1fbe57dcf42c2a237ef5c7b60b6c7c19321147fa6c8a5d4b9d23b29f05237bbe1e2cdcbe020370315d54098c0ddda414c4610f12f3e3c2bc1b5a916843d1189c695006c9dd2a873c6bd089d7e2d044aa508ee5485f7a482107da159bbc6dd9b3b5ac1aa74a0469e5478ef4e01ef73538e4b2044ac50fb5e1863ac43738ddab7801b3d7382504b2d2f03d3c19b456626b5e9f2dbbd0ce6329a82b3e00544f2477270e18a5a436f32e5fc89977369a6cde0607cb2aff1b636c6556d91e126c283b49a47786dfe595478d44f31666d0d74eb6a799f0713ecbbc749edd46e9a4325c61483a1a825c5fbba9e0201858c7a6a6b3e096f28c22a76c41d3420feefb12aca05e3af1d7b7865b62cdaec9df9a6b53a0bccdb40f47301decb947d287c698728d77f45695321fa434f63955fef7b2b1f5e27f385cfcaf15fa3eeb7487478c48963337b674d6b4223c19f195ab42642818146ca776b071de492ea4e8c0c59b0fad31c4d154e37f76840df1820275462fbe97adc7eabbec6ef0146042e4cf81548b2d5c95eb915cf2015b005a69e19b232bb0b4fe0a0080dfbb4b07b502685271a0fb0c61e5657b882063ab1a9dc8ad0d97941a9b13afe9e719c1abaa071edc04015022593604cb7dfa1be93e38c4f25d404f7289b1c92c873f703c47d81fc8d3dea15c9640b0771256c41ef2f5754db50e835bacf31d0df98732acef1c7596a2fd42226c1a4deff6600de866327e6c979183c25cfb3c4c7243ee81636546acae45bd993068709ccfdfd8767ec5d4df61da36900bb140581982181562c1f9a42dfca4c20927e918d2e6fb66f32de6fe20e8010094243377afabf7bf66f66d1dd60c43860ec98303e7e715cca955a076934166b1dc3fbc8fe181984dfd8245402fb6908688c394cc75544ee89e3af84a0abc2b1803e12e450f2a2200fc4da0ae415bd9337e3d62a82b6549debff63d9fe343b268b4014d4d223aec41e621e4e93802d4cb6dc1928f1b11d3921fed20fc3953f52ffcd365cbd9bf3a58b72e94dd4d4b0e9ace9f31b0f2bc718e8bddd98f7d414f37045df1e765184fa8254e0f4bf354abf5ccd2b82d6c8cbaead2a3caa564401cfc681feb4888b9a6cc711927c3037a725463e5c4bb01d10a719130d8034a8aeef8b207fbcfae97ca8e468f32992bbf15ef830adf48cf6ff6fde981725ba5a77f226e2059f631827699a67df207cfc2f873a3971bd66f5a95143d13ad0678287b2141561949ce2685fa30783c2062e3362e8f16577f482caa95320727db3a90f7af60d86c81525b2eb92779897e9984c560ba1e1bab9c9376c98b86b65c58e8906672a79cf90cca7a8f0fc22744ef74f2aeeb28bb6d7dbebebc15e1175ca1291491789513d350ea7e3708e80e1766beadbf53e6c1e9438aa696355b0a5e3b55f7313d5e417308915eb7acf3e3406fbcb40a98cf4866308c464d7e95b8f5c7318f0c2ae434638d4bb81b559faa8af7944a31ade9878b68d870016d561a57db01bed160c5dfaee0e8d772206cad0bf5408a0b2b508286d727a58cc612bdfaeb3971c1f49c117e0baab1a53968b00ed43d068f812a06e666edf155ed9f7b8d902d7de3469295696a83d22f8cc9df51de3676b3001a7cf2316c239361a65bc9b5d890fb042ebd5dc108f80a24c2fb40cf6ac181c22b79e7327b2d5b7b7fe6d3c6bb470ed7baf4e95c8719d7adc64cbc754ed85cef79a30075d94fc02ea1cd3508adc967526d8abce008311c3c2f78212041e4372876edbbaf755809581f093f7ea56336a1ca9b9958c2096aeef7a7e7e20e8d0f6ca397d58b5f62cdc2675c1a509b15de05b5aa4e0b15f8d45429ecd3ba2f7723d9491310f494e4dfae5bd5f72868066e8edfb2a1d6befe43b5cb3c92ab158693db70319e4236ab5f5ed297ffc548d290c241d66ebd9e37ccc634c9a5b9a8dfffe1e14a05abb98422fafcdda9dbdab188c5fc9d73e588159de39ce533393e4aae3b6de65c5edde1e6156c0592001b6f33f02d12088bf1584e2e0fa3d4ccaf05a147ddb04dd1b5812d4c7863114a6feefe813b48364dee90cbd66f862ed03f2a7b0c98bff5282714c13aa5642d4591c7cfb6f6f8775c6b841ec7f34fa91dc5694ed6b3b4d0c7c8777840976a17018801327f75f2775c83d93546629ae32cfa6d3b66cb548e20dc3ecb8875954854d5bdbaeb00e2ab8077a88cc3185333fc300b8c2380855d829a4606fce93a505ed3f606d7d1ac396b7bad6ab494dd070a5c57d1c4038bd5e7444dd26680e13698fbcb88b0db01ff64c5c3005ea7d42357c9aa5d097c38586bfc4837f7da755b6e93b9340e81e7c442379e67b0942de2041c58dace742b85dcd4eb1a5911d7c0efc63ec4e4e9ed768a0baa3b00cd1b805df9a810099e3e0e3d47d28ebdb491f93acac28b4be396c1c2c4ccac1ea67654af63f8f393753c736a1c1ce970d686d984bc1a262e096129fe38bf18dbd673e23e8681663e06e768800e61b10dbfc464ad119e0a2b9768045e9ac72b6a33ba5fe7575dde544db8766ff96770f02fd25aca5b83bf44c346cd16a5cd4f6bd2924080d8255eba6e154191ee24a9665ef883204013791f0f9b8c0e1a8c3248ba974d21b4e77bdeeec59668fa386c0e4f64aa4d71084ff27bebb3d2a6a82b6f78a92dfa67cc1dc4dd52c297dd0cb5c993f5135a39756c3b57eb0ade974bf6eef7b7d830e41658771ba278cb859fc388578297815b9b1e322367d78ded62ab7a915bfc14bda73485d37b23ba7d2b6c55c4ff41244c0f18af06df7e22aef89a0c70909f34f3c276529f21fe90dcf75d62695e956482fb0060f89953c07cda628d02bac4f516368a67fa9d87354edc83c5e2ae2242a9671d091cf9bf223657e0e1a0e4c3d8055c944cf9ece97db8bee9e65a3328baa336949f853ce27d69b65f90f799a953383ba18a0dd49272f23ebc1b205136e8d98107b8722aee13656e5b6965b57f7139c5a4058858ced1a78cfb9aded41de11d3d408d045e2ceb9b3d6946890846ec2cb520b5c2764aef5f7dfe309f63bc463f23789bc11273e6225086b39ca38d7494d39ea9861687f0ed5e9c76c8a343fa20fb5e256e8ef871f35252fa07c25be7f30b76e4fd667d7e0d76f2ddc3d3ad00b224fb3a06f5b69749bfb4b3a93cd2bba42d4be5ccd9fc8bf20061f69a411d57acd7ccc161d1516b4617afb504b5845a0dd30b428ebee7e22d83f8c594b930131967ae5cc02cf531bfc195fd80e51633dd9f9b98ed261cbc72ff8e3b93efcdd6349b9b776bd1f9d14d2914ebead0749f9750a71daef945cc32d129e7be24d9c7a15a7e4e4d9912171da6c9067d95b54cd6133cf46e01f76251568774ea0ce8f110100be7061b004a8b0e435052c1a9d8a2dd61e0374ed750ca53a1d0d2762fb43dd8e2cf41ccd67026aa5f7757acd73be6452fef3789b366f51ac894056bcb0b0dee90b6465c120187efc29f9238a38307116e0dc877cfcba5b55178ce6cf4653d546559c46273a0d802f6edf14b9538ac00c712948e51cd40b45e1fac860bb73601b6b2d3482d1addd9ff0a606ead649b96e8b84277cb57ade44d4b56db8d9995a68fe291b0c0f05a6aaf386e760fdac8e0b8d789f653407e1b91aa74679d3b1e89581eba99f5b0fd404c9e0b8bff7a9b5980c584e1d0ef08b1faa2808a30b732cdc180c2da22b34e31e6fc5f8ba614d623051d50c52844d23d15b60759ec355d042b83e75bfddfd71095d1e264c056fa7b15df5df35fbd091b4f70137fa26eb3213c23116e7ca3051bce6cc874008f1acf15265d284de09677bc2e7b0405bcba347fb876de0a8eda421b6b83128da5a9aa4bce8508fb971e09b8d5b1058cfb57c9e860e6a18e6dde15257a8d9dcf8db3193f6e564de698f2777e5b518a44de3d3e173abcb92bc94567594d9d81e89bceff0ff36a22e2f067bf3809e8b00321c7fbb3f20973f14f109303c1d1ca1ffa27ebdd99cf9f990f1f7e56a862aa5da014f53115cb8a012ca22d5077e725698ae8507ef127499adacf20f84da657125884e21158b0e70baa5e17dfd07ab3da69f5b81841d41db2afec88bcea7e44a077ce0e8525984a74d2e9e45a486a1088bd7e34f04a80bf37bdc1085ceb0736fd52917139be204cce5aa9131be977ae58637b6880a95178427cd1634847c49710005721d677674175d2e45cfc35d1bd11f8e786ef6a378f266f7a9f5f2ff22a2d25ed895bb85cbde36e4e889f3825cc328e1c65a93f3fb59bcd3cbcd6c083c6f47e1005fa9de09cee65e084f44c7410bf0c359b89fc18993bda2cc775e8db9a77bfa33184fe9c2ab99d3f21d8284a7f47189886ed705856cc8adedba8775a4dfe664719ffe9c47e08bca9ea6937cc3631db3bce64916f762546835d2686d21efc8a817bd06869d01010acf257bf77aadfab6fa86ade6b3506bb0ad9151defb10c0c2be7ee90c873ea605b8c25df490bae03d241b8a378ba5143909ebe99a09dc109480fa9c5fed728f0c1d8f4f01b7ea440d2a8a833770b4fd299b6b114f186e9ace8b558c7df9f88fa3a6e8715e3ef9c8320d511269bf2f752808e58e442694b7d7b173471b143861462d08ca5575ed140a9795d772046c9f8bdf703bbb5f393e4977de5d6db9912abebbe9d1743eac0e9730f1f9f210d55849f96e64136c0af6ed360319f80b3f44fca6ec731454a7db27da2f71083a728aeeca3a52d684bcba4ad1b26668e6c15af67ff39e3a59dbc235f9bb7f2465e70bb788e945fdd72d3397a884251d9704c337903be69e2887a7d56297360b3252c578b224a14b52b8e3b0cac3537e47177c797585c7f641ab54984d5475dfb43b6cffa1632382ce9b834871255c</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码以阅读这篇私密文章。</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">此文章已被加密，需要输入密码访问。</summary>
    
    
    
    <category term="未定义" scheme="https://Dragonliu2018.github.io/categories/未定义/"/>
    
    
  </entry>
  
</feed>
