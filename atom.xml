<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dragon Liu</title>
  
  
  <link href="https://dragonliu2018.github.io/atom.xml" rel="self"/>
  
  <link href="https://dragonliu2018.github.io/"/>
  <updated>2022-04-18T14:52:33.148Z</updated>
  <id>https://dragonliu2018.github.io/</id>
  
  <author>
    <name>Dragon Liu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>卫语句</title>
    <link href="https://dragonliu2018.github.io/2022/04/18/%E5%8D%AB%E8%AF%AD%E5%8F%A5/"/>
    <id>https://dragonliu2018.github.io/2022/04/18/%E5%8D%AB%E8%AF%AD%E5%8F%A5/</id>
    <published>2022-04-18T08:32:06.000Z</published>
    <updated>2022-04-18T14:52:33.148Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p><strong>转载</strong>：<a href="https://blog.csdn.net/qq_36631379/article/details/107951535" target="_blank" rel="noopener">浅谈使用卫语句重构方法</a></p></blockquote><h1 id="1-卫语句定义"><a class="markdownIt-Anchor" href="#1-卫语句定义"></a> 1 卫语句定义</h1><p>如果条件语句极其复杂，就应该将条件语句拆解开，然后逐个检查，并在条件为真时立刻从函数中返回，这样的单独检查通常被称之为“卫语句”(Guard Clauses)。</p><p><strong>说人话就是</strong>：写方法时在合适的时候尽快return，少用else</p><h1 id="2-按卫语句对函数进行重构应遵循"><a class="markdownIt-Anchor" href="#2-按卫语句对函数进行重构应遵循"></a> 2 按卫语句对函数进行重构应遵循</h1><ol><li>及时return，if中能return就return。(一旦满足条件return后你根本无需关注后面的代码)</li><li>能够return的就尽量少使用else。(用else太多，读者需要维护大量的栈在大脑中)</li><li>减少嵌套，一般嵌套超过4层读者就会产生阅读恐惧感。</li></ol><h1 id="3-示例"><a class="markdownIt-Anchor" href="#3-示例"></a> 3 示例</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>（it == 活的）&#123;</span><br><span class="line">    <span class="keyword">if</span>（it == 人）&#123;</span><br><span class="line">        <span class="keyword">if</span>（it ！= 女人）&#123;</span><br><span class="line">            <span class="keyword">return</span> 不喜欢；</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> 喜欢；</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> 不喜欢；</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> 不喜欢；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码无非就是表达 <code>我只喜欢活的女人</code> 的意思，但是代码一层套一层明显妨碍了我在第一时间获取最核心信息的效率，使用卫语句来表达就是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> （it ！= 活的）&#123;<span class="keyword">return</span> 不喜欢&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>（it！=人）&#123;<span class="keyword">return</span> 不喜欢&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>（it！=女人）&#123;<span class="keyword">return</span> 不喜欢&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>（it == 女人 &amp;&amp; it == 活的） &#123;<span class="keyword">return</span> 喜欢&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> 不喜欢</span><br></pre></td></tr></table></figure><p>这样看起来，代码就更明晰易懂。</p><p>有点<strong>逆向思维</strong>的意思。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="未分类" scheme="https://Dragonliu2018.github.io/categories/未分类/"/>
    
    
    <category term="重构" scheme="https://Dragonliu2018.github.io/tags/重构/"/>
    
  </entry>
  
  <entry>
    <title>git vs svn</title>
    <link href="https://dragonliu2018.github.io/2022/04/18/git-vs-svn/"/>
    <id>https://dragonliu2018.github.io/2022/04/18/git-vs-svn/</id>
    <published>2022-04-18T08:28:44.000Z</published>
    <updated>2022-04-18T15:53:23.147Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p><strong>转载</strong>：<a href="https://www.cnblogs.com/Sungeek/p/9152223.html#sg3" target="_blank" rel="noopener">SVN与Git比较的优缺点差异</a></p></blockquote><h1 id="1-集中式-vs-分布式"><a class="markdownIt-Anchor" href="#1-集中式-vs-分布式"></a> 1 集中式 vs 分布式</h1><h2 id="11-subversion属于集中式的版本控制系统"><a class="markdownIt-Anchor" href="#11-subversion属于集中式的版本控制系统"></a> 1.1 <strong>Subversion属于集中式的版本控制系统</strong></h2><p>集中式的版本控制系统都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。</p><img src="https://s2.loli.net/2022/04/18/bqmSZKA6HNOGxyu.png" width="300" height="300" alt="图片名称" align="center" id="172"><p><strong>Subversion的特点概括起来主要由以下几条：</strong></p><ul><li>每个版本库有唯一的URL（官方地址），每个用户都从这个地址获取代码和数据；</li><li>获取代码的更新，也只能连接到这个唯一的版本库，同步以取得最新数据；</li><li>提交必须有网络连接（非本地版本库）；</li><li>提交需要授权，如果没有写权限，提交会失败；</li><li>提交并非每次都能够成功。如果有其他人先于你提交，会提示“改动基于过时的版本，先更新再提交”… 诸如此类；</li><li>冲突解决是一个提交速度的竞赛：手快者，先提交，平安无事；手慢者，后提交，可能遇到麻烦的冲突解决。</li></ul><p><strong>好处</strong>：每个人都可以一定程度上看到项目中的其他人正在做些什么。而管理员也可以轻松掌控每个开发者的权限。</p><p><strong>缺点</strong>：</p><ul><li>中央服务器的单点故障。若是宕机一小时，那么在这一小时内，谁都无法提交更新、还原、对比等，也就无法协同工作。如果中央服务器的磁盘发生故障，并且没做过备份或者备份得不够及时的话，还会有丢失数据的风险。最坏的情况是彻底丢失整个项目的所有历史更改记录，被客户端提取出来的某些快照数据除外，但这样的话依然是个问题，你不能保证所有的数据都已经有人提取出来。</li><li>Subversion原理上只关心文件内容的具体差异。每次记录有哪些文件作了更新，以及都更新了哪些行的什么内容。</li></ul><h2 id="12-git属于分布式的版本控制系统"><a class="markdownIt-Anchor" href="#12-git属于分布式的版本控制系统"></a> 1.2 Git属于分布式的版本控制系统</h2><img src="https://s2.loli.net/2022/04/18/uryM1ZCEP6b2NRF.png" width="300" height="300" alt="图片名称" align="center" id="171"><p>Git记录版本历史只关心文件数据的<strong>整体</strong>是否发生变化。Git 不保存文件内容前后变化的差异数据。</p><p>实际上，Git 更像是把变化的文件作快照后，记录在一个微型的文件系统中。每次提交更新时，它会纵览一遍所有文件的指纹信息并对文件作一快照，然后保存一个指向这次快照的索引。为提高性能，若文件没有变化，Git 不会再次保存，而只对上次保存的快照作一连接。</p><p>在分布式版本控制系统中，客户端并不只提取最新版本的文件快照，而是把原始的代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。这类系统都可以指定和若干不同的远端代码仓库进行交互。籍此，你就可以在同一个项目中，分别和不同工作小组的人相互协作。你可以根据需要设定不同的协作流程。</p><p>另外，因为Git在本地磁盘上就保存着所有有关当前项目的历史更新，并且Git中的绝大多数操作都只需要访问本地文件和资源，不用连网，所以处理起来速度飞快。用SVN的话，没有网络或者断开VPN你就无法做任何事情。但用Git的话，就算你在飞机或者火车上，都可以非常愉快地频繁提交更新，等到了有网络的时候再上传到远程的镜像仓库。换作其他版本控制系统，这么做几乎不可能，抑或是非常麻烦。</p><p><strong>Git具有以下特点：</strong></p><ul><li>Git中每个克隆(clone)的版本库都是平等的。你可以从任何一个版本库的克隆来创建属于你自己的版本库，同时你的版本库也可以作为源提供给他人，只要你愿意。</li><li>Git的每一次提取操作，实际上都是一次对代码仓库的完整备份。</li><li>提交完全在本地完成，无须别人给你授权，你的版本库你作主，并且提交总是会成功。</li><li>甚至基于旧版本的改动也可以成功提交，提交会基于旧的版本创建一个新的分支。</li><li>Git的提交不会被打断，直到你的工作完全满意了，PUSH给他人或者他人PULL你的版本库，合并会发生在PULL和PUSH过程中，不能自动解决的冲突会提示您手工完成。</li><li>冲突解决不再像是SVN一样的提交竞赛，而是在需要的时候才进行合并和冲突解决。</li><li>Git 也可以模拟集中式的工作模式</li><li>Git版本库统一放在服务器中</li><li>可以为 Git 版本库进行授权：谁能创建版本库，谁能向版本库PUSH，谁能够读取（克隆）版本库</li><li>团队的成员先将服务器的版本库克隆到本地；并经常的从服务器的版本库拉（PULL）最新的更新；</li><li>团队的成员将自己的改动推（PUSH）到服务器的版本库中，当其他人和版本库同步（PULL）时，会自动获取改变</li><li>Git 的集中式工作模式非常灵活</li><li>你完全可以在脱离Git服务器所在网络的情况下，如移动办公／出差时，照常使用代码库</li><li>你只需要在能够接入Git服务器所在网络时，PULL和PUSH即可完成和服务器同步以及提交</li><li>Git提供 rebase 命令，可以让你的改动看起来是基于最新的代码实现的改动</li><li>Git 有更多的工作模式可以选择，远非 Subversion可比</li></ul><h1 id="2-版本库与工作区"><a class="markdownIt-Anchor" href="#2-版本库与工作区"></a> 2 版本库与工作区</h1><p>Subversion的工作区和版本库是截然分开的，而Git的工作区和版本库是如影随形的。</p><h2 id="21-svn的版本库和工作区是分离的"><a class="markdownIt-Anchor" href="#21-svn的版本库和工作区是分离的"></a> 2.1 SVN的版本库和工作区是分离的</h2><ul><li>Subversion 的工作区和版本库物理上分开：Subversion的版本库和工作区是存储在不同路径下，一般是在不同的主机中</li><li>Subversion的企业级部署中，版本库在服务器上，只能通过 https, http, svn 等协议访问，而不能直接被用户接触到。</li><li>Subversion的工作区是一份版本库在某个历史状态下的快照，如：版本库最新的数据检出到工作区。</li><li>Subversion的工作区中每一个目录下都包含一个名为 .svn 的控制目录（隐藏的目录），该目录的作用是：<ul><li>标识工作区和版本库的对应关系。</li><li>包含一份该子目录下检出文件的原始拷贝。当文件改动的差异比较或者本地改动的回退时，可以直接参考原始拷贝而无须通过网络访问远程版本库。</li></ul></li><li>Subversion 的 .svn 控制目录会引入很多麻烦：<ul><li>.svn 下的文件原始考本，会导致在目录下按照文件内容搜索时，多出一倍的搜索时间和搜索结果。</li><li>.svn 很容易在集成时，引入产品中，尤其是 Web 应用，将 .svn 目录带入Web服务器会导致安全隐患。因为一个不允许目录浏览的Web目录，可以通过 .svn/entries 文件查看到该目录下可能存在的文件。</li></ul></li></ul><h2 id="22-git-的版本库和工作区如影随形"><a class="markdownIt-Anchor" href="#22-git-的版本库和工作区如影随形"></a> 2.2 Git 的版本库和工作区如影随形</h2><ul><li>Git 的版本库和工作区在同一个目录下，工作区的根目录有一个.git的子目录，这个名为 .git的目录就是版本库本身，它是Git 用来保存元数据和对象数据库的地方。该目录非常重要，每次克隆镜像仓库的时候，实际拷贝的就是这个目录里面的数据。所以千万要小心删除这个文件。</li><li>工作区中其他文件为工作区文件，可能是从 .git 中检出的，或者是要检入的，或者是运行产生的临时文件等。</li><li>版本库可以脱离工作区而存在，成为 bare（赤裸）版本库。可以用 –bare 参数来创建。但是工作区不能脱离版本库而存在，即工作区的根目录下必须有一个名为 .git 的版本库克隆文件。</li><li>Git 的版本库因为就在工作区中，能直接被用户接触到。<ul><li>用户可以编辑 .git/config 文件，修改配置，增添新的源</li><li>用户可以编辑 .git/info/exclude 文件，创建本地忽略…</li></ul></li><li>Git 的工作区中只在工作区的根目录下有一个 .git 目录，此外再无任何控制目录。Git 工作区下唯一的 .git 目录是版本库，并非 .svn 的等价物，如果删除了 .git 目录，而又没有该版本库的其他镜像（克隆）的话，你破坏了整个历史，版本库也永远的失去了。</li><li>Git 在本地的 .git 版本库，提供了完全的改动历史。除了和其他人数据交换外，任何版本库相关的操作都在本地完成，更多的本地操作，避免了冗长的网络延迟，大大节省了时间。例如：查看 log，切换到任何历史版本等操作都无须连接网络。</li><li>Git如何保证安全：本地创建一个Git库，因为工作区和库是在同一个目录中，如果工作区删除了，或者所在的磁盘分区格式化了，数据不是全都没有了么？其实我们可以这样做：<ul><li>在一个磁盘分区中创建版本库（最好是用 –bare 参数创建），然后在另外的磁盘分区中克隆一个新的作为工作区。在工作区的提交要不时的PUSH到另外分区的版本库，这样就实现了本地的数据镜像。你甚至可以在本地创建更多的版本库镜像，安全性要比Subversion的一个库加上一个工作区安全。</li><li>另一个办法：把你的版本库共享给他人，当他人克隆了你的版本库时，你就拥有了一个异地备份。</li></ul></li></ul><h1 id="3-全局版本号和全球版本号"><a class="markdownIt-Anchor" href="#3-全局版本号和全球版本号"></a> 3 全局版本号和全球版本号</h1><p>SVN的全局版本号和CVS的每个文件都独立维护一套版本号相比，是一个非常大的进步。在看似简单的全局版本号的背后，是Subversion提供对于事物处理的支持，每一个事物处理（即一次提交）都具有整个版本库全局唯一的版本号。</p><p>Git的版本号则更进一步，版本号是全球唯一的。Git 对于每一次提交，通过对文件的内容或目录的结构计算出一个SHA-1 哈希值，得到一个40位的十六进制字符串，Git将此字符串作为版本号。</p><h2 id="31-svn与git版本号比较"><a class="markdownIt-Anchor" href="#31-svn与git版本号比较"></a> 3.1 SVN与Git版本号比较</h2><ul><li>所有保存在Git 数据库中的数据都是用此40位的哈希值作索引的，而不是靠文件名。</li><li>使用哈希值作版本号的好处就是对于一个分布式的版本控制系统，每个人每次提交后形成的版本号都不会出现重复。另一好处是保证数据的完整性，因为哈希值是根据内容或目录结构计算出来的，所以我们还可以据此来判断数据内容是否被篡改。</li><li>SVN 的版本号是连续的，可以预判下一个版本号，而 Git 的版本号则不是。<ul><li>因为 subversion 是集中式版本控制，很容易实现版本号的连续性。</li><li>Git 是分布式的版本控制系统，而且 Git 采用 40 位长的哈希值作为版本号，每个人的提交都是各自独立完成的，没有先后之分（即使提交有先后之分，也由于PUSH/PULL的方向和时机而不同）。Git 的版本号虽然不连续，但是是有线索的，即每一个版本都有对应的父版本（一个或者两个），进而可以形成一个复杂的提交链</li></ul></li><li>Git 的版本号简化：Git 可以使用从左面开始任意长度的字串作为简化版本号，只要该简化的版本号不产生歧义。一般采用7位的短版本号（只要不会出现重复的，你也可以使用更短的版本号）。</li></ul><h1 id="4-部分检出"><a class="markdownIt-Anchor" href="#4-部分检出"></a> 4 部分检出</h1><p>Subversion可以将整个库检出到工作区，也可以将某个目录检出到工作区。对于要使用一个庞大、臃肿的版本库的用户来说，部分检出是非常方便和实际的。</p><p>但是Git只能全部检出，不支持按照目录进行的部分检出。</p><h2 id="41-svn的部分检出"><a class="markdownIt-Anchor" href="#41-svn的部分检出"></a> 4.1 SVN的部分检出</h2><ul><li>在SVN中，从仓库checkout的一个工作树，每个子目录下都维护着自己的.svn目录，记录着该目录中文件的修改情况以及和服务器端仓库的对应关系。所以SVN可以checkout部分路径下的内容（部分检出），而不用checkout整个版本库或分支。</li><li>Subversion 有一条命令：svn export ，可以将 subversion 版本库的一个目录下所有内容导出到指定的目录下。Subversion 需要 svn export 命令是因为该命令可以导出一个干净的目录，即不包含 .svn 目录（包含配置文件和文件原始拷贝）。</li></ul><h2 id="42-git的检出"><a class="markdownIt-Anchor" href="#42-git的检出"></a> 4.2 Git的检出</h2><ul><li>Git 没有部分检出，这并不是说只有将整个库克隆下来才能查看文件。有很多 git 工具，提供直接浏览git库的功能，例如 gitweb, trac 的 git 版本库浏览, redmine 的 git 版本库浏览。</li><li>Git-submodule 可以实现版本库的模块化：Git 通过子模块处理这个问题。子模块允许你将一个Git 仓库当作另外一个Git仓库的子目录。这允许你克隆另外一个仓库到你的项目中并且保持你的提交相对独立。</li><li>Git 为什么没有实现 svn export 的功能？由于git的本地仓库信息完全维护在project根目录的.git目录下，（不像svn一样，每个子目录下都有单独的.svn目录）。所以，只要clone，checkout然后删除.git目录就可以了。</li></ul><h1 id="5-更新和提交"><a class="markdownIt-Anchor" href="#5-更新和提交"></a> 5 更新和提交</h1><h2 id="51-更新操作"><a class="markdownIt-Anchor" href="#51-更新操作"></a> 5.1 更新操作</h2><p>在SVN中，因为只有一个中心仓库，所以所谓的远程更新，也就是svn update ,通过此命令来使工作区和版本库保持同步。</p><p>对于git来说，别人的改动是存在于远程仓库上的，所以git checkout命令尽管在某些功能上和svn中的update类似（例如取仓库特定版本的内容），但是在远程更新这一点上，还是不同的，不属于git checkout的功能涵盖范围。 Git使用git fetch和git pull来完成远程更新任务，fetch操作只是将远程数据库的object拷贝到本地，然后更新remotes head的refs，git pull 的操作则是在git fetch的基础上对当前分支外加merge操作。</p><blockquote><p>大致上 git pull = git fetch + git merge</p></blockquote><h2 id="52-svn中的commit命令"><a class="markdownIt-Anchor" href="#52-svn中的commit命令"></a> 5.2 SVN中的commit命令</h2><p>对于SVN来说，由于是中心式的仓库管理形式，所以并不存在特殊的远程提交的概念，所有的commit操作都可以认为是对远程仓库的更新动作。在工作区中对文件进行添加、修改、删除操作要同步到版本库，必须使用 commit命令。</p><ul><li>add 命令，是将未标记为版本控制状态的文件标记为添加状态，并在下次提交时入库。</li><li>delete命令，是通过SVN来删除文件，并在下次提交后有效。</li><li>Subversion 有提交列表功能，即将某些文件加入一个修改列表，提交可以只提交处于该列表的文件。</li></ul><h2 id="53-git中的暂存区域stage"><a class="markdownIt-Anchor" href="#53-git中的暂存区域stage"></a> 5.3 Git中的暂存区域（stage）</h2><p>Git 管理项目时，文件在三个工作区域中流转：Git 的本地数据目录，工作目录以及暂存区域。暂存区域（stage）是介于 workcopy 和 版本库 HEAD 版本的一种中间状态。所谓的暂存区域只不过是个简单的文件，一般都放在git 目录中。有时候人们会把这个文件叫做索引文件，不过标准说法还是叫暂存区域。</p><p>要将一个文件纳入版本管理的范畴，首先是要用git add将文件纳入stage的监控范围，只有更新到stage中的内容才会在commit的时候被提交。另外，文件本身的改动并不会自动更新到stage中，每次的任何修改都必须重新更新到stage中去才会被提交。对于工作区直接删除的文件，需要用 git rm 命令进行标记，在下次提交时，在版本库中删除。</p><ul><li>工作区的文件改动（新增文件，修改文件，删除文件），必须用 git add 或者 git rm 命令标识，使得改动进入 stage</li><li>提交只对加入 stage 的改动进行提交</li><li>如果一个文件改动加入 stage 后再次改动，则后续改动不改变 stage。即该文件的改动有两个状态，一个是标记到 stage 中并将在下次提交时入库的改动，另外的后续改动则不被提交，除非再次使用 git add 命令将改动加入到 stage 中。</li><li>Git的stag让你在提交的时候清楚的知道git将要提交哪些改动。除非提交的时候使用 -a 参数（不建议使用）。</li></ul><p>我们可以从文件所处的位置来判断其状态：如果是git目录中保存着的特定版本文件，就属于已提交状态；如果作了修改并已放入暂存区域，就属于已暂存状态；如果自上次取出后，作了修改但还没有放到暂存区域，就是已修改状态，如果取出后未进行修改则是未修改状态。</p><p>在git中，因为有本地仓库和remote仓库之分，所以也就区别于commit 操作，存在额外的push命令，用于将本地仓库的数据更新到远程仓库中去。git push 可以选择需要提交的、更新的分支以及制定该分支在远程仓库上的名字。</p><h1 id="6-分支和里程碑的实现"><a class="markdownIt-Anchor" href="#6-分支和里程碑的实现"></a> 6 分支和里程碑的实现</h1><p>几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。在很多版本控制系统中，这是个昂贵的过程，常常需要创建一个源代码目录的完整副本，对大型项目来说会花费很长时间。</p><p>轻量级分支/里程碑的含义是，创建分支/里程碑的复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>，不会因为版本库的愈加庞大而变得缓慢。在CVS中，创建分支的复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>的，导致大的版本库的的分支创建非常缓慢。</p><blockquote><p>CVS （代码版本控制软件）：<a href="https://baike.baidu.com/item/CVS/405463" target="_blank" rel="noopener">百度百科</a></p></blockquote><h2 id="61-subversion的分支里程碑"><a class="markdownIt-Anchor" href="#61-subversion的分支里程碑"></a> 6.1 Subversion的分支/里程碑</h2><p>Subversion轻量级分支和里程碑的实现是通过svn cp命令，即带历史的拷贝就是创建快速创建分支和里程碑的秘籍。Subversion的版本库有特殊的设计，当你复制一个目录，你不需要担心版本库会变得十分巨大—Subversion并不是拷贝所有的数据，相反，它只是建立了一个已存在目录树的入口。这种“廉价的拷贝”就是创建分支/里程碑是轻量级的原因。</p><p>由于Svn的分支和标签是来自目录拷贝，约定俗成是拷贝在 branches/和tags/目录下。所谓分支，tag等概念都只是仓库中不同路径上的一个对象或索引而已，和普通的路径并没有什么本质的区别，谁也不能阻止在一个提交中同时修改不同分支中的数据。</p><p>里程碑是对某个历史提交所起的一个别名，作为历史的标记，是不应该被更改的。svn的里程碑要建立到 tags/目录下，要求不要在tags/下的里程碑目录下进行提交。但是谁也阻止不了对未进行权限控制的里程碑的篡改。</p><h2 id="62-git-的轻量级分支和里程碑"><a class="markdownIt-Anchor" href="#62-git-的轻量级分支和里程碑"></a> 6.2 Git 的轻量级分支和里程碑</h2><p>Git中的分支实际上仅是一个包含所指对象校验和（40个字符长度SHA-1 哈希值）的文件，所以创建和销毁一个分支就变得非常廉价。说白了，新建一个分支就是向一个文件写入41个字节（版本号外加一个换行符）那么简单，自然速度就很快了。 Git的实现与项目复杂度无关，它永远可以在几毫秒的时间内完成分支的创建和切换。这和大多数版本控制系统形成了鲜明对比。</p><p>Git的分支是完全隔离的，而Subversion则没有。分支本来就应该是相对独立的命名空间，一个提交一般只能发生在一个分支中。在Git中，其内部的对象层级依赖关系或许和SVN类似，但是其工作树的视图表现形式和SVN完全不同。工作树永远是一个完整的分支，不同的分支由不同的head索引去构建，你不可能在工作树中同时获得多个分支的内容。</p><p>Git使用的标签有两种类型：轻量级的（lightweight）和含附注的（annotated）。</p><p>① 轻量级标签就像是个不会变化的分支，实际上它就是个指向特定提交对象的引用。</p><p>② 而含附注标签，实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，电子邮件地址和日期，以及标签说明，标签本身也允许使用GNU Privacy Guard (GPG) 来签署或验证。</p><p>Git的里程碑是只读的，Git完全遵守历史不可更改这一时空法则。用户不能向git的里程碑中提交，否则里程碑就不是标记，而成了一个分支。当然Git允许用户删除里程碑再重新创建指定到不同历史提交。</p><h2 id="63-多分支间的切换"><a class="markdownIt-Anchor" href="#63-多分支间的切换"></a> 6.3 多分支间的切换</h2><p>SVN中提供了一个功能switch，使用switch可以在同一个工作树上，在不同的分支中进行切换。</p><p>Git在分支中进行切换使用的命令是checkout。</p><h1 id="7-分支与合并"><a class="markdownIt-Anchor" href="#7-分支与合并"></a> 7 分支与合并</h1><p>Git 和 Svn 的分支实现机制完全的不同，这也直接导致了 SVN 在分支合并中困难重重。尽管在 SVN 1.5 之后，通过 svn:mergeinfo 属性引入了合并追踪机制，但是在特定情况下，合并仍会出现很多困难。</p><h2 id="71-svn的分支合并"><a class="markdownIt-Anchor" href="#71-svn的分支合并"></a> 7.1 SVN的分支合并</h2><p>当你在一个分支上工作数周或几个月之后，主干的修改也同时在进行着，两条线的开发会区别巨大，当你想合并分支回主干，可能因为太多冲突，已经无法轻易合并你的分支和主干的修改。</p><p>另一个问题，Subversion不会记录任何合并操作，当你提交本地修改，版本库并不能判断出你是通过svn merge还是手工修改得到这些文件。所以你必须手工记录这些信息（说明合并的特定版本号或是版本号的范围）。</p><p>要解决以上的问题只有通过有规律的将主干合并到分支来避免，制定这样一个政策：每周将上周的修改合并到分支，注意这样做时需要小心，你必须手工记录合并的过程，以避免重复的合并，你需要小心的撰写合并的日志信息，精确的描述合并包括的范围。这样做看起来有点像是胁迫。</p><p>SVN 的版本号是连续的版本号。每一次新的提交都会版本号+1 ，而无论这个提交是在哪个分支中进行的。SVN一个提交可以同时修改不同分支的不同文件，因为提交命令可以在 /trunk, /branches, /tags 的上一级目录执行。</p><ul><li>SVN 的提交是单线索的，每一个提交（最原始的提交0除外）都只有一个父节点（版本号小一个的提交节点）</li><li>SVN 的提交链只有一条，仅从版本号和提交说明，我们无法获得分支图</li><li>SVN 的分支图在某些工具（如乌龟SVN）可以提供，那是需要对提交内容进行检查，对目录拷贝动作视为分支，对 svn:mergeinfo 的改动视为合并，但这会由于目录管理的灵活性，导致千奇百怪的分支图表。</li></ul><h2 id="72-git的分支合并"><a class="markdownIt-Anchor" href="#72-git的分支合并"></a> 7.2 Git的分支合并</h2><p>在 git 版本库中创建分支的成本几乎为零，所以，不必吝啬多创建几个分支。当第一次执行git-init时，系统就会创建一个名为”master”的分支。 而其它分支则通过手工创建。下面列举一些常见的分支策略。</p><p>① 创建一个属于自己的个人工作分支，以避免对主分支 master 造成太多的干扰，也方便与他人交流协作。<br>② 当进行高风险的工作时，创建一个试验性的分支，扔掉一个烂摊子总比收拾一个烂摊子好得多。<br>③ 合并别人修改的时候，最好创建一个临时的分支用来合并，合并完成后再“fatch”到自己的分支。</p><p>Git分支相关的操作命令</p><h1 id="8-撤消操作"><a class="markdownIt-Anchor" href="#8-撤消操作"></a> 8 撤消操作</h1><h2 id="81-提交的撤销"><a class="markdownIt-Anchor" href="#81-提交的撤销"></a> 8.1 提交的撤销</h2><p>在Subversion中一旦完成向服务器的数据提交，你就没有办法再从客户端追回，只能在后续的提交中修正（回退或者修改）等。因为Subversion作为集中式的版本控制，不能允许个人对已提交的数据进行篡改。Subversion具有一个非常重要的特性就是它的信息从不丢失，即使当你删除了文件或目录，它也许从最新版本中消失了 ，但这个对象依然存在于历史的早期版本中。</p><p>Git则不同，Git是分布式版本控制系统，代码库是属于个人，允许任意修改。Git通过对提交建立数字摘要来保证提交的唯一性和不可更改性，通过版本库在多人之间的多份拷贝来保障数据的安全性。Git可以丢弃最新的一个或几个提交，使用 git reset –hard命令可以永远丢弃最新的一个或者几个提交。</p><h2 id="82-提交说明的修改"><a class="markdownIt-Anchor" href="#82-提交说明的修改"></a> 8.2 提交说明的修改</h2><p>提交后如果对提交说明不满意，如何实现对提交说明的修改：</p><ol><li>Git可以使用命令git commit –amend修改提交说明。<ul><li>Git可以修改最后一次提交说明，并不是说不能修改历史版本的提交说明，只是修改最后一个版本提交说明拥有最简单的命令；</li><li>Git修改提交说明，会改变提交的commit-id。即修改提交说明后，将产生一个新的提交；</li><li>Git可以通过git reset –hard ，git commit –amend，git rebase onto 等命令来实现对历史提交的修改；</li><li>使用stg工具可以更为简单的修改历史提交的提交说明，包括提交内容；</li></ul></li><li>Subversion也可以修改提交说明，是通过修改提交的svn:log版本属性实现的：<ul><li>不但可以修改最后一次提交的说明，并且可以修改历史提交的提交说明；</li><li>Subversion修改提交说明是不可逆的操作，可能会造成说明被恶意修改；</li><li>Subversion缺省关闭修改提交说明的功能。管理员在设置了提交说明更改的邮件通知后，才可以打开该功能。</li></ul></li></ol><h2 id="83-修改和重构历史提交"><a class="markdownIt-Anchor" href="#83-修改和重构历史提交"></a> 8.3 修改和重构历史提交</h2><p>Git可以修改和重构历史提交：使用Git本身的reset以及 rebase 命令可以修改或者重整/重构历史提交，非常灵活。使用强大的 stg 可以使得历史提交的重构更为简洁，如果您对 stg 或者 Hg/MQ 熟悉的话。</p><p>Subversion 修改历史提交，只能由管理员完成。</p><p>Subversion 是集中式版本控制系统，从客户端一旦完成提交，就没有办法从客户端撤销提交。但是管理员可以在服务器端完成提交的撤销和修改，但是操作过程和代价较大。</p><h1 id="9-权限管理"><a class="markdownIt-Anchor" href="#9-权限管理"></a> 9 权限管理</h1><p>Subversion通过对文件目录授权来实现权限管理，子目录默认继承父目录的权限。但是也有缺憾，即权限不能在分支中继承，不能对单个文件授权。例如为 /trunk及其子目录的授权，不能继承到分支或者标签中相应的目录下。</p><p>Git 的授权做不到Subversion那样精细。Git的授权模型只能实现非零即壹式的授权，要么拥有全部的写权限，要么没有写权限，要么拥有整个版本库的读权限，要么禁用。</p><p>从技术上将，Git可能永远也做不到类似SVN的路径授权（读授权）：</p><ul><li>如果允许按照路径授权，则各个克隆的关系将不再是平等的关系，有的内容多，有的内容少，分布式的理念被破坏</li><li>如果只有部分路径可读，则克隆出来的提交和原始提交的提交ID可能不同。因为提交ID是和提交内容有关的，克隆中提交的部分内容被丢弃，势必提交的ID也要重新计算</li><li>允许全部代码可读，只允许部分代码可写，在版本控制的管理下，是没有多大实际意义的，而且导致了提交的逻辑上的不完整。</li></ul><p>那么有什么办法来解决授权的问题？</p><ol><li>公司内部代码开放。即代码在公司内部，对项目组成员一视同仁的开放。</li><li>公司对代码库进行合理分解，对每个代码库分别授权。即某个代码库对团队成员完全开放，对其它团队完全封闭。</li><li>公司使用Subversion做集中式的版本控制，个人和/或团队使用 Git-svn。这样在无法改变公司版本控制策略时，程序员可以采用的变通之法。</li><li>Git服务器的部署实际上可以使用钩子对分支和路径进行写授权，即可以控制谁能够创建分支，能够写特定文件。</li></ol><h1 id="10-优缺点比较"><a class="markdownIt-Anchor" href="#10-优缺点比较"></a> 10 优缺点比较</h1><h2 id="101-svn优缺点"><a class="markdownIt-Anchor" href="#101-svn优缺点"></a> 10.1 SVN优缺点</h2><p><strong>优点</strong>：</p><ol><li>管理方便，逻辑明确，符合一般人思维习惯。</li><li>易于管理，集中式服务器更能保证安全性。</li><li>代码一致性非常高。</li><li>适合开发人数不多的项目开发。</li></ol><p><strong>缺点</strong>：</p><ol><li>服务器压力太大，数据库容量暴增。</li><li>如果不能连接到服务器上，基本上不可以工作，看上面第二步，如果服务器不能连接上，就不能提交，还原，对比等等。</li><li>不适合开源开发（开发人数非常非常多，但是Google app engine就是用svn的）。但是一般集中式管理的有非常明确的权限管理机制（例如分支访问限制），可以实现分层管理，从而很好的解决开发人数众多的问题。</li></ol><h2 id="102-git优缺点"><a class="markdownIt-Anchor" href="#102-git优缺点"></a> 10.2 Git优缺点</h2><p><strong>优点</strong>：</p><ol><li>适合分布式开发，强调个体。</li><li>公共服务器压力和数据量都不会太大。</li><li>速度快、灵活。</li><li>任意两个开发者之间可以很容易的解决冲突。</li><li>离线工作。</li></ol><p><strong>缺点</strong>：</p><ol><li>学习周期相对而言比较长。</li><li>不符合常规思维。</li><li>代码保密性差，一旦开发者把整个库克隆下来就可以完全公开所有代码和版本信息。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="环境与工具" scheme="https://Dragonliu2018.github.io/categories/环境与工具/"/>
    
    
    <category term="Git" scheme="https://Dragonliu2018.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>指针 vs 引用 vs 指针引用</title>
    <link href="https://dragonliu2018.github.io/2022/04/18/%E6%8C%87%E9%92%88-vs-%E5%BC%95%E7%94%A8-vs-%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8/"/>
    <id>https://dragonliu2018.github.io/2022/04/18/%E6%8C%87%E9%92%88-vs-%E5%BC%95%E7%94%A8-vs-%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8/</id>
    <published>2022-04-18T08:27:41.000Z</published>
    <updated>2022-04-18T11:40:19.443Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-引入"><a class="markdownIt-Anchor" href="#1-引入"></a> 1 引入</h1><p>待补充</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="C++" scheme="https://Dragonliu2018.github.io/categories/C/"/>
    
    
    <category term="待补充" scheme="https://Dragonliu2018.github.io/tags/待补充/"/>
    
  </entry>
  
  <entry>
    <title>函数打桩</title>
    <link href="https://dragonliu2018.github.io/2022/04/18/%E5%87%BD%E6%95%B0%E6%89%93%E6%A1%A9/"/>
    <id>https://dragonliu2018.github.io/2022/04/18/%E5%87%BD%E6%95%B0%E6%89%93%E6%A1%A9/</id>
    <published>2022-04-18T08:11:30.000Z</published>
    <updated>2022-04-18T15:58:48.152Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p><strong>转载</strong>：<a href="https://sim41.com/2019/11/28/stub/" target="_blank" rel="noopener">stub</a></p></blockquote><h1 id="1-定义"><a class="markdownIt-Anchor" href="#1-定义"></a> 1 定义</h1><p>函数打桩，就是将一个函数用另一个函数实现(桩代码)进行替换，以达到在原有函数入口的位置执行新的实现。函数打桩类似于Windows系统中的钩子Hook，不过Hook针对的是事件，这里针对的是函数，或者说是函数的入口。在做C的Cunit单元测试时，遇到了这样的概念，在此梳理一下。</p><h1 id="2-目的"><a class="markdownIt-Anchor" href="#2-目的"></a> 2 目的</h1><p>函数打桩的目的一般是隔离、占位和控制，这里是参考其他博主的文章进行的大概分类，其实也不是很严格。</p><p>隔离就是将复杂的函数从程序中隔离，比如一个复杂的嵌套函数，如果只想要知道前几步的运行结果，则可以在调用下一层函数时替换一个简单的实现，甚至直接return。在进行流程的测试时比较常见。</p><p>占位就是对一些未实现的函数进行占位，多见于协同开发中，对于其他人完成的函数可以先使用空函数进行占位。</p><p>控制就是将原本的函数功能进行替换，控制流程。如在测试中，替换函数部分内容得到需要的结果，以进行单元测试。或者对一些系统函数进行替换，实现自己的功能。如常见的将内存分配的函数替换为自己重写的内存池分配等，这里就是一个函数Hook。</p><h1 id="3-方法"><a class="markdownIt-Anchor" href="#3-方法"></a> 3 方法</h1><h2 id="31-编译时打桩"><a class="markdownIt-Anchor" href="#31-编译时打桩"></a> 3.1 编译时打桩</h2><p>用宏定义#define，在预处理时进行字符串替换，将原函数定义成桩函数的形式。同时可以使用条件编译来控制编译选项。</p><h2 id="32-链接时打桩"><a class="markdownIt-Anchor" href="#32-链接时打桩"></a> 3.2 链接时打桩</h2><p>将桩函数定义到新的库文件中，并在原代码基础上增加条件编译选项，屏蔽原有的库，采用桩函数库。</p><h2 id="33-运行时打桩"><a class="markdownIt-Anchor" href="#33-运行时打桩"></a> 3.3 运行时打桩</h2><p>运行时打桩是对内存的应用，我们知道程序的函数是在代码段中存储，一个函数的操作对应一个栈帧的存储地址，如果在调用函数时，在一旦访问这个栈帧，我们就使它跳转到我们需要的桩函数去，那么也就实现了函数的打桩。这种方法要复杂一点，但是不需要对原有的代码进行修改，而是额外增加了打桩和还原的操作，在进行单元测试时也常用。</p><p>简单来说，就是读取到原函数指令的地址，并读取桩函数的地址，并使用jmp命令从原函数跳转到桩函数去，以实现打桩。</p><p>一个完整的打桩流程应该分为装载和卸载，因此需要做到的是记录原函数的函数指针，记录桩函数的函数指针，计算地址差值，调用jmp指令，完成桩函数的装载。使用完成后，再删除jmp指令，恢复原函数。此间由于操作系统对于进程的保护机制，可能存在对于进程内存的解锁和权限设置，将指定内存区域设定为可读可写可操作的权限。</p><h3 id="331-数据结构"><a class="markdownIt-Anchor" href="#331-数据结构"></a> 3.3.1 数据结构</h3><p>设定一个链表用于存储原函数、桩函数之间的对应关系，使用链表是为了动态分配同时记录多个函数。数据结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stub</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stub</span> *<span class="title">node</span>;</span></span><br><span class="line"><span class="keyword">void</span> *orig_f;<span class="comment">//原函数的函数指针</span></span><br><span class="line"><span class="keyword">void</span> *stub_f;<span class="comment">//桩函数的函数指针</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> old_flg;<span class="comment">//存储原有内存的权限</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> assm[<span class="number">5</span>];<span class="comment">//用于暂存原函数起始的5字节指令，用于被jmp指令(0xE9 + 4bytes地址)覆盖后恢复</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="332-设置内存的保护属性"><a class="markdownIt-Anchor" href="#332-设置内存的保护属性"></a> 3.3.2 设置内存的保护属性</h3><p>在Linux下，mprotect()函数可以用于更改指定内存区域的保护属性。原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mprotect</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> prot)</span></span>;</span><br><span class="line"><span class="comment">//addr为内存起始地址，必须是内存页的起始地址</span></span><br><span class="line"><span class="comment">//len为内存区域长度,以字节为单位，必须是页大小的整数倍</span></span><br><span class="line"><span class="comment">//prot为权限值，类似于Linux的权限值</span></span><br></pre></td></tr></table></figure><p>同样，在Windows下，采用读取系统的页大小:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">long</span> pagesize = sysconf(_SC_PAGESIZE);</span><br></pre></td></tr></table></figure><p>计算内存页的起始地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">pageof</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">void</span> *)((<span class="keyword">unsigned</span> <span class="keyword">long</span>)p &amp; ~(pagesize - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="333-安装桩函数"><a class="markdownIt-Anchor" href="#333-安装桩函数"></a> 3.3.3 安装桩函数</h3><p>计算原函数与桩函数地址的偏移量，将原函数的入口5字节指令替换为jmp [offset]，同时缓存原本的5字节，用于后续的恢复。</p><p>jmp指令对应0xE9，后续为4字节的偏移量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">install_stub</span><span class="params">(<span class="keyword">void</span> *orig_f, <span class="keyword">void</span> *stub_f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//初始化stub数据结构</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stub</span> *<span class="title">pstub</span> = <span class="title">calloc</span>(1, <span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">stub</span>));</span></span><br><span class="line">  pstub-&gt;orig_f = orig_f;</span><br><span class="line">  pstub-&gt;stub_f = stub_f;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//设置内存保护属性</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="number">-1</span> == mprotect(pageof(orig_f), pagesize * <span class="number">2</span>, PROT_READ | PROT_WRITE | PROT_EXEC))</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"mprotect to w+r+x faild"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(errno);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//缓存原函数orig_f头部的5字节指令</span></span><br><span class="line">  <span class="built_in">memcpy</span>(pstub-&gt;assm, pstub-&gt;orig_f, <span class="keyword">sizeof</span>(pstub-&gt;assm));</span><br><span class="line">  <span class="comment">//将头部重写为jmp [offset]</span></span><br><span class="line">  *((<span class="keyword">char</span>*)pstub-&gt;orig_f) = <span class="number">0xE9</span>;</span><br><span class="line">  offset = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)((<span class="keyword">long</span>)pstub-&gt;stub_f - ((<span class="keyword">long</span>)pstub-&gt;orig_f + <span class="number">5</span>));</span><br><span class="line">  *((<span class="keyword">unsigned</span> <span class="keyword">int</span>*)((<span class="keyword">char</span>*)pstub-&gt;orig_f + <span class="number">1</span>)) = offset;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//如果有多线程同时操作，加锁</span></span><br><span class="line">  <span class="comment">//lock()；</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//如果对多个函数打桩，维护struct stub 链表</span></span><br><span class="line">  <span class="comment">//list_add(&amp;ptsub-&gt;node, &amp;head)；</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//unlock();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="334-卸载桩函数"><a class="markdownIt-Anchor" href="#334-卸载桩函数"></a> 3.3.4 卸载桩函数</h3><p>将原函数开始的5字节恢复，并释放stub结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uninstall_stub</span><span class="params">(<span class="keyword">void</span> *stub_f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//从桩函数链表中找到要释放的桩函数对应的数据结构</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stub</span> *<span class="title">pstub</span> = <span class="title">NULL</span>:</span></span><br><span class="line">  pstub = find_pstub(stub_f);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//设置内存保护属性</span></span><br><span class="line">  mprotect(pageof(pstub-&gt;orig_f), pagesize * <span class="number">2</span>, PROT_READ | PROT_WRITE | PROT_EXEC);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//恢复原函数的初始5字节指令</span></span><br><span class="line">  <span class="built_in">memcpy</span>(pstub-&gt;orig_f, pstub-&gt;assm, <span class="keyword">sizeof</span>(pstub-&gt;assm));</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//删除节点</span></span><br><span class="line">  del_node(pstub)；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码只包含了关键代码，部分声明省略，并未对异常情况进行处理。</p><h1 id="4-进程内存安全"><a class="markdownIt-Anchor" href="#4-进程内存安全"></a> 4 进程内存安全</h1><p>这里的函数打桩利用jmp指令将原有的函数入口跳转到了我们指定的桩函数入口，自然会想到在非法情况下，也利用jmp将原本的函数跳转到指定的函数去。其实这也是一些病毒的做法，跳转到非法代码；或者一些软件破解的方法，将原本的验证机制跳转屏蔽。只不过我们打桩时是在同一进程内部进行了跳转，且是在获取源码到情况下进行的。而在破解和攻击时，一般只有可执行文件的二进制代码，此时可以通过反汇编得到程序的汇编指令，并找到需要修改的函数入口。在攻击时，也存在另外一个问题，就是跨进程的权限，在进程外对进程的内存进行修改。</p><p>操作系统对内存的保护，采取了虚拟地址空间（进程独立的虚拟内存），内存起点的随机偏移量（不能找到代码段段入口）等方式。而且mprotect()仅可以对同一进程的内存块进行修改。如果想要修改其他进程的内存块的保护属性，就要从两个方面下手，一是变成同一个进程，另一个则是对mprotect()动手脚。</p><p>当成同一个进程，可以使用代码注入，让我们的攻击代码从进程自身发出，则我们的代码就有了通过mprotect改变进程保护属性的权限。</p><p>而对mprotect()做手脚，即实现我们自己的mprotect()函数，让其模仿内核函数的行为，但是却拥有跨进程的能力。这就要编写一个类似于mprotect()函数功能的内核模块。</p><p>具体的操作暂时还没有深入了解，原理如上述所示。</p><h1 id="5-cunit的使用"><a class="markdownIt-Anchor" href="#5-cunit的使用"></a> 5 Cunit的使用</h1><p>CUnit是一个C语言的单元测试框架，以静态链接库的形式，连接到用户代码中。提供了语义丰富的断言和多种测试结果输出接口，可以方便地生成测试报告。可以结合 gcov/lcov等生成测试覆盖度报表。</p><h2 id="51-结构"><a class="markdownIt-Anchor" href="#51-结构"></a> 5.1 结构</h2><p>Cunit的结构基本如下图所示，分为三层，第一层是总的测试入口，第二层是测试包，第三层是测试用例。然后通过一系列的断言展示测试结果。</p><img src="https://s2.loli.net/2022/04/18/mIGRBMVLqA9Urha.jpg" width="500" height="400" alt="图片名称" align="center" id="164"><h2 id="52-基本流程"><a class="markdownIt-Anchor" href="#52-基本流程"></a> 5.2 基本流程</h2><ol><li>编写待测函数对应的测试函数（如果必要，需要写suite的init/cleanup函数）</li><li>初始化Test Registry - CU_initialize_registry()</li><li>把测试包（Test Suites）加入到Test Registry - CU_add_suite()</li><li>把测试用例（Test Case）加入到测试包当中 - CU_add_test()</li><li>使用适当的接口来运行测试测试程序，例如 CU_console_run_tests()</li><li>清除Test Registry - CU_cleanup_registry()</li></ol><h1 id="6-参考"><a class="markdownIt-Anchor" href="#6-参考"></a> 6 参考</h1><p><a href="https://blog.csdn.net/wangwencong/article/details/8189778" target="_blank" rel="noopener">wangwencong-认识单元测试中的打桩</a></p><p><a href="https://www.yanbinghu.com/2019/07/28/59484.html" target="_blank" rel="noopener">守望-库打桩机制-偷梁换柱</a></p><p><a href="https://m.2cto.com/kf/201708/667113.html" target="_blank" rel="noopener">一种C语言”打桩”的源码实现</a></p><p><a href="https://www.freebuf.com/articles/system/191865.html" target="_blank" rel="noopener">Covfefe-深入Linux | 如何在任意进程中修改内存保护（含PoC）</a></p><p><a href="https://promisechen.github.io/kbase/cunit.html" target="_blank" rel="noopener">陈令祥-CUnit测试工具</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="未分类" scheme="https://Dragonliu2018.github.io/categories/未分类/"/>
    
    
    <category term="待补充" scheme="https://Dragonliu2018.github.io/tags/待补充/"/>
    
  </entry>
  
  <entry>
    <title>华为实习任务-codecheck</title>
    <link href="https://dragonliu2018.github.io/2022/04/18/%E5%8D%8E%E4%B8%BA%E5%AE%9E%E4%B9%A0%E4%BB%BB%E5%8A%A1-codecheck/"/>
    <id>https://dragonliu2018.github.io/2022/04/18/%E5%8D%8E%E4%B8%BA%E5%AE%9E%E4%B9%A0%E4%BB%BB%E5%8A%A1-codecheck/</id>
    <published>2022-04-18T05:40:01.000Z</published>
    <updated>2022-04-18T16:50:22.812Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-引入"><a class="markdownIt-Anchor" href="#1-引入"></a> 1 引入</h1><p>在华为实习的三个月(2021.9-2021.11)中有两个月(9&amp;11月)都在做codecheck的工作，重复性操作，&quot;毫无&quot;技术含量可言。</p><p>令我惊讶的是：2022年4月份在实习答辩时，我说做了codecheck的工作。一位老师说（具体咋说的忘了，大致意思是：你是实习生，才三个月，华为不会让你改代码的（指核心代码？），你不要吹过头了），当时我愣住了，哈哈哈哈🥦。</p><p>答辩结束后仔细想了下，应该这样说：“实习期间，部门正好有codecheck的任务，我在其中做了一部分工作（包括xxx），改完代码后有检视人员保障代码质量。”</p><p>值得肯定的是：面对老师的奇怪语气+奇怪问法，没有进行反驳，毕竟到时间了（答辩每人10min），而且老师也没有听的意思。</p><p>总而言之，答辩时表达要得体（本次实习答辩自己多多少少存在这方面的问题，可能真是吹的口吻，只是自己没察觉）；认真听取老师的意见，一些情况下没必要进行反驳。还有就是要努力🥦🥦🥦</p><blockquote><p><a href="https://www.bookstack.cn/read/openharmony-1.0-zh-cn/contribute-OpenHarmony-cpp-coding-style-guide.md" target="_blank" rel="noopener">华为c++语言编程规范</a></p></blockquote><h1 id="2-冗余代码"><a class="markdownIt-Anchor" href="#2-冗余代码"></a> 2 冗余代码</h1><p><strong>规则4.4.3 不用的代码段直接删除，不要注释掉</strong></p><p>被注释掉的代码，无法被正常维护；当企图恢复使用这段代码时，极有可能引入易被忽略的缺陷。 正确的做法是，不需要的代码直接删除掉。若再需要时，考虑移植或重写这段代码。</p><p>这里说的注释掉代码，包括用 <code>/* */</code>和 <code>//</code>，还包括 <code>#if 0， #ifdef NEVER_DEFINED</code> 等等。</p><h1 id="3-圈复杂度cyclomatic-complexity"><a class="markdownIt-Anchor" href="#3-圈复杂度cyclomatic-complexity"></a> 3 圈复杂度（Cyclomatic complexity）</h1><p>详见 博客：<code>圈复杂度</code></p><p>定义：软件源码某部分的圈复杂度就是这部分代码中<a href="https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E6%97%A0%E5%85%B3/4705660" target="_blank" rel="noopener">线性无关</a>路径的数量。<a href="https://baike.baidu.com/item/%E5%9C%88%E5%A4%8D%E6%9D%82%E5%BA%A6/828737?fr=aladdin" target="_blank" rel="noopener">百度百科</a></p><p>含huge_cyclomatic_complexity和huge_cca_cyclomatic_complexity两个指标；cyclomatic_complexity和cca_cyclomatic_complexity的计算差异：</p><ul><li>cca_cyclomatic_complexity：不管switch里面有多少个case，圈复杂度只加1</li><li>cyclomatic_complexity：switch里面有多少个case，圈复杂度就加多少</li></ul><p>精髓：覆盖所有的可能情况最少使用的测试用例个数</p><ol><li>?: 三元运算符 +1</li><li>case +1</li><li>default +1</li><li>else +1</li></ol><p>华为规则：圈复杂度改到15以下</p><h1 id="4-超大目录"><a class="markdownIt-Anchor" href="#4-超大目录"></a> 4 超大目录</h1><p>华为规则：超大目录门槛50</p><p>拆分标准：根据数据库表，PDMReader</p><h1 id="5-降低文件重复率"><a class="markdownIt-Anchor" href="#5-降低文件重复率"></a> 5 降低文件重复率</h1><p><strong>问题</strong>：采用抽离函数的方式降DT重复率，但是cpp文件中重复代码过多且存在不同，所以会导致函数参数过多；抽离的函数中使用的if-else也会过多，导致圈复杂度上升；</p><p><strong>解决</strong>：将抽离函数按照功能块再拆分</p><h1 id="6-llvmclang-tidy"><a class="markdownIt-Anchor" href="#6-llvmclang-tidy"></a> 6 llvm(clang-tidy)</h1><p>llvm原生的，华为版本的</p><p>重新下库后需要执行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir cmake_build</span><br><span class="line"><span class="built_in">cd</span>  cmake_build</span><br><span class="line">cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=1 -DCMAKE_TOOLCHAIN_FILE=../cmake/scripts/gcc_all_toolchain.cmake ..</span><br><span class="line">cp ./compile_commands.json ..</span><br><span class="line"><span class="built_in">cd</span> ..</span><br></pre></td></tr></table></figure><p>在01_RB下执行命令，工具路径替换成自己的：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr1/dragon/llvm/tools/clang/tools/extra/clang-tidy/tool/run-clang-tidy.py -check=-*,modernize-use-nullptr,modernize-use-using,modernize-use-override -clang-tidy-binary=<span class="string">'/usr1/dragon/llvm/build/bin/clang-tidy'</span> -clang-apply-replacements-binary=<span class="string">'/usr1/dragon/llvm/build/bin/clang-apply-replacements'</span> -header-filter=./rating_charging/cppcode/tools/* -fix ./rating_charging/cppcode/tools</span><br></pre></td></tr></table></figure><p>自动化修复：</p><ul><li>modernize-use-nullptr</li><li>modernize-use-using：typedef-&gt;using</li><li>modernize-use-override</li></ul><h1 id="7-c类型风格转换"><a class="markdownIt-Anchor" href="#7-c类型风格转换"></a> 7 c++类型风格转换</h1><ul><li>先去了解清楚C++11类型转换的语法</li><li>几种转换使用的场景</li></ul><h1 id="8-超大函数huge-method"><a class="markdownIt-Anchor" href="#8-超大函数huge-method"></a> 8 超大函数（huge method）</h1><p>代码行大于阈值（阈值由产品CMC根据自身情况决策、定义）的函数</p><h1 id="9-gexp35-cpp-使用nullptr作为空指针常量"><a class="markdownIt-Anchor" href="#9-gexp35-cpp-使用nullptr作为空指针常量"></a> 9 G.EXP.35-CPP 使用<code>nullptr</code>作为空指针常量</h1><p><strong>【级别】</strong> 要求</p><p><strong>【描述】</strong></p><p>C++11开始引入了nullptr关键字代表空指针，在此之前使用NULL宏来表示空指针常量，导致出现如下问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL ((void*)0)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* str = <span class="literal">NULL</span>; <span class="comment">// 编译错误: void* 不能自动转换为 char*</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>(C::*pmf)() = &amp;C::Func;</span><br><span class="line"><span class="keyword">if</span> (pmf == <span class="literal">NULL</span>) &#123; <span class="comment">// 编译错误: void* 不能自动转换为指向成员函数的指针</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果把<code>NULL</code>被定义为<code>0</code>或<code>0L</code>。可以解决上面的问题。或者在需要空指针的地方直接使用<code>0</code>。</p><p>但这引入另一个问题，代码不清晰，特别是使用<code>auto</code>自动推导时更为突出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> result =Find(id);</span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">0</span>) &#123;<span class="comment">// Find() 返回的是 指针 还是 整数?</span></span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>0</code>字面上是<code>int</code>类型(<code>0L</code>是<code>long</code>)，所以<code>NULL</code>和<code>0</code>都不是指针类型。</p><p>当重载指针和整数类型的函数时，传递<code>NULL</code>或<code>0</code>都调用到整数类型重载的函数:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line">F(<span class="number">0</span>);<span class="comment">// 调用 F(int)，而非 F(int*)</span></span><br><span class="line">F(<span class="literal">NULL</span>);<span class="comment">// 调用 F(int)，而非 F(int*)</span></span><br></pre></td></tr></table></figure><p>另外，<code>sizeof(NULL) == sizeof(void*)</code>并不一定总是成立的，直接使用<code>0</code>或<code>0L</code>，代码不清晰，且无法做到类型安全；使用<code>NULL</code>无法做到类型安全。这些都是潜在的风险。</p><p><code>nullptr</code>的优势不仅仅是在字面上代表了空指针，使代码清晰，而且它不再是一个整数类型。</p><p><code>nullptr</code>是<code>std::nullptr_t</code>类型，而<code>std::nullptr_t</code>可以隐式的转换为所有的原始指针类型，这使得<code>nullptr</code>可以表现成指向任意类型的空指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span>*)</span></span>;</span><br><span class="line">F(<span class="literal">nullptr</span>);<span class="comment">// 调用 F(int*)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> result =Find(id);</span><br><span class="line"><span class="keyword">if</span> (result ==<span class="literal">nullptr</span>) &#123; <span class="comment">// Find() 返回的是 指针</span></span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="10-gexp03-cpp-使用using定义类型别名"><a class="markdownIt-Anchor" href="#10-gexp03-cpp-使用using定义类型别名"></a> 10 G.EXP.03-CPP 使用using定义类型别名</h1><p>**【级别】**建议</p><p><strong>【描述】</strong></p><p>类型的别名实际是对类型的封装。而通过封装，可以让代码更清晰，同时在很大程度上避免类型变化带来的散弹式修改。</p><p>在<code>C++11</code>之前，可以通过<code>typedef</code>定义类型的别名：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">uint32_t</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; SomeType;</span><br></pre></td></tr></table></figure><p>在<code>C++11</code>之后，提供<code>using</code>，实现<code>声明别名(alias declarations)</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> SomeType = <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">uint32_t</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;;</span><br></pre></td></tr></table></figure><p>对比两者的格式，使用using更容易理解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Type Alias; <span class="comment">// Type 在前，还是 Alias 在前，不宜历届</span></span><br><span class="line"><span class="keyword">using</span> Alias = Type; <span class="comment">// 符合'赋值'的用法，容易理解，不易出错</span></span><br></pre></td></tr></table></figure><p>如果觉得这点还不足以切换到<code>using</code>，我们接着看看<code>模板别名(alias template)</code>更简洁:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义模板的别名，一行代码</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; // <span class="title">template</span></span></span><br><span class="line"><span class="class"><span class="title">using</span> <span class="title">MyAllocatorVector</span> = <span class="title">std</span>:</span>:<span class="built_in">vector</span>&lt;T,MyAllocator&lt;T&gt;&gt;;</span><br><span class="line"></span><br><span class="line">MyAllocatorVector&lt;<span class="keyword">int</span>&gt; data;<span class="comment">// 使用 using 定义的别名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; // <span class="title">template</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        MyAllocatorVector&lt;<span class="keyword">int</span>&gt; data_;<span class="comment">// 模板类中使用 using 定义的别名</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而<code>typedef</code>不支持带模板参数的别名，只能”曲线救国”:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过模板包装 typedef，需要实现一个模板类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">MyAllocatorVector</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T,MyAllocator&lt;T&gt;&gt; type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyAllocatorVector&lt;<span class="keyword">int</span>&gt;::type data; <span class="comment">// 使用 typedef 定义的别名，多写 ::type</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typename</span> MyAllocatorVector&lt;<span class="keyword">int</span>&gt;::type data_; <span class="comment">// 模板类中使用，除了 ::type，还需要加上 typename</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实习中遇到的实例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">typedef</span> TChar NumArray[<span class="number">24</span>];</span><br><span class="line"><span class="keyword">using</span> NumArray = TChar[<span class="number">24</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体c++中，定义变量无需加关键字struct</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    TUInt4 uiAVPcode;</span><br><span class="line">    TUChar ucAVPflag_r : <span class="number">5</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125; AVPHEAD;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AVPHEAD</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数指针</span></span><br><span class="line"><span class="comment">// typedef 返回类型(*新类型)(参数表)</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">RETCODE</span> <span class="params">(*FnFmtFunc)</span><span class="params">(<span class="keyword">const</span> TChar* cdrBuff, TUInt4 cdrLen)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">using</span> FnFmtFunc = RETCODE (*)(<span class="keyword">const</span> TChar* cdrBuff, TUInt4 cdrLen) <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure><h1 id="10-gcls12-cpp-在重写虚函数时应明确指定override或final"><a class="markdownIt-Anchor" href="#10-gcls12-cpp-在重写虚函数时应明确指定override或final"></a> 10  G.CLS.12-CPP 在重写虚函数时应明确指定<code>override</code>或<code>final</code></h1><p>**【级别】**要求</p><p><strong>【描述】</strong></p><p>在重写虚函数时明确指定override或final，能保证该函数是重写了基类的虚函数，并且无需再添加virtual关键字。如果派生类函数与基类函数原型不一致，则产生编译错误。<code>final</code>还保证虚函数不会再被派生类重写。</p><ul><li>virtual 表示一个新的虚函数</li><li>override 表示重写了基类中的虚函数，可以再被派生类重写</li><li>final 表示重写了基类中的虚函数，不能再被派生类重写</li></ul><p>使用<code>override</code>或<code>final</code>关键字后，如果修改了基类虚函数原型，但忘记修改子类重写的虚函数，在编译期就可以发现。也可以避免有多个子类时，重写虚函数的修改遗漏。</p><p><strong>【正例】</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base();</span><br><span class="line">    <span class="keyword">virtual</span> ~Base();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Foo</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Foo</span><span class="params">(<span class="keyword">int</span> var)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Bar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">class <span class="title">Derived</span><span class="params">()</span>: <span class="keyword">public</span> Base </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived();</span><br><span class="line">    ~Derived() <span class="keyword">override</span>; <span class="comment">// 符合：析构函数添加override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">(<span class="keyword">int</span> var)</span> <span class="keyword">final</span></span>; <span class="comment">// 符合：重写基类函数，且Derived的派生类不能再重写此函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">()</span> <span class="keyword">override</span></span>;<span class="comment">// 符合：重写基类函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;<span class="comment">// 编译失败: Derived::Foo 和 Base::Foo 原型不一致，</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Bar</span><span class="params">()</span> <span class="keyword">override</span></span>;<span class="comment">// 编译失败: Base::Bar 不是虚函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><ol><li>基类首次定义虚函数，使用<code>virtual</code>关键字</li><li>子类重写基类虚函数（包括析构函数），使用<code>override</code>或<code>final</code>关键字（但不要两者一起使用），并且不使用<code>virtual</code>关键字</li><li>非虚函数，<code>virtual</code>、<code>override</code>和<code>final</code>都不使用</li></ol><p>【实习实例】</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_SERVICE_PLUGIN(CBypassMsgController);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_SERVICE_PLUGIN(CLASS_NAME) \</span></span><br><span class="line">DECLARE_SERVICE_COMPONET(CLASS_NAME); \</span><br><span class="line"><span class="keyword">protected</span>: \</span><br><span class="line">virtual const TChar* MyName() const \</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> #CLASS_NAME; \</span><br><span class="line">    &#125; \</span><br><span class="line">        </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_SERVICE_PLUGIN(CLASS_NAME) \</span></span><br><span class="line">DECLARE_SERVICE_COMPONET(CLASS_NAME); \</span><br><span class="line"><span class="keyword">protected</span>: \</span><br><span class="line">virtual const TChar* MyName() const override \</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> #CLASS_NAME; \</span><br><span class="line">    &#125; \</span><br></pre></td></tr></table></figure><h1 id="11-gexp29-cpp-比较两个表达式左侧倾向于变化右侧倾向于不变"><a class="markdownIt-Anchor" href="#11-gexp29-cpp-比较两个表达式左侧倾向于变化右侧倾向于不变"></a> 11 G.EXP.29-CPP 比较两个表达式，左侧倾向于变化，右侧倾向于不变</h1><p>**【级别】**建议</p><p><strong>【描述】</strong></p><p>当变量与常量比较时，如果常量放左边，如 if (MAX == v) 不符合阅读习惯，而 if (MAX &gt; v) 更是难于理解。 应当按人的正常阅读、表达习惯，将常量放右边。写成如下方式：</p><p><strong>【正例】</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (value == MAX) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (value &lt; MAX) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也有特殊情况，如：<code>if (MIN &lt; value &amp;&amp; value &lt; MAX)</code> 用来描述区间时，前半段是常量在左的。</p><p>不用担心将 <code>==</code> 误写成 <code>=</code>，因为<code>if (value = MAX)</code> 会有编译告警，其他静态检查工具也会报错。让工具去解决笔误问题，代码要符合可读性第一。</p><p><strong>【脚本误报】</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 逻辑或</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">'N'</span> == cSIPChgSubsNoType || <span class="string">'\0'</span> == cSIPChgSubsNoType) </span><br><span class="line"><span class="keyword">if</span> (cSIPChgSubsNoType == <span class="string">'N'</span> == cSIPChgSubsNoType || <span class="string">'\0'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 逻辑并</span></span><br><span class="line">TBool bContinue = <span class="number">0</span> &gt;= lSecUnpaid &amp;&amp; bSingle;</span><br><span class="line">TBool bContinue = lSecUnpaid &amp;&amp; bSingle &lt;= <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h1 id="12-其他"><a class="markdownIt-Anchor" href="#12-其他"></a> 12 其他</h1><ul><li>G.FMT.02-CPP 使用空格进行缩进，每次缩进4个空格</li><li>G.CMT.03-CPP 文件头注释包含版权说明</li><li>G.CMT.02-CPP 代码注释置于对应代码的上方或右边</li><li>G.FMT.06-CPP 换行时将操作符留在行末，新行缩进一层或进行同类对齐</li><li>G.FMT.09-CPP 构造函数初始化列表放在同一行或按4空格缩进并排多行</li><li>G.FMT.13-CPP case/default语句相对于switch缩进一层</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="未分类" scheme="https://Dragonliu2018.github.io/categories/未分类/"/>
    
    
    <category term="重构" scheme="https://Dragonliu2018.github.io/tags/重构/"/>
    
  </entry>
  
  <entry>
    <title>大数据训练营项目《北京二手房交易数据分析平台》整理</title>
    <link href="https://dragonliu2018.github.io/2022/04/18/%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%AE%AD%E7%BB%83%E8%90%A5%E9%A1%B9%E7%9B%AE%E3%80%8A%E5%8C%97%E4%BA%AC%E4%BA%8C%E6%89%8B%E6%88%BF%E4%BA%A4%E6%98%93%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%E3%80%8B%E6%95%B4%E7%90%86/"/>
    <id>https://dragonliu2018.github.io/2022/04/18/%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%AE%AD%E7%BB%83%E8%90%A5%E9%A1%B9%E7%9B%AE%E3%80%8A%E5%8C%97%E4%BA%AC%E4%BA%8C%E6%89%8B%E6%88%BF%E4%BA%A4%E6%98%93%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%E3%80%8B%E6%95%B4%E7%90%86/</id>
    <published>2022-04-18T05:10:43.000Z</published>
    <updated>2022-04-18T16:02:57.639Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-简介"><a class="markdownIt-Anchor" href="#1-简介"></a> 1 简介</h1><p>北京二手房交易数据分析平台：收集二手房交易数据，利用大数据技术进行处理，大屏展示结果  。</p><h1 id="2-工作流程"><a class="markdownIt-Anchor" href="#2-工作流程"></a> 2 工作流程</h1><ol><li><strong>数据收集</strong>：爬取二手房交易网站的数据（链家、贝壳等）</li><li><strong>数据预处理</strong>：不同的数据源，不同的数据结构，垃圾数据，对收集到的大数据集合进行预处理</li><li><strong>数据存储、处理与分析（我负责）</strong>：搭建hadoop环境，将数据文件上传hdfs，通过mapreduce进行数据分析等</li><li><strong>数据可视化</strong>：后端使用java、前端使用echarts模板等进行展示</li></ol><h1 id="3-负责"><a class="markdownIt-Anchor" href="#3-负责"></a> 3 负责</h1><ul><li><strong>集群</strong>：3台centos虚拟机</li><li><strong>名词解释</strong>：<ul><li>hadoop：Hadoop是一个能够对大量数据进行<a href="https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E5%A4%84%E7%90%86" target="_blank" rel="noopener">分布式处理</a>的<a href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6" target="_blank" rel="noopener">软件</a>框架。 <a href="https://baike.baidu.com/item/Hadoop/3526507" target="_blank" rel="noopener">https://baike.baidu.com/item/Hadoop/3526507</a><ul><li>hdfs：分布式文件系统 <a href="https://baike.baidu.com/item/hdfs/4836121" target="_blank" rel="noopener">https://baike.baidu.com/item/hdfs/4836121</a></li><li>mapreduce：是一种编程模型，用于大规模数据集（大于1TB）的并行运算 <a href="https://baike.baidu.com/item/MapReduce/133425" target="_blank" rel="noopener">https://baike.baidu.com/item/MapReduce/133425</a></li></ul></li><li>hive：Hive是基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表，并提供类SQL查询功能。 <a href="https://developer.aliyun.com/article/100911" target="_blank" rel="noopener">https://developer.aliyun.com/article/100911</a></li><li>sqoop：主要用于在Hadoop(Hive)与传统的数据库(mysql、postgresql…)间进行数据的传递   <a href="https://baike.baidu.com/item/sqoop/5033853" target="_blank" rel="noopener">https://baike.baidu.com/item/sqoop/5033853</a></li></ul></li></ul><h1 id="4-项目架构图"><a class="markdownIt-Anchor" href="#4-项目架构图"></a> 4 项目架构图</h1><p><img src="https://s2.loli.net/2022/03/23/FPK2J3Ozo71Veav.png" alt></p><h1 id="5-困难"><a class="markdownIt-Anchor" href="#5-困难"></a> 5 困难</h1><ul><li>hadoop集群搭建失败：版本没用对</li><li></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="大数据" scheme="https://Dragonliu2018.github.io/categories/大数据/"/>
    
    
    <category term="待补充" scheme="https://Dragonliu2018.github.io/tags/待补充/"/>
    
  </entry>
  
  <entry>
    <title>《世事如书，我只爱你这一句》书籍</title>
    <link href="https://dragonliu2018.github.io/2022/04/17/%E3%80%8A%E4%B8%96%E4%BA%8B%E5%A6%82%E4%B9%A6%EF%BC%8C%E6%88%91%E5%8F%AA%E7%88%B1%E4%BD%A0%E8%BF%99%E4%B8%80%E5%8F%A5%E3%80%8B%E4%B9%A6%E7%B1%8D/"/>
    <id>https://dragonliu2018.github.io/2022/04/17/%E3%80%8A%E4%B8%96%E4%BA%8B%E5%A6%82%E4%B9%A6%EF%BC%8C%E6%88%91%E5%8F%AA%E7%88%B1%E4%BD%A0%E8%BF%99%E4%B8%80%E5%8F%A5%E3%80%8B%E4%B9%A6%E7%B1%8D/</id>
    <published>2022-04-17T14:34:04.000Z</published>
    <updated>2022-04-17T16:10:08.246Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-简介"><a class="markdownIt-Anchor" href="#1-简介"></a> 1 简介</h1><p>朱生豪：“醒来觉得甚是爱你。”</p><p>张爱玲：“因为爱过，所以慈悲；因为懂得，所以宽容。”</p><p>林徽因：“答案很长，我得用一生去回答你，准备好听我了吗？”</p><p>钱钟书：“我见到她之前，从未想到要结婚；我娶了她十几年，从未后悔娶她；也从未想过要娶别的女人。”</p><p>沈从文说：“我走过许多地方的路，行过许多地方的桥，看过许多次数的云，喝过许多种类的酒，却只爱过一个正当最好年龄的人。”</p><p>央视朗读者盛赞，温暖了一个世纪的民国爱情故事。20对民国才子佳人的缱绻情书，有梁思成与林徽因的“门当户对四月天”，有林语堂与廖翠凤的“焚证报卿缠绵意”，有徐志摩与陆小曼的“离悲成欢有绝期”，也有胡兰成与张爱玲的“终成饭粘萎尘泥”，一字字，一句句，令人心生暖意，不禁想回到那个年代，去同他们一起谈天说地，抑或静下心来给心上人，写一封暖暖的情书。</p><p>关于民国美好的爱情故事，是印刻在我们记忆里的传奇，我们不断回忆，不断打磨，把思念书写成文字，把故事打磨成璞玉。最终，裁成四月的天。</p><h1 id="2-作者"><a class="markdownIt-Anchor" href="#2-作者"></a> 2 作者</h1><p>特立独行的猪先生，编剧、民国史研究者。因热爱民国史，致力于把枯燥的历史用年轻人喜闻乐见的方式表述出来，创有历史游记节目“猪游记”，现为独立自媒体人。</p><p>作者访遍书中人物故居，翻阅现存史料记载，游历了各个名人博物馆，并整理了他们当年的信件及书稿，历数年写就成书。</p><p>作者完全摒弃了市面上诸多历史书籍误读的地方，并一一实地考察校正，为我们真实还原了那个时期民国才子佳人的爱情故事，完整重现了他们可歌可泣的爱情历程。</p><h1 id="3-摘抄"><a class="markdownIt-Anchor" href="#3-摘抄"></a> 3 摘抄</h1><center>一刹那的爱意，可以永恒</center><p><strong>醒来觉得甚是爱你 朱生豪&amp;宋清如</strong></p><blockquote><p>朱生豪在给宋清如的信中写道：“要是我们两人一同在雨声里做梦，那意境是如何不同，或者一同在雨声里失眠，那也是何等有味。”</p><hr><p>我是宋清如至上主义者。</p><hr><p>要是世上只有我们两个人多么好，我一定要把你欺负得哭不出来。</p><hr><p>我爱你也许并不为什么理由，虽然可以有理由，例如你聪明，你纯洁，你可爱，你是好人等，但主要的原因大概是你全然适合我的趣味。因此你仍知道我是自私的，故不用感激我。</p></blockquote><p><strong>从今往后，咱们只有死别，再无生离 钱钟书&amp;杨绛</strong></p><blockquote><p>有的时候，人和人的缘分，一面就能注定。</p><hr><p>后来两人再次见面，约在了清华大学工字厅。钱钟书说道：“我没有订婚。”杨绛答：“我也没有男朋友。”</p><p>对话就是这样直白，一旦遇到了自己心动的那个人，不需要太多的言语，从对方的瞳孔里，你会看到光。</p><hr><p>缠绵悱恻好文章，粉恋香凄足断肠。答报情痴无别物，辛酸一把泪千行。</p><p>依穰小妹剧关心，髾瓣多情一往深。别后经时无只字，居然惜墨抵兼金。</p><p>良宵苦被睡相谩，猎猎风声测测寒。如此星辰如此月，与谁指点与谁看。</p><p>困人节气奈何天，泥煞衾函梦不圆。苦雨泼寒宵似水，百虫声里怯孤眠。</p></blockquote><p><strong>我明白你会来，所以我等 沈从文&amp;张兆和</strong></p><blockquote><p>沈从文这个从乡下走出来的男子遇见清秀典雅的张兆和，便爱得一发不可收拾，他按捺不住内心狂热的爱慕。他把爱慕之情化作情书，第一封情书的开头就直白地写道：</p><p>不知道为什么，我突然爱上了你！</p><hr><p>张兆和对于爱的理解是对的，爱是双方的，需要灵魂的契合，爱就是爱，不爱就是不爱。爱不是感动，不是单方面的付出，当爱掺杂了太多的不平等时，这份爱也就不再能给相爱的人带来快乐。</p></blockquote><p><strong>因为懂得，所以慈悲 张爱玲&amp;胡兰成</strong></p><blockquote><p>张爱玲说：“见了他，她变得很低很低，低到尘埃里，但她心里是欢喜的，从尘埃里开出花来。”</p></blockquote><p><strong>明月装饰了你的窗子，你装饰了别人的梦 卞之琳&amp;张充和</strong></p><blockquote><p>那一抹笑，像是一朵莲花，盛开在那清波碧水间，荡起了一圈一圈涟漪，倩影映射在他的瞳孔里，在他明亮细腻的心里，扎下了根。</p><hr><p>这首诗便是《断章》：</p><p>你站在桥上看风景，</p><p>看风景的人在楼上看你。</p><p>明月装饰了你的窗子，</p><p>你装饰了别人的梦。</p><hr><p>张充和无奈地说道：“从来大家都这么问，我说：他没有说请客，我怎么能说不来呢？他从来没有认真跟我表白过，写信说的也只是日常普通的事，只是写得有点啰唆。</p><hr><p>不得不承认，在我们的生命中，有些人哪怕是很多年没见，你早已忘记了她的声音，脑海中模糊了她的容颜，但再次相遇时，那感觉却永远不会变。</p></blockquote><p><strong>你是燕在梁间的呢喃，你是人间的四月天 梁思成&amp;林徽因</strong></p><blockquote><p>中国有句俗话，‘文章是自己的好，老婆是人家的好’。可是对我来说是，老婆是自己的好，文章是老婆的好，我不否认和林徽因在一起有时很累，因为她的思想太活跃，和她在一起必须和她同样的反应敏捷才行，不然就跟不上她。</p></blockquote><p><strong>心里挂念一个人，从此便有一座城 金岳霖&amp;林徽因</strong></p><blockquote><p>金岳霖听闻后不禁恸哭，在林徽因的追悼会上，金岳霖眼泪没停过，并为她送上了一副挽联：</p><p>一身诗意千寻瀑<br>万古人间四月天</p><hr><p>我们能想象，他在想什么，他或许会想起总布胡同的那段时光，那天，他第一次见到林徽因笑靥如花的样子，就像那四月的花，开在了那个初春，扎根在了他的心里；他或许会想起西南联大的艰苦岁月，会想起林徽因的一颦一笑、一步一印，往事一幕一幕在眼前晃过，活着的他又何尝不想去见她？心里挂念一个人，从此便有一座城。</p><hr><p>人生在世，是该相信点什么的。</p><p>相信爱情，相信遇见与离别；相信未来，会有那样一个人，在不远处等着你；相信一切都是最好的安排；相信美好的事即将发生。</p></blockquote><p><strong>风华是一指流沙，苍老是一段年华 徐志摩&amp;陆小曼</strong></p><blockquote><p>这是婚后陆小曼写给王映霞的信里的话，可谓一针见血。这点她没有林徽因明白得早，当年林徽因就知道徐志摩喜欢的自己并不是真实的自己，而是他自己臆想出来的林徽因。</p></blockquote><p><strong>彪悍的婚姻，不需要解释 胡适&amp;江冬秀</strong></p><blockquote><p>…</p></blockquote><p><strong>小白象与小刺猬，他们相拥而爱 鲁迅&amp;许广平</strong></p><blockquote><p>鲁迅说：“我脾气不好。”</p><p>许广平说：“因为你是先生，我多少让你些，如果是年龄相仿的对手，我不会这样的。”</p></blockquote><p><strong>你许我岁月静好，我还你现世安稳 巴金&amp;萧珊</strong></p><blockquote><p>一生选一人，择一城，生同眠，死同穴，生生世世都要在一起。巴金与萧珊二十多年相濡以沫，两个人在一起，朝着相同的方向努力，相互扶持，这就是最好的爱情。</p></blockquote><p><strong>陪伴是最长情的爱恋，相守是最美好的婚姻 林语堂&amp;廖翠凤</strong></p><blockquote><p>结婚的时候，林语堂做了一件奇事，他把结婚证书一把火烧掉了。</p><p>他说了这样一句话：“把婚书烧了吧，因为婚书只是离婚时才用得着。”</p><p>张爱玲说：“也许每一个男子全都有过这样的两个女人，至少两个，娶了红玫瑰，久而久之，红的变了墙上的一抹蚊子血，白的还是床前明月光，娶了白玫瑰，白的便是衣服上沾的一粒饭粘子，红的却是心口上一颗朱砂痣。</p><hr><p>廖翠凤的一生是甜蜜的、快乐的。人生中最幸福的事就是和同床共枕的那个人一起嘻嘻闹闹，一起看着彼此鬓角渐白、牙齿渐松，然后相对掩嘴偷笑，彼此相依，共度一生。</p></blockquote><p><strong>爱情和婚姻，就该是这般模样 梁实秋&amp;程季淑</strong></p><blockquote><p>程季淑去世后，梁实秋说：“我像一棵树，突然一声霹雳，电火殛毁了半劈的树干，还剩下半株，有枝有叶，还活着，但是生意尽矣。两个人手拉着手的走下山，一个突然倒下去，另一个只好踉踉跄跄地独自继续他的旅程！</p><hr><p>娶妻如此，夫复何求。<br>平生伴侣，亦友亦妻。</p></blockquote><p><strong>他们的爱情，如荷塘清风般淡雅 朱自清&amp;陈竹隐</strong></p><blockquote><p>一九三一年六月十二日，朱自清在情书中写道：“隐，一见你的眼睛，我便清醒起来，我更喜欢看你那晕红的双腮，黄昏时的霞彩似的，谢谢你给我力量。</p><hr><p>原来，生活可以美好，只是过去忘了去寻找。</p></blockquote><p><strong>君对我情断义绝，我偏长出倔强花朵 徐志摩&amp;张幼仪</strong></p><blockquote><p>张幼仪其实长得不差，她自己也说： 我身材不错，还长着一双大眼睛，也是被人夸大的。</p></blockquote><p><strong>生同眠，死同穴，生生世世都要在一起 吴文藻&amp;冰心</strong></p><blockquote><p>冰心：“爱在右，同情在左，走在生命路的两旁，随时撒种，随时开花，将这一径长途，点缀得香花弥漫，使穿枝拂叶的行人，踏着荆棘，不觉得痛苦，有泪可落，也不是悲凉。”</p><hr><p>生同眠，死同穴，天地合，不可与君绝，这大抵就是世间最圆满的爱情了。</p><blockquote><p><strong>此处化用</strong>：汉代<a href="https://so.gushiwen.cn/authorv_2128926194cd.aspx" target="_blank" rel="noopener">佚名</a>的《上邪》</p><p>我欲与君相知，长命无绝衰。<br><strong>山无陵</strong>，江水为竭，冬雷震震，夏雨雪，<strong>天地合，乃敢与君绝！</strong></p></blockquote></blockquote><p><strong>你走，我当你没来过 徐悲鸿&amp;蒋碧微</strong></p><blockquote><p>但蒋碧微拒绝了，并拒绝了六次，无论这个男人在她面前表现得多么悔恨。蒋碧微对徐悲鸿说：“你来，我相信你不会走；你走，我当你没来过。”</p></blockquote><p><strong>在你的生命中，我将孤独地老去 鲁迅&amp;朱安</strong></p><blockquote><p>这是母亲给我的一件礼物，我只能好好地供养她，爱情是我所不知道的。</p><hr><p>朱安明白自己这一生的命运，明白她追随鲁迅一辈子，与他也只能是两条平行线，此生没有相交的可能。她终其一生，都不会是那个与鲁迅温馨相伴的女子。</p><hr><p>朱安的一生，是悲剧的一生，如她自己所说：鲁迅与她不好，她想好好地服侍他，一切顺着他，将来总会好的。</p><p>然而一切没有变好，她与鲁迅越走越远，她就这样在岁月中蹉跎了自己的一生。就像那只蜗牛，一点一点地往上爬，她相信总有一天能爬到墙顶，走进鲁迅的心里，但鲁迅终究不是胡适，朱安也不是江冬秀，她拼尽余生的力气终究也没能成为鲁迅心口上的一颗朱砂痣。</p></blockquote><p><strong>最好的爱情，便是我懂你 张伯驹&amp;潘素</strong></p><blockquote><p>…</p></blockquote><p><strong>微风吹动了我的头发，教我如何不想她 赵元任&amp;杨步伟</strong></p><blockquote><p>…</p></blockquote><h1 id="4-自评"><a class="markdownIt-Anchor" href="#4-自评"></a> 4 自评</h1><p>大四上学期一段时间特别喜欢看欧丽娟关于爱情的视频，其中她推荐了这本书《世事如书，我只爱你这一句》。</p><p>向来欣赏民国才子佳人，但是将其冠以<code>择一人终老，携一人白首</code>的刻板印象，未免有些不公平，对此我有心理准备，于是安静地期待地翻开了这本书。</p><hr><p>（待补充）</p><hr><p>我明白你会来，所以我等。等到最好的我，去遇到更好的你。</p><h1 id="5-他评"><a class="markdownIt-Anchor" href="#5-他评"></a> 5 他评</h1><p>xxx</p><h1 id="6-拓展"><a class="markdownIt-Anchor" href="#6-拓展"></a> 6 拓展</h1><p>是否被拍成影视作品？（无）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="阅读" scheme="https://Dragonliu2018.github.io/categories/阅读/"/>
    
    
    <category term="书评" scheme="https://Dragonliu2018.github.io/tags/书评/"/>
    
  </entry>
  
  <entry>
    <title>Clion项目配置教程</title>
    <link href="https://dragonliu2018.github.io/2022/04/17/Clion%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/"/>
    <id>https://dragonliu2018.github.io/2022/04/17/Clion%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/</id>
    <published>2022-04-16T16:31:32.000Z</published>
    <updated>2022-04-16T17:08:48.772Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-下载clion申请license"><a class="markdownIt-Anchor" href="#1-下载clion申请license"></a> 1 下载clion，申请license</h1><ol><li>在clion官网下载安装包（在华为实习时是在IT工具库下载的）；</li><li>申请license，学生邮箱免费使用（公司里面需要审批申请license）；</li></ol><h1 id="2-第一次打开clion前修改缓存位置"><a class="markdownIt-Anchor" href="#2-第一次打开clion前修改缓存位置"></a> 2 第一次打开clion前修改缓存位置</h1><ol><li><p>打开下载目录<code>bin</code>文件夹下<code>idea.properties</code>文件；</p></li><li><p>放开如下注释，并修改<code>idea.config.path</code>和<code>idea.system.path</code>的取值（事先创建这两个目录）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">idea.config.path=目录1</span><br><span class="line">idea.system.path=目录2</span><br><span class="line">idea.plugins.path=$&#123;idea.config.path&#125;/plugins</span><br><span class="line">idea.log.path=$&#123;idea.system.path&#125;/log</span><br></pre></td></tr></table></figure></li></ol><p>这一步是为了避免C盘存放JetBrains的工程缓存内容而被过度占用。</p><p>如果clion已经打开了，也可以修改此配置，只不过可能要重新配置一下clion的初始化步骤。</p><h1 id="3-下载01_rb代码用clion打开"><a class="markdownIt-Anchor" href="#3-下载01_rb代码用clion打开"></a> 3 下载01_RB代码，用clion打开</h1><ol><li>打开部门主仓库；</li><li>Fork自己的仓库；</li><li>安装git并配置，然后将自己的仓库拉到本地。</li></ol><h1 id="4-手动代理设置"><a class="markdownIt-Anchor" href="#4-手动代理设置"></a> 4 手动代理设置</h1><ol><li>点击<code>文件(File)</code>，选择<code>设置(setting)</code>，选择<code>外观和行为——系统设置——HTTP代理</code></li><li>进行配置：<ul><li>主机名：<code>proxy.huawei.com</code></li><li>端口：<code>8080</code></li><li>不为以下项使用代理：<code>127.0.0.1, 10.*.100.*, *.huawei.com</code></li></ul></li></ol><img src="https://s2.loli.net/2022/04/17/LdPivWetjscnFD9.png" width="800" height="400" alt="图片名称" align="center" id="1"><h1 id="5-安装插件"><a class="markdownIt-Anchor" href="#5-安装插件"></a> 5 安装插件</h1><ol><li>打开clion，点击<code>文件(File)</code>，选择<code>设置(settings)</code>，选择<code>插件(plugins)</code>；</li><li>安装以下插件：Chinese，（JetBrains Foundation，Huawei Jetbrains Marketplace，codecheck未找到）</li><li>重启IDE生效</li></ol><h1 id="6-配置远程工作模式"><a class="markdownIt-Anchor" href="#6-配置远程工作模式"></a> 6 配置远程工作模式</h1><ol><li><p><strong>配置工具链</strong>：点击<code>文件(File)</code>，选择<code>设置(setting)</code>，选择<code>构建、执行、部署——工具链</code>，添加远程主机，配置远程主机信息。凭据需要点击后方齿轮进行配置。Make，C编译器，C++编译器会自动检测，不需要配置。</p><img src="https://s2.loli.net/2022/04/17/1u7gXWixpfLIYHT.png" width="1000" height="500" alt="图片名称" align="center" id="2"></li><li><p><strong>配置CMake</strong>：</p><ul><li>CMake 选项：<code>-DCMAKE_TOOLCHAIN_FILE=../cmake/scripts/gcc_ut_toolchain.cmake ..</code></li><li>构建目录：<code>cmake-build-debug</code>（需要与自己项目中的目录对应）</li><li>构建选项：<code>-- -j 32</code>（多线程）</li><li>环境：<code>CHG_HOME=xxx;LD_LIBRARY_PATH=xxx</code>（需要和自己项目中的目录对应）</li></ul></li><li><p><strong>配置部署</strong>：点击<code>文件</code>，选择<code>设置</code>，选择<code>部署</code>，点击<code>映射</code>，配置部署路径：<code>/usr1/dragon/01_RB</code>（改成自己的，远程主机上的项目根目录）</p><img src="https://s2.loli.net/2022/04/17/2h1tioH4Q5snyrp.png" width="1000" height="300" alt="图片名称" align="center" id="3"></li><li><p><strong>Debug配置</strong>：登陆到远程主机，将环境变量添加到<code>~/.bashrc</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> CHG_HOME=xxx</span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=xxx</span><br><span class="line"><span class="built_in">export</span> TZ=BEST-8</span><br><span class="line"><span class="built_in">export</span> BILLING_HOME=xxx</span><br></pre></td></tr></table></figure></li></ol><h1 id="7-clang-format的使用"><a class="markdownIt-Anchor" href="#7-clang-format的使用"></a> 7 clang-format的使用</h1><ol><li>将<code>.clang-fromat</code>文件放到要打开项目的根目录下，CLion会自动启用ClangFormat并应用设置；</li><li>在<code>文件——设置——编辑器——代码样式</code>勾选启用<code>ClangFormat</code>，然后状态栏会显示<code>ClangFormat</code>；</li><li>使用快捷键<code>Ctrl+Alt+L</code>，可以重新格式化选定代码，没有选定代码时，会格式化整个文件；</li></ol><h1 id="8-ut的配置"><a class="markdownIt-Anchor" href="#8-ut的配置"></a> 8 UT的配置</h1><ol><li>选择<code>编辑配置--UTTest</code>，进行配置并应用：<ul><li>程序参数：<code>nolog --gtest_filter=&quot;xxx&quot;</code>（后面的–gtest_filter=&quot;…&quot;是根据CLion输出信息填写的，过滤掉无关报错）</li><li>环境变量：<code>CHG_HOME=xxx;LD_LIBRARY_PATH=xxx;TZ=BEST-8;BILLING_HOME=xxx</code></li></ul></li><li>单个执行配置，在当前界面点击<code>编辑配置模板</code>，选择<code>Google Test</code>，进行配置并应用：<ul><li>目标：选择<code>UTTest</code></li><li>程序参数：不用填</li><li>工作目录：<code>\usr1\dragon\01_RB\test\rating_charging\cppcode\90_uttest\bin</code> （需要改成自己的）</li><li>环境变量：<code>CHG_HOME=xxx;LD_LIBRARY_PATH=xxx;TZ=BEST-8;BILLING_HOME=xxx</code>（需要改成自己的）</li></ul></li></ol><h1 id="9-编译"><a class="markdownIt-Anchor" href="#9-编译"></a> 9 编译</h1><p>点击运行按钮，如果出现下面的报错：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c++: internal compiler error</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>编译内部错误有可能是后台内存不足导致的，点击左边的构建按钮，可能会编译成功。</p><p>如果后面再出现这种错误，就把<code>构建选项</code>中的数字改小一点：<code>-- -j 32</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="环境与工具" scheme="https://Dragonliu2018.github.io/categories/环境与工具/"/>
    
    
  </entry>
  
  <entry>
    <title>Jenkins配置定时发送邮件功能</title>
    <link href="https://dragonliu2018.github.io/2022/04/16/Jenkins%E9%85%8D%E7%BD%AE%E5%AE%9A%E6%97%B6%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E5%8A%9F%E8%83%BD/"/>
    <id>https://dragonliu2018.github.io/2022/04/16/Jenkins%E9%85%8D%E7%BD%AE%E5%AE%9A%E6%97%B6%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E5%8A%9F%E8%83%BD/</id>
    <published>2022-04-16T15:48:10.000Z</published>
    <updated>2022-04-18T16:08:20.970Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="0-安装jenkins"><a class="markdownIt-Anchor" href="#0-安装jenkins"></a> 0 安装Jenkins</h1><p><a href="https://cloud.tencent.com/developer/article/1666282" target="_blank" rel="noopener">如何在 Ubuntu 20.04 上安装 Jenkins</a></p><p>Jenkins 是最流行的，开源的，基于 Java 的自动化服务器，它允许你很容易地设置一个<a href="https://cloud.tencent.com/product/coding-ci?from=10680" target="_blank" rel="noopener">持续集成</a>和持续发布的管道。</p><p>持续集成 (CI)是一个 DevOps 实践。当团队成员正常提交代码到版本控制仓库时，会运行自动化构建和测试。持续发布（CD）是一系列实践，当代码修改后，自动构建，测试，并且发布到生产环境中。</p><p>Jenkins 可以被作为一个独立应用安装，作为 Java servlet 容器（例如 Apache Tomcat）中的一个 servlet 安装，或者 以 Docker 容器的形式运行。</p><p>独立服务的形式安装 Jenkins：</p><h1 id="1-发送邮件"><a class="markdownIt-Anchor" href="#1-发送邮件"></a> 1 发送邮件</h1><h2 id="11-设置参数"><a class="markdownIt-Anchor" href="#11-设置参数"></a> 1.1 设置参数</h2><p>为了使得下面脚本成功执行，需要设置以下参数：</p><ul><li><strong>Receiver</strong> 邮件接收邮箱</li><li><strong>Copyer</strong> 邮件抄送邮箱</li><li><strong>Subject</strong> 邮件主题</li><li><strong>ReportLink</strong> 邮件链接</li><li><strong>ReportFile</strong> 邮件报告文件（本次测试中未使用）</li></ul><p>样例如下：</p><img src="https://s2.loli.net/2022/04/17/jkUSXfEdhbH4C6M.png" width="700" height="500" alt="图片名称" align="center" id="162"><h2 id="12-运行脚本"><a class="markdownIt-Anchor" href="#12-运行脚本"></a> 1.2 运行脚本</h2><p>该脚本在<code>01_RB</code>工程中已存在，根据需求修改即可。路径：<code>test/install/AutoInstallRB/icp/send_report_email.py</code></p><p>运行脚本：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 send_report_email.py -u <span class="string">"用户ID/codehub密码的Base64编码"</span> <span class="string">"本人邮箱"</span> <span class="string">"<span class="variable">$Receiver</span>"</span> <span class="string">"<span class="variable">$Copyer</span>"</span> <span class="string">"<span class="variable">$ReportFile</span>"</span> <span class="string">"<span class="variable">$Subject</span>"</span> <span class="string">"<span class="variable">$ReportLink</span>"</span></span><br></pre></td></tr></table></figure><p><code>send_report_email.py</code>脚本路径目录：<code>E:\04 Worker_work\01 实习\202109-华为C++后端实习\hw-addlcov\CBS-SW\01_RB\scripts</code></p><h1 id="2-jenkins-定时任务时间设置"><a class="markdownIt-Anchor" href="#2-jenkins-定时任务时间设置"></a> 2 Jenkins 定时任务时间设置</h1><h2 id="21-定时任务的时间格式"><a class="markdownIt-Anchor" href="#21-定时任务的时间格式"></a> 2.1 定时任务的时间格式</h2><p>定时任务的时间格式设定遵循的是cron的语法规则。具体的格式划分为5个字段：分别为 分钟、小时、日、月、星期、通过tab或者空格进行隔离区分</p><table><thead><tr><th style="text-align:center">字段</th><th style="text-align:center">*</th><th style="text-align:center">*</th><th style="text-align:center">*</th><th style="text-align:center">*</th><th style="text-align:center">*</th></tr></thead><tbody><tr><td style="text-align:center">含义</td><td style="text-align:center">分钟</td><td style="text-align:center">小时</td><td style="text-align:center">日期</td><td style="text-align:center">月份</td><td style="text-align:center">星期</td></tr><tr><td style="text-align:center">取值范围</td><td style="text-align:center">0-59</td><td style="text-align:center">0-23</td><td style="text-align:center">1月30日</td><td style="text-align:center">1月11日</td><td style="text-align:center">0-7</td></tr><tr><td style="text-align:center"><strong>实例</strong></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">每隔15分钟执行一次</td><td style="text-align:center">H/15</td><td style="text-align:center">*</td><td style="text-align:center">*</td><td style="text-align:center">*</td><td style="text-align:center">*</td></tr><tr><td style="text-align:center">每隔2小时执行一次</td><td style="text-align:center">H</td><td style="text-align:center">H/2</td><td style="text-align:center">*</td><td style="text-align:center">*</td><td style="text-align:center">*</td></tr><tr><td style="text-align:center">每隔3天执行一次</td><td style="text-align:center">H</td><td style="text-align:center">H</td><td style="text-align:center">H/3</td><td style="text-align:center">*</td><td style="text-align:center">*</td></tr><tr><td style="text-align:center">每隔3天执行一次（每月1-15号）</td><td style="text-align:center">H</td><td style="text-align:center">H</td><td style="text-align:center">1-15/3</td><td style="text-align:center">*</td><td style="text-align:center">*</td></tr><tr><td style="text-align:center">每隔1、3、5执行一次</td><td style="text-align:center">H</td><td style="text-align:center">H</td><td style="text-align:center">*</td><td style="text-align:center">*</td><td style="text-align:center">1,3,5</td></tr><tr><td style="text-align:center"><strong>规则</strong></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">指定时间范围</td><td style="text-align:center">a-b</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">指定时间间隔</td><td style="text-align:center">/</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">指定变量取值</td><td style="text-align:center">a,b,c</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><p>参数含义：</p><ol><li>*代表 匹配范围内所有值</li><li>M-N 匹配M~N范围内所有值</li><li>M-N/X 或者 */X 在指定M~N范围内或整个有效区间内每隔X构建一次</li><li>A,B,…,Z 匹配多个值</li></ol><h2 id="22-一些常用的时间规则"><a class="markdownIt-Anchor" href="#22-一些常用的时间规则"></a> 2.2 一些常用的时间规则</h2><table><thead><tr><th style="text-align:center">时间规则</th><th style="text-align:center">规则内容</th></tr></thead><tbody><tr><td style="text-align:center">每天上午9点定时构建</td><td style="text-align:center">H 9 * * *</td></tr><tr><td style="text-align:center">每天上午11点和下午6点定时构建</td><td style="text-align:center">H 11,18 * * *</td></tr><tr><td style="text-align:center">每个小时的前30分钟内，每10分钟构建一次</td><td style="text-align:center">H(0-29)/10 * * * *</td></tr><tr><td style="text-align:center">周一到周五，9-16点，每2小时的第45分钟构建一次</td><td style="text-align:center">45 9-16/2 * * 1-5</td></tr><tr><td style="text-align:center">每个工作日从早上9点到下午5点这段时间内每间隔2小时之间的某刻。(或许在上午10:38, 下午12:38, 下午2:38 , 下午4:38)</td><td style="text-align:center">H H(9-16)/2 * * 1-5</td></tr><tr><td style="text-align:center">每月（除了12月）从1号到15号这段时间内某刻</td><td style="text-align:center">H H 1,15 1-11 *</td></tr></tbody></table><h2 id="23-样例"><a class="markdownIt-Anchor" href="#23-样例"></a> 2.3 样例</h2><img src="https://s2.loli.net/2022/04/17/YfT4HG5mLbhXBPF.png" width="800" height="500" alt="图片名称" align="center" id="163">]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="环境与工具" scheme="https://Dragonliu2018.github.io/categories/环境与工具/"/>
    
    
  </entry>
  
  <entry>
    <title>圈复杂度</title>
    <link href="https://dragonliu2018.github.io/2022/04/15/%E5%9C%88%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <id>https://dragonliu2018.github.io/2022/04/15/%E5%9C%88%E5%A4%8D%E6%9D%82%E5%BA%A6/</id>
    <published>2022-04-15T12:03:41.000Z</published>
    <updated>2022-04-18T16:10:02.076Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p><strong>转载</strong>：<a href="http://kaelzhang81.github.io/2017/06/18/%E8%AF%A6%E8%A7%A3%E5%9C%88%E5%A4%8D%E6%9D%82%E5%BA%A6/#" target="_blank" rel="noopener">详解圈复杂度</a></p></blockquote><h1 id="1-圈复杂度概念"><a class="markdownIt-Anchor" href="#1-圈复杂度概念"></a> 1 圈复杂度概念</h1><p>圈复杂度（Cyclomatic complexity，简写CC）也称为条件复杂度，是一种代码复杂度的衡量标准。由托马斯·J·麦凯布（Thomas J. McCabe, Sr.）于1976年提出，用来表示程序的复杂度，其符号为VG或是M。它可以用来衡量一个模块判定结构的复杂程度，数量上表现为独立现行路径条数，也可理解为覆盖所有的可能情况最少使用的测试用例数。圈复杂度大说明程序代码的判断逻辑复杂，可能质量低且难于测试和维护。程序的可能错误和高的圈复杂度有着很大关系。</p><h1 id="2-圈复杂度计算方法"><a class="markdownIt-Anchor" href="#2-圈复杂度计算方法"></a> 2 圈复杂度计算方法</h1><h2 id="21-点边计算法"><a class="markdownIt-Anchor" href="#21-点边计算法"></a> 2.1 点边计算法</h2><img src="https://s2.loli.net/2022/04/16/BrNW3etERXLkhgD.jpg" width="400" height="300" alt="图片名称" align="center" id="154"><p>圈复杂度的计算方法很简单，计算公式为：</p><blockquote><p>V(G) = E - N + 2</p></blockquote><p>其中，e表示控制流图中边的数量，n表示控制流图中节点的数量。</p><p>几个节点通过边连接。下面是典型的控制流程，如if-else，While，until和正常的流程顺序：</p><img src="https://s2.loli.net/2022/04/16/g4uVjXO2MIixykz.png" width="400" height="300" alt="图片名称" align="center" id="155"><h2 id="22-节点判定法"><a class="markdownIt-Anchor" href="#22-节点判定法"></a> 2.2 节点判定法</h2><p>其实，圈复杂度的计算还有更直观的方法，因为圈复杂度所反映的是“判定条件”的数量，所以圈复杂度实际上就是等于判定节点的数量再加上1，也即控制流图的区域数，对应的计算公式为：</p><blockquote><p>V (G) = P + 1</p></blockquote><p>其中P为判定节点数，判定节点举例：</p><ol><li>if语句</li><li>while语句</li><li>for语句</li><li>case语句</li><li>catch语句</li><li>and和or布尔操作</li><li>?:三元运算符</li></ol><p>对于多分支的CASE结构或IF-ELSEIF-ELSE结构，统计判定节点的个数时需要特别注意一点，要求必须统计全部实际的判定节点数，也即每个ELSEIF语句，以及每个CASE语句，都应该算为一个判定节点。</p><p>判定节点在模块的控制流图中很容易被识别出来，所以，针对程序的控制流图计算圈复杂度V(G)时，一般采用点边计算法，也即V(G)=e-n+2；而针对模块的控制流图时，可以直接使用统计判定节点数，这样更为简单。</p><h1 id="3-圈复杂度计算练习"><a class="markdownIt-Anchor" href="#3-圈复杂度计算练习"></a> 3 圈复杂度计算练习</h1><h2 id="31-练习1"><a class="markdownIt-Anchor" href="#31-练习1"></a> 3.1 练习1：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> * A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        j = i +<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span>(j &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] &lt; A[j])</span><br><span class="line">                 swap(A[i], A[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用点边计算法绘出控制流图：</p><img src="https://s2.loli.net/2022/04/16/12dtWP4XsOMEHjU.png" width="400" height="300" alt="图片名称" align="center" id="156"><p>其圈复杂度为：V(G) = 9 - 7 + 2 = 4</p><h2 id="32-练习2"><a class="markdownIt-Anchor" href="#32-练习2"></a> 3.2 练习2：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">U32 <span class="title">find</span> <span class="params">(<span class="built_in">string</span> match)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> var : <span class="built_in">list</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(var == match &amp;&amp; from != INVALID_U32) <span class="keyword">return</span> INVALID_U32;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//match step1</span></span><br><span class="line">    <span class="keyword">if</span>(session == getName() &amp;&amp; key == <span class="built_in">getKey</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; kv : Map)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (kv.second == last &amp;&amp; match == kv.first)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> last;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//match step2</span></span><br><span class="line">    <span class="keyword">auto</span> var = Map.<span class="built_in">find</span>(match);</span><br><span class="line">    <span class="keyword">if</span>(var != Map.<span class="built_in">end</span>()&amp;&amp; (from != var-&gt;second)) <span class="keyword">return</span> var-&gt;second;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//match step3</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> var: Map)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((var.first, match) &amp;&amp; from != var.second)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> var.second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> INVALID_U32;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其圈复杂度为：V(G) = 1(for) + 2(if) + 2(if) + 1(for) + 2(if) + 2(if) + 1(for) + 2(if) + 1= 14</p><h1 id="4-圈复杂度的意义"><a class="markdownIt-Anchor" href="#4-圈复杂度的意义"></a> 4 圈复杂度的意义</h1><p>在缺陷成为缺陷之前捕获它们。</p><h2 id="41-圈复杂度与缺陷"><a class="markdownIt-Anchor" href="#41-圈复杂度与缺陷"></a> 4.1 圈复杂度与缺陷</h2><p>一般来说圈复杂度大于10的方法存在很大的出错风险。圈复杂度和缺陷个数有高度的正相关：<strong>圈复杂度最高的模块和方法，其缺陷个数也可能最多。</strong></p><h2 id="42-圈复杂度与结构化测试"><a class="markdownIt-Anchor" href="#42-圈复杂度与结构化测试"></a> 4.2 圈复杂度与结构化测试</h2><p>此外，它还为测试设计提供很好的参考。一个好的用例设计经验是：**创建数量与被测代码圈复杂度值相等的测试用例，**以此提升用例对代码的分支覆盖率。</p><h2 id="43-圈复杂度与tdd"><a class="markdownIt-Anchor" href="#43-圈复杂度与tdd"></a> 4.3 圈复杂度与TDD</h2><p>TDD（测试驱动的开发，test-driven development)和低<strong>CC</strong>值之间存在着紧密联系。在编写测试时，开发人员会考虑代码的可测试性，倾向于编写简单的代码，因为复杂的代码难以测试。因此TDD的“代码、测试、代码、测试” 循环将导致频繁重构，驱使非复杂代码的开发。</p><h2 id="44-圈复杂度与遗留代码"><a class="markdownIt-Anchor" href="#44-圈复杂度与遗留代码"></a> 4.4 圈复杂度与遗留代码</h2><p>对于遗留代码的维护或重构，测量圈复杂度特别有价值。一般使用圈复杂度作为提升代码质量的切入点。</p><h2 id="45-圈复杂度与ci"><a class="markdownIt-Anchor" href="#45-圈复杂度与ci"></a> 4.5 圈复杂度与CI</h2><p>在持续集成环境中，可以基于时间变化维度来评估模块或函数的复杂度和增长值。如果<strong>CC</strong>值在不断增长，那么应该开展两项活动：</p><ol><li>确保相关测试的有效性，减少故障风险。</li><li>评估重构必要性和具体方式，以降低出现代码维护问题的可能性。</li></ol><h2 id="46-圈复杂度和软件质量"><a class="markdownIt-Anchor" href="#46-圈复杂度和软件质量"></a> 4.6 圈复杂度和软件质量</h2><table><thead><tr><th style="text-align:left">圈复杂度</th><th style="text-align:left">代码状况</th><th style="text-align:left">可测性</th><th style="text-align:left">维护成本</th></tr></thead><tbody><tr><td style="text-align:left">1-10</td><td style="text-align:left">清晰、结构化</td><td style="text-align:left">高</td><td style="text-align:left">低</td></tr><tr><td style="text-align:left">10-20</td><td style="text-align:left">复杂</td><td style="text-align:left">中</td><td style="text-align:left">中</td></tr><tr><td style="text-align:left">20-30</td><td style="text-align:left">非常复杂</td><td style="text-align:left">低</td><td style="text-align:left">高</td></tr><tr><td style="text-align:left">&gt;30</td><td style="text-align:left">不可读</td><td style="text-align:left">不可测</td><td style="text-align:left">非常高</td></tr></tbody></table><h1 id="5-降低圈复杂度的方法"><a class="markdownIt-Anchor" href="#5-降低圈复杂度的方法"></a> 5 降低圈复杂度的方法</h1><h2 id="51-重新组织你的函数"><a class="markdownIt-Anchor" href="#51-重新组织你的函数"></a> 5.1 重新组织你的函数</h2><h3 id="511-技巧1-提炼函数"><a class="markdownIt-Anchor" href="#511-技巧1-提炼函数"></a> 5.1.1 技巧1 提炼函数</h3><p>有一段代码可以被组织在一起并独立出来:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Example</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>( val &gt; MAX_VAL)</span><br><span class="line">&#123;</span><br><span class="line">val = MAX_VAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; val; i++)</span><br><span class="line">&#123;</span><br><span class="line">doSomething(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将这段代码放进一个独立函数中，并让函数名称解释该函数的用途:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getValidVal</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>( val &gt; MAX_VAL)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> MAX_VAL;</span><br><span class="line">&#125; </span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomethings</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; val; i++)</span><br><span class="line">&#123;</span><br><span class="line">doSomething(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Example</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    doSomethings(getValidVal(val));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后还要重新审视函数内容是否在统一层次上。</p><h3 id="512-技巧2-替换算法"><a class="markdownIt-Anchor" href="#512-技巧2-替换算法"></a> 5.1.2 技巧2 替换算法</h3><p>把某个算法替换为另一个更清晰的算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">foundPerson</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; peoples)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; people : peoples) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (people == <span class="string">"Don"</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Don"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (people == <span class="string">"John"</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"John"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (people == <span class="string">"Kent"</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Kent"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将函数实现替换为另一个算法:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">foundPerson</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; people)</span></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt;candidates&#123;</span><br><span class="line">    &#123; <span class="string">"Don"</span>, <span class="string">"Don"</span>&#125;,</span><br><span class="line">    &#123; <span class="string">"John"</span>, <span class="string">"John"</span>&#125;,</span><br><span class="line">    &#123; <span class="string">"Kent"</span>, <span class="string">"Kent"</span>&#125;,</span><br><span class="line">       &#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; people : peoples) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; it = candidates.<span class="built_in">find</span>(people);</span><br><span class="line">    <span class="keyword">if</span>(it != candidates.<span class="built_in">end</span>())</span><br><span class="line">        <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所谓的表驱动。</p><h2 id="52-简化条件表达式"><a class="markdownIt-Anchor" href="#52-简化条件表达式"></a> 5.2 简化条件表达式</h2><h3 id="521-技巧3-逆向表达"><a class="markdownIt-Anchor" href="#521-技巧3-逆向表达"></a> 5.2.1 技巧3 逆向表达</h3><p>在代码中可能存在条件表达如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((condition1() &amp;&amp; condition2()) || !condition1())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用逆向表达调换表达顺序后效果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(condition1() &amp;&amp; !condition2())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><h3 id="522-技巧4-分解条件"><a class="markdownIt-Anchor" href="#522-技巧4-分解条件"></a> 5.2.2 技巧4 分解条件</h3><p>在代码中存在复杂的条件表达：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(date.before (SUMMER_START) || date.after(SUMMER_END))</span><br><span class="line">    charge = quantity * _winterRate + _winterServiceCharge;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    charge = quantity * _summerRate;</span><br></pre></td></tr></table></figure><p>从if、then、else三个段落中分别提炼出独立函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(notSummer(date))</span><br><span class="line">    charge = winterCharge(quantity);</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    charge = summerCharge (quantity);</span><br></pre></td></tr></table></figure><h3 id="523-技巧5-合并条件"><a class="markdownIt-Anchor" href="#523-技巧5-合并条件"></a> 5.2.3 技巧5 合并条件</h3><p>一系列条件判断，都得到相同结果:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">disabilityAmount</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_seniority &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (_monthsDisabled &gt; <span class="number">12</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (_isPartTime) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// compute the disability amount</span></span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><p>将这些判断合并为一个条件式，并将这个条件式提炼成为一个独立函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">disabilityAmount</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isNotEligableForDisability()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// compute the disability amount</span></span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><h3 id="524-技巧6-移除控制标记"><a class="markdownIt-Anchor" href="#524-技巧6-移除控制标记"></a> 5.2.4 技巧6 移除控制标记</h3><p>在代码逻辑中，有时候会使用bool类型作为逻辑控制标记：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkSecurity</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; peoples)</span> </span>&#123;</span><br><span class="line"><span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; people : peoples) </span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">if</span> (! found) &#123;</span><br><span class="line"><span class="keyword">if</span> (people == <span class="string">"Don"</span>)&#123;</span><br><span class="line">sendAlert();</span><br><span class="line">found = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (people == <span class="string">"John"</span>)&#123;</span><br><span class="line">   sendAlert();</span><br><span class="line">   found = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用break和return取代控制标记：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkSecurity</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; peoples)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; people : peoples)</span><br><span class="line">&#123;     </span><br><span class="line"><span class="keyword">if</span> (people == <span class="string">"Don"</span> || people == <span class="string">"John"</span>)</span><br><span class="line">&#123;</span><br><span class="line">sendAlert();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="525-技巧7-以多态取代条件式"><a class="markdownIt-Anchor" href="#525-技巧7-以多态取代条件式"></a> 5.2.5 技巧7 以多态取代条件式</h3><p>条件式根据对象类型的不同而选择不同的行为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getSpeed</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (_type) &#123;</span><br><span class="line">        <span class="keyword">case</span> EUROPEAN:</span><br><span class="line">            <span class="keyword">return</span> getBaseSpeed();</span><br><span class="line">        <span class="keyword">case</span> AFRICAN:</span><br><span class="line">            <span class="keyword">return</span> getBaseSpeed() - getLoadFactor() *_numberOfCoconuts;</span><br><span class="line">        <span class="keyword">case</span> NORWEGIAN_BLUE:</span><br><span class="line">            <span class="keyword">return</span> (_isNailed) ? <span class="number">0</span> : getBaseSpeed(_voltage);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException (<span class="string">"Should be unreachable"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将整个条件式的每个分支放进一个子类的重载方法中，然后将原始函数声明为抽象方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">getSpeed</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getBaseSpeed</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EuropeanBird</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getSpeed</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getBaseSpeed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AfricanBird</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getSpeed</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getBaseSpeed() - getLoadFactor() *_numberOfCoconuts;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getLoadFactor</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">double</span> _numberOfCoconuts;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NorwegianBlueBird</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getSpeed</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (_isNailed) ? <span class="number">0</span> : getBaseSpeed(_voltage);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> _isNailed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="53-简化函数调用"><a class="markdownIt-Anchor" href="#53-简化函数调用"></a> 5.3 简化函数调用</h2><h3 id="531-技巧8-读写分离"><a class="markdownIt-Anchor" href="#531-技巧8-读写分离"></a> 5.3.1 技巧8 读写分离</h3><p>某个函数既返回对象状态值，又修改对象状态:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getTotalOutstandingAndSetReadyForSummaries</span><span class="params">(<span class="keyword">int</span> number)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建立两个不同的函数，其中一个负责查询，另一个负责修改:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getTotalOutstanding</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetReadyForSummaries</span><span class="params">(<span class="keyword">int</span> number)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="532-技巧9-参数化方法"><a class="markdownIt-Anchor" href="#532-技巧9-参数化方法"></a> 5.3.2 技巧9 参数化方法</h3><p>若干函数做了类似的工作，但在函数本体中却 包含了不同的值:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Dollars <span class="title">baseCharge</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> result = Math.<span class="built_in">min</span>(lastUsage(),<span class="number">100</span>) * <span class="number">0.03</span>;</span><br><span class="line">    <span class="keyword">if</span> (lastUsage() &gt; <span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        result += (Math.<span class="built_in">min</span> (lastUsage(),<span class="number">200</span>) - <span class="number">100</span>) * <span class="number">0.05</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lastUsage() &gt; <span class="number">200</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        result += (lastUsage() - <span class="number">200</span>) * <span class="number">0.07</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Dollars (result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建立单一函数，以参数表达那些不同的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Dollars <span class="title">baseCharge</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> result = usageInRange(<span class="number">0</span>, <span class="number">100</span>) * <span class="number">0.03</span>;</span><br><span class="line">    result += usageInRange (<span class="number">100</span>,<span class="number">200</span>) * <span class="number">0.05</span>;</span><br><span class="line">    result += usageInRange (<span class="number">200</span>, Integer.MAX_VALUE) * <span class="number">0.07</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Dollars (result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">usageInRange</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lastUsage() &gt; start) </span><br><span class="line">        <span class="keyword">return</span> Math.<span class="built_in">min</span>(lastUsage(),<span class="built_in">end</span>) -start;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="533-技巧10-以明确函数取代参数"><a class="markdownIt-Anchor" href="#533-技巧10-以明确函数取代参数"></a> 5.3.3 技巧10 以明确函数取代参数</h3><p>函数实现完全取决于参数值而采取不同反应：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setValue</span> <span class="params">(<span class="built_in">string</span> name, <span class="keyword">int</span> value)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="string">"height"</span>)</span><br><span class="line">        _height = value;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (name == <span class="string">"width"</span>)</span><br><span class="line">        _width = value;</span><br><span class="line">    Assert.shouldNeverReachHere();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对该参数的每一个可能值，建立一个独立函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">int</span> arg)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _height = arg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setWidth</span> <span class="params">(<span class="keyword">int</span> arg)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _width = arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="54-实战练习"><a class="markdownIt-Anchor" href="#54-实战练习"></a> 5.4 实战练习</h2><p>还是以之前统计<strong>CC</strong>值的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">U32 <span class="title">find</span> <span class="params">(<span class="built_in">string</span> match)</span></span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">auto</span> var : List)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span>(var == match &amp;&amp; from != INVALID_U32) </span><br><span class="line">    <span class="keyword">return</span> INVALID_U32;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//match step1</span></span><br><span class="line">       <span class="keyword">if</span>(session == getName() &amp;&amp; key == <span class="built_in">getKey</span>())</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; kv : Map)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">if</span> (kv.second == last &amp;&amp; match == kv.first)</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="keyword">return</span> last;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//match step2</span></span><br><span class="line">       <span class="keyword">auto</span> var = Map.<span class="built_in">find</span>(match);</span><br><span class="line">       <span class="keyword">if</span>(var != Map.<span class="built_in">end</span>()&amp;&amp; (from != var-&gt;second)) <span class="keyword">return</span> var-&gt;second;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//match step3</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">auto</span> var: Map)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span>((var.first, match) &amp;&amp; from != var.second)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">return</span> var.second;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> INVALID_U32;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure><p>综合运用降低CC值的技巧后：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Matcher</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        Matcher(<span class="built_in">string</span> name, <span class="built_in">string</span> key);</span><br><span class="line">        <span class="function">U32 <span class="title">find</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">except</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function">U32 <span class="title">matchStep1</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function">U32 <span class="title">matchStep2</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function">U32 <span class="title">matchStep3</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">isTheSameMatch</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> match;</span><br><span class="line">        U32 from;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Matcher::Matcher(<span class="built_in">string</span> name, <span class="built_in">string</span> key):</span><br><span class="line">        match(name + key)</span><br><span class="line">    &#123;</span><br><span class="line">        from = GetFrom();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">U32 <span class="title">Matcher::find</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (except())</span><br><span class="line">            <span class="keyword">return</span> INVALID_U32;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> result = matchStep1();</span><br><span class="line">        <span class="keyword">if</span> (result != INVALID_U32)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        result = matchStep2();</span><br><span class="line">        <span class="keyword">if</span> (result != INVALID_U32)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> matchStep3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Matcher::except</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> var : List)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(var == match &amp;&amp; from != INVALID_U32)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">U32 <span class="title">Matcher::matchStep1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!isTheSameMatch())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> INVALID_U32;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; kv : Map)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( last == kv.second &amp;&amp; match == kv.first)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> last;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> INVALID_U32;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Matcher::isTheSameMatch</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> match == getName() + <span class="built_in">getKey</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">U32 <span class="title">Matcher::matchStep2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> var = Map.<span class="built_in">find</span>(match);</span><br><span class="line">        <span class="keyword">if</span>(var != Map.<span class="built_in">end</span>()&amp;&amp; (from != var-&gt;second))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> var-&gt;second;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> INVALID_U32;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">U32 <span class="title">Matcher::matchStep3</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> var: Map)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(keyMatch(var.first, match) &amp;&amp; from != var.second)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> var.second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> INVALID_U32;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">U32 <span class="title">find</span> <span class="params">(<span class="built_in">string</span> match)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Matcher matcher;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> matcher.<span class="built_in">find</span>(match);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该例子将匹配算法都封装到Matcher类中，并将原有逻辑通过提炼函数（技巧1）和合并条件（技巧6）将匹配逻辑抽象成能力查询、粘滞、精确匹配及模糊匹配四个步骤，这样将循环和条件分支封入小函数中，从而降低接口函数（findPno）的圈复杂度，函数职责也更加单一和清晰。整体圈复杂度从单个函数的14降到多个函数最高的5。</p><h1 id="6-圈复杂度思辨"><a class="markdownIt-Anchor" href="#6-圈复杂度思辨"></a> 6 圈复杂度思辨</h1><h2 id="61-思辨1-高复杂度的代码是否可维护性差"><a class="markdownIt-Anchor" href="#61-思辨1-高复杂度的代码是否可维护性差"></a> 6.1 思辨1 高复杂度的代码是否可维护性差</h2><p>在实际项目中为了调试方便，经常会把消息号对应的名称打印出来：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">getMessageName</span><span class="params">(Message msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(msg)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> MSG_1:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"MSG_1"</span>;</span><br><span class="line">        <span class="keyword">case</span> MSG_2:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"MSG_2"</span>;</span><br><span class="line">        <span class="keyword">case</span> MSG_3:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"MSG_3"</span>;</span><br><span class="line">        <span class="keyword">case</span> MSG_4:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"MSG_4"</span>;</span><br><span class="line">        <span class="keyword">case</span> MSG_5:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"MSG_5"</span>;</span><br><span class="line">        <span class="keyword">case</span> MSG_6:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"MSG_6"</span>;</span><br><span class="line">        <span class="keyword">case</span> MSG_7:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"MSG_7"</span>;</span><br><span class="line">        <span class="keyword">case</span> MSG_8:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"MSG_8"</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"MSG_UNKNOWN"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码无论从可读性来说，还是从可维护性来说都是可以接收的。因此，当因为”高”复杂度就进行重构的话（例如：技巧2或技巧6），在降低圈复杂度的同时会带来不必要的逻辑复杂度。</p><p>当然，如果出现下面的情况的话，还是有必要进一步降低圈复杂度的：</p><ol><li>消息数过多。</li><li>switch…case…多处重复。 对于消息过多的情况，可以考虑将消息进行分类，然后采用技巧1进行重构。对于出现多处重复的情况，可以通过技巧6将同样case的内容内聚到一个具体的类的方法中，然后通过多态的方式来使用。</li></ol><h2 id="62-思辨2-复杂度相同的代码是否是一致的"><a class="markdownIt-Anchor" href="#62-思辨2-复杂度相同的代码是否是一致的"></a> 6.2 思辨2 复杂度相同的代码是否是一致的</h2><p>例如下面两个代码片段的圈复杂度都是6。 代码片段1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">getWeight</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"no weight"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">10</span>) </span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"light"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">20</span>) </span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"medium"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">30</span>) </span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"heavy"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">40</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"very heavy"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"super heavy"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码片段2</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumOfNonPrimes</span><span class="params">(<span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> bAdd = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &lt;= <span class="number">2</span>) </span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; i; ++j) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i % j == <span class="number">0</span>) </span><br><span class="line">                    &#123;</span><br><span class="line">                            bAdd = <span class="literal">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    bAdd = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (bAdd)</span><br><span class="line">                    sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是它们的代码无论从可读性上来说，还是从可维护性来说，代码片段1应该都优于代码片段2，代码片段2的坏味道更加浓郁。因此，圈复杂度还需要具体情况具体分析，其只能作为重构的一个度量指标，作为决策的一个参考依据。</p><h1 id="7-圈复杂度工具"><a class="markdownIt-Anchor" href="#7-圈复杂度工具"></a> 7 圈复杂度工具</h1><p>圈复杂度的工具有很多，大致有三类：</p><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">名称</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">专用工具（单语言）</td><td style="text-align:left">OCLint</td><td style="text-align:left">C语言相关</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">GMetrics</td><td style="text-align:left">Java</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">PyMetrics</td><td style="text-align:left">python</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">JSComplexity</td><td style="text-align:left">js</td></tr><tr><td style="text-align:left">通用工具（多语言）</td><td style="text-align:left">lizard</td><td style="text-align:left">支持多种语言：C/C++ (works with C++14)、Java、C#、JavaScript、Objective C、Swift、Python、Ruby、PHP、Scala等。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">sourcemonitor</td><td style="text-align:left">免费、Windows平台。支持语言包括C、C++、C#、Java、VB、Delphi和HTML。</td></tr><tr><td style="text-align:left">通用平台</td><td style="text-align:left">sonarqube</td><td style="text-align:left">一个用于代码质量管理的开源平台，支持20多种语言。通过插件机制可集成不同的测试工具，代码分析工具及持续集成工具</td></tr></tbody></table><h1 id="8-参考资料"><a class="markdownIt-Anchor" href="#8-参考资料"></a> 8 参考资料</h1><ol><li><a href="https://zh.wikipedia.org/wiki/%E5%BE%AA%E7%92%B0%E8%A4%87%E9%9B%9C%E5%BA%A6" target="_blank" rel="noopener">循環複雜度- 维基百科，自由的百科全书</a></li><li><a href="http://www.guru99.com/cyclomatic-complexity.html" target="_blank" rel="noopener">Learn Mccabe’s Cyclomatic Complexity with Example</a></li><li><a href="https://www.cqse.eu/en/blog/mccabe-cyclomatic-complexity/" target="_blank" rel="noopener">McCabe’s Cyclomatic Complexity and Why We Don’t Use It</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="未分类" scheme="https://Dragonliu2018.github.io/categories/未分类/"/>
    
    
    <category term="待补充" scheme="https://Dragonliu2018.github.io/tags/待补充/"/>
    
    <category term="重构" scheme="https://Dragonliu2018.github.io/tags/重构/"/>
    
  </entry>
  
  <entry>
    <title>代码覆盖率</title>
    <link href="https://dragonliu2018.github.io/2022/04/15/%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87/"/>
    <id>https://dragonliu2018.github.io/2022/04/15/%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87/</id>
    <published>2022-04-15T08:05:16.000Z</published>
    <updated>2022-04-18T16:11:05.206Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-介绍"><a class="markdownIt-Anchor" href="#1-介绍"></a> 1 介绍</h1><p><strong>代码覆盖率</strong>，是一种通过计算测试过程中被执行的源代码占全部源代码的比例，进而间接度量软件质量的方法。</p><p><strong>全量覆盖率</strong>：基于全部代码的代码覆盖率</p><p><strong>增量覆盖率</strong>：基于代码增量的代码覆盖率</p><p>按性质，它属于白盒测试的范畴，即主要依据源代码的内部结构来设计测试用例，通过设计不同的输入来测试软件的不同部分。</p><p>常见的编程语言，如C/C++，python和Java等，都有相应的代码覆盖率测试工具。</p><h1 id="2-意义"><a class="markdownIt-Anchor" href="#2-意义"></a> 2 意义</h1><ol><li>提升开发者测试意识，可以基于此在程序中寻找没有被测试用例测试过的地方，创建新的测试用例来增加覆盖率，从而提高软件质量；</li><li>也为代码管理提供了新的手段，降低管理成本。</li></ol><p><strong>注意</strong>：代码覆盖率不是灵丹妙药，它只是告诉我们有哪些代码没有被测试用例“执行到”而已，高百分比的代码覆盖率不等于高质量的有效测试。</p><p><strong>举例</strong>：假设代码覆盖率只在某一些模块代码覆盖率很高，但在一些关键模块并没有足够的测试用例覆盖，那样虽然代码覆盖率很高，但并不能说明产品质量就很高。</p><p>Martin Fowler <a href="https://link.zhihu.com/?target=https%3A//www.martinfowler.com/bliki/TestCoverage.html" target="_blank" rel="noopener">测试覆盖率</a> 写到：</p><blockquote><p>代码覆盖率是查找代码库中未测试部分的有用工具，然而它作为一个数字说明你的测试有多好用处不大。</p></blockquote><h1 id="3-分类"><a class="markdownIt-Anchor" href="#3-分类"></a> 3 分类</h1><h2 id="31-语句覆盖statement-coverage"><a class="markdownIt-Anchor" href="#31-语句覆盖statement-coverage"></a> 3.1 语句覆盖（statement coverage）</h2><p><strong>程序中的语句有多少被执行</strong>。它是最常用也是最简单的一种代码覆盖率度量方式，就是度量被测代码中每个可执行语句是否被执行到了。“可执行语句”，并不包括C++的头文件声明、代码注释和空行等。但是，单独一行的花括号｛｝ 常常也被统计进去。</p><h2 id="32-行覆盖率"><a class="markdownIt-Anchor" href="#32-行覆盖率"></a> 3.2 行覆盖率</h2><p><strong>有多少行的源代码被测试过</strong>。感觉和<code>语句覆盖</code>一样。</p><h2 id="33-判定覆盖率decision-coverageor-分支覆盖"><a class="markdownIt-Anchor" href="#33-判定覆盖率decision-coverageor-分支覆盖"></a> 3.3 判定覆盖率（decision coverage）or 分支覆盖</h2><p>又称<strong>分支覆盖</strong>，所有边界覆盖，基本路径覆盖，判定路径覆盖，它度量程序中每一个判定的分支是否都被测试到了。所谓判定，是指一条判断语句的结果，而不考虑其中包含的子判断的结果和组合情况。</p><h2 id="34-条件覆盖condition-coverage"><a class="markdownIt-Anchor" href="#34-条件覆盖condition-coverage"></a> 3.4 条件覆盖（condition coverage）</h2><p>它报告每一个子表达式的结果的true 或false 是否测试到了。即构造测试用例时，要使得每个判定语句中每个逻辑条件的可能值至少满足一次（即每一个被“逻辑与”或“逻辑非”分开的布尔表达式真假值情况）。但是，需要注意的是，条件覆盖不是将判定中的每个条件表达式的结果进行排列组合，而是只要每个条件表达式的结果true和false测试到了就可以了。</p><h2 id="35-修正条件判定覆盖modified-condition-decision-coverage"><a class="markdownIt-Anchor" href="#35-修正条件判定覆盖modified-condition-decision-coverage"></a> 3.5 修正条件判定覆盖（modified condition / decision coverage）</h2><p>前面提到的条件覆盖比语句覆盖和判定覆盖都要严格，但是由于它只关注每个条件表达式的结果是否都被测试到，而不要求对每个条件表达式的解果进行排列组合，所以它也只能覆盖一部分的情况。如果真要做到全覆盖，随着子表达式的增加，不仅测试用例设计的难度会越来越大，而且用例的数量也会指数级增长。</p><p>修正条件判定覆盖，要求在一个程序中每一种输入输出至少得出现一次，在程序中的每一个条件必须产生所有可能的输出结果至少一次，并且每一个判定中的每一个条件必须能够独立影响一个判定的输出，即在其他条件不变的前提下仅改变这个条件的值，而使判定结果改变。显然，修正条件判定覆盖的定义有点抽象，接下来还是以前面的代码为例介绍。</p><p>修正条件判定覆盖要求在每个判定中，每个条件都独立地影响判定结果至少一次（所谓独立影响就是在其他条件不变的情况下，改变该条件可以改变判定结果）。例如，要想a对判定独立影响，则b或function的结果必须为true；要想b对判定独立影响，则a必须为true；同理，要想function对判定独立影响，a也必须为true。如果列出测试用例表，则不难发现满足以上条件的测试用例的数量并不需要很多！主要因为有些用例是重复的。</p><h2 id="36-条件判定组合覆盖condition-decision-coverage"><a class="markdownIt-Anchor" href="#36-条件判定组合覆盖condition-decision-coverage"></a> 3.6 条件判定组合覆盖（condition decision coverage）</h2><h2 id="37-路径覆盖path-coverage"><a class="markdownIt-Anchor" href="#37-路径覆盖path-coverage"></a> 3.7 路径覆盖（path coverage）</h2><h2 id="38-多条件覆盖multi-condition-coverage"><a class="markdownIt-Anchor" href="#38-多条件覆盖multi-condition-coverage"></a> 3.8 多条件覆盖（multi-condition coverage）</h2><h2 id="39-方法覆盖率"><a class="markdownIt-Anchor" href="#39-方法覆盖率"></a> 3.9 方法覆盖率</h2><p><strong>程序中的方法/函数有多少被执行。</strong></p><h2 id="310-类覆盖率"><a class="markdownIt-Anchor" href="#310-类覆盖率"></a> 3.10 类覆盖率</h2><p><strong>程序中的类有多少被执行。</strong></p><h1 id="4-工作原理"><a class="markdownIt-Anchor" href="#4-工作原理"></a> 4 工作原理</h1><p>代码覆盖率测量主要有以下三种方式：</p><h2 id="41-source-code-instrumentation-源代码检测"><a class="markdownIt-Anchor" href="#41-source-code-instrumentation-源代码检测"></a> 4.1 Source code instrumentation - 源代码检测</h2><p>将检测语句添加到源代码中，并使用正常的编译工具链编译代码以生成检测的程序集。这是我们常说的插桩，Gcov 是属于这一类的代码覆盖率工具。</p><h2 id="42-runtime-instrumentation-运行时收集"><a class="markdownIt-Anchor" href="#42-runtime-instrumentation-运行时收集"></a> 4.2 Runtime instrumentation - 运行时收集</h2><p>这种方法在代码执行时从运行时环境收集信息以确定覆盖率信息。以我的理解 JaCoCo 和 Coverage 这两个工具的原理属于这一类别。</p><h2 id="43-intermediate-code-instrumentation-中间代码检测"><a class="markdownIt-Anchor" href="#43-intermediate-code-instrumentation-中间代码检测"></a> 4.3 Intermediate code instrumentation - 中间代码检测</h2><p>通过添加新的字节码来检测编译后的类文件，并生成一个新的检测类。说实话，我 Google 了很多文章并找到确定的说明哪个工具是属于这一类的。<a href="https://blog.csdn.net/Nathan1987_/article/details/100932502" target="_blank" rel="noopener">机器码(machine code)和字节码(byte code)是什么？</a></p><hr><p>了解这些工具的基本原理，结合现有的测试用例，有助于正确的选择代码覆盖率工具。比如：</p><ul><li>产品的源代码只有 E2E（端到端）测试用例，通常只能选择第一类工具，即通过插桩编译出的可执行文件，然后进行测试和结果收集。</li><li>产品的源代码有单元测试用例，通常选择第二类工具，即运行时收集。这类工具的执行效率高，易于做持续集成。</li></ul><h1 id="5-当前主流代码覆盖率工具"><a class="markdownIt-Anchor" href="#5-当前主流代码覆盖率工具"></a> 5 当前主流代码覆盖率工具</h1><p>代码覆盖率的工具有很多，以下是我用过的不同编程语言的代码覆盖率工具。在选择工具时，力求去选择那些开源、流行（活跃）、好用的工具。</p><table><thead><tr><th style="text-align:center">编程语言</th><th style="text-align:center">代码覆盖率工具</th></tr></thead><tbody><tr><td style="text-align:center">C/C++</td><td style="text-align:center">Gcov</td></tr><tr><td style="text-align:center">Java</td><td style="text-align:center">JaCoCo</td></tr><tr><td style="text-align:center">JavaScript</td><td style="text-align:center">Istanbul</td></tr><tr><td style="text-align:center">Python</td><td style="text-align:center"><a href="http://Coverage.py" target="_blank" rel="noopener">Coverage.py</a></td></tr><tr><td style="text-align:center">Golang</td><td style="text-align:center">cover</td></tr></tbody></table><h2 id="51-gcov"><a class="markdownIt-Anchor" href="#51-gcov"></a> 5.1 Gcov</h2><p>Gcov 工作流程图：</p><img src="https://s2.loli.net/2022/04/15/AHyX8j6SR2eGYqV.png" width="400" height="300" alt="图片名称" align="center" id="157"><p>主要分三步：</p><ol><li>在 GCC 编译的时加入特殊的编译选项<code>-ftest-coverage</code>，生成可执行文件和 <code>.gcno</code>；</li><li>运行（测试）生成的可执行文件，生成了 <code>.gcda</code> 数据文件；（<code>.gcda</code>的生成是因为程序在编译的时候引入了 <code>-fprofile-arcs</code>选项）</li><li>有了 <code>.gcno</code> 和 <code>.gcda</code>，通过源码生成 <code>.gcov</code> 文件，最后生成代码覆盖率报告。</li></ol><p>用GCC编译的时候加上-fprofile-arcs -ftest-coverage选项，链接的时候也加上。</p><p><code>fprofile-arcs</code>参数使gcc创建一个程序的流图，之后找到适合图的生成树。只有不在生成树中的弧被操纵（instrumented）：gcc添加了代码来清点这些弧执行的次数。当这段弧是一个块的唯一出口或入口时，操纵工具代码（instrumentation code)将会添加到块中，否则创建一个基础块来包含操纵工具代码。</p><p>gcov主要使用<code>.gcno</code>和<code>.gcda</code>两个文件：</p><ol><li><code>.gcno</code>是由<code>-ftest-coverage</code>产生的，它包含了重建基本块图和相应的块的源码的行号的信息。</li><li><code>.gcda</code>是由加了<code>-fprofile-arcs</code>编译参数的编译后的文件运行所产生的，它包含了弧跳变的次数和其他的概要信息（而gcda只能在程序运行完毕后才能产生的）</li></ol><p><strong>参考</strong>：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/402463278" target="_blank" rel="noopener">使用 Gcov 和 LCOV 度量 C/C++ 项目的代码覆盖率</a></li><li><a href="https://segmentfault.com/a/1190000040733605" target="_blank" rel="noopener">源码分析 | 使用 gcov 和 lcov 测试 PostgreSQL 代码覆盖率</a></li><li><a href="https://www.cnblogs.com/ChinaHook/p/5508660.html" target="_blank" rel="noopener">lcov收集覆盖率</a></li></ul><p><strong>实践部分详见</strong> 博客：<code>C/C++项目的全量覆盖率和增量覆盖率</code></p><h2 id="52-jacoco"><a class="markdownIt-Anchor" href="#52-jacoco"></a> 5.2 Jacoco</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/363864068" target="_blank" rel="noopener">Java代码覆盖率工具Jacoco上手指引</a></li><li><a href="https://juejin.cn/post/7001005602994389005" target="_blank" rel="noopener">基于Jacoco的增量覆盖率实现与落地</a></li><li><a href="https://zhuanlan.zhihu.com/p/337957182" target="_blank" rel="noopener">滴滴开源Super-jacoco：java代码覆盖率收集平台</a></li><li><a href="https://www.cxyzjd.com/article/zou90512/102163415" target="_blank" rel="noopener">DevOps - Java增量代码覆盖率工具_zou90512的专栏-程序员宅基地_java增量覆盖率</a></li><li><a href="https://www.bilibili.com/video/BV1ba4y1v7K6" target="_blank" rel="noopener">onthefly动态插桩覆盖率统计</a></li></ul><h1 id="x-参考"><a class="markdownIt-Anchor" href="#x-参考"></a> X 参考</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/144826192" target="_blank" rel="noopener">什么是代码覆盖率？</a></li><li><a href="https://zhuanlan.zhihu.com/p/397701541" target="_blank" rel="noopener">关于代码覆盖率(Code Coverage)</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="未分类" scheme="https://Dragonliu2018.github.io/categories/未分类/"/>
    
    
    <category term="待补充" scheme="https://Dragonliu2018.github.io/tags/待补充/"/>
    
  </entry>
  
  <entry>
    <title>MR(merge request) vs PR(pull request)</title>
    <link href="https://dragonliu2018.github.io/2022/04/15/MR-merge-request-vs-PR-pull-request/"/>
    <id>https://dragonliu2018.github.io/2022/04/15/MR-merge-request-vs-PR-pull-request/</id>
    <published>2022-04-15T08:04:41.000Z</published>
    <updated>2022-04-18T11:31:16.498Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p><strong>转载</strong>：<a href="https://mp.weixin.qq.com/s?__biz=MzkwNzI0MzQ2NQ==&amp;mid=2247489125&amp;idx=2&amp;sn=735299f1744b1074e54cbeeaeadc1e9c&amp;source=41#wechat_redirect" target="_blank" rel="noopener">啥是 PR？啥又是MR？</a></p></blockquote><h1 id="1-引入"><a class="markdownIt-Anchor" href="#1-引入"></a> 1 引入</h1><p>在团队中我承担了<code>Committer</code> 的责任，也就是帮同事们检视代码（<code>Code Review</code>）和合入代码，经常听到有同事在群里喊：“大佬，帮我合个 PR”，“大佬，我刚提交了一个 MR，帮忙合一下，急着出补丁”。我有点懵了，<code>PR</code> 和 <code>MR</code> 到底哪个才是正确的，这两个到底有什么区别，我决定先搞清楚这两个概念再合入他们的代码。[手动滑稽]</p><h1 id="2-什么是pull-request"><a class="markdownIt-Anchor" href="#2-什么是pull-request"></a> 2 什么是Pull Request？</h1><p><code>PR</code> 的全称是<code>Pull Request</code>，经常用 <code>Github</code> 的同学对这个肯定很熟悉了。Github 聚集了4000万开发者，过亿的开源项目，如果想给别人的开源仓库贡献代码，通常是先 <code>fork</code> 别人的项目，然后本地修改完成提交到自己的个人 fork 仓库，最后提交 PR 等待别人合入你的代码。</p><p>Github 的工作流（fork 工作流）：</p><img src="https://s2.loli.net/2022/04/15/CLTr3VjuGOwJUBg.png" width="400" height="400" alt="fork 工作流" align="center" id="150"><p>我们重点看一下第6步，小明写完代码了想合入到原作者的仓库，新建了一个“<code>pull request</code>”，拉请求？这明明是推啊，小明将自己的修改推到原作者的仓，感觉叫“<code>push request</code>”比较合适吧。</p><p>既然 Github 坚持叫“<code>pull request</code>”，我们试着理解一下它的思路，小明写完代码了心里肯定是在想：<code>原作者大神，我改了点东西，你快把我的修改拉回去吧</code>。站在原作者的角度思考，叫pull request好像也说得过去，每天有大量的人从我这里 fork 代码走，我只会拉取我感兴趣的代码回来。</p><p>我好像把自己说服了。</p><h1 id="3-什么是-merge-request"><a class="markdownIt-Anchor" href="#3-什么是-merge-request"></a> 3 什么是 Merge Request？</h1><p>MR 的全称是 <code>Merge Request</code>，相信玩过 Gitlab 的同学都知道这个。</p><p>插播一下，Github这么好用了为什么还有人玩 Gitlab，这就要几年前说起了。在微软没有收购 Github 之前，Github 上面所有的项目必须是公开的，也就是说自己很渣的代码也必须要公开，不能藏着噎着。但是在一些小的公司或者创业团队，代码这种核心资产是不希望被公开，他们迫切需要私密仓这种需求，所以很多人都选择了 Gitlab。当然后面 Github 也放开了私有仓库，这是后话了。</p><p>merge 工作流：</p><img src="https://s2.loli.net/2022/04/15/q4NIh1H7ZVA9CR2.png" width="500" height="400" alt="merge 工作流" align="center" id="151"><p>团队中每个人都从远程仓库 develop 分支拉取代码，本地基于 develop 分支新建特性分支，修改完代码将特性分支推到远程仓，紧接着新建 Merge Request 期望将自己的特性分支合入 develop 分支。</p><p>从上面这个流程来看Merge Request 就是将自己的特性分支合入到主干分支。</p><h1 id="4-pull-request-vs-merge-request"><a class="markdownIt-Anchor" href="#4-pull-request-vs-merge-request"></a> 4 Pull Request VS Merge Request</h1><p>总结一下上面两个例子。</p><p>Github 是玩 fork 模式的，开发者提交自己的代码新建 Pull Request，请求原作者：“把我的代码拉回去吧”。</p><p>Gitlab 是玩分支模式的，开发者提交自己的代码新建 Merge Request，想将自己的特性分支合并到主干。</p><p>上面总结的好像很有道理，但是不要忘了，Github 也可以玩分支模式，Gitlab 也可以玩 fork 模式，更令人无语的是：</p><p>Github 上合并分支还是叫 Pull Request；Gitlab 上fork 模式也是叫 Merge Request；</p><p>不行，这种答案我没法接受，去 stackoverflow上搜一些大家是怎么理解的。果然有一个帖子很火：</p><p>Pull request vs Merge request</p><p>有一个回答摘取了 Gitlab 的官方解释：</p><blockquote><p>Merge or pull requests are created in a git management application and ask an assigned person to merge two branches. Tools such as GitHub and Bitbucket choose the name pull request since the first manual action would be to pull the feature branch. Tools such as GitLab and Gitorious choose the name merge request since that is the final action that is requested of the assignee. In this article we’ll refer to them as merge requests.</p></blockquote><p>翻译过来简单理解就是：这两个没有本质区别，站在不同立场说法不一样而已。</p><p><strong>好了，官方已经盖棺定论了，这两个就是一个东西，不要纠结啦~</strong></p><h1 id="5-疯狂吐槽"><a class="markdownIt-Anchor" href="#5-疯狂吐槽"></a> 5 疯狂吐槽</h1><p>对于初学者来说，Github 的 pull request 确实让人难以理解，我们去各大网站看看用户的声音。</p><p>StackOverflow：</p><img src="https://s2.loli.net/2022/04/15/f8jlvChkSD5FBxi.png" width="600" height="400" alt="merge 工作流" align="center" id="152"><p>知乎：</p><img src="https://s2.loli.net/2022/04/15/LGJDK7hlTadr3Pn.png" width="600" height="400" alt="merge 工作流" align="center" id="153"><p>从国外到国内都有大量的用户对这个名字不理解，明明是提交提交代码，为什么是 pull request，有些人甚至怀疑是名字打错了。</p><p>如果让我来给 Github 取名字，我可能会取：</p><ul><li><code>push request</code> 推请求</li><li><code>merge request</code> 合并请求</li></ul><p>想多了，不会有如果。[嘿哈]</p><h1 id="6-总结"><a class="markdownIt-Anchor" href="#6-总结"></a> 6 总结</h1><p><code>Pull Request</code> 和<code>Merge Request</code> 本质上都是合入代码，只是站在不同角度有不同的说法而已，因此在学习和工作中无论用哪一个都没有问题。</p><p>鼓励大家在 GitHub上多多提交 PR，为个人简历加分</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="环境与工具" scheme="https://Dragonliu2018.github.io/categories/环境与工具/"/>
    
    
    <category term="Git" scheme="https://Dragonliu2018.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>《代码整洁之道 clean code》笔记</title>
    <link href="https://dragonliu2018.github.io/2022/04/15/%E3%80%8A%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%20clean%20code%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    <id>https://dragonliu2018.github.io/2022/04/15/%E3%80%8A%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%20clean%20code%E3%80%8B%E7%AC%94%E8%AE%B0/</id>
    <published>2022-04-15T07:43:14.000Z</published>
    <updated>2022-04-18T14:18:55.189Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><ul><li>《代码整洁之道 Clean Code》Robert C. Martin 著 韩磊 译 人民邮电出版社 2020</li><li>《Clean Code(评注版)》Robert C. Martin 著 韩磊 评注 电子工业出版社 2012</li></ul></blockquote><h1 id="ch2-meaningful-names有意义的命名"><a class="markdownIt-Anchor" href="#ch2-meaningful-names有意义的命名"></a> Ch2 Meaningful Names(有意义的命名)</h1><h2 id="21-use-intention-revealing-names名副其实"><a class="markdownIt-Anchor" href="#21-use-intention-revealing-names名副其实"></a> 2.1 Use Intention-Revealing Names(名副其实)</h2><p>如果名称需要注释来补充，那就算不上名副其实。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> d;<span class="comment">//消逝的时间，以日计</span></span><br><span class="line"><span class="keyword">int</span> elapsedTimeInDays;</span><br></pre></td></tr></table></figure><h2 id="22-avoid-disinformation避免误导"><a class="markdownIt-Anchor" href="#22-avoid-disinformation避免误导"></a> 2.2 Avoid Disinformation(避免误导)</h2><p>程序员必须避免留下掩藏代码本意的错误线索。应当避免使用与本意相悖的词。</p><ul><li><p>缩写形式常常带来误导。编写三角计算程序，hp是hypotenuse(直角三角形的斜边)缩写，但也是UNIX平台或类UNIX平台的专有名称。</p></li><li><p>一些词对于程序员有特殊含义，如List：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">accountList;<span class="comment">//一组账号，如果账号的容器并List，就会引起错误的判断。</span></span><br><span class="line"><span class="comment">// 可以换成</span></span><br><span class="line">accountGroup;</span><br><span class="line">bunchOfAccounts;</span><br></pre></td></tr></table></figure></li><li><p>不使用差异较小的名称，不易区分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XYZControllerForEfficientHandlingOfStrings;</span><br><span class="line">XYZControllerForEfficientStorageOfStrings;</span><br></pre></td></tr></table></figure></li><li><p>不用小写字母<code>l</code>和大写字母<code>O</code>做为变量名，容易与数字<code>1</code>和<code>0</code>混淆</p></li></ul><h2 id="23-make-meaningful-distinctions做有意义的区分"><a class="markdownIt-Anchor" href="#23-make-meaningful-distinctions做有意义的区分"></a> 2.3 Make Meaningful Distinctions(做有意义的区分)</h2><ul><li>以数字系列命名：<code>a1,a2,a3...aN</code></li><li>废话：Product类、ProductInfo类、ProductData类三者名称不同，但是意思无区别</li></ul><h2 id="24-use-pronounceable-names使用可读命名"><a class="markdownIt-Anchor" href="#24-use-pronounceable-names使用可读命名"></a> 2.4 Use Pronounceable Names(使用可读命名)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Data genymdhms;<span class="comment">//生成日期，年、月、日、时、分、秒</span></span><br><span class="line">Data generationTimestamp;<span class="comment">//改进</span></span><br></pre></td></tr></table></figure><h2 id="25-use-searchable-names使用可搜索命名"><a class="markdownIt-Anchor" href="#25-use-searchable-names使用可搜索命名"></a> 2.5 Use Searchable Names(使用可搜索命名)</h2><p>不使用单字母名称和数字常量，在代码中找数字<code>7</code>要比找<code>MAX_CLASSES_PER_STUDENT</code>容易多；单字母名称可用在短方法的本地变量(local variables inside short methods)，如循环中的计数因子<code>i</code>，名称长短应与其作用域大小相对应。</p><h2 id="26-avoid-encoding避免编码"><a class="markdownIt-Anchor" href="#26-avoid-encoding避免编码"></a> 2.6 Avoid Encoding(避免编码)</h2><p>把类型或作用域加进命名中，徒然增加了读懂命名的负担。带编码的名称也不便发音，容易打错。</p><ul><li><p>匈牙利语标记法：</p><ul><li>在变量名中用缩写标记变量的类型。</li><li>在Windows的C语言API时代，编译器并不做类型检查，程序员需要匈牙利语标记法来帮助自己记住类型。</li><li>现代编程语言具有更丰富的类型系统，编译器也记得并强制使用类型。而且，人们趋向于使用更小的类、更短的方法，好让每个变量的定义都在视野范围之内。所以，如今HN和其他类型的编码方式纯属多余。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PhoneNumber phoneString;<span class="comment">//类型发生变化时，名称并不发生变化</span></span><br></pre></td></tr></table></figure></li><li><p>成员前缀：不必使用<code>m_</code>前缀来表明成员变量</p></li><li><p>接口和实现(Interfaces and Implementations)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// build an Abstract Factory for the creation of shapes</span></span><br><span class="line">ShapeFactory;<span class="comment">//比较好</span></span><br><span class="line">IShapeFactory;<span class="comment">//I前缀表示接口，是废话</span></span><br><span class="line">ShapeFactoryImp;<span class="comment">//实现比接口好一些</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="27-avoid-mental-mapping避免惯性思维"><a class="markdownIt-Anchor" href="#27-avoid-mental-mapping避免惯性思维"></a> 2.7 Avoid Mental Mapping(避免惯性思维)</h2><p>不应当让读者在脑中把你的名称翻译为他们熟知的名称；这种问题经常出现在选择是使用问题领域术语还是解决方案领域术语时。</p><blockquote><p>聪明程序员和专业程序员之间的区别在于，专业程序员了解，明确是王道。专业程序员善用其能，编写其他人能理解的代码。</p></blockquote><h2 id="28-class-names类名"><a class="markdownIt-Anchor" href="#28-class-names类名"></a> 2.8 Class Names(类名)</h2><ul><li>类名和对象名应该是名词或名词短语，如Customer、WikiPage、Account 和AddressParser。</li><li>避免使用Manager、Processor、Data或Info这样的类名。</li><li>类名不应当是动词。</li></ul><h2 id="29-method-names方法名"><a class="markdownIt-Anchor" href="#29-method-names方法名"></a> 2.9 Method Names(方法名)</h2><ul><li><p>方法名应当是动词或动词短语，如postPayment、deletePage 或save。</p></li><li><p>属性访问器、修改器和断言(accessors, mutators, predicates)应该根据其值命名，并依Javabean 标准1加上get、set和is前缀。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> name=employee.getName();</span><br><span class="line">customer.setName(<span class="string">"mike"</span>);</span><br><span class="line"><span class="keyword">if</span>(paycheck.isPosted())...</span><br></pre></td></tr></table></figure></li><li><p>重载构造器时，使用描述了参数的静态工厂方法名(static factory methods)。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Complex fulcrumPoint=Complex.FromRealNumber(<span class="number">23.0</span>);</span><br><span class="line"><span class="comment">// 通常好于</span></span><br><span class="line">Complex fulcrumPoint=<span class="keyword">new</span> Complex(<span class="number">23.0</span>);</span><br></pre></td></tr></table></figure><p>可以考虑将相应的构造器设置为private，强制使用这种命名手段。</p></li></ul><h2 id="210-dont-be-cute别抖机灵"><a class="markdownIt-Anchor" href="#210-dont-be-cute别抖机灵"></a> 2.10 Don’t Be Cute(别抖机灵)</h2><p>别用俗语、俚语。</p><h2 id="211-pick-one-word-per-concept每个概念对应一个词"><a class="markdownIt-Anchor" href="#211-pick-one-word-per-concept每个概念对应一个词"></a> 2.11 Pick One Word per Concept(每个概念对应一个词)</h2><p>给每个抽象概念选一个词，并且一以贯之。例如：</p><ul><li>fetch、retrieve和get虽有区别，但在前后一致、团队一致的情况下，可以任取其一，一以贯之。</li><li>还有controller、manager、driver</li></ul><h2 id="212-dont-pun别用双关语"><a class="markdownIt-Anchor" href="#212-dont-pun别用双关语"></a> 2.12 Don’t Pun(别用双关语)</h2><p>避免将同一单词用于不同目的。“一词一义”原则</p><h2 id="213-use-solution-domain-names使用解决方案领域名称"><a class="markdownIt-Anchor" href="#213-use-solution-domain-names使用解决方案领域名称"></a> 2.13 Use Solution Domain Names(使用解决方案领域名称)</h2><p>只有程序员才会读你的代码，所以尽量用那些计算机科学（Computer Science，CS）术语、算法名、模式名、数学术语。</p><h2 id="214-use-problem-domain-names使用问题领域名称"><a class="markdownIt-Anchor" href="#214-use-problem-domain-names使用问题领域名称"></a> 2.14 Use Problem Domain Names(使用问题领域名称)</h2><p>如果不能用程序员熟悉的术语来命名，就采用从所涉问题领域而来的名称。这样负责维护代码的程序员就能去请教领域专家了。</p><blockquote><p>优秀的程序员和设计师，其工作之一就是分离解决方案领域和问题领域的概念。</p></blockquote><h2 id="215-add-meaningful-context添加有意义的语境"><a class="markdownIt-Anchor" href="#215-add-meaningful-context添加有意义的语境"></a> 2.15 Add Meaningful Context(添加有意义的语境)</h2><p>用有良好命名的类、函数或名称空间来放置名称给读者提供语境，如果没这么做，给名称添加前缀。比如：firstName、lastName、street、houseNumber、city、state和zipcode的变量</p><ol><li>如果他们在一起，很明确是构成了一个地址；</li><li>如果只有state，那么很难猜测是地址的一部分；</li><li>可以添加前缀addrFirstName、addrLastName、addrState等，以此提供语境；</li><li>更好的方案是创建名为Address的类。</li></ol><h2 id="216-dont-add-gratutous-context不要添加没用的语境"><a class="markdownIt-Anchor" href="#216-dont-add-gratutous-context不要添加没用的语境"></a> 2.16 Don’t Add Gratutous Context(不要添加没用的语境)</h2><p>只要短名称足够清楚，就要比长名称好，别给名称添加不必要的语境。</p><p>比如：设若有一个名为“加油站豪华版”（Gas Station Deluxe）的应用，每个类不要添加GSD前缀。</p><h1 id="ch3-functions函数"><a class="markdownIt-Anchor" href="#ch3-functions函数"></a> Ch3 Functions(函数)</h1><h2 id="31-small短小"><a class="markdownIt-Anchor" href="#31-small短小"></a> 3.1 Small(短小)</h2><ul><li>if语句、else语句、while 语句等，其中的代码块应该只有一行。该行大抵应该是一个函数调用语句。这样不但能保持函数短小，而且，因为块内调用的函数拥有较具说明性的名称，从而增加了文档上的价值。</li><li>这也意味着函数不应该大到足以容纳嵌套结构。所以，<strong>函数的缩进层级不该多于一层或两层</strong>。当然，这样的函数易于阅读和理解。</li></ul><h2 id="32-do-one-thing只做一件事"><a class="markdownIt-Anchor" href="#32-do-one-thing只做一件事"></a> 3.2 Do One Thing(只做一件事)</h2><p>如果函数只是做了该函数名下同一抽象层上的步骤，则函数还是只做了一件事。</p><p>只做一件事的函数无法被合理地切分为多个区段。</p><h2 id="33-one-level-of-abstraction-per-function每个函数一个抽象层级"><a class="markdownIt-Anchor" href="#33-one-level-of-abstraction-per-function每个函数一个抽象层级"></a> 3.3 One Level of Abstraction per Function(每个函数一个抽象层级)</h2><p>要确保函数只做一件事，函数中的语句都要在同一抽象层级上。</p><p>自顶向下读代码：向下规则。让代码拥有自顶向下的阅读顺序，让每个函数后面都跟着位于下一抽象层级的函数，这样一来，在查看函数列表时，就能循抽象层级向下阅读了。</p><h2 id="34-switch-statementsswitch语句"><a class="markdownIt-Anchor" href="#34-switch-statementsswitch语句"></a> 3.4 Switch Statements(Switch语句)</h2><p>利用多态能够确保每个switch都埋藏在较低的抽象层级，而且永远不重复。</p><h2 id="35-use-descriptive-names使用描述性的名称"><a class="markdownIt-Anchor" href="#35-use-descriptive-names使用描述性的名称"></a> 3.5 Use Descriptive Names(使用描述性的名称)</h2><ul><li>沃德原则：“如果每个例程都让你感到深合己意，那就是整洁代码。” 函数越短小、功能越集中，就越便于取个好名字。</li><li>长而具有描述性的名称，比短而令人费解的名称好，比描述性的长注释好。</li><li>命名方式要保持一致。使用与模块名一脉相承的短语、名词和动词给函数命名。</li></ul><h2 id="36-function-arguments函数参数"><a class="markdownIt-Anchor" href="#36-function-arguments函数参数"></a> 3.6 Function Arguments(函数参数)</h2><p>最理想的参数数量是零（零参数函数），其次是一（单参数函数），再次是二（双参数函数），应尽量避免三（三参数函数）。有足够特殊的理由才能用三个以上参数（多参数函数）。</p><ul><li><p>标识参数：尽量不向函数传入布尔值；</p></li><li><p>参数对象：如果函数看来需要两个、三个或三个以上参数，就说明其中一些参数应该封装为类了。例如，下面两个声明的差别：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Circle <span class="title">makeCircle</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y, <span class="keyword">double</span> radius)</span></span>;</span><br><span class="line"><span class="function">Circle <span class="title">makeCircle</span><span class="params">(Point center, <span class="keyword">double</span> radius)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>参数列表：有时，我们想要向函数传入数量可变的参数。例如，String.format方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String.format(<span class="string">"s worked $.2f hours."</span>, name, hours);</span><br></pre></td></tr></table></figure><p>如果可变参数像上例中那样被同等对待，就和类型为List的单个参数没什么两样。这样一来，String.formate实则是二元函数。下列 String.format的声明也很明显是二元的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">format</span><span class="params">(String format, Object...args)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="37-have-no-side-effects无副作用"><a class="markdownIt-Anchor" href="#37-have-no-side-effects无副作用"></a> 3.7 Have No Side Effects(无副作用)</h2><p>函数承诺只做一件事，但还是会做其他被藏起来的事。有时，它会对自己类中的变量做出未能预期的改动。有时，它会把变量搞成向函数传递的参数或是系统全局变量。无论哪种情况，都是具有破坏性的，会导致古怪的时序性耦合及顺序依赖。</p><h2 id="38-command-query-separation分隔指令和询问"><a class="markdownIt-Anchor" href="#38-command-query-separation分隔指令和询问"></a> 3.8 Command Query Separation(分隔指令和询问)</h2><p>函数要么做什么事，要么回答什么事，但二者不可得兼。函数应该修改某对象的状态，或是返回该对象的有关信息。两样都干常会导致混乱。</p><ol><li>有两种指令与查询混杂的情况：查询某个状态，再根据状态执行操作；执行某个操作，返回该操作的执行情况。</li><li>最常见的就是函数执行某项操作，其布尔类型的返回值代表操作成功与否。</li></ol><h2 id="39-prefer-exceptions-to-returning-error-codes使用异常代替返回错误码"><a class="markdownIt-Anchor" href="#39-prefer-exceptions-to-returning-error-codes使用异常代替返回错误码"></a> 3.9 Prefer Exceptions to Returning Error Codes(使用异常代替返回错误码)</h2><h2 id="310-dont-repeat-yourself别重复自己"><a class="markdownIt-Anchor" href="#310-dont-repeat-yourself别重复自己"></a> 3.10 Don’t Repeat Yourself(别重复自己)</h2><p>重复可能是软件中一切邪恶的根源。许多原则与实践规则都是为控制与消除重复而创建。例如，</p><ul><li>考德（Codd）数据库范式都是为消灭数据重复而服务；</li><li>面向对象编程是如何将代码集中到基类，从而避免了冗余。</li><li>面向方面编程（Aspect Oriented Programming）、面向组件编程（Component Oriented Programming）多少也都是消除重复的一种策略。</li></ul><h2 id="311-structured-programming结构化编程"><a class="markdownIt-Anchor" href="#311-structured-programming结构化编程"></a> 3.11 Structured Programming(结构化编程)</h2><ul><li>Dijkstra认为，每个函数、函数中的每个代码块都应该有一个入口、一个出口。意味着在每个函数中只该有一个return语句，循环中不能有break 或continue 语句，而且不能有任何 goto语句。</li><li>但对于小函数，这些规则助益不大。只有在大函数中，这些规则才会有明显的好处。</li><li>所以，只要函数保持短小，偶尔出现的returm、break 或continue语句没有坏处，甚至还比单入单出原则更具有表达力。另外一方面，goto只在大函数中才有道理，所以应该尽量避免使用。</li></ul><h2 id="312-如何写出这样的函数"><a class="markdownIt-Anchor" href="#312-如何写出这样的函数"></a> 3.12 如何写出这样的函数</h2><p>并不是一开始就按照规则写函数，需要打磨。</p><h1 id="ch4-comments注释"><a class="markdownIt-Anchor" href="#ch4-comments注释"></a> Ch4 Comments(注释)</h1><ol><li>注释最多也就是一种必须的恶。若编程语言足够有表达力，或者我们长于用这些语言来表达意图，就不需要注释。</li><li>代码在发动，演化；注释不总是随之变动；而代码是唯一真正准确的信息来源。</li></ol><h2 id="41-comments-do-not-make-up-for-bad-code注释不能弥补糟糕的代码"><a class="markdownIt-Anchor" href="#41-comments-do-not-make-up-for-bad-code注释不能弥补糟糕的代码"></a> 4.1 Comments Do Not Make Up for Bad Code(注释不能弥补糟糕的代码)</h2><h2 id="42-explain-yourself-in-code用代码来阐述"><a class="markdownIt-Anchor" href="#42-explain-yourself-in-code用代码来阐述"></a> 4.2 Explain Yourself in Code(用代码来阐述)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式1</span></span><br><span class="line"><span class="comment">//Check to see if the employee is eligible for full benefits </span></span><br><span class="line"><span class="keyword">if</span> ((employee.flags &amp; HOURLY_FLAG) &amp;&amp; (employee.age &gt;<span class="number">65</span>))</span><br><span class="line"><span class="comment">//方式2</span></span><br><span class="line"><span class="keyword">if</span> (employee.isEligibleForFu11Benefits())</span><br></pre></td></tr></table></figure><h2 id="43-good-comments好注释"><a class="markdownIt-Anchor" href="#43-good-comments好注释"></a> 4.3 Good Comments(好注释)</h2><p>有些注释是必须的，也是有利的。</p><ol><li><p>法律信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Copyright (C)2003,2004,2005 by Object Mentor, Inc. All rights reserved.</span></span><br><span class="line"><span class="comment">//Released under the terms of the GNU General Public License version 2 or later.</span></span><br></pre></td></tr></table></figure></li><li><p>提供信息的注释。以下注释解释了某个抽象方法的返回值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Returns an instance of the Responder being tested.</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Responder <span class="title">responderInstance</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>对意图的解释</p></li><li><p>阐释：有时，注释把某些晦涩难明的参数或返回值的意义翻译为某种可读形式，也会是有用的。这类注释在低层抽象中较为常见，也应该只出现在低层抽象中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCompareTo</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WikiPagePath a=PathParser. parse(<span class="string">"PageA"</span>); </span><br><span class="line">    WikiPagePath ab=PathParser. parse(<span class="string">"PageA. PageB"</span>);</span><br><span class="line">    WikiPagePath b=PathParser. parse(<span class="string">"PageB"</span>); </span><br><span class="line">    WikiPagePath aa=PathParser. parse(<span class="string">"PageA. PageA"</span>); </span><br><span class="line">    WikiPagePath bb=PathParser. parse(<span class="string">"PageB. PageB"</span>);</span><br><span class="line">    WikiPagePath ba=PathParser. parse(<span class="string">"PageB. PageA"</span>); </span><br><span class="line">    </span><br><span class="line">    assertTrue(a. compareTo(a)==<span class="number">0</span>);<span class="comment">//a==a</span></span><br><span class="line">    assertTrue(a. compareTo(b)!=<span class="number">0</span>);<span class="comment">//a!=b </span></span><br><span class="line">    assertTrue(ab. compareTo(ab)==<span class="number">0</span>);<span class="comment">//ab==ab </span></span><br><span class="line">    assertTrue(a. compareTo(b)==-<span class="number">1</span>);<span class="comment">//a&lt;b </span></span><br><span class="line">    assertTrue(aa. compareTo(ab)==-<span class="number">1</span>);<span class="comment">//aa&lt; ab </span></span><br><span class="line">    assertTrue(ba. compareTo(bb)==-<span class="number">1</span>);<span class="comment">//ba&lt;bb </span></span><br><span class="line">    assertTrue(b. compareTo(a)==<span class="number">1</span>);<span class="comment">//b&gt;a </span></span><br><span class="line">    assertTrue(ab. compareTo(aa)==<span class="number">1</span>);<span class="comment">//ab&gt;aa </span></span><br><span class="line">    assertTrue(bb. compareTo (ba)==<span class="number">1</span>);<span class="comment">//bb&gt;ba</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>警示：有时，用于警告其他程序员会出现某种后果的注释也是有用的。</p></li><li><p>TODO注释：有时用//TODO形式在源代码中放置要做的工作列表。如今，大多数好IDE都提供了特别的手段来定位所有TODO注释，所以TODO注释变得多余。</p></li><li><p>放大(Amplification)：注释可以用来放大某种看来不合理之物的重要性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String listItemContent=match.group(<span class="number">3</span>).trim();</span><br><span class="line"><span class="comment">//the trim is real important. It removes the starting//spaces that could cause the itam to be recognized</span></span><br><span class="line"><span class="comment">//as another list.</span></span><br><span class="line"><span class="keyword">new</span> ListItemwidget(<span class="keyword">this</span>, listItemContent, <span class="keyword">this</span>.level+<span class="number">1</span>); </span><br><span class="line"><span class="keyword">return</span> buildList(text.substring(match. end()));</span><br></pre></td></tr></table></figure></li><li><p>公共API中的Javadoc</p></li></ol><h2 id="44-bad-comments坏注释"><a class="markdownIt-Anchor" href="#44-bad-comments坏注释"></a> 4.4 Bad Comments(坏注释)</h2><ol><li><p>Mumbling：自言自语的注释，往往是作者边写代码边整理思路时留下的。</p></li><li><p>多余的注释(Redundant Comments)：对足够小的函数不需要再做注释，但是一些关键业务函数加上“他是用来做什么”之类的注释。</p></li><li><p>误导性注释(Misleading Comments)</p></li><li><p>循规式注释(Mandated Comments)：每个函数都要有Javadoc 或每个变量都要有注释的规矩是愚蠢可笑的。</p></li><li><p>日志式注释(Journal Comments)：很久以前，在模块开始处创建并维护这些记录还算有道理。那时，我们还没有源代码控制系统可用。如今，这种冗长的记录只会让模块变得凌乱不堪，应当全部删除。</p></li><li><p>废话注释(Noise Comments)</p></li><li><p>可怕的废话(Scary Noise)：Javadoc 也可能是废话。</p></li><li><p>Don’t Use a Comment When You can Use a Function or a Variable.</p></li><li><p>位置标记(Position Markers)</p></li><li><p>括号后面的注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (...) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;<span class="comment">//while</span></span><br></pre></td></tr></table></figure></li><li><p>归属与署名：源代码控制系统非常善于记住是谁在何时添加了什么，源代码控制系统是这类信息最好的归属地。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Added by Rick*/</span></span><br></pre></td></tr></table></figure></li><li><p>注释掉的代码：20世纪60年代，曾经有那么一段时间，注释掉的代码可能有用，但现在源代码控制系统记住不要的代码。</p></li><li><p>HTML注释</p></li><li><p>非本地信息：假如你一定要写注释，请确保它描述了离它最近的代码，别在本地注释的上下文环境中给出系统级的信息。</p></li><li><p>信息过多：别在注释中添加有趣的历史性话题或者无关的细节描述。</p></li><li><p>不明显的联系：注释及其描述的代码之间的联系应该显而易见。</p></li><li><p>函数头：短函数不需要太多描述。为只做一件事的短函数选个好名字，通常要比写函数头注释要好。</p></li><li><p>非公共代码中的Javadoc</p></li></ol><h1 id="ch5-formatting格式"><a class="markdownIt-Anchor" href="#ch5-formatting格式"></a> Ch5 Formatting(格式)</h1><h2 id="51-vertical-formatting垂直格式"><a class="markdownIt-Anchor" href="#51-vertical-formatting垂直格式"></a> 5.1 Vertical Formatting(垂直格式)</h2><p>有可能用大多数为200行、最长500行的单个文件构造出色的系统。尽管这并非不可违背的原则，也应该乐于接受。短文件通常比长文件易于理解。</p><ol><li><p>Vertical Openness Between Concepts(间隔)：在封包声明、导入声明和每个函数之间，都有空白行隔开。每个空白行都是一条线索，标识出新的独立概念。</p></li><li><p>Vertical Density(靠近)：紧密相关的代码应该互相靠近</p></li><li><p>Vertical Distance(垂直距离)：</p><ul><li><p>变量声明：变量声明应尽可能靠近其使用位置。因为函数很短，本地变量应该在函数的顶部出现。循环中的控制变量应该总是在循环语句中声明。</p></li><li><p>实体变量应该在类的顶部声明。关于实体变量应该放在哪里，争论不断。在C++中，通常会采用所谓“剪刀原则”（scissors rule），所有实体变量都放在底部。而在Java中，惯例是放在类的顶部。</p><blockquote><p>关于“剪刀原则”较为确切的解释：在类的头文件中，公共部分放在前面，私有部分放到后面，这样就可以用剪刀将文件一分为二，上半部分是该类的可用部分。</p></blockquote></li><li><p>相关函数：若某个函数调用了另外一个，就应该把它们放到一起，而且<strong>调用者应该尽可能放在被调用者上面</strong>。</p></li><li><p>概念相关：概念相关的代码应该放到一起。相关性越强，彼此之间的距离就该越短。这些函数有着极强的概念相关性，因为他们拥有共同的命名模式，执行同一基础任务的不同变种。互相调用是第二位的。即便没有互相调用，也应该放在一起。</p></li></ul></li></ol><h2 id="52-horizontal-formatting横向格式"><a class="markdownIt-Anchor" href="#52-horizontal-formatting横向格式"></a> 5.2 Horizontal Formatting(横向格式)</h2><ul><li><p>尽力保持代码行短小。死守80个字符的上限有点僵化，不反对代码行长度达到100个字符或120个字符。</p></li><li><p>无需拖动滚动条到右边的原则。但近年来显示器越来越宽，而年轻程序员又能将显示字符缩小到如此程度，屏幕上甚至能容纳200个字符的宽度。作者的上限是<strong>120</strong>个字符。</p></li></ul><ol><li><p>Horizontal Openness and Density(区隔与靠近)：使用空格字符将彼此紧密相关的事物连接到一起，也用空格字符把相关性较弱的事物分隔开。请看以下函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Func</span><span class="params">(String line)</span></span>&#123;<span class="comment">//不在函数名和左圆括号之间加空格,是函数与其参数密切相关；把参数隔开，是参数互相分离的</span></span><br><span class="line">lineCount++;</span><br><span class="line">    <span class="keyword">int</span> lineSize = line.length(); <span class="comment">//在赋值操作符周围加上空格字符，分隔表达式左边、右边</span></span><br><span class="line">    (-b + c) / (<span class="number">2</span>*a);<span class="comment">//空格表示运算顺序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>水平对齐：汇编语言程序使用水平对齐来强调某些程序结构，但是C、C++、Java不需要。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>    intNumber;</span><br><span class="line"><span class="keyword">float</span>  floatNumber;</span><br><span class="line"><span class="keyword">double</span> doubleNumber;</span><br></pre></td></tr></table></figure></li><li><p>缩进：在短小的if 语句、while循环或小函数中不要违反缩进规则。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (...) &#123;<span class="keyword">return</span> ;&#125;</span><br></pre></td></tr></table></figure></li><li><p>空范围：while或for语句的语句体为空，尽量不使用。如果无法避免，就确保空范围体的缩进，用括号包围起来。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式1</span></span><br><span class="line"><span class="keyword">while</span> (...)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方式2</span></span><br><span class="line"><span class="keyword">while</span> (...)</span><br><span class="line">;</span><br></pre></td></tr></table></figure></li></ol><h2 id="53-team-rules团队规则"><a class="markdownIt-Anchor" href="#53-team-rules团队规则"></a> 5.3 Team Rules(团队规则)</h2><h1 id="ch6-objects-and-data-structures对象和数据结构"><a class="markdownIt-Anchor" href="#ch6-objects-and-data-structures对象和数据结构"></a> Ch6 Objects and Data Structures(对象和数据结构)</h1><h2 id="61-data-abstraction数据抽象"><a class="markdownIt-Anchor" href="#61-data-abstraction数据抽象"></a> 6.1 Data Abstraction(数据抽象)</h2><p>数据本体是否一定要隐藏起来，也要视使用场合而定；公共变量存在的原因就是其他类总会有存取他的需要。</p><p>不要乱加取值器和赋值器而曝露其内部结构。</p><h2 id="62-dataobjects-anti-symmetrey数据-对象的反对称性"><a class="markdownIt-Anchor" href="#62-dataobjects-anti-symmetrey数据-对象的反对称性"></a> 6.2 Data/Objects Anti-Symmetrey(数据、对象的反对称性)</h2><p>对象把数据隐藏于抽象之后，曝露操作数据的函数。数据结构曝露其数据，没有提供有意义的函数。</p><h2 id="63-the-law-of-demeter得墨忒耳律"><a class="markdownIt-Anchor" href="#63-the-law-of-demeter得墨忒耳律"></a> * 6.3 The Law of Demeter(得墨忒耳律)</h2><p>著名的得墨忒耳律（The Law of Demeter）认为，模块不应了解它所操作对象的内部情形。<br>更准确地说，得墨忒耳律认为，类C的方法f只应该调用以下对象的方法：</p><ul><li>C</li><li>由f创建的对象；</li><li>作为参数传递给f的对象；</li><li>由C的实体变量持有的对象。</li></ul><p>方法不应调用由任何函数返回的对象的方法。</p><h2 id="64-data-transfer-objects数据传送对象"><a class="markdownIt-Anchor" href="#64-data-transfer-objects数据传送对象"></a> 6.4 Data Transfer Objects(数据传送对象)</h2><p>最为精练的数据结构，是一个只有公共变量、没有函数的类。这种数据结构有时被称为数据传送对象，或DTO（Data Transfer Objects）。DTO是非常有用的结构，尤其是在与数据库通信、或解析套接字传递的消息之类场景中。在应用程序代码里一系列将原始数据转换为数据库的翻译过程中，它们往往是排头兵。</p><h1 id="ch7-error-handling错误处理"><a class="markdownIt-Anchor" href="#ch7-error-handling错误处理"></a> * Ch7 Error Handling(错误处理)</h1><p>错误处理很重要，但如果它搞乱了代码逻辑，就是错误的做法。</p><h2 id="71-使用异常而非返回码"><a class="markdownIt-Anchor" href="#71-使用异常而非返回码"></a> 7.1 使用异常而非返回码</h2><h2 id="72-write-your-try-catch-finally-statement-first"><a class="markdownIt-Anchor" href="#72-write-your-try-catch-finally-statement-first"></a> 7.2 Write Your Try-Catch-Finally Statement First</h2><h2 id="73-use-unchecked-exceptions使用不可控异常"><a class="markdownIt-Anchor" href="#73-use-unchecked-exceptions使用不可控异常"></a> 7.3 Use Unchecked Exceptions(使用不可控异常)</h2><p>可控异常的代价就是违反开放/闭合原则。如果你在方法中抛出可控异常，而catch 语句在三个层级之上，你就得在catch 语句和抛出异常处之间的每个方法签名中声明该异常。这意味着对软件中较低层级的修改，都将波及较高层级的签名。修改好的模块必须重新构建、发布，即便它们自身所关注的任何东西都没改动过。</p><h2 id="74-provide-context-with-exceptions给出异常发生的环境说明"><a class="markdownIt-Anchor" href="#74-provide-context-with-exceptions给出异常发生的环境说明"></a> 7.4 Provide Context with Exceptions(给出异常发生的环境说明)</h2><ul><li>抛出的每个异常，都应当提供足够的环境说明，以便判断错误的来源和处所。在Java中，你可以从任何异常里得到堆栈踪迹（stack trace）；然而，堆栈踪迹却无法告诉你该失败操作的初衷。</li><li>应创建信息充分的错误消息，并和异常一起传递出去。在消息中，包括失败的操作和失败类型。如果你的应用程序有日志系统，传递足够的信息给catch块，并记录下来。</li></ul><h2 id="75-define-exception-classes-in-terms-of-a-callers-needs依照调用者需要定义异常类"><a class="markdownIt-Anchor" href="#75-define-exception-classes-in-terms-of-a-callers-needs依照调用者需要定义异常类"></a> 7.5 Define Exception Classes in Terms of a Caller’s Needs(依照调用者需要定义异常类)</h2><p>对错误分类有很多方式。可以依其来源分类：是来目组件还是其他地方？或依其类型分类：是设备错误、网络错误还是编程错误？不过，当我们在应用程序中定义异常类时，最重要的考虑应该是他们如何被捕获。</p><h2 id="76-define-the-normal-flow定义常规流程"><a class="markdownIt-Anchor" href="#76-define-the-normal-flow定义常规流程"></a> 7.6 Define the Normal Flow(定义常规流程)</h2><h2 id="77-dont-return-null"><a class="markdownIt-Anchor" href="#77-dont-return-null"></a> 7.7 Don’t Return Null</h2><h2 id="78-dont-pass-null不传递null值"><a class="markdownIt-Anchor" href="#78-dont-pass-null不传递null值"></a> 7.8 Don’t Pass Null(不传递null值)</h2><h1 id="ch8-boundaries边界"><a class="markdownIt-Anchor" href="#ch8-boundaries边界"></a> * Ch8 Boundaries(边界)</h1><h2 id="81-using-third-party-code使用第三方代码"><a class="markdownIt-Anchor" href="#81-using-third-party-code使用第三方代码"></a> 8.1 Using Third-Party Code(使用第三方代码)</h2><p>第三方程序包和框架提供者追求普适性，这样就能在多个环境中工作，吸引广泛的用户。而使用者则想要集中满足特定需求的接口，这样会导致系统边界上出现问题。</p><h2 id="82-浏览和学习边界"><a class="markdownIt-Anchor" href="#82-浏览和学习边界"></a> 8.2 浏览和学习边界</h2><p>编写测试来浏览和理解第三方代码。</p><h1 id="ch9-unit-tests单元测试"><a class="markdownIt-Anchor" href="#ch9-unit-tests单元测试"></a> Ch9 Unit Tests(单元测试)</h1><h2 id="91-tdd三定律"><a class="markdownIt-Anchor" href="#91-tdd三定律"></a> 9.1 TDD三定律</h2><blockquote><p>TDD是<strong>测试驱动开发</strong>（Test-Driven Development）的英文简称，是敏捷开发中的一项核心实践和技术，也是一种设计方法论。TDD的原理是在开发功能代码之前，先编写单元测试用例代码，测试代码确定需要编写什么产品代码。TDD虽是敏捷方法的核心实践，但不只适用于<a href="https://baike.baidu.com/item/XP/776028" target="_blank" rel="noopener">XP</a>（Extreme Programming），同样可以适用于其他开发方法和过程。</p></blockquote><p>三定律：</p><ol><li>在编写不能通过的单元测试前，不能编写生成代码；</li><li>只可编写刚好无法通过的单元测试，不能编译也算不通过；</li><li>只可编写刚好足以通过当前失败测试的生产代码。</li></ol><h2 id="92-keeping-tests-clean保持测试整洁"><a class="markdownIt-Anchor" href="#92-keeping-tests-clean保持测试整洁"></a> 9.2 Keeping Tests Clean(保持测试整洁)</h2><p>测试代码与生产代码一样重要。</p><p>测试能给软件带来各种好处，flexibilities(可扩展性)、relabilities(可靠性)等。</p><h2 id="93-clean-tests整洁的测试"><a class="markdownIt-Anchor" href="#93-clean-tests整洁的测试"></a> 9.3 Clean Tests(整洁的测试)</h2><h2 id="94-one-assert-per-test每个测试一个断言"><a class="markdownIt-Anchor" href="#94-one-assert-per-test每个测试一个断言"></a> 9.4 One Assert per Test(每个测试一个断言)</h2><ul><li>有流派认为，JUnit中每个测试函数都应该有且只有一个断言语句。</li><li>单个测试中的断言数量应该最小化。</li></ul><h2 id="95-first"><a class="markdownIt-Anchor" href="#95-first"></a> 9.5 F.I.R.S.T.</h2><ul><li>**快速（Fast）**测试应该够快。测试应该能快速运行。测试运行缓慢，你就不会想要频繁地运行它。如果你不频繁运行测试，就不能尽早发现问题，也无法轻易修正，从而也不能轻而易举地清理代码。最终，代码就会腐坏。</li><li>**独立（Independent）**测试应该相互独立。某个测试不应为下一个测试设定条件。你应该可以单独运行每个测试，及以任何顺序运行测试。当测试互相依赖时，头一个没通过就会导致一连串的测试失败，使问题诊断变得困难，隐藏了下级错误。</li><li>**可重复（Repeatable）**测试应当可在任何环境中重复通过。你应该能够在生产环境、质检环境中运行测试，也能够在无网络的列车上用笔记本电脑运行测试。如果测试不能在任意环境中重复，你就总会有个解释其失败的接口。当环境条件不具备时，你也会无法运行测试。</li><li>**自足验证（Self-Validating）**测试应该有布尔值输出。无论是通过或失败，你不应该查看日志文件来确认测试是否通过。你不应该手工对比两个不同文本文件来确认测试是否通过。如果测试不能自足验证，对失败的判断就会变得依赖主观，而运行测试也需要更长的手工操作时间。</li><li>**及时（Timely）**测试应及时编写。单元测试应该恰好在使其通过的生产代码之前编写。如果在编写生产代码之后编写测试，你会发现生产代码难以测试。你可能会认为某些生产代码本身难以测试。你可能不会去设计可测试的代码。</li></ul><h1 id="ch10-classes类"><a class="markdownIt-Anchor" href="#ch10-classes类"></a> Ch10 Classes(类)</h1><h2 id="101-class-organization类的组织"><a class="markdownIt-Anchor" href="#101-class-organization类的组织"></a> 10.1 Class Organization(类的组织)</h2><p>遵循标准的Java约定，类应该从一组变量列表开始。如果有公共静态常量，应该先出现。然后是私有静态变量，以及私有实体变量。很少会有公共变量。公共函数应跟在变量列表之后。我们喜欢把由某个公共函数调用的私有工具函数紧随在该公共函数后面。这符合了自顶向下原则，让程序读起来就像一篇报纸文章。</p><h2 id="102-class-should-be-small类应该短小"><a class="markdownIt-Anchor" href="#102-class-should-be-small类应该短小"></a> 10.2 Class Should Be Small!(类应该短小)</h2><p>对于函数，我们通过计算代码行数衡量大小。对于类，我们采用不同的衡量方法，计算权责（responsibility）。</p><ol><li><p>单一权责原则：一个类应该只有一个发生变化的原因。</p></li><li><p>内聚：</p><ul><li>类应该只有少量实体变量。类中的每个方法都应该操作一个或多个这种变量。通常而言，方法操作的变量越多，就越黏聚到类上。如果一个类中的每个变量都被每个方法所使用，则该类具有最大的内聚性。</li><li>一般来说，创建这种极大化内聚类是既不可取也不可能的；另一方面，我们希望内聚性保持在较高位置。内聚性高，意味着类中的方法和变量互相依赖、互相结合成一个逻辑整体。</li></ul></li><li><p>保持内聚性就会得到许多短小的类</p></li></ol><h2 id="103-organizing-for-change为了修改而组织"><a class="markdownIt-Anchor" href="#103-organizing-for-change为了修改而组织"></a> 10.3 Organizing for Change(为了修改而组织)</h2><blockquote><p>依赖倒置原则(DIP)：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。</p></blockquote><p>DIP认为类应当依赖于抽象而不是依赖于具体细节。</p><h1 id="ch11-systems系统"><a class="markdownIt-Anchor" href="#ch11-systems系统"></a> * Ch11 Systems(系统)</h1><h2 id="111-separate-constructing-a-system-from-using-it将系统的构造与使用分开"><a class="markdownIt-Anchor" href="#111-separate-constructing-a-system-from-using-it将系统的构造与使用分开"></a> 11.1 Separate Constructing a System from Using It(将系统的构造与使用分开)</h2><ol><li>分解main</li><li>工厂</li><li>依赖注入</li></ol><h2 id="112-scaling-up扩容"><a class="markdownIt-Anchor" href="#112-scaling-up扩容"></a> 11.2 Scaling Up(扩容)</h2><h2 id="113-java-proxiesjava代理"><a class="markdownIt-Anchor" href="#113-java-proxiesjava代理"></a> 11.3 Java Proxies(Java代理)</h2><h2 id="114-pure-java-aop-frameworks纯java-aop框架"><a class="markdownIt-Anchor" href="#114-pure-java-aop-frameworks纯java-aop框架"></a> 11.4 Pure Java AOP Frameworks(纯Java AOP框架)</h2><h2 id="115-aspectj-aspectsaspectj的方面"><a class="markdownIt-Anchor" href="#115-aspectj-aspectsaspectj的方面"></a> 11.5 AspectJ Aspects(AspectJ的方面)</h2><h2 id="116-test-drive-the-system-architecture测试驱动系统框架"><a class="markdownIt-Anchor" href="#116-test-drive-the-system-architecture测试驱动系统框架"></a> 11.6 Test Drive the System Architecture(测试驱动系统框架)</h2><h2 id="117-optimize-decision-making优化决策"><a class="markdownIt-Anchor" href="#117-optimize-decision-making优化决策"></a> 11.7 Optimize Decision Making(优化决策)</h2><h1 id="ch12-emergence迭进"><a class="markdownIt-Anchor" href="#ch12-emergence迭进"></a> Ch12 Emergence(迭进)</h1><p>Kent Beck关于简单设计的四条规则：</p><ol><li>运行所有测试；</li><li>不可重复；</li><li>表达了程序员的意图；</li><li>尽可能减少类和方法的数量；</li></ol><p>以上规则按其重要程度排列。</p><h1 id="ch13-concurrency并发编程"><a class="markdownIt-Anchor" href="#ch13-concurrency并发编程"></a> * Ch13 Concurrency(并发编程)</h1><blockquote><p>“对象是过程的抽象。线程是调度的抽象。”   一James O Coplien</p></blockquote><h2 id="131-并发防御原则"><a class="markdownIt-Anchor" href="#131-并发防御原则"></a> 13.1 并发防御原则</h2><ol><li>单一权责原则：分离并发相关代码与其他代码</li><li>限制数据作用域：谨记数据封装；严格限制对可能被共享的数据的访问。</li><li>使用数据副本</li><li>线程尽可能独立：尝试将数据分解到可被独立线程（可能在不同处理器上）操作的独立子集。</li></ol><h1 id="ch14-successive-refinement逐步改进"><a class="markdownIt-Anchor" href="#ch14-successive-refinement逐步改进"></a> Ch14 Successive Refinement(逐步改进)</h1><h1 id="ch15-junit-internalsjunit内幕"><a class="markdownIt-Anchor" href="#ch15-junit-internalsjunit内幕"></a> * Ch15 JUnit Internals(JUnit内幕)</h1><h1 id="ch16-refactoring-serialdate重构-serialdate"><a class="markdownIt-Anchor" href="#ch16-refactoring-serialdate重构-serialdate"></a> * Ch16 Refactoring SerialDate(重构 SerialDate)</h1><h1 id="ch17-smells-and-heuristics味道与启发"><a class="markdownIt-Anchor" href="#ch17-smells-and-heuristics味道与启发"></a> * Ch17 Smells and Heuristics(味道与启发)</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="阅读" scheme="https://Dragonliu2018.github.io/categories/阅读/"/>
    
    
    <category term="IT书籍" scheme="https://Dragonliu2018.github.io/tags/IT书籍/"/>
    
    <category term="重构" scheme="https://Dragonliu2018.github.io/tags/重构/"/>
    
  </entry>
  
  <entry>
    <title>2021年华为C++后端实习名词积累</title>
    <link href="https://dragonliu2018.github.io/2022/04/15/2021%E5%B9%B4%E5%8D%8E%E4%B8%BAC++%E5%90%8E%E7%AB%AF%E5%AE%9E%E4%B9%A0%E5%90%8D%E8%AF%8D%E7%A7%AF%E7%B4%AF/"/>
    <id>https://dragonliu2018.github.io/2022/04/15/2021%E5%B9%B4%E5%8D%8E%E4%B8%BAC++%E5%90%8E%E7%AB%AF%E5%AE%9E%E4%B9%A0%E5%90%8D%E8%AF%8D%E7%A7%AF%E7%B4%AF/</id>
    <published>2022-04-15T06:55:14.000Z</published>
    <updated>2022-04-18T16:11:58.367Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-perl语言"><a class="markdownIt-Anchor" href="#1-perl语言"></a> 1 Perl语言</h1><p>本次实习主要成果：基于SR的全量/增量覆盖率统计。</p><p>部门之前的该部分脚本是使用Perl语言编写的，晦涩难懂，没有维护人员。</p><p><a href="https://www.runoob.com/perl/perl-intro.html" target="_blank" rel="noopener">菜鸟教程——Perl语言教程</a></p><h1 id="2-ut-it-st"><a class="markdownIt-Anchor" href="#2-ut-it-st"></a> 2 UT &amp; IT &amp; ST</h1><h2 id="21-utunit-test单元测试"><a class="markdownIt-Anchor" href="#21-utunit-test单元测试"></a> 2.1 UT（Unit Test）：单元测试</h2><img src="https://s2.loli.net/2022/04/15/zqP8duipHcGLo9A.png" width="800" height="450" alt="图片名称" align="center" id="142"><img src="https://s2.loli.net/2022/04/15/1rNEqOydYzTGlM8.png" width="800" height="450" alt="图片名称" align="center" id="143"><h2 id="22-itintegration-test集成测试"><a class="markdownIt-Anchor" href="#22-itintegration-test集成测试"></a> 2.2 IT（Integration Test）：集成测试</h2><h2 id="23-stsystem-test系统测试"><a class="markdownIt-Anchor" href="#23-stsystem-test系统测试"></a> 2.3 ST（System Test）：系统测试</h2><img src="https://s2.loli.net/2022/04/15/Pqu6ZcTo3V12Aki.png" width="800" height="450" alt="图片名称" align="center" id="144"><h1 id="3-dtdevelpor-test开发者测试"><a class="markdownIt-Anchor" href="#3-dtdevelpor-test开发者测试"></a> 3 DT（Develpor Test）：开发者测试</h1><img src="https://s2.loli.net/2022/04/15/LiBpyJIXtcT7Ehx.png" width="800" height="450" alt="图片名称" align="center" id="145"><img src="https://s2.loli.net/2022/04/15/iYqjF5adrbM64yP.png" width="800" height="450" alt="图片名称" align="center" id="146"><img src="https://s2.loli.net/2022/04/15/oOHX4u95I8UabyE.png" width="800" height="450" alt="图片名称" align="center" id="147"><p><strong>参考</strong>：</p><ul><li><a href="https://developer.huaweiuniversity.com/courses/course-v1:HuaweiX+20210203+Self-paced/courseware/25e635447c474515909fd984d075dee7/5bfcf9c7a1dc4f3b8c0d78038bd21e36/" target="_blank" rel="noopener">华为课程学习</a></li><li><a href="https://xie.infoq.cn/article/126ff8488cd203a65a60d9643" target="_blank" rel="noopener">开发者测试：你必须知道 7 件事</a></li></ul><h1 id="4-tddtest-driven-development测试驱动开发"><a class="markdownIt-Anchor" href="#4-tddtest-driven-development测试驱动开发"></a> 4 TDD（Test-Driven Development）：测试驱动开发</h1><p>测试驱动开发，在开发功能代码之前，先编写单元测试用例代码，测试代码确定需要编写什么产品代码。</p><h1 id="5-cleancode"><a class="markdownIt-Anchor" href="#5-cleancode"></a> 5 cleancode</h1><blockquote><p>详见博客<code>《代码整洁之道 clean code》笔记</code></p></blockquote><p>软件工程领域的大师级人物罗伯特·马丁(Robert C. Martin)所著的一本重量级经典图书《Clean Code》，中文译为代码整洁之道，书中提出代码质量与其整洁度成正比。 比如编程要遵守一些原则；命名、注释、函数。</p><p><strong>参考</strong>：<a href="https://blog.csdn.net/nkGavinGuo/article/details/103752914" target="_blank" rel="noopener">浅谈Clean Code</a></p><h1 id="6-sr-ar"><a class="markdownIt-Anchor" href="#6-sr-ar"></a> 6 SR &amp; AR</h1><ul><li><strong>IR（Initial Requirement）</strong>：初始需求</li><li><strong>SR（System Requirement）</strong>：系统需要</li><li><strong>AR（Allocation Requirement）</strong>：配置需求</li><li><strong>SA（System Analyst）</strong>：系统分析师，</li><li><strong>SE（System Engineer）</strong>：系统工程师</li><li><strong>MDE（Module Design Engineer）</strong>：模块设计师，当SE把不同模块之间的接口大致画清晰后，模块内部的设计交给MDE来进行；<a href="https://blog.csdn.net/isscollege/article/details/75022142" target="_blank" rel="noopener">敏捷之MDE认知</a></li><li><strong>User Story</strong>：用户故事； <a href="http://www.woshipm.com/user-research/1725827.html" target="_blank" rel="noopener">用户故事（一）：什么是用户故事？</a></li></ul><img src="https://s2.loli.net/2022/04/15/fJ74SagOE6NRM8e.png" width="800" height="450" alt="图片名称" align="center" id="148"><p><strong>步骤</strong>：</p><ol><li><p><strong>需求经理</strong>：将用户需求（user story）转换成 客户能够接受的 初始需求 IR（Initial Requirement）</p></li><li><p><strong>SA</strong>：IR 拆分为 SR</p></li><li><p><strong>SE</strong>：SR 继续拆分 AR</p></li><li><p><strong>MDE</strong>：当SE把不同模块之间的接口大致画清晰后，模块内部的设计交给MDE来进行；</p></li></ol><p><strong>参考</strong>：<a href="https://blog.csdn.net/minminzhe520/article/details/52164752" target="_blank" rel="noopener">我从华为身上学到的项目管理经验 – 需求篇</a></p><h1 id="7-敏捷开发"><a class="markdownIt-Anchor" href="#7-敏捷开发"></a> 7 敏捷开发</h1><p>敏捷开发是一种项目管理和软件开发的迭代方法，侧重于协作、客户反馈和快速发布。</p><p>敏捷开发以用户的需求进化为核心，采用迭代、循序渐进的方法进行软件开发，适用于竞争激烈，快速变化的市场。敏捷的客户协作观念，快速迭代能帮助团队以最小成本，最快速度满足客户真正的需求。</p><p>其特点：“个体与交互”胜过“过程与工具”、“可以工作的软件”胜过“面面俱到的文挡”、“客户协作”胜过“合同谈判”、“响应变化”胜过“遵循计划”。</p><p>敏捷开发迭代流程一般遵循以下五个步骤：需求分析（requirements analysis）、产品设计（design）、功能编码（coding）、功能测试（testing）、部署评估（deployment / evaluation）。流程图如下：</p><img src="https://s2.loli.net/2022/04/15/qWpRhD3SQ7NltMX.png" width="800" height="450" alt="图片名称" align="center" id="149"><p><strong>参考</strong>：<a href="https://kknews.cc/news/5r38jvl.html" target="_blank" rel="noopener">四種軟體開發模式（瀑布、疊代、螺旋、敏捷），對比分析</a></p><h1 id="8-持续集成"><a class="markdownIt-Anchor" href="#8-持续集成"></a> 8 持续集成</h1><p>持续集成是一种软件开发实践，即团队开发成员经常集成他们的工作，通常每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。</p><p>实习部门使用Jenkins自动化部署， Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。</p><h1 id="9-devops"><a class="markdownIt-Anchor" href="#9-devops"></a> 9 DevOps</h1><p>DevOps（Development和Operations的组合词）是一种重视“软件开发人员（Dev）”和“IT运维技术人员（Ops）”之间沟通合作的文化、运动或惯例。通过自动化“软件交付”和“架构变更”的流程，来使得构建、测试、发布软件能够更加地快捷、频繁和可靠。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="未分类" scheme="https://Dragonliu2018.github.io/categories/未分类/"/>
    
    
  </entry>
  
  <entry>
    <title>i南航自动打卡</title>
    <link href="https://dragonliu2018.github.io/2022/04/13/i%E5%8D%97%E8%88%AA%E8%87%AA%E5%8A%A8%E6%89%93%E5%8D%A1/"/>
    <id>https://dragonliu2018.github.io/2022/04/13/i%E5%8D%97%E8%88%AA%E8%87%AA%E5%8A%A8%E6%89%93%E5%8D%A1/</id>
    <published>2022-04-13T04:17:36.000Z</published>
    <updated>2022-04-18T16:12:49.836Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-引言"><a class="markdownIt-Anchor" href="#1-引言"></a> 1 引言</h1><p><strong>需求</strong>：每天的i南航打卡比较难受，想自动化处理此事。</p><p><strong>声明</strong>：学习与技术讨论，勿实操！！！</p><p><strong>其他</strong>：目前在使用<code>2.1 IOS系统</code>的方法实现自动打卡</p><h1 id="2-解决"><a class="markdownIt-Anchor" href="#2-解决"></a> 2 解决</h1><h2 id="21-ios系统"><a class="markdownIt-Anchor" href="#21-ios系统"></a> 2.1  IOS系统</h2><p>iPhone和iPad可以使用快捷指令，体验感较好。</p><p>But最近i南航签到界面增加了字段，目前（2022年4月13日）打卡虽然可以成功，但是健康码是黄色的。快捷指令的作者当前未更新，自己不会改。🥦</p><p>(2022年4月14日)打卡恢复正常。</p><ul><li><p><a href="https://blog.cvvv.me/posts/a67c.html" target="_blank" rel="noopener">博客教程：使用快捷指令自动进行i·南航健康打卡</a></p></li><li><p><a href="https://www.bilibili.com/video/BV1CY41137Af" target="_blank" rel="noopener">B站教程：【南航】【i南航打卡】iOS/iPadOS快捷指令i南航自动打卡教程</a></p></li></ul><h2 id="22-linux客户机或服务器"><a class="markdownIt-Anchor" href="#22-linux客户机或服务器"></a> 2.2 Linux客户机或服务器</h2><p>wood的项目：<a href="https://github.com/Wood1314/inuaa" target="_blank" rel="noopener">i南航校外自动打卡小工具</a></p><h2 id="23-windows待完成"><a class="markdownIt-Anchor" href="#23-windows待完成"></a> 2.3 Windows（待完成）</h2><p>上面wood的项目是通过Linux服务器运行脚本，邮件通知提醒打卡成功。</p><p>对脚本稍作修改，迁移到Windows上来，实现定时运行脚本+Windows自带的消息通知。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="未分类" scheme="https://Dragonliu2018.github.io/categories/未分类/"/>
    
    
    <category term="待补充" scheme="https://Dragonliu2018.github.io/tags/待补充/"/>
    
  </entry>
  
  <entry>
    <title>git操作手册</title>
    <link href="https://dragonliu2018.github.io/2022/04/13/git%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/"/>
    <id>https://dragonliu2018.github.io/2022/04/13/git%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/</id>
    <published>2022-04-13T02:17:22.000Z</published>
    <updated>2022-04-18T15:52:00.464Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-命令"><a class="markdownIt-Anchor" href="#1-命令"></a> 1 命令</h1><ul><li>show-log</li><li>show-diff</li><li>pull：大致上 git pull = git fetch + git merge</li><li>commit</li><li>push</li><li>rebase：可以对某一段线性提交历史进行编辑、删除、复制、粘贴 <a href="https://www.yiibai.com/git/git_rebase.html" target="_blank" rel="noopener">git rebase命令</a></li><li>delete（rm）</li><li>revert</li><li>新建本地分支</li><li>推到远程分支</li><li>切分支</li><li>cherry-pick</li><li>解冲突</li><li>.gitignore</li></ul><h1 id="2-举例"><a class="markdownIt-Anchor" href="#2-举例"></a> 2 举例</h1><h2 id="21-对方更新过代码然后自己也需要上传新增文件"><a class="markdownIt-Anchor" href="#21-对方更新过代码然后自己也需要上传新增文件"></a> 2.1 对方更新过代码，然后自己也需要上传新增文件</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拉下更新代码</span></span><br><span class="line">git pull</span><br><span class="line">git pull origin master:master</span><br><span class="line"><span class="comment"># 详细的。。。</span></span><br><span class="line">git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br><span class="line"><span class="comment"># 新增文件</span></span><br><span class="line">···</span><br><span class="line"><span class="comment"># 将所有新增文件添加到暂存区</span></span><br><span class="line">git add .</span><br><span class="line"><span class="comment"># 将暂存区内容添加到本地仓库中</span></span><br><span class="line">git commit -m <span class="string">"注释"</span></span><br><span class="line"><span class="comment"># 从将本地的分支版本上传到远程并合并</span></span><br><span class="line">git push</span><br><span class="line">git push origin master:master</span><br><span class="line"><span class="comment"># 详细的。。。</span></span><br><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt; <span class="comment"># 如果本地分支名与远程分支名相同，则可以省略冒号</span></span><br></pre></td></tr></table></figure><h2 id="22-贡献自己的代码"><a class="markdownIt-Anchor" href="#22-贡献自己的代码"></a> 2.2 贡献自己的代码</h2><p><strong>commit-&gt;pull-&gt;push-&gt;MR</strong></p><p><strong>冲突：resolved-&gt;修改（edited）-&gt;完成（resolved）</strong></p><h1 id="x-参考"><a class="markdownIt-Anchor" href="#x-参考"></a> X 参考</h1><ul><li><a href="https://www.runoob.com/git/git-tutorial.html" target="_blank" rel="noopener">菜鸟教程——git</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="环境与工具" scheme="https://Dragonliu2018.github.io/categories/环境与工具/"/>
    
    
    <category term="Git" scheme="https://Dragonliu2018.github.io/tags/Git/"/>
    
    <category term="待补充" scheme="https://Dragonliu2018.github.io/tags/待补充/"/>
    
  </entry>
  
  <entry>
    <title>Linux操作手册</title>
    <link href="https://dragonliu2018.github.io/2022/04/13/Linux%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/"/>
    <id>https://dragonliu2018.github.io/2022/04/13/Linux%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/</id>
    <published>2022-04-13T02:14:47.000Z</published>
    <updated>2022-04-13T04:08:07.035Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-命令"><a class="markdownIt-Anchor" href="#1-命令"></a> 1 命令</h1><h2 id="11-基本"><a class="markdownIt-Anchor" href="#11-基本"></a> 1.1 基本</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">touch file <span class="comment">#创建文件</span></span><br><span class="line">mkdir dir <span class="comment">#新建目录</span></span><br><span class="line">cp -r src target <span class="comment">#复制文件(夹)</span></span><br><span class="line">rm -rf dir <span class="comment">#强制删除文件(夹)</span></span><br><span class="line">mv src target <span class="comment">#移动或重命名文件(夹)</span></span><br><span class="line"><span class="built_in">cd</span> <span class="comment">#切换目录</span></span><br><span class="line"><span class="built_in">pwd</span> <span class="comment">#查看当前目录</span></span><br><span class="line">man &lt;command_name&gt; <span class="comment">#获得某个命令的说明和使用方式的详细介绍</span></span><br><span class="line">who am i <span class="comment">#查看用户</span></span><br><span class="line">su &lt;user&gt; <span class="comment">#可以切换到用户 user</span></span><br><span class="line">su - &lt;user&gt; <span class="comment">#切换用户，但是同时用户的环境变量和工作目录也会跟着改变成目标用户所对应的</span></span><br><span class="line">sudo adduser &lt;user&gt; <span class="comment">#新建用户</span></span><br><span class="line">groups &lt;user&gt; <span class="comment">#查看自己属于的用户组</span></span><br><span class="line">sudo usermod -G sudo &lt;user&gt; <span class="comment">#将用户添加到sudo用户组</span></span><br><span class="line">sudo deluser &lt;user&gt; --remove-home <span class="comment">#删除用户，参数是在删除用户时候会一并将该用户的工作目录一并删除</span></span><br><span class="line">sudo groupdel &lt;group&gt; <span class="comment">#删除用户组，倘若该群组中仍包括某些用户，则必须先删除这些用户后，才能删除群组</span></span><br><span class="line"><span class="comment"># 修改权限</span></span><br><span class="line">chmod 777 file <span class="comment">#读写执行rwx二进制位数分别是210，文件有三组固定的权限，拥有者，所属用户组，其他用户</span></span><br><span class="line">chmod gou-rw file <span class="comment">#g(group用户组)、o(others其他用户)、u(user用户)，+ - 表示增加和去掉相应的权限</span></span><br><span class="line">file &lt;file&gt; <span class="comment">#查看文件类型</span></span><br><span class="line"><span class="comment">#查看文件</span></span><br><span class="line">cat -n file <span class="comment">#参数是显示行号</span></span><br><span class="line">nl -b a file <span class="comment">#与上面一样</span></span><br><span class="line">nl -b t file <span class="comment">#只列出非空行，默认</span></span><br><span class="line">head/tail -n 1 file <span class="comment">#只看文件首部尾部一行</span></span><br><span class="line">head/tail -f file <span class="comment">#这个参数可以实现不停地读取某个文件的内容并显示，实现实时监视</span></span><br></pre></td></tr></table></figure><h2 id="12-压缩解压"><a class="markdownIt-Anchor" href="#12-压缩解压"></a> 1.2 压缩/解压</h2><h3 id="121-gzip"><a class="markdownIt-Anchor" href="#121-gzip"></a> 1.2.1 gzip</h3><ul><li><p>压缩后的格式为：*.gz</p></li><li><p>这种压缩方式不能保存原文件；且不能压缩目录</p></li><li><p>命令举例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">压缩</span></span><br><span class="line">gzip file</span><br><span class="line"><span class="meta">#</span><span class="bash">解压</span></span><br><span class="line">gunzip file.gz</span><br></pre></td></tr></table></figure></li></ul><h3 id="122-tar"><a class="markdownIt-Anchor" href="#122-tar"></a> 1.2.2 tar</h3><ul><li><p>命令选项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-z(gzip)      用gzip来压缩/解压缩文件</span><br><span class="line">-j(bzip2)     用bzip2来压缩/解压缩文件</span><br><span class="line">-v(verbose)   详细报告tar处理的文件信息</span><br><span class="line">-c(create)    创建新的档案文件</span><br><span class="line">-x(extract)   解压缩文件或目录</span><br><span class="line">-f(file)      使用档案文件或设备，这个选项通常是必选的。</span><br></pre></td></tr></table></figure></li><li><p>命令举例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">压缩</span></span><br><span class="line">tar -zvcf file.tar.gz file</span><br><span class="line">tar -jvcf file.tar.bz2 file</span><br><span class="line"><span class="meta">#</span><span class="bash">解压</span></span><br><span class="line">tar -zvxf file.tar.gz </span><br><span class="line">tar -jvxf file.tar.bz2</span><br></pre></td></tr></table></figure></li></ul><h3 id="123-zip"><a class="markdownIt-Anchor" href="#123-zip"></a> 1.2.3 zip</h3><ul><li><p>与gzip相比：1）可以压缩目录； 2）可以保留原文件</p></li><li><p>命令选项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-r(recursive)    递归压缩目录内的所有文件和目录</span><br></pre></td></tr></table></figure></li><li><p>命令举例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">压缩</span></span><br><span class="line">zip -r dir.zip dir</span><br><span class="line"><span class="meta">#</span><span class="bash">解压</span></span><br><span class="line">unzip dir.zip</span><br></pre></td></tr></table></figure></li></ul><h1 id="2-快捷键"><a class="markdownIt-Anchor" href="#2-快捷键"></a> 2 快捷键</h1><table><thead><tr><th style="text-align:center">按键</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>Ctrl+c</code></td><td style="text-align:center">强行终止当前程序</td></tr><tr><td style="text-align:center"><code>Ctrl+z</code></td><td style="text-align:center">将当前程序放到后台运行，恢复到前台为命令<code>fg</code></td></tr><tr><td style="text-align:center"><code>Ctrl+a</code></td><td style="text-align:center">将光标移至输入行头，相当于<code>Home</code>键</td></tr><tr><td style="text-align:center"><code>Ctrl+e</code></td><td style="text-align:center">将光标移至输入行末，相当于<code>End</code>键</td></tr><tr><td style="text-align:center"><code>Ctrl+k</code></td><td style="text-align:center">删除从光标所在位置到行末</td></tr><tr><td style="text-align:center"><code>Alt+Backspace</code></td><td style="text-align:center">向前删除一个单词</td></tr><tr><td style="text-align:center"><code>Shift+PgUp</code></td><td style="text-align:center">将终端显示向上滚动</td></tr><tr><td style="text-align:center"><code>Shift+PgDn</code></td><td style="text-align:center">将终端显示向下滚动</td></tr></tbody></table><h1 id="3-通配符"><a class="markdownIt-Anchor" href="#3-通配符"></a> 3 通配符</h1><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center"><code>*</code></td><td style="text-align:center">匹配 0 或多个字符</td></tr><tr><td style="text-align:center"><code>?</code></td><td style="text-align:center">匹配任意一个字符</td></tr><tr><td style="text-align:center"><code>[list]</code></td><td style="text-align:center">匹配 list 中的任意单一字符</td></tr><tr><td style="text-align:center"><code>[^list]</code></td><td style="text-align:center">匹配 除 list 中的任意单一字符以外的字符</td></tr><tr><td style="text-align:center"><code>[c1-c2]</code></td><td style="text-align:center">匹配 c1-c2 中的任意单一字符 如：[0-9][a-z]</td></tr><tr><td style="text-align:center"><code>{string1,string2,...}</code></td><td style="text-align:center">匹配 string1 或 string2 (或更多)其一字符串</td></tr><tr><td style="text-align:center"><code>{c1..c2}</code></td><td style="text-align:center">匹配 c1-c2 中全部字符 如{1…10}</td></tr></tbody></table><h1 id="4-目录结构"><a class="markdownIt-Anchor" href="#4-目录结构"></a> 4 目录结构</h1><img src="https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/4-1.png">]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="环境与工具" scheme="https://Dragonliu2018.github.io/categories/环境与工具/"/>
    
    
  </entry>
  
  <entry>
    <title>vim操作手册</title>
    <link href="https://dragonliu2018.github.io/2022/04/13/vim%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/"/>
    <id>https://dragonliu2018.github.io/2022/04/13/vim%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/</id>
    <published>2022-04-13T02:10:21.000Z</published>
    <updated>2022-04-18T11:28:44.158Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-删除"><a class="markdownIt-Anchor" href="#1-删除"></a> 1 删除</h1><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">指令</th></tr></thead><tbody><tr><td style="text-align:center">删除某一行</td><td style="text-align:center">在VIM的命令模式下，使用<code>dd</code>，即可删除光标所在的行</td></tr><tr><td style="text-align:center">删除多行</td><td style="text-align:center">比如要删除8-17行，在VIM模式下，输入<code>:8,17d</code>，即可将8-17行全部删除，<strong>行号从1开始</strong></td></tr><tr><td style="text-align:center">删除全部内容</td><td style="text-align:center">在VIM的命令模式下，<code>ggdG</code></td></tr><tr><td style="text-align:center">误删后恢复</td><td style="text-align:center">在VIM命令模式下，输入<code>u</code>（与<code>u</code>相反的操作 <code>Ctrl+r</code>）</td></tr></tbody></table><h1 id="2-复制与粘贴"><a class="markdownIt-Anchor" href="#2-复制与粘贴"></a> 2 复制与粘贴</h1><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">指令</th></tr></thead><tbody><tr><td style="text-align:center">单行复制</td><td style="text-align:center">在光标的位置按<code>yy</code>，复制当前行； 然后再光标的行按<code>p</code>粘贴到下一行，原来的往下顺移</td></tr><tr><td style="text-align:center">多行复制</td><td style="text-align:center">在命令模式下，将光标移动到将要复制的首行处，按<code>nyy</code>复制标所在的向下n行(其中n为1、2、3…)</td></tr><tr><td style="text-align:center">粘贴</td><td style="text-align:center"><code>p</code>为将已经复制的数据在光标下一行粘贴；<code>P</code>为将已经复制的数据在光标上一行粘贴</td></tr></tbody></table><h1 id="3-查找"><a class="markdownIt-Anchor" href="#3-查找"></a> 3 查找</h1><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">指令</th></tr></thead><tbody><tr><td style="text-align:center"><code>/word</code></td><td style="text-align:center">在文件中查找内容为word的字符串（向下查找）</td></tr><tr><td style="text-align:center"><code>?word</code></td><td style="text-align:center">在文件中查找内容为word的字符串（向上查找）</td></tr><tr><td style="text-align:center"><code>n</code></td><td style="text-align:center">（先按<code>Enter</code>）表示重复查找动作，即查找下一个</td></tr><tr><td style="text-align:center"><code>N</code></td><td style="text-align:center">（先按<code>Enter</code>）反向查找下一个</td></tr></tbody></table><h1 id="5-跳到指定行"><a class="markdownIt-Anchor" href="#5-跳到指定行"></a> 5 跳到指定行</h1><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">指令</th></tr></thead><tbody><tr><td style="text-align:center">跳到第12行</td><td style="text-align:center">在VIM命令模式下，输入 <code>:12</code></td></tr><tr><td style="text-align:center">跳到最后一行</td><td style="text-align:center">在VIM命令模式下，输入 <code>G</code></td></tr><tr><td style="text-align:center">跳到最后一个字符</td><td style="text-align:center">在VIM命令模式下，输入 <code>G</code> ，之后按<code>$</code></td></tr><tr><td style="text-align:center">跳到第一行</td><td style="text-align:center">在VIM命令模式下，输入 <code>gg</code></td></tr></tbody></table><h1 id="6-替换"><a class="markdownIt-Anchor" href="#6-替换"></a> 6 替换</h1><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">指令</th></tr></thead><tbody><tr><td style="text-align:center"><code>:%s/s1/s2/</code></td><td style="text-align:center">用字符串s2替换每行的第一个字符串s1</td></tr><tr><td style="text-align:center"><code>:%s/s1/s2/g</code></td><td style="text-align:center">用字符串s2替换每行的所有字符串s1</td></tr></tbody></table><h1 id="7-显示行号"><a class="markdownIt-Anchor" href="#7-显示行号"></a> 7 显示行号</h1><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">指令</th></tr></thead><tbody><tr><td style="text-align:center">显示行号</td><td style="text-align:center">在VIM命令模式下，输入<code>:set nu</code></td></tr><tr><td style="text-align:center">取消显示行号</td><td style="text-align:center">在VIM命令模式下，输入<code>:set nonu</code></td></tr></tbody></table><h1 id="8-其他"><a class="markdownIt-Anchor" href="#8-其他"></a> 8 其他</h1><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">指令</th></tr></thead><tbody><tr><td style="text-align:center">ctrl+s卡住</td><td style="text-align:center"><code>ctrl+q</code> 解除卡住</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><h1 id="x-参考"><a class="markdownIt-Anchor" href="#x-参考"></a> X 参考</h1><ul><li>比较全的手册：<a href="https://www.cnblogs.com/h-c-g/p/11122899.html" target="_blank" rel="noopener">Vim复制一整行和复制多行</a></li><li><a href="https://blog.csdn.net/qiulinsama/article/details/88073663" target="_blank" rel="noopener">vi vim 字符串替换</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="环境与工具" scheme="https://Dragonliu2018.github.io/categories/环境与工具/"/>
    
    
  </entry>
  
  <entry>
    <title>selenium爬虫教程</title>
    <link href="https://dragonliu2018.github.io/2022/04/11/selenium%E7%88%AC%E8%99%AB%E6%95%99%E7%A8%8B/"/>
    <id>https://dragonliu2018.github.io/2022/04/11/selenium%E7%88%AC%E8%99%AB%E6%95%99%E7%A8%8B/</id>
    <published>2022-04-11T02:59:25.000Z</published>
    <updated>2022-04-18T16:13:53.085Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-简介"><a class="markdownIt-Anchor" href="#1-简介"></a> 1 简介</h1><p>Selenium最初是一个自动化测试工具，Selenium可以驱动浏览器自动执行自定义好的逻辑代码，即通过代码完全模拟使用浏览器自动访问目标站点并操作，所以也可以用来爬虫。</p><p>本次教程使用<code>Python3.9.9</code>，谷歌浏览器<code>版本 100.0.4896.75（正式版本） （64 位）</code>：</p><img src="https://s2.loli.net/2022/04/11/ShGQJUO7mYHkVKi.png" width="700" height="300" alt="图片名称" align="center" id="135"><h1 id="2-安装"><a class="markdownIt-Anchor" href="#2-安装"></a> 2 安装</h1><ol><li><p>安装selenium：<code>pip install selenium</code></p></li><li><p>安装谷歌浏览器驱动，版本要与上面的浏览器版本对应（版本不一定完全一致，尽量一致），<a href="https://chromedriver.chromium.org/downloads" target="_blank" rel="noopener">驱动下载链接</a></p><img src="https://s2.loli.net/2022/04/11/ZYPEVz83DrwC2m1.png" width="700" height="300" alt="图片名称" align="center" id="136"></li><li><p>将下载好的驱动文件解压后放到python安装路径下，使其生效：</p><img src="https://s2.loli.net/2022/04/11/Aom1YZhTpqMeVfQ.png" width="700" height="300" alt="图片名称" align="center" id="137"></li></ol><h1 id="3-样例"><a class="markdownIt-Anchor" href="#3-样例"></a> 3 样例</h1><p><strong>爬取百度搜索结果</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置浏览器</span></span><br><span class="line">co = webdriver.ChromeOptions()</span><br><span class="line">co.headless = <span class="literal">False</span></span><br><span class="line">browser = webdriver.Chrome(options=co)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开指定url</span></span><br><span class="line">browser.implicitly_wait(<span class="number">30</span>)</span><br><span class="line">url = <span class="string">'https://www.baidu.com'</span></span><br><span class="line">browser.get(url)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定位操作</span></span><br><span class="line">browser.find_element(by=By.ID, value=<span class="string">'kw'</span>).send_keys(<span class="string">"python"</span>)  <span class="comment"># 输入框</span></span><br><span class="line">browser.find_element(by=By.ID, value=<span class="string">'su'</span>).click()  <span class="comment"># 点击搜索按钮</span></span><br><span class="line">elements = browser.find_elements(by=By.CLASS_NAME, value=<span class="string">'c-container'</span>)  <span class="comment"># 查找到所有c-container类</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> elements:</span><br><span class="line">    span = element.find_element(by=By.TAG_NAME, value=<span class="string">'a'</span>)</span><br><span class="line">    print(span.text)</span><br><span class="line">    <span class="comment"># print(span.get_attribute('innerHTML'))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 爬取完毕，退出浏览器</span></span><br><span class="line">sleep(<span class="number">2</span>)</span><br><span class="line">browser.quit()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><hr><p><strong>代码解读</strong>：</p><ol><li><p>配置浏览器，当<code>co.headless = False</code>时候有界面化（默认）；当<code>co.headless = True</code>时为无头浏览器，也就是无界面化浏览器。</p></li><li><p>百度服务器响应存在延迟，所以很可能造成接下来的代码执行失败，因此执行 <code>browser.implicitly_wait(30)</code>。这样如果找不到元素，每隔<strong>半秒钟</strong>再去界面上查看一次， 直到找到该元素， 或者过了<code>30</code>秒最大时长。</p></li><li><p>利用chrome的f12开查找搜索框和搜索按钮的id：</p><img src="https://s2.loli.net/2022/04/11/lKTLUdZaOfH2SsD.png" width="800" height="300" alt="图片名称" align="center" id="138"><p>根据ID定位有两种写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">browser.find_element_by_id(<span class="string">'kw'</span>)  <span class="comment"># 已废弃</span></span><br><span class="line">browser.find_element(by=By.ID, <span class="string">'kw'</span>)  <span class="comment"># 推荐</span></span><br></pre></td></tr></table></figure><p>第一种写法会报warning：<a href="https://blog.csdn.net/qq_45007567/article/details/120829410" target="_blank" rel="noopener">selenium弃用警告DeprecationWarning</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DeprecationWarning: find_element_by_* commands are deprecated. Please use find_element() instead</span><br><span class="line">  browser.find_element_by_id(<span class="string">'kw'</span>).send_keys(<span class="string">"python"</span>)  <span class="comment"># 输入框</span></span><br></pre></td></tr></table></figure><p><code>send_keys()</code>方法可以在对应的元素中输入字符串；<code>click()</code>方法是点击该元素。</p></li><li><p><code>find_elements()</code>返回的是找到的符合条件的<strong>所有</strong>元素，放在一个<strong>列表</strong>中返回；<code>find_element()</code>只会返回<strong>第一个</strong>元素。</p></li></ol><h1 id="4-定位元素"><a class="markdownIt-Anchor" href="#4-定位元素"></a> 4 定位元素</h1><p><code>find_elements()</code>返回的是找到的符合条件的<strong>所有</strong>元素，放在一个<strong>列表</strong>中返回；<code>find_element()</code>只会返回<strong>第一个</strong>元素。</p><h2 id="41-id"><a class="markdownIt-Anchor" href="#41-id"></a> 4.1 id</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"coolestWidgetEvah"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element = driver.find_element(by=By.ID, value=<span class="string">"coolestWidgetEvah"</span>)</span><br></pre></td></tr></table></figure><h2 id="42-class-name"><a class="markdownIt-Anchor" href="#42-class-name"></a> 4.2 class name</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"cheese"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>Cheddar<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"cheese"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>Gouda<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cheeses = driver.find_elements(By.CLASS_NAME, <span class="string">"cheese"</span>)</span><br></pre></td></tr></table></figure><h2 id="43-tag-name"><a class="markdownIt-Anchor" href="#43-tag-name"></a> 4.3 tag name</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"..."</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frame = driver.find_element(By.TAG_NAME, <span class="string">"iframe"</span>)</span><br></pre></td></tr></table></figure><h2 id="44-name"><a class="markdownIt-Anchor" href="#44-name"></a> 4.4 name</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"cheese"</span> <span class="attr">type</span>=<span class="string">"text"</span>/&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cheese = driver.find_element(By.NAME, <span class="string">"cheese"</span>)</span><br></pre></td></tr></table></figure><h2 id="45-link-text"><a class="markdownIt-Anchor" href="#45-link-text"></a> 4.5 link text</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.google.com/search?q=cheese"</span>&gt;</span>cheese<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cheese = driver.find_element(By.PARTIAL_LINK_TEXT, <span class="string">"cheese"</span>)</span><br></pre></td></tr></table></figure><h2 id="46-partial-link-text"><a class="markdownIt-Anchor" href="#46-partial-link-text"></a> 4.6 Partial Link Text</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.google.com/search?q=cheese"</span>&gt;</span>search for cheese<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cheese = driver.find_element(By.PARTIAL_LINK_TEXT, <span class="string">"cheese"</span>)</span><br></pre></td></tr></table></figure><h2 id="47-css-selector"><a class="markdownIt-Anchor" href="#47-css-selector"></a> 4.7 css selector</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"food"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"dairy"</span>&gt;</span>milk<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"dairy aged"</span>&gt;</span>cheese<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2022/04/11/Ph9O4gL1FSVA2D3.png" width="800" height="300" alt="图片名称" align="center" id="139"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cheese = driver.find_element(By.CSS_SELECTOR, <span class="string">"#food span.dairy.aged"</span>)</span><br></pre></td></tr></table></figure><h2 id="48-xpath"><a class="markdownIt-Anchor" href="#48-xpath"></a> 4.8 xpath</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"example"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"other"</span> /&gt;</span></span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2022/04/11/rvxGgYde3ANzWoF.png" width="800" height="300" alt="图片名称" align="center" id="140"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inputs = driver.find_elements(By.XPATH, <span class="string">"//input"</span>)</span><br></pre></td></tr></table></figure><h1 id="5-鼠标动作链"><a class="markdownIt-Anchor" href="#5-鼠标动作链"></a> 5 鼠标动作链</h1><p>有些时候，我们需要再页面上模拟一些鼠标操作，比如双击、右击、拖拽甚至按住不动等，我们可以通过导入 <code>ActionChains</code> 类来做到：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#导入 ActionChains 类</span></span><br><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> ActionChains</span><br><span class="line"></span><br><span class="line"><span class="comment"># 鼠标移动到 ac 位置</span></span><br><span class="line">ac = driver.find_element_by_xpath(<span class="string">'element'</span>)</span><br><span class="line">ActionChains(driver).move_to_element(ac).perform()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 ac 位置单击</span></span><br><span class="line">ac = driver.find_element_by_xpath(<span class="string">"elementA"</span>)</span><br><span class="line">ActionChains(driver).move_to_element(ac).click(ac).perform()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 ac 位置双击</span></span><br><span class="line">ac = driver.find_element_by_xpath(<span class="string">"elementB"</span>)</span><br><span class="line">ActionChains(driver).move_to_element(ac).double_click(ac).perform()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 ac 位置右击</span></span><br><span class="line">ac = driver.find_element_by_xpath(<span class="string">"elementC"</span>)</span><br><span class="line">ActionChains(driver).move_to_element(ac).context_click(ac).perform()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 ac 位置左键单击hold住</span></span><br><span class="line">ac = driver.find_element_by_xpath(<span class="string">'elementF'</span>)</span><br><span class="line">ActionChains(driver).move_to_element(ac).click_and_hold(ac).perform()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 ac1 拖拽到 ac2 位置</span></span><br><span class="line">ac1 = driver.find_element_by_xpath(<span class="string">'elementD'</span>)</span><br><span class="line">ac2 = driver.find_element_by_xpath(<span class="string">'elementE'</span>)</span><br><span class="line">ActionChains(driver).drag_and_drop(ac1, ac2).perform()</span><br></pre></td></tr></table></figure><h1 id="6-页面等待"><a class="markdownIt-Anchor" href="#6-页面等待"></a> 6 页面等待</h1><p>现在的网页越来越多采用了 Ajax 技术，这样程序便不能确定何时某个元素完全加载出来了。如果实际页面等待时间过长导致某个dom元素还没出来，但是你的代码直接使用了这个WebElement，那么就会抛出NullPointer的异常。</p><p>为了避免这种元素定位困难而且会提高产生 ElementNotVisibleException 的概率。所以 Selenium 提供了两种等待方式，一种是隐式等待，一种是显式等待。</p><p>隐式等待是等待特定的时间，显式等待是指定某一条件直到这个条件成立时继续执行。</p><h2 id="61-显式等待"><a class="markdownIt-Anchor" href="#61-显式等待"></a> 6.1 显式等待</h2><p>显式等待指定某个条件，然后设置最长等待时间。如果在这个时间还没有找到元素，那么便会抛出异常了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="comment"># WebDriverWait 库，负责循环等待</span></span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="comment"># expected_conditions 类，负责条件出发</span></span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.get(<span class="string">"http://www.xxxxx.com/loading"</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 页面一直循环，直到 id="myDynamicElement" 出现</span></span><br><span class="line">    element = WebDriverWait(driver, <span class="number">10</span>).until(</span><br><span class="line">        EC.presence_of_element_located((By.ID, <span class="string">"myDynamicElement"</span>))</span><br><span class="line">    )</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    driver.quit()</span><br></pre></td></tr></table></figure><p>如果不写参数，程序默认会 0.5s 调用一次来查看元素是否已经生成，如果本来元素就是存在的，那么会立即返回。</p><p>下面是一些内置的等待条件，你可以直接调用这些条件，而不用自己写某些等待条件了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">title_is</span><br><span class="line">title_contains</span><br><span class="line">presence_of_element_located</span><br><span class="line">visibility_of_element_located</span><br><span class="line">visibility_of</span><br><span class="line">presence_of_all_elements_located</span><br><span class="line">text_to_be_present_in_element</span><br><span class="line">text_to_be_present_in_element_value</span><br><span class="line">frame_to_be_available_and_switch_to_it</span><br><span class="line">invisibility_of_element_located</span><br><span class="line">element_to_be_clickable – it <span class="keyword">is</span> Displayed <span class="keyword">and</span> Enabled.</span><br><span class="line">staleness_of</span><br><span class="line">element_to_be_selected</span><br><span class="line">element_located_to_be_selected</span><br><span class="line">element_selection_state_to_be</span><br><span class="line">element_located_selection_state_to_be</span><br><span class="line">alert_is_present</span><br></pre></td></tr></table></figure><h2 id="62-隐式等待"><a class="markdownIt-Anchor" href="#62-隐式等待"></a> 6.2 隐式等待</h2><p>隐式等待比较简单，就是简单地设置一个等待时间，单位为秒。当然如果不设置，默认等待时间为0。</p><p>上面的样例就使用的这种等待方式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.implicitly_wait(<span class="number">10</span>) <span class="comment"># seconds</span></span><br><span class="line">driver.get(<span class="string">"http://www.xxxxx.com/loading"</span>)</span><br><span class="line">myDynamicElement = driver.find_element_by_id(<span class="string">"myDynamicElement"</span>)</span><br></pre></td></tr></table></figure><h1 id="x-参考"><a class="markdownIt-Anchor" href="#x-参考"></a> X 参考</h1><ul><li><a href="https://www.yiibai.com/selenium/selenium-basic-terminology.html" target="_blank" rel="noopener">Selenium教程</a></li><li><a href="https://zhuanlan.zhihu.com/p/366773104" target="_blank" rel="noopener">Python 爬虫进阶篇——Selenium教程（一）</a></li><li><a href="https://www.jianshu.com/p/6c82c965c014" target="_blank" rel="noopener">简书-selenium教程</a></li><li><a href="https://yuaneuro.cn/archives/3.html" target="_blank" rel="noopener">python用selenium爬取百度搜索结果</a></li><li><a href="https://zhuanlan.zhihu.com/p/88152781" target="_blank" rel="noopener">python爬虫之selenium模拟浏览器</a></li><li><a href="https://zhuanlan.zhihu.com/p/111859925" target="_blank" rel="noopener">Selenium Python 教程</a></li><li><a href="https://blog.csdn.net/langdei/article/details/102883424" target="_blank" rel="noopener">python 爬虫（九）selenium常用方法总结</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="爬虫" scheme="https://Dragonliu2018.github.io/categories/爬虫/"/>
    
    
    <category term="selenium" scheme="https://Dragonliu2018.github.io/tags/selenium/"/>
    
    <category term="待补充" scheme="https://Dragonliu2018.github.io/tags/待补充/"/>
    
  </entry>
  
  <entry>
    <title>Dukou网站自动化签到</title>
    <link href="https://dragonliu2018.github.io/2022/04/10/Dukou%E7%BD%91%E7%AB%99%E8%87%AA%E5%8A%A8%E5%8C%96%E7%AD%BE%E5%88%B0/"/>
    <id>https://dragonliu2018.github.io/2022/04/10/Dukou%E7%BD%91%E7%AB%99%E8%87%AA%E5%8A%A8%E5%8C%96%E7%AD%BE%E5%88%B0/</id>
    <published>2022-04-10T02:47:26.000Z</published>
    <updated>2022-04-18T11:30:09.097Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-问题需求"><a class="markdownIt-Anchor" href="#1-问题需求"></a> 1 问题需求</h1><p>登陆Dukou网站，点击签到按钮，每天执行此操作。</p><h1 id="2-解决"><a class="markdownIt-Anchor" href="#2-解决"></a> 2 解决</h1><p>解决方法有两个：</p><ol><li>利用selenium编写浏览器爬虫，模拟执行操作；然后利用Windows自带的<code>任务计划程序</code>实现定时执行爬虫；</li><li>编写ios快捷指令</li></ol><h2 id="21-windows自动执行"><a class="markdownIt-Anchor" href="#21-windows自动执行"></a> 2.1 Windows自动执行</h2><h3 id="211-爬虫脚本"><a class="markdownIt-Anchor" href="#211-爬虫脚本"></a> 2.1.1 爬虫脚本</h3><p><strong>参考</strong>：<a href="https://yuaneuro.cn/archives/3.html" target="_blank" rel="noopener">python用selenium爬取百度搜索结果</a></p><p><strong>dukou_sign_in.py</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dukou_sign</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 无头浏览器设置</span></span><br><span class="line">    co = webdriver.ChromeOptions()</span><br><span class="line">    co.headless = <span class="literal">False</span></span><br><span class="line">    browser = webdriver.Chrome(options=co)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 登陆</span></span><br><span class="line">    browser.implicitly_wait(<span class="number">20</span>)  <span class="comment"># 如果找不到元素，每隔半秒钟再去界面上查看一次， 直到找到该元素， 或者过了20秒最大时长。</span></span><br><span class="line">    url = <span class="string">'https://dukou.icu/user/index'</span>  <span class="comment"># 目标网站</span></span><br><span class="line">    browser.get(url)</span><br><span class="line">    sleep(<span class="number">5</span>)</span><br><span class="line">    username = <span class="string">"xxx"</span>  <span class="comment"># dukou用户名</span></span><br><span class="line">    password = <span class="string">"xxx"</span>  <span class="comment"># dukou密码</span></span><br><span class="line">    browser.find_element(by=By.ID, value=<span class="string">"email"</span>).send_keys(username)  <span class="comment"># 输入框</span></span><br><span class="line">    browser.find_element(by=By.ID, value=<span class="string">"passwd"</span>).send_keys(password)  <span class="comment">#</span></span><br><span class="line">    browser.find_element(by=By.XPATH, value=<span class="string">'//*[@id="formLogin"]/div[3]/div/div/span/button'</span>).click()  <span class="comment"># 点击登陆按钮</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 进行签到</span></span><br><span class="line">    sleep(<span class="number">5</span>)</span><br><span class="line">    browser.find_element(by=By.XPATH, value=<span class="string">'//*[@id="app"]/section/section/main/div/div[2]/div/div/div/div[2]/div[3]'</span></span><br><span class="line">                                            <span class="string">'/div/div/button[1]'</span>).click()  <span class="comment"># 点击签到</span></span><br><span class="line">    <span class="comment"># 停止爬虫</span></span><br><span class="line">    browser.quit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    dukou_sign()</span><br></pre></td></tr></table></figure><hr><p>selenium打开指定URL后，需要登陆：</p><img src="https://s2.loli.net/2022/04/10/bLCpikNS1GY3unM.png" width="600" height="400" alt="图片名称" align="center" id="127"><p>在此页面按F12，找到对应输入框的<code>id</code></p><img src="https://s2.loli.net/2022/04/10/toCgMNPVl6ExiJj.png" width="800" height="300" alt="图片名称" align="center" id="128"><p>然后通过ID定位element，并发送对应内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">browser.find_element(by=By.ID, value=<span class="string">"email"</span>).send_keys(username)</span><br><span class="line">browser.find_element(by=By.ID, value=<span class="string">"passwd"</span>).send_keys(password)</span><br></pre></td></tr></table></figure><p>下一步点击<code>确定</code>按钮，通过XPATH定位element，并进行点击：</p><img src="https://s2.loli.net/2022/04/10/rhKxLbaFgdlpI6W.png" width="800" height="300" alt="图片名称" align="center" id="129"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">browser.find_element(by=By.XPATH, value=<span class="string">'//*[@id="formLogin"]/div[3]/div/div/span/button'</span>).click()</span><br></pre></td></tr></table></figure><p>登陆后，点击<code>签到</code>按钮与上面点击<code>确定</code>按钮类似：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">browser.find_element(by=By.XPATH, value=<span class="string">'//*[@id="app"]/section/section/main/div/div[2]/div/div/div/div[2]/div[3]'</span></span><br><span class="line">                                            <span class="string">'/div/div/button[1]'</span>).click()  <span class="comment"># 点击签到</span></span><br></pre></td></tr></table></figure><h3 id="212-消息通知脚本"><a class="markdownIt-Anchor" href="#212-消息通知脚本"></a> 2.1.2 消息通知脚本</h3><p>爬虫脚本执行完，需要消息提醒，提高体验。</p><p>通过 <strong>win10toast</strong> 实现在 Win10 系统中发送桌面消息通知，<a href="https://zhuanlan.zhihu.com/p/350300654" target="_blank" rel="noopener">参考</a></p><p>安装 win10toast：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install win10toast</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> win10toast <span class="keyword">import</span> ToastNotifier</span><br><span class="line"></span><br><span class="line">toaster = ToastNotifier()</span><br><span class="line">toaster.show_toast(<span class="string">"Dukou自动签到"</span>,</span><br><span class="line">                   <span class="string">"签到成功！"</span>,</span><br><span class="line">                   icon_path=<span class="string">"./img/dukou.ico"</span>,</span><br><span class="line">                   duration=<span class="number">60</span>*<span class="number">60</span>*<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>但是这种方法发送的消息会在一定的时间内消失（由参数<code>duration</code>指定，单位是秒），不会在<code>管理通知</code>中保存；如果将参数<code>duration</code>改的足够大，消息可以&quot;永存&quot;，但是后台会持续运行该程序，不太理想。</p><p>下面的程序解决了上面的问题，参考<a href="https://github.com/jithurjacob/Windows-10-Toast-Notifications/issues/76" target="_blank" rel="noopener">how to storage notifications into Action center</a></p><p><strong>dukou_notice.py</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> winrt.windows.ui.notifications <span class="keyword">import</span> ToastNotificationManager, ToastNotification</span><br><span class="line"><span class="keyword">import</span> winrt.windows.data.xml.dom <span class="keyword">as</span> dom</span><br><span class="line"></span><br><span class="line">notifier = ToastNotificationManager.create_toast_notifier(<span class="string">r'D:\developer\Python\python399\python.exe'</span>)  <span class="comment"># python程序路径</span></span><br><span class="line"></span><br><span class="line">title = <span class="string">"Dukou自动签到"</span></span><br><span class="line">desp = <span class="string">"签到成功！"</span></span><br><span class="line">tString = <span class="string">"""&lt;toast duration='short'&gt;&lt;audio src  = 'ms-winsoundevent:Notification.Reminder' loop = 'false' silent = 'false'/&gt;&lt;visual&gt;&lt;binding template='ToastText02'&gt;&lt;text id="1"&gt;"""</span> + title + <span class="string">"""&lt;/text&gt;&lt;text id="2"&gt;"""</span> + desp + <span class="string">"""&lt;/text&gt;&lt;/binding&gt;&lt;/visual&gt;&lt;/toast&gt;"""</span></span><br><span class="line"></span><br><span class="line">xDoc = dom.XmlDocument()</span><br><span class="line">xDoc.load_xml(tString)</span><br><span class="line">notifier.show(ToastNotification(xDoc))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：<code>dukou_notice.py</code> 脚本不能与 <code>dukou_sign_in.py</code> 脚本合在一个文件内，否则会报错：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_winrt.init_apartment()</span><br><span class="line">RuntimeError: 无法在设置线程模式后对其加以更改。</span><br></pre></td></tr></table></figure><h3 id="213-定时执行脚本"><a class="markdownIt-Anchor" href="#213-定时执行脚本"></a> 2.1.3 定时执行脚本</h3><p>使用Windows自带的<code>任务计划程序</code>实现定时执行脚本，具体参考 <a href="https://blog.csdn.net/Icesteam/article/details/112328159" target="_blank" rel="noopener">Window自带的定时自动执行程序</a></p><ol><li><p>在Windows搜索框输入<code>任务计划程序</code>找到这个软件并打开；</p></li><li><p>点击<code>创建任务</code>：</p><img src="https://s2.loli.net/2022/04/10/XfGe4wvulnDd8gV.png" width="800" height="300" alt="图片名称" align="center" id="130"></li><li><p><code>常规</code>部分，填写<code>名称</code>，勾选<code>不管用户是否登录都要运行</code>以及 <code>使用最高权限运行</code> ：</p><img src="https://s2.loli.net/2022/04/10/l7CUeAj9sc3BkTr.png" width="500" height="400" alt="图片名称" align="center" id="131"></li><li><p><code>触发器</code>部分，选择合适的触发条件：</p><img src="https://s2.loli.net/2022/04/10/l4YJQbhWKopZd2e.png" width="500" height="400" alt="图片名称" align="center" id="132"></li><li><p><code>操作</code>部分，这里运行的程序或者脚本，最好直接选择个bat来执行（bat名称和路径分开放），执行exe有时候会出错，bat里设置的是要执行的Python脚本（bat与python脚本同目录下）：</p><img src="https://s2.loli.net/2022/04/10/ZadxHV2C8P4bS5L.png" width="500" height="400" alt="图片名称" align="center" id="133"><p><strong>dukou.bat</strong>：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python dukou_sign_in.py</span><br><span class="line">python dukou_notice.py</span><br></pre></td></tr></table></figure></li><li><p><code>条件</code>和<code>设置</code>部分默认即可，然后点击确定即可，前端界面已经出现了设置的任务：</p><img src="https://s2.loli.net/2022/04/10/i64vxcqGRu7C1Kl.png" width="1000" height="100" alt="图片名称" align="center" id="134"></li><li><p>到此已经完成问题需求。</p></li></ol><h2 id="22-ios快捷指令未实现"><a class="markdownIt-Anchor" href="#22-ios快捷指令未实现"></a> 2.2 ios快捷指令（未实现）</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="爬虫" scheme="https://Dragonliu2018.github.io/categories/爬虫/"/>
    
    
    <category term="selenium" scheme="https://Dragonliu2018.github.io/tags/selenium/"/>
    
  </entry>
  
</feed>
