<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dragon Liu</title>
  
  
  <link href="https://dragonliu2018.github.io/atom.xml" rel="self"/>
  
  <link href="https://dragonliu2018.github.io/"/>
  <updated>2021-07-28T05:36:10.000Z</updated>
  <id>https://dragonliu2018.github.io/</id>
  
  <author>
    <name>Dragon Liu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>专业英语</title>
    <link href="https://dragonliu2018.github.io/2021/07/25/%E4%B8%93%E4%B8%9A%E8%8B%B1%E8%AF%AD/"/>
    <id>https://dragonliu2018.github.io/2021/07/25/%E4%B8%93%E4%B8%9A%E8%8B%B1%E8%AF%AD/</id>
    <published>2021-07-25T06:45:20.000Z</published>
    <updated>2021-07-28T05:36:10.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h1><p>Good afternoon, teachers. I’m Liu Zhenlong a rising Junior at Nanjing University of Aeronautics and Astronautics majoring in information security. Next, I’ll introduce myself from the following aspects: professional learning and competitions.</p><p>In the first five semesters, I ranked first of 101 students in the same grade. Moreover, I have received many academic honors, such as National Scholarship,  National Encouragement scholarship, Pacemaker to Merit Student, and many other scholarships.</p><p>At the same time, I took part in many competitions and won many honors. It’s worth mentioning that I won the national second prize in the CUMCM competition.</p><p>That’s all. Thank you.</p><hr><p>各位老师下午好，我是刘振龙，来自南京航空航天大学计算机科学与技术学院/人工智能学院信息安全专业的一名大三学生。下面我将从专业学习和竞赛两方面介绍自己。专业学习方面，前五个学期绩点排名专业第一，曾获国家奖学金、国家励志奖学金、校级三好学生标兵等学业荣誉。竞赛方面，在去年的数模国赛中获得二等奖，本人负责代码编写模块；软件杯国赛三等奖、天梯赛三等奖。好的，我的介绍到此结束。</p><h1 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h1><h2 id="Project"><a href="#Project" class="headerlink" title="Project"></a>Project</h2><p>In terms of project experience, one of my classmates and I once  developed a college physics experiment evaluation system, and Now it has been put into use in our school. Besides, in the last summer vacation，our team collaborated to develop a Big Data Project named Data Analysis Platform of Second-hand House Transaction in Beijing. And I was the leader of the seven-person team.</p><h2 id="数模国赛"><a href="#数模国赛" class="headerlink" title="数模国赛"></a>数模国赛</h2><p>CUMCM stands for Contemporary Undergraduate Mathematical Contest in Modeling. Our group chose  problem B named Crossing the desert. The tagert is to reach the end in the time frame and save as much money as possible.  Here’s the idea：<br>Step1：Build a graph<br>Step2：Use Dijkstra to find the shortest path<br>Step3：dynamic programming<br>Step4：Markov prediction<br>Step5：Add the healthy competition</p><p>去年的数模国赛，我们组选择了B题——穿越沙漠，背景取自《沙漠掘金》。游戏的目标是在规定时间内到达终点，并保留尽可能多的资金。题目有三个问题。第一个是天气情况已知，根据题目要求建图，使用dijk算法简化图，保留主要节点，使用动态规划递推。第二个仅知道当天天气情况，使用马尔可夫预测。第三个问题涉及多个游戏玩家，存在竞争关系，加入良性竞争对模型的影响。（目标函数有两个：个人利益最大化+游戏玩家间方差最小化）</p><h2 id="大数据项目"><a href="#大数据项目" class="headerlink" title="大数据项目"></a>大数据项目</h2><p>In the last summer vacation，our team developed a Big Data Project named Data Analysis Platform of Second-hand House Transaction in Beijing. And I was the leader of the seven-person team. The tagert is to show Second-hand House Transaction in beijing  . Here’s the idea:<br>Step1：data collection<br>Step2：data processing<br>Step3：data  Analysis<br>Step4：data visualization</p><p>消费者，房地产中介和政府来说，对二手房数据的分析研究来帮助用户更好的评估房产和预测未来走势</p><ol><li><p>数据收集：爬取二手房交易网站的数据</p></li><li><p>数据预处理：搭建Hadoop环境，将数据文件上传Hdfs，进行数据清洗等</p></li><li>数据分析：通过Hive进行数据分析，并利用Sqoop将结果导入Mysql</li><li>数据可视化：后端使用java、前端使用echarts模板等进行数据展示</li></ol><ul><li>Hadoop实现了一个分布式文件系统（ Distributed File System）<ul><li>HDFS为海量的数据提供了存储</li><li>而MapReduce则为海量的数据提供了计算</li></ul></li><li>hive是基于Hadoop的一个数据仓库工具，用来进行数据提取、转化、加载，将结构化的数据文件映射为一张数据库表，并提供SQL查询功能，能将SQL语句转变成MapReduce任务来执行。</li><li>Sqoop(发音：skup)是一款开源的工具，主要用于在Hadoop(Hive)与传统的数据库(mysql、postgresql…)间进行数据的传递，可以将一个关系型数据库（例如 ： MySQL ,Oracle ,Postgres等）中的数据导进到Hadoop的HDFS中，也可以将HDFS的数据导进到关系型数据库中。</li><li>spark是Hadoop MapReduce的通用并行框架，Spark，拥有Hadoop MapReduce所具有的优点；但不同于MapReduce的是——Job中间输出结果可以保存在内存中，从而不再需要读写HDFS，因此Spark能更好地适用于数据挖掘与机器学习等需要迭代的MapReduce的算法。</li></ul><h2 id="APT"><a href="#APT" class="headerlink" title="APT"></a>APT</h2><p>基于知识图谱的网络威胁情报与态势感知系统</p><p>收集情报信息，转成固定文件格式（cve转stix2.1）、构建知识图谱、态势感知系统（攻击击检测、威胁分析）</p><p>收集数据cve，完成格式转化</p><p>模拟攻击fin6：攻击生命周期包括初步入侵，建立立足点，提升特权，内部侦察与横向运动等 </p><p>检测：</p><ul><li>Windows：借助微软的sysmon 进行日志收集 ，检测；通过恶意文件得hash等文件特征进行检测；</li><li>Linux：用 FaceBook 开源监控工具 osquery 进行日志收集  </li></ul><h1 id="专业英语"><a href="#专业英语" class="headerlink" title="专业英语"></a>专业英语</h1><h2 id="科目"><a href="#科目" class="headerlink" title="科目"></a>科目</h2><ul><li>data structure. Through this course, I learn many common data structures, such as list、stack、queue、Binery tree、graph,  and learn many common algorithms, such as patition、quick sort、dijsktra、prim、topological-sort. It can be used in other subjects, such as network、operating system and so on.</li><li>dynamic programming: divide a large problem into smaller subproblems and solve the subproblems</li><li>The divide and conquer algorithm： divide a large problem into smaller subproblems and solve the subproblems</li><li>greedy algorithm algorithm：select the optimal solution in the current state  </li><li>quick sort: Fisrt, partition, select a pivot, and divide the whole array into 2 subarrays. Second, recursion.</li><li>Banker’s Algorithm: is a well-known Algorithm for avoiding Deadlock. Determine whether the system is secure before allocating resources. If so, allocate.</li></ul><h1 id="常见话题"><a href="#常见话题" class="headerlink" title="常见话题"></a>常见话题</h1><h2 id="Introduce-your-college（介绍你的大学）"><a href="#Introduce-your-college（介绍你的大学）" class="headerlink" title="Introduce your college（介绍你的大学）"></a>Introduce your college（介绍你的大学）</h2><p>My college is Nanjing University of Aeronautics and Astronautics. It was founded in October 1952. In 1996, it entered the national “211 Project” construction. </p><p>I major in information security, and it has a great learning environment .</p><h2 id="What-is-your-greatest-strength-weakness？（你的优势-弱势是什么）"><a href="#What-is-your-greatest-strength-weakness？（你的优势-弱势是什么）" class="headerlink" title="What is your greatest strength/weakness？（你的优势/弱势是什么）"></a>What is your greatest strength/weakness？（你的优势/弱势是什么）</h2><p>My greatest strength is perseverance. For example, I didn’t get  national scholarship in my first year at university.  I am not discouraged, but work harder on my major, take part in more professional competitions and win more hornoes. So, I got it in the next year.</p><p>In terms of my greatest weakness,  I’m an introvert and sometimes I notice that I am shy to share my ideas when there’s a room of people.</p><h2 id="Talk-about-your-hometown"><a href="#Talk-about-your-hometown" class="headerlink" title="Talk about your hometown"></a>Talk about your hometown</h2><p>I come from Weifang. I live in a small town with a harmony family.  Weifang is a city in the center of Shandong province. It is a historical city with well known figures. It is famous for paper cutting、kites and so on.</p><h2 id="Talk-about-your-family"><a href="#Talk-about-your-family" class="headerlink" title="Talk about your family"></a>Talk about your family</h2><p>There are five people in my family including my grandmother, my parents, my sister and myself.  My parents are both farmers and work hard to support this family. My sister is 14 years old, a junior high school student. Our family is in harmony and I really love my family.</p><h2 id="What-are-your-hobbies？"><a href="#What-are-your-hobbies？" class="headerlink" title="What are your hobbies？"></a>What are your hobbies？</h2><p>coding and sports. </p><p>In terms of coding, I take part in many competitions and develop many projects.</p><p>Sports such as runnig, playing basketball.</p><h2 id="关于提升等"><a href="#关于提升等" class="headerlink" title="关于提升等"></a>关于提升等</h2><p>In order to achieve the target, here’s the idea:<br>First, Chunk it up. Second, deliberte practicing. Finally, Feedbook.</p><p>Look for more opportunities to deliberte practicing. </p><h2 id="不会"><a href="#不会" class="headerlink" title="不会"></a>不会</h2><p>I’m sorry，could you repeat the question？</p><p>This is so hard for me to explain, sorry.</p><hr><h1 id="最近专业新闻"><a href="#最近专业新闻" class="headerlink" title="最近专业新闻"></a>最近专业新闻</h1><ul><li>sudo堆溢出高危漏洞</li><li>wifi漏洞</li><li>滴滴下架</li><li>推特，youtube，大佬的博客，吾爱破解，看雪论坛，安全客，军火库，知识星球</li></ul><h1 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h1><ul><li>握手定理：有n个人握手，每人握手x次，握手总次数为S= nx/2。在图论中的应用：由握手定理得图中所有结点的总度数(degree)之和为<a href="https://baike.baidu.com/item/偶数/403454" target="_blank" rel="noopener">偶数</a>。</li><li>点到空间直线的距离</li><li>空间直线间的距离：重合、相交、平行、异面（求解公垂线，过一条直线做一个面平行于另一条面）</li><li>线性方程组的可解不可解：<ul><li>有解的充分必要条件为向量 <img alt="[公式]" data-src="https://www.zhihu.com/equation?tex=%5Cbeta" class="lozad"> 可以表示成向量组<img alt="[公式]" data-src="https://www.zhihu.com/equation?tex=%5Calpha_%7B1%7D%2C+%5Calpha_%7B2%7D%2C+%5Ccdots%2C+%5Calpha_%7Bn%7D" class="lozad"> 的线性组合.</li><li>它的系数矩阵秩等于增广矩阵的秩</li><li>系数矩阵秩等于n，那么方程组有唯一解，如果A的秩小于n，那么方程组有无穷多个解</li><li>n元齐次线性方程组，有非零解的充分必要条件为：它的系数矩阵的秩小于未知量的个数n</li></ul></li><li>拉格朗日定理<ul><li>微积分中的拉格朗日中值定理；</li><li>数论中的四平方和定理；</li><li>群论中的拉格朗日定理 (群论)：设H是有限群G的子群，则H的阶整除G的阶。</li></ul></li><li>泊松分布：泊松分布的参数λ是单位时间(或单位面积)内随机事件的平均发生次数。 泊松分布适合于描述单位时间内随机事件发生的次数。泊松分布的期望和方差均为λ</li><li>A <em> B=B </em> A：<ul><li>设A , B 至少有一个为零矩阵,则A , B 可交换;</li><li>设A , B 至少有一个为单位矩阵, 则A , B可交换;</li><li>设A , B 至少有一个为数量矩阵, 则A , B可交换;</li><li>设A , B 均为对角矩阵,则A , B 可交换;</li><li>设A , B 均为准对角矩阵（准对角矩阵是分块矩阵概念下的一种矩阵。即除去主对角线上分块矩阵不为零矩阵外，其余分块矩阵均为零矩阵）,且对角线上的子块均可交换，则A , B 可交换;</li></ul></li><li>极大值什么时候等于最大值，在给定区间内,有且只有一个极值点,则极值等于最值; 实质为单峰函数</li><li>m维线性空间的定义</li><li>独立性和不相关的关系：独立性是指两个变量的发生概率一点关系没有，而相关性通常是指线性关系。如果两个变量不相关，指的是线性关系里不相关，但是不能说它们么有关系，可能是线性以外的其他关系。</li><li></li></ul><h1 id="专业"><a href="#专业" class="headerlink" title="专业"></a>专业</h1><ul><li><strong>物理层到应用层的安全策略</strong></li><li>排序<ul><li>m</li></ul></li><li>二层交换与路由器的关系   我擦！我感觉这个上课没讲过！！！然后就说我印象里老师没讲了。。          Q2: 输入一个网址后，用到的协议（大概这意思）  这个有点印象，先是DNS，然后是TCP, IP, ICMP, ARP什么的；老师就接着问“那ICMP协议是干什么用的”，我我我…懵了。。。就说好像是…给某台主机发报文，然后给个回应什么的。。。</li></ul><h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><ul><li><p>selenium爬虫</p><ul><li>通过访问频率识别爬虫：代理IP来保证效率，如飞鱼ip代理</li><li>在携带 cookie 的情况下，某个 IP 请求网站过于频繁。豆瓣的反爬虫机制变为只封 cookie 不封 IP。也就说退出登录或者换个账号还能继续访问网站。</li></ul></li><li><p>做项目遇到的困难</p></li><li>MVC</li><li><p>什么是耦合<br>耦合性(Coupling)，也叫耦合度，是对模块间关联程度的度量。耦合的强弱取决于模块间接口的复杂性、调用模块的方式以及通过界面传送数据的多少。模块间的耦合度是指模块之间的依赖关系，包括控制关系、调用关系、数据传递关系。模块间联系越多，其耦合性越强，同时表明其独立性越差( 降低耦合性，可以提高其独立性)。软件设计中通常用耦合度和内聚度作为衡量模块独立程度的标准。划分模块的一个准则就是高内聚低耦合。</p></li><li><p>设计模式</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="课程" scheme="https://Dragonliu2018.github.io/categories/课程/"/>
    
    
  </entry>
  
  <entry>
    <title>高数笔记</title>
    <link href="https://dragonliu2018.github.io/2021/07/25/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/"/>
    <id>https://dragonliu2018.github.io/2021/07/25/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/</id>
    <published>2021-07-25T05:51:41.000Z</published>
    <updated>2021-07-26T15:08:30.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="第1章-函数-极限-连续"><a href="#第1章-函数-极限-连续" class="headerlink" title="第1章 函数 极限 连续"></a>第1章 函数 极限 连续</h1><ol><li>数列的极限定义、收敛数列、发散数列</li><li>收敛数列的性质：唯一性、有界性、四则运算法则、保号性、保序性</li><li><strong>数列收敛与有界性的关系</strong>：收敛一定有界，有界不一定收敛（${(-1)^n}$）。</li><li>数列收敛的判别准则：夹逼准则、单调有界准则</li><li>函数极限、性质（唯一性、局部有界性、局部保号性、局部保序性、夹逼准则）</li><li><strong>两个重要极限</strong>：$\lim<em>{x\rightarrow0}\frac {\sin x}{x}=1 $、$\lim</em>{x\rightarrow\infty}(1+\frac 1 x)^x=e $</li><li>无穷小量、无穷大量、等价无穷小</li><li>连续与间断</li><li>闭区间上的连续函数的性质：最大值最小值定理、有界性定理、零点定理、界值定理</li><li><strong>一致连续性与连续</strong>：<ul><li>设函数 $f(x)$ 在区间I上有定义，如果 $\forall \varepsilon&gt;0, \exists \delta&gt;0$, 使得对于在区间I上的任意两点 $x<em>{1}, x</em>{2}$, 当 $\left|x<em>{1}-x</em>{2}\right|&lt;\delta$ 时 恒有 $\left|f\left(x<em>{1}\right)-f\left(x</em>{2}\right)\right|&lt;\varepsilon$, 则称函数 $f(x)$ 在区间I上一致连续。 </li><li>设函数 $f(x)$ 在区间I上有定义，如果 $\forall \varepsilon&gt;0, \exists \delta&gt;0$, 使得对于在区间I上的任意两点 $x<em>{1}, c$(定值), 当 $\left|x</em>{1}-c\right|&lt;\delta$ 时 恒有 $\left|f\left(x_{1}\right)-f\left(c\right)\right|&lt;\varepsilon$, 则称函数 $f(x)$ 在区间I上连续。 </li></ul></li></ol><h1 id="第2章-导数与微分"><a href="#第2章-导数与微分" class="headerlink" title="第2章 导数与微分"></a>第2章 导数与微分</h1><ol><li>导数、左右导数</li><li><strong>可导与连续的关系</strong>：可导必连续，连续未必可导（$f(x)=|x|$，在x=0处连续不可导）</li><li>六类基本初等函数的导数公式</li><li>微分</li><li><strong>可微与可导的关系</strong>：在一元函数中，函数$y=f(x)$在点$x_0$处可微与可导是等价的，并且$A=f’(x)$</li></ol><h1 id="第3章-微分学中值定理"><a href="#第3章-微分学中值定理" class="headerlink" title="第3章 微分学中值定理"></a>第3章 微分学中值定理</h1><ol><li>罗尔定理</li><li>拉格朗日定理</li><li>柯西定理</li><li>洛必达法则</li><li>泰勒公式</li></ol><h1 id="第4章-微分学应用"><a href="#第4章-微分学应用" class="headerlink" title="第4章 微分学应用"></a>第4章 微分学应用</h1><ol><li>函数的单调性、凹凸性、极值最值</li><li><strong>可导函数的极值点与驻点的关系</strong>：极值点一定是驻点，但是驻点不一定是极值点（$y=x^3$，x=0时）</li></ol><h1 id="第5章-不定积分"><a href="#第5章-不定积分" class="headerlink" title="第5章 不定积分"></a>第5章 不定积分</h1><ol><li>不定积分、性质</li><li>连续函数必定存在原函数</li><li>换元积分法、分部积分法</li></ol><h1 id="第6章-定积分"><a href="#第6章-定积分" class="headerlink" title="第6章 定积分"></a>第6章 定积分</h1><ol><li>定积分、存在条件、性质</li><li><strong>有界与函数可积的关系</strong>：可积一定有界，有界不一定可积（狄利克雷函数）</li><li>积分第一中值定理、积分中值定理</li><li>微积分基本公式</li></ol><h1 id="第7章-定积分的应用"><a href="#第7章-定积分的应用" class="headerlink" title="第7章 定积分的应用"></a>第7章 定积分的应用</h1><h1 id="第8章-向量代数与空间解析几何"><a href="#第8章-向量代数与空间解析几何" class="headerlink" title="第8章 向量代数与空间解析几何"></a>第8章 向量代数与空间解析几何</h1><ol><li>向量的数量积、向量的向量积、向量的混合积</li></ol><h1 id="第9章-多元函数微分学"><a href="#第9章-多元函数微分学" class="headerlink" title="第9章 多元函数微分学"></a>第9章 多元函数微分学</h1><ol><li>偏导数、全微分</li><li><strong>偏导数连续 -》可微 -》（连续 -》极限存在）、（可偏导）</strong></li></ol><h1 id="第10章-多元函数积分学"><a href="#第10章-多元函数积分学" class="headerlink" title="第10章 多元函数积分学"></a>第10章 多元函数积分学</h1><ol><li>二重积分</li></ol><h1 id="第11章-无穷级数"><a href="#第11章-无穷级数" class="headerlink" title="第11章 无穷级数"></a>第11章 无穷级数</h1><ol><li>级数、泰勒级数、傅里叶级数</li></ol><h1 id="第12章-常微分方程"><a href="#第12章-常微分方程" class="headerlink" title="第12章 常微分方程"></a>第12章 常微分方程</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="课程" scheme="https://Dragonliu2018.github.io/categories/课程/"/>
    
    
  </entry>
  
  <entry>
    <title>线性代数笔记</title>
    <link href="https://dragonliu2018.github.io/2021/07/25/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0/"/>
    <id>https://dragonliu2018.github.io/2021/07/25/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0/</id>
    <published>2021-07-25T05:51:30.000Z</published>
    <updated>2021-07-26T17:04:42.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Ch1-行列式与线性方程组的Gauss消元法"><a href="#Ch1-行列式与线性方程组的Gauss消元法" class="headerlink" title="Ch1 行列式与线性方程组的Gauss消元法"></a>Ch1 行列式与线性方程组的Gauss消元法</h1><ol><li>行列式</li><li>n阶排列、逆序数、奇偶排列</li><li>n阶行列式定义、上三角行列式、下三角行列式</li><li>n阶行列式的性质</li><li>余子式、代数余子式、n阶行列式的展开定理</li><li>Cramer法则，（非）齐次线性方程组的解与系数行列式的关系</li><li>Gauss消元法</li></ol><h1 id="Ch2-矩阵"><a href="#Ch2-矩阵" class="headerlink" title="Ch2 矩阵"></a>Ch2 矩阵</h1><ol><li>矩阵、增广矩阵、同型矩阵、矩阵相等</li><li>行矩阵和列矩阵、零矩阵、阶梯形矩阵、方阵、（上下）三角矩阵、对角矩阵、数量矩阵、单位矩阵</li><li>矩阵的运算：加法、数乘、乘法</li><li>矩阵的转置、对称矩阵、反对称矩阵</li><li>可逆矩阵、伴随矩阵、矩阵可逆的充要条件</li><li>分块矩阵</li><li>矩阵的初等变化、初等矩阵、矩阵等价</li><li>矩阵的秩：子矩阵、k阶子式、矩阵可逆与秩的关系、行（列）满秩矩阵</li></ol><h1 id="Ch3-n维向量与线性方程组解的结构"><a href="#Ch3-n维向量与线性方程组解的结构" class="headerlink" title="Ch3 n维向量与线性方程组解的结构"></a>Ch3 n维向量与线性方程组解的结构</h1><ol><li>向量的线性组合、线性表出、组合系数</li><li>线性表出与线性方程组有解互为充要条件</li><li>向量的线性相关与线性无关</li><li>线性相关的充要条件：齐次线性方程组有非零解、矩阵的秩&lt;s、矩阵的行列式=0、向量组内线性表出</li><li>线性无关的充要条件：齐次线性方程组只有零解、矩阵的秩=s、向量组内无法线性表出</li><li>向量组的秩：向量组等价、极大线性无关组、向量组的秩</li><li>向量组的秩等于它的列（行）向量组的秩</li><li>齐次线性方程组：<ul><li>有非零解的充要条件：$r(A)&lt;n$</li><li>只有零解则：$r(A)=n$</li></ul></li><li>非齐次线性方程组：<ul><li>有解的充要条件：系数矩阵的秩与增广矩阵的秩相等</li><li>唯一解的充要条件：两者等于n</li><li>无穷解的充要条件：两者小于n</li></ul></li></ol><h1 id="Ch4-线性空间和线性变换"><a href="#Ch4-线性空间和线性变换" class="headerlink" title="Ch4 线性空间和线性变换"></a>Ch4 线性空间和线性变换</h1><ol><li>线性空间、基、维数、正交矩阵</li><li>线性变化、正交变换</li></ol><h1 id="Ch5-相似矩阵与矩阵的对角化"><a href="#Ch5-相似矩阵与矩阵的对角化" class="headerlink" title="Ch5 相似矩阵与矩阵的对角化"></a>Ch5 相似矩阵与矩阵的对角化</h1><ol><li>特征值、特征向量、特征矩阵、特征多项式</li><li>相似矩阵、性质</li><li>矩阵的对角化：n阶矩阵A可以对角化的充要条件是A有n个线性无关的特征向量。</li></ol><h1 id="Ch6-二次型"><a href="#Ch6-二次型" class="headerlink" title="Ch6 二次型"></a>Ch6 二次型</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="课程" scheme="https://Dragonliu2018.github.io/categories/课程/"/>
    
    
  </entry>
  
  <entry>
    <title>离散数学笔记</title>
    <link href="https://dragonliu2018.github.io/2021/07/25/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://dragonliu2018.github.io/2021/07/25/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2021-07-25T04:03:12.000Z</published>
    <updated>2021-07-26T01:34:40.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><hr><h1 id="第1章-命题逻辑的基本概念"><a href="#第1章-命题逻辑的基本概念" class="headerlink" title="第1章 命题逻辑的基本概念"></a>第1章 命题逻辑的基本概念</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ol><li>判断给定句子是否为命题，应该分两步：首先判断它是否为陈述句，其次判断它是否有唯一的真值。</li><li>由真推出假，又由假能推出真，从而既不能为真，也不能为假的陈述句称作悖论，悖论不是命题。eg: 我正在说假话。</li><li>相容或与排斥或。</li><li>p$\rightarrow$q：p与q的蕴涵式。p$\rightarrow$q为假当且仅当p为真q为假。叙述方式：如果p，则q；只要p，就q；因为p，所以q；p仅当q；只有q才p；除非q才p；除非q，否则非p。</li><li>联结词集{$\neg$, $\bigwedge$, $\bigvee$, $\rightarrow$, $\leftrightarrow$}: 优先顺序为(), $\neg$, $\bigwedge$,  $\bigvee$, $\rightarrow$, $\leftrightarrow$; 对同一优先级，从左向右顺序进行。</li><li>给定n个命题变项，按照合式公式的形成规则，可以形成无穷个公式。其产生2<sup>n</sup>个不同的赋值，任何公式在每个赋值下只能去两个值(0，1)，真值表有$2^{2^n}$种情况，因而必有无穷多个公式具有相同的真值表。</li></ol><h2 id="题型汇总"><a href="#题型汇总" class="headerlink" title="题型汇总"></a>题型汇总</h2><ul><li><strong>命题符号化</strong></li><li><strong>求复合命题的真值与命题公式的赋值</strong></li><li><strong>判断公式的类型</strong></li><li><strong>复合命题符号化</strong></li></ul><hr><h1 id="第2章-命题逻辑等值演算"><a href="#第2章-命题逻辑等值演算" class="headerlink" title="第2章 命题逻辑等值演算"></a>第2章 命题逻辑等值演算</h1><h2 id="基础知识-1"><a href="#基础知识-1" class="headerlink" title="基础知识"></a>基础知识</h2><ol><li>$\Leftrightarrow$是元语言符号，用来说明A与B等值的一种记法，$\leftrightarrow$是联结符，也要注意与一般等号=的区别。</li><li><a href="https://wenku.baidu.com/view/61b8cb43a8956bec0975e346.html" target="_blank" rel="noopener">等值式模式</a>：双重否定律，幂等律，交换律，结合律，分配律，德摩根律，吸收律，零律，同一律，排中律，矛盾律，蕴涵等值式，等价等值式，假言易位，等价否定等值式，归谬论。</li><li>判断A$\Leftrightarrow$B是否成立的方法：<ul><li><strong>真值表法</strong>：判断A$\leftrightarrow$B是否是重言式</li><li><strong>观察法(求证$\not \Leftrightarrow$)</strong>：给出一个赋值使两个命题公式真值不同</li><li><strong>等值演算法</strong></li><li><strong>主范式</strong></li></ul></li><li>求公式A的主析取(合取范式)的方法和步骤：<ul><li><strong>等值演算法</strong><ol><li>消去联结词$\rightarrow$, $\leftrightarrow$；</li><li>否定联结词$\neg$的内移(德摩根律)或消去(双重否定律)；</li><li>使用分配律(求析取范式用$\bigwedge$对$\bigvee$的分配律，求析取范式用$\bigvee$对$\bigwedge$的分配律) -&gt; 已将A化为析取(合取范式)</li><li>将范式中不是极小项(极大项)的简单合取式(析取式)利用排中律、同一律、分配律化成若干个极小项(极大项)。</li><li>将极小项(极大项)用名称m<sub>i</sub>(M<sub>i</sub>)表示，使用幂等律，最后排序。</li></ol></li><li><strong>真值表法</strong><ol><li>写出A的真值表</li><li>找出A的成真赋值(成假赋值)</li><li>写出每个成真赋值(成假赋值)对应的极小项(极大项)，按角标从小到大析取(合取)</li></ol></li><li><strong>主析取合取互推</strong><ol><li>$\neg$m<sub>i</sub>$\Leftrightarrow$M<sub>i</sub></li><li>$\neg$M<sub>i</sub>$\Leftrightarrow$m<sub>i</sub></li></ol></li></ul></li><li>与非$\uparrow$、或非$\downarrow$：$\neg$p$\Leftrightarrow$p$\uparrow$p$\Leftrightarrow$p$\downarrow$p</li><li>{$\uparrow$},{$\downarrow$}都是联结词完备集。</li></ol><h2 id="题型汇总-1"><a href="#题型汇总-1" class="headerlink" title="题型汇总"></a>题型汇总</h2><ul><li><strong>用等值演算法证明重言式和矛盾式</strong>：A$\Leftrightarrow$1, A$\Leftrightarrow$0</li><li><strong>用等值演算法证明等值式</strong></li><li><strong>通过求公式的主析取范式(主合取范式)判断公式类型</strong></li><li><strong>通过求公式的主析取范式(主合取范式)判断两个公式是否等值</strong></li><li><strong>将已知的命题公式等值地化成给定联结词完备集上的公式</strong></li><li><strong>用等值演算等方法解决实际问题</strong></li><li>消去规则及其性质</li><li>消去序列与消去法</li></ul><hr><h1 id="第3章-命题逻辑的推理理论"><a href="#第3章-命题逻辑的推理理论" class="headerlink" title="第3章 命题逻辑的推理理论"></a>第3章 命题逻辑的推理理论</h1><h2 id="基础知识-2"><a href="#基础知识-2" class="headerlink" title="基础知识"></a>基础知识</h2><ol><li>判断推理是否正确的方法：<ul><li>真值表法</li><li>等值演算法</li><li>主析取范式法</li><li><strong><font color="#dd0000">推理定律</font></strong></li></ul></li><li><a href="https://wenku.baidu.com/view/61b8cb43a8956bec0975e346.html" target="_blank" rel="noopener">推理定律</a>：附加律、化简律、假言推理、拒取式、析取三段论、假言三段论、等价三段论、<em>构造性二难、构造性二难（特殊形式）、破坏性二难</em></li><li><strong>推理规则</strong>：前提引入规则、结论引入规则、置换规则、假言推理规则、附加规则、化简规则、拒取式规则、析取三段论规则、假言三段论规则、等价三段论规则、<em>构造性二难规则、破坏性二难规则</em>、合取引入规则</li><li>构造证明的方法：<ul><li>直接证明法</li><li>附加前提证明法</li><li>归谬证明法</li></ul></li></ol><h2 id="题型汇总-2"><a href="#题型汇总-2" class="headerlink" title="题型汇总"></a>题型汇总</h2><ul><li><strong>用等值演算法判断推理是否正确</strong></li><li><strong>用主析取范式法判断推理是否正确</strong></li><li><strong>在自然推理系统P中用直接证明法证明推理</strong></li><li><strong>在自然推理系统P中用附加前提证明法证明推理</strong></li><li><strong>在自然推理系统P中用归谬法证明推理</strong></li><li><strong>寻找给定前提的有效结论</strong></li><li>用消解证明法构造推理证明</li><li>在自然推理系统P中，构造用自然语言描述的推理</li></ul><hr><h1 id="第4章-一阶逻辑基本概念"><a href="#第4章-一阶逻辑基本概念" class="headerlink" title="第4章 一阶逻辑基本概念"></a>第4章 一阶逻辑基本概念</h1><h2 id="基础知识-3"><a href="#基础知识-3" class="headerlink" title="基础知识"></a>基础知识</h2><ol><li><p>一阶逻辑命题符号化</p><ul><li><strong>个体词</strong>：个体、个体常项、个体变项、个体域(论域)、有限个体域、无限个体域、全总个体域</li><li><strong>谓词</strong>：谓词常项、谓词变项、n元谓词、0元谓词</li><li><strong>量词</strong>：量词、全称量词($\forall$)、存在量词($\exists$)</li><li><strong>命题符号化</strong>：<ul><li>基本公式1：“对D中所有x而言，如果x有性质F，x就有性质G” $\forall$x(F(x)$\rightarrow$G(x))</li><li>基本公式2：“D中存在x既有性质F、又有性质G”  $\exists$x(F(x)$\bigwedge$G(x))</li><li>基本公式应用：“对D中所有x,y而言，若x有性质F，y有性质G，则x与y就有关系H”  $\forall$x$\forall$y(F(x)$\bigwedge$G(y)$\rightarrow$H(x,y))</li><li>基本公式应用：“对D中所有x而言，若x有性质F，就存在y有性质G，使得x与y就有关系H”$\forall$x(F(x)$\rightarrow$(G(y)$\bigwedge$H(x,y)))</li><li>基本公式应用：“D中存在x有性质F，并且对D中所有y而言，如果y有性质G,则x与y就有性质H”  $\exists$x(F(x)$\bigwedge$ $\forall$y(G(y)$\rightarrow$H(x,y)))</li></ul></li></ul></li><li><p>一阶逻辑公式及解释</p><ul><li><strong>一阶语言</strong>：由非逻辑符集合L生成的一阶语言的字母表(非逻辑符号、逻辑符号)，项，原子公式、合式公式(也称谓词公式，简称公式)</li><li><strong>量词的辖域</strong>：量词的辖域、指导变元、个体变项的自由出现与约束出现、闭式</li><li><strong>一阶语言的解释</strong>：解释、赋值、公式在解释I和I下的赋σ值下的解释</li><li><strong>公式的类型</strong>：永真式(逻辑有效式)、矛盾式(永假式)、可满足式、代换实例</li></ul></li></ol><h2 id="题型汇总-3"><a href="#题型汇总-3" class="headerlink" title="题型汇总"></a>题型汇总</h2><ul><li><strong>一阶逻辑命题符号化</strong></li><li><strong>在一阶逻辑中将简单的数学命题符号化</strong></li><li><strong>给定解释和赋值，解释给定公式</strong></li><li><strong>证明公式既不是永真式，也不是矛盾式</strong></li><li><strong>证明永真式、矛盾式</strong></li></ul><hr><h1 id="第5章-一阶逻辑等值演算与推理"><a href="#第5章-一阶逻辑等值演算与推理" class="headerlink" title="第5章 一阶逻辑等值演算与推理"></a>第5章 一阶逻辑等值演算与推理</h1><h2 id="基础知识-4"><a href="#基础知识-4" class="headerlink" title="基础知识"></a>基础知识</h2><ol><li>一阶逻辑等值式与置换规则<ul><li><strong>等值式</strong>：设A，B为一阶逻辑公式，若A$\leftrightarrow$B为永真式，则称A与B等值，记作A$\Leftrightarrow$B.</li><li><strong>基本的等值式</strong>：<ul><li><a href="https://wenku.baidu.com/view/61b8cb43a8956bec0975e346.html" target="_blank" rel="noopener">等值式模式</a>的代换实例</li><li><a href="https://wenku.baidu.com/view/61b8cb43a8956bec0975e346.html" target="_blank" rel="noopener">一阶逻辑中的重要等值式</a>：消去量词等值式、量词否定等值式、量词辖域收缩与扩张等值式、量词分配等值式</li></ul></li><li><strong>两个主要规则</strong>：<ul><li>置换规则</li><li>换名规则</li></ul></li></ul></li><li>一阶逻辑的前束范式<ul><li><strong>前束范式</strong></li><li><strong>求前束范式</strong>：利用重要的等值式、置换规则、换名规则等进行等值演算求解。</li></ul></li><li>一阶逻辑的推理理论<ul><li><strong>自然推理系统N的推理规则</strong>：前提引入、结论引入、置换、假言推理、附加、化简、拒取式、假言三段论、析取三段论、构造性二难、合取引入、全称量词消去($\forall$-)、全称量词引入($\forall$+)、存在量词消去($\exists$-)、存在量词引入($\exists$+)</li></ul></li></ol><h2 id="题型汇总-4"><a href="#题型汇总-4" class="headerlink" title="题型汇总"></a>题型汇总</h2><ul><li><strong>由已知的等值式证明新的等值式</strong></li><li><strong>在有限的个体域内消去公式中的量词</strong></li><li><strong>求给定公式的前束范式</strong></li><li><strong>在自然推理系统N中构造推理的证明</strong></li><li><strong>在自然推理系统N中，构造用自然语言描述的推理的证明</strong></li></ul><hr><h1 id="第6章-集合代数"><a href="#第6章-集合代数" class="headerlink" title="第6章 集合代数"></a>第6章 集合代数</h1><h2 id="基础知识-5"><a href="#基础知识-5" class="headerlink" title="基础知识"></a>基础知识</h2><ol><li>集合的基本概念<ul><li><strong>元素与集合</strong>：集合、元素(成员)、$\in$、$\notin$</li><li><strong>特殊集合</strong>：N、Q、R、C、$\emptyset$、全集E、A的幂集P(A)={x|x$\subseteq$A}</li><li><strong>集合的表示法</strong>：列元素法、谓词表示法、文氏图</li><li><strong>集合之间的关系</strong>：$\subseteq$，$\not \subseteq$，$\subset$，$\not \subset$，$=$，$\not =$</li><li><strong>重要结果</strong>：<ul><li>空集是任何集合的子集</li><li>对任何集合A，都有A$\notin$A</li><li>如果集合|A|=n, 则|P(A)|=2<sup>n</sup> </li></ul></li></ul></li><li>集合的运算<ul><li><strong>集合的初级运算</strong>：$\bigcup$、$\bigcap$、相对补$-$、绝对补~、对称差$\bigoplus$ </li><li><strong>集合的广义运算</strong>：广义并$\bigcup$A={ {x|$\exists$z(z$\in$A$\bigwedge$x$\in$z)} }、广义交$\bigcap$A={ {x|$\forall$z(z$\in$A$\rightarrow$x$\in$z)} }</li><li><strong>转化广义并、交</strong>：$\bigcup${A<sub>1</sub>,A<sub>2</sub>,…,A<sub>n</sub>}=A<sub>1</sub>$\bigcup$A<sub>2</sub>$\bigcup$…$\bigcup$A<sub>n</sub>，$\bigcap${A<sub>1</sub>,A<sub>2</sub>,…,A<sub>n</sub>}=A<sub>1</sub>$\bigcap$A<sub>2</sub>$\bigcap$…$\bigcap$A<sub>n</sub></li><li><strong>运算的优先权规定</strong>：一类运算($\bigcup$、$\bigcap$、相对补$-$、对称差$\bigoplus$ )优先顺序由括号确定，二类运算(绝对补~、广义运算、幂集)由右向左进行、二类运算优先于一类运算。</li></ul></li><li>有穷集合元素的计数<ul><li><strong>计数方法</strong>：文氏图、包含排斥原理</li><li><strong><a href="https://wenku.baidu.com/view/c47fa19769dc5022aaea00a9.html" target="_blank" rel="noopener">包含排斥原理</a></strong></li><li><strong><a href="https://baike.baidu.com/item/全错位排列" target="_blank" rel="noopener">错位排斥数</a></strong></li></ul></li><li><a href="https://wenku.baidu.com/view/33f57008bed5b9f3f90f1cf2.html" target="_blank" rel="noopener"><strong>集合恒等式</strong></a>：幂等律、结合律、交换律、分配律、同一律、零律、排中律、矛盾律·、吸收律、德摩根律、双重否定律</li></ol><h2 id="题型汇总-5"><a href="#题型汇总-5" class="headerlink" title="题型汇总"></a>题型汇总</h2><ul><li><strong>判断元素与集合的隶属关系以及集合之间的包含关系</strong></li><li><strong>集合的基本运算题</strong></li><li><strong>有关集合性质的分析题</strong></li><li><strong>集合相等或者包含的证明题</strong>：<ul><li>证明P$\subseteq$Q的基本方法：命题演算法、包含的传递性、反证法 </li><li>证明P$=$Q的基本方法：命题演算法、恒等变形、反证法、利用已知等式通过运算得到新的等式 </li></ul></li><li><strong>有穷集合的计数问题</strong></li></ul><hr><h1 id="第7章-二元关系"><a href="#第7章-二元关系" class="headerlink" title="第7章 二元关系"></a>第7章 二元关系</h1><h2 id="基础知识-6"><a href="#基础知识-6" class="headerlink" title="基础知识"></a>基础知识</h2><ol><li><p>有序对和笛卡儿积</p><ul><li><strong>有序对</strong>：有序对(序偶)、第一元素、第二元素、性质</li><li><strong>笛卡儿积</strong></li><li><strong>笛卡儿积运算性质</strong>：<ul><li>A×$\emptyset$=$\emptyset$, $\emptyset$×A=$\emptyset$</li><li>A×B$\not =$B×A(当A$\not =$ $\emptyset$ $\bigwedge$ A$\not =$ $\emptyset$ $\bigwedge$A$\not =$B时)</li><li>(A×B)×C$\not =$A×(B×C)(当A$\not =$ $\emptyset$ $\bigwedge$ A$\not =$ $\emptyset$ $\bigwedge$ C $\not =$ $\emptyset$时)</li><li>对并和交满足分配律</li></ul></li><li><strong>笛卡儿积中元素的计数</strong>：|A|=m, |B|=n, |A×B|=mn</li></ul></li><li><p>二元关系</p><ul><li><strong>二元关系</strong>：二元关系（简称关系）{条件：集合非空，且他的元素都是有序对；集合为空集}记作R，若<x,y>$\in$R,则记作xRy，否则记作x$\not R$y</x,y></li><li><strong>从A到B的二元关系与A上的二元关系</strong>：A×B的子集是从A到B的二元关系，当A=B时就是A上的二元关系。若|A|=n,|B|=m,|A×B|=mn，从A到B的二元关系有2<sup>mn</sup>，A上的关系有2<sup>n<sup>2</sup>&lt;/sup&gt;</sup></li><li><strong>A上的特殊关系</strong>：空关系$\emptyset$、全域关系E<sub>A</sub>、恒等关系I<sub>A</sub>，<em>小于等于关系，整除关系，包含关系</em></li><li><strong>关系的表示</strong>：集合表达式、关系矩阵、关系图</li></ul></li><li><p>关系的运算</p><ul><li><strong>定义</strong>：定义域(domR)、值域(ranR)、域(fldR)、逆关系(逆，R<sup>-1</sup>)、右复合(F$\circ$G)、限制(R$\upharpoonright$A={<x,y>|xRy$\bigwedge$x$\in$A})、像(R[A]=ran(R$\upharpoonright$A))、n次幂(R<sup>n</sup>){定义：R<sup>0</sup>={<x,x>|x$\in$A}=I<sub>A</sub>; R<sup>n+1</sup>=R<sup>n</sup>$\circ$R}</x,x></x,y></li><li><strong>运算顺序</strong>：关系运算中逆运算优先于其他运算，而所有的关系运算都优先于集合运算，对于没有规定优先级的运算以括号决定运算顺序。</li><li><strong>基本运算的性质</strong>：<ul><li>(F<sup>-1</sup>)<sup>-1</sup>=F</li><li>domF<sup>-1</sup>=ranF, ranF<sup>-1</sup>=domF</li><li>(F$\circ$G)$\circ$H=F$\circ$(G$\circ$H)</li><li>(F$\circ$G)<sup>-1</sup>=G<sup>-1</sup>$\circ$F<sup>-1</sup></li><li>R$\circ$I<sub>A</sub>=I<sub>A</sub>$\circ$R=R</li><li>F$\circ$(G$\bigcup$H)=F$\circ$G$\bigcup$F$\circ$H</li><li>(G$\bigcup$H)$\circ$F=G$\circ$F$\bigcup$H$\circ$F</li><li>F$\circ$(G$\bigcap$H)$\subseteq$F$\circ$G$\bigcap$F$\circ$H</li><li>(G$\bigcap$H)$\circ$F$\subseteq$G$\circ$F$\bigcap$H$\circ$F</li><li>F$\upharpoonright$(A$\bigcup$B)=F$\upharpoonright$A$\bigcup$F$\upharpoonright$B</li><li>F[A$\bigcup$B]=F[A]$\bigcup$F[B]</li><li>F$\upharpoonright$(A$\bigcap$B)=F$\upharpoonright$A$\bigcap$F$\upharpoonright$B</li><li>F[A$\bigcup$B]$\subseteq$F[A]$\bigcup$F[B]</li><li>设A为n元集，R是A上的关系，则存在自然数s和t，使得R<sup>s</sup>=R<sup>t</sup></li><li>R<sup>m</sup>$\circ$R<sup>n</sup>=R<sup>m+n</sup></li><li>(R<sup>m</sup>)<sup>n</sup>=R<sup>mn</sup></li><li>设R为A上的关系，若存在自然数s和t(s$&lt;$t)，使得R<sup>s</sup>=R<sup>t</sup>则：<ul><li>对任何k$\in$N有R<sup>s+k</sup>=R<sup>t+k</sup></li><li>对任何k,i$\in$N有R<sup>s+kp+i</sup>=R<sup>s+i</sup>，其中p=t-s</li><li>令S={R<sup>0</sup>,R<sup>1</sup>,$\cdots$,R<sup>n</sup>},则对任意的q$\in$N有R<sup>q</sup>$\in$S</li></ul></li></ul></li></ul></li><li><p>关系的性质</p><ul><li><p><strong>性质</strong>：</p><ul><li>自反{ $\forall$x(x$\in$A$\rightarrow$<x,x>$\in$R) }</x,x></li><li>反自反{ $\forall$x(x$\in$A$\rightarrow$<x,x>$\not \in$R) }</x,x></li><li>对称{ $\forall$x$\forall$y(x,y$\in$A$\bigwedge$<x,y>$\in$R$\rightarrow$<y,x>$\in$R) }</y,x></x,y></li><li>反对称{ $\forall$x$\forall$y(x,y$\in$A$\bigwedge$<x,y>$\in$R$\bigwedge$<y,x>$\in$R$\rightarrow$x=y) }</y,x></x,y></li><li>传递{ $\forall$x$\forall$y$\forall$z(x,y,z$\in$A$\bigwedge$<x,y>$\in$R$\bigwedge$<y,z>$\in$R$\rightarrow$<x,z>$\in$R) }</x,z></y,z></x,y></li></ul></li><li><p><strong>性质表</strong></p><p>|            |          自反性           |              反自反性               |                         对称性                         |                      反对称性                      |                            传递性                            |<br>| :————: | :———————————-: | :————————————————-: | :——————————————————————————: | :————————————————————————: | :—————————————————————————————: |<br>| 集合表达式 | I<sub>A</sub>$\subseteq$R | R$\bigcap$I<sub>A</sub>=$\emptyset$ |                    R=R<sup>-1</sup>                    |  R$\bigcap$R<sup>-1</sup>$\subseteq$I<sub>A</sub>  |                    R$\circ$R$\subseteq$R                     |<br>|  关系矩阵  |     主对角线元素全是1     |          主对角线元素全是0          |                     矩阵是对称矩阵                     | 若r<sub>ij</sub>=1且i$\not =$j，则r<sub>ji</sub>=0 |       对M<sup>2</sup>中1所在的位置，M中相应的位置都是1       |<br>|   关系图   |      每个顶点都有环       |          每个顶点都没有环           | 如果两个顶点之间有边，则一定是一对方向相反的边(无单边) |  如果两个顶点之间有边，则一定是一条有向边(无双边)  | 如果顶点x<sub>i</sub>到x<sub>j</sub>有边，x<sub>j</sub>到x<sub>k</sub>有边，则从x<sub>i</sub>到x<sub>k</sub>也有边 |</p></li><li><p><strong>关系的性质与运算之间的联系</strong>：</p><p>|                                     | 自反性 | 反自反性 | 对称性 | 反对称性 | 传递性 |<br>| :————————————————-: | :——: | :———: | :——: | :———: | :——: |<br>|     R<sub>1</sub><sup>-1</sup>      |   √    |    √     |   √    |    √     |   √    |<br>| R<sub>1</sub>$\bigcap$R<sub>2</sub> |   √    |    √     |   √    |    √     |   √    |<br>| R<sub>1</sub>$\bigcup$R<sub>2</sub> |   √    |    √     |   √    |    ×     |   ×    |<br>|     R<sub>1</sub>-R<sub>2</sub>     |   ×    |    √     |   √    |    √     |   ×    |<br>|  R<sub>1</sub>$\circ$R<sub>2</sub>  |   √    |    ×     |   ×    |    ×     |   ×    |</p></li></ul></li><li><p>关系的闭包</p><ul><li><strong>定义</strong>：自反包(r(R)=R$\bigcup$R<sup>0</sup>)、对称闭包(s(R)=R$\bigcup$R<sup>-1</sup>)、传递闭包(t(R)=R$\bigcup$R<sup>2</sup>$\bigcup$R<sup>3</sup>$\bigcup$ $\cdots$)</li><li><strong>关系矩阵表示</strong>：M<sub>r</sub>=M+E, M<sub>s</sub>=M+M’, M<sub>t</sub>=M+M<sup>2</sup>+M<sup>3</sup>+$\cdots$</li><li><strong>关系图表示</strong>：<ul><li>G<sub>r</sub>: 考察G的每个顶点，若没有环就加一个环</li><li>G<sub>s</sub>: 考察G的每条边，若有单向边就补边改为双向边</li><li>G<sub>t</sub>: 考察G的路径，补边使其可达则直达(特例：2步及以上回到本身补环)</li></ul></li><li><strong>定理</strong>：<ul><li>设R是非空集合A上的关系，则：R是自反的当且仅当r(R)=R；R是对称的当且仅当s(R)=R；R是传递的当且仅当t(R)=R。</li><li>设R1，R2是非空集合A上的关系，且R<sub>1</sub>$\subseteq$R<sub>2</sub>则：r(R<sub>1</sub>)$\subseteq$r(R<sub>2</sub>); s(R<sub>1</sub>)$\subseteq$s(R<sub>2</sub>); t(R<sub>1</sub>)$\subseteq$t(R<sub>2</sub>)。</li><li>设R是非空集合A上的关系，则：R自反$\rightarrow$s(R)与t(R)自反、R对称$\rightarrow$r(R)与t(R)对称、R是传递$\rightarrow$r(R)传递</li><li>tsr(R)=t(s(r(R))){传递闭包运算在对称闭包运算后面}  </li></ul></li></ul></li><li><p>等价关系与划分</p><ul><li><strong>等价关系</strong>：A上的自反、对称和传递的关系。（设R是一个等价关系，若<x,y>$\in$R, 称x等价于y，记作x~y）</x,y></li><li><strong>等价类</strong>：设R是非空集合A上的等价关系，$\forall$x$\in$A，令[x]<sub>R</sub>={y|y$\in$A$\bigwedge$xRy}称[x]<sub>R</sub>为x关于R的等价类，简称x的等价类，简记为[x]或$\overline{a}$</li><li><strong>等价类的性质</strong>：设R为非空集合A上的等价关系，则：<ul><li>$\forall$x$\in$A, [x]是A的非空子集</li><li>$\forall$x,y$\in$A, xRy$\rightarrow$[x]=[y]</li><li>$\forall$x,y$\in$A, x$\not R$y$\rightarrow$[x]、[y]不相交</li><li>$\bigcup${[x]|x$\in$A}=A</li></ul></li><li><strong>商集</strong>：设R为非空集合A上的等价关系，以R的所有等价类作为元素的集合称为A关于R的商集，记作A/R，即A/R={[x]<sub>R</sub>|x$\in$A}</li><li><strong>划分</strong>：设A为非空集合，若A的子集族π(π$\subseteq$P(A), 是A的子集构成的集合)满足($\emptyset$ $\not \in$π、$\forall$x$\forall$y(x,y$\in$π$\bigwedge$$x\not =y$ $\rightarrow$x$\bigcap$y=$\emptyset$)、$\bigcup$π=A)则称π是A的一个划分，称π中的元素为A的划分块。</li><li><strong>关系</strong>：商集就是A的一个划分，并且不同的商集将对应于不同的划分。A上的等价关系与A的划分一一对应。</li></ul></li><li><p>偏序关系：</p><ul><li><strong>偏序关系</strong>：设R为非空集合A上的关系，如果R是自反的、反对称的、传递的，则称R为A上的偏序关系，记作$\preccurlyeq$，设为偏序关系，<x,y>$\in$ $\preccurlyeq$, 则记作x$\preccurlyeq$y, 读作x”小于等于”y。{含义：依照这个序，x排在y前面或者x就是y}、{eg: 恒等关系、小于等于、整除、包含关系是偏序关系，一般全域关系不是}</x,y></li><li><strong>全序关系</strong>：设R为非空集合A上的偏序关系，如果$\forall$x,y$\in$A，x与y都是可比的，则称R为A上的全序关系(或线序关系)</li><li><strong>偏序集</strong>：集合A和A上的偏序关系$\preccurlyeq$一起称为偏序集，记作<a,$\preccurlyeq$></a,$\preccurlyeq$></li><li><strong>覆盖</strong>：设<a,$\preccurlyeq$>为偏序集，$\forall$x,y$\in$A，如果x$&lt;$y且不存在z$\in$A使得x$&lt;$z$&lt;$y, 则称y覆盖x</a,$\preccurlyeq$></li><li><strong>哈斯图</strong>：有穷偏序集<a,$\preccurlyeq$>可以用哈斯图表示。在哈斯图中用结点表示A中的元素，如果对于不同的结点x和y，x$&lt;$y, 那么x画在y的下方；如果y覆盖x，则在x和y之间连一条线。</a,$\preccurlyeq$></li><li><strong>特殊元素</strong>：<a,$\preccurlyeq$>，B$\subseteq$A, y$\in$B, 则：<ul><li>$\forall$x(x$\in$B$\rightarrow$y$\preccurlyeq$x)$\rightarrow$y为B的最小元</li><li>$\forall$x(x$\in$B$\rightarrow$x$\preccurlyeq$y)$\rightarrow$y为B的最大元  </li><li>$\forall$x(x$\in$B$\bigwedge$x$\preccurlyeq$y$\rightarrow$x=y)$\rightarrow$y为B的极小元  </li><li>$\forall$x(x$\in$B$\bigwedge$y$\preccurlyeq$x$\rightarrow$x=y)$\rightarrow$y为B的极大元  </li></ul></a,$\preccurlyeq$></li><li><strong>界</strong>：<a,$\preccurlyeq$>，B$\subseteq$A, y$\in$A, 则：<ul><li>$\forall$x(x$\in$B$\rightarrow$x$\preccurlyeq$y)$\rightarrow$y为B的上界</li><li>$\forall$x(x$\in$B$\rightarrow$y$\preccurlyeq$x)$\rightarrow$y为B的下界  </li><li>令C={y|y为B上界}，则称C的最小元为B的最小上界或上确界</li><li>令D={y|y为B下界}，则称D的最大元为B的最大下界或下确界</li></ul></a,$\preccurlyeq$></li></ul></li></ol><h2 id="题型汇总-6"><a href="#题型汇总-6" class="headerlink" title="题型汇总"></a>题型汇总</h2><ul><li><strong>有序对与笛卡儿积</strong></li><li><strong>关系的基本概念</strong></li><li><strong>关系的三种表示法即关系性质的判断</strong></li><li><strong>关系的基本运算</strong></li><li><strong>求关系的闭包</strong></li><li><strong>证明涉及关系的恒等式或包含式</strong></li><li><strong>证明关系的性质</strong></li><li><strong>等价关系的等价类、商集及划分的对应</strong></li><li><strong>偏序集与哈斯图</strong></li></ul><hr><h1 id="第8章-函数"><a href="#第8章-函数" class="headerlink" title="第8章 函数"></a>第8章 函数</h1><h2 id="基础知识-7"><a href="#基础知识-7" class="headerlink" title="基础知识"></a>基础知识</h2><ol><li>函数的定义与性质<ul><li><strong>函数</strong>：设F为二元关系，若$\forall$x$\in$domF都存在唯一的y$\in$ranF使xFy成立，则称F为函数</li><li><strong>函数相等</strong>：设F,G为函数，则F=G$\Leftrightarrow$F$\subseteq$G$\bigwedge$G$\subseteq$F{满足：domF=domG、$\forall$x$\in$domF=domG，都有F(x)=G(x)}</li><li><strong>从A到B的函数</strong>：设A，B为集合，如果f为函数，且domf=A, ranf$\subseteq$B，则f称为从A到B的函数，记作f: A$\rightarrow$B</li><li><strong>B上A</strong>：所有从A到B的函数的集合记作B<sup>A</sup>，读作“B上A”。符号化表示为B<sup>A</sup>={f|f:A$\rightarrow$B} {|A|=m,|B|=n,|B<sup>A</sup>|=n<sup>m</sup>；A=$\emptyset$ $\bigwedge$B=$\emptyset$ $\rightarrow$B<sup>A</sup>=$\emptyset$<sup>$\emptyset$</sup>={$\emptyset$}、A=$\emptyset$ $\bigwedge$B$\not =$ $\emptyset$ $\rightarrow$B<sup>A</sup>=B<sup>$\emptyset$</sup>={$\emptyset$}、A$\not =$ $\emptyset$ $\bigwedge$B=$\emptyset$ $\rightarrow$B<sup>A</sup>=$\emptyset$<sup>A</sup>=$\emptyset$}</li><li><strong>像</strong>：设f: A$\rightarrow$B, A<sub>1</sub>$\subseteq$A，B<sub>1</sub>$\subseteq$B，f(A<sub>1</sub>)={f(x)|x$\in$B<sub>1</sub>}称为A<sub>1</sub>在f下的像。f(A)称为函数的像</li><li><strong>完全原像</strong>：设f: A$\rightarrow$B, B<sub>1</sub>$\subseteq$B, f<sup>-1</sup>(B<sub>1</sub>)={x|x$\in$A$\bigwedge$f(x)$\in$B<sub>1</sub>}称为B<sub>1</sub>在f下的完全原像。{一般来说，像与完全原像满足：A<sub>1</sub>$\subseteq$f<sup>-1</sup>(f(A<sub>1</sub>)), f<sup>-1</sup>(f(B<sub>1</sub>))$\subseteq$B<sub>1</sub>}</li><li><strong>函数的性质</strong>：设f:A$\rightarrow$B:<ul><li>若ranf=B，则称f:A$\rightarrow$B是满射的</li><li>若$\forall$y$\in$ranf都存在唯一的x$\in$A使得f(x)=y，则称f:A$\rightarrow$B是单射的</li><li>若f:A$\rightarrow$B既是满射又是单射，则称f:A$\rightarrow$B是双射的(或一一映像)</li></ul></li><li><strong>常用函数</strong>：常函数、恒等函数、单调函数、集合的特征函数、自然映射、定义在自然数集合上的计数函数</li></ul></li><li>函数的复合与反函数<ul><li><strong>有关函数复合的定理</strong></li><li><strong>有关反函数的定理</strong></li></ul></li><li>双射与集合的基数</li></ol><h2 id="题型汇总-7"><a href="#题型汇总-7" class="headerlink" title="题型汇总"></a>题型汇总</h2><ul><li><strong>函数定义与从A到B的函数f:A$\rightarrow$B的定义</strong></li><li><strong>判断函数的性质</strong></li><li><strong>有关函数的计算题</strong></li><li><strong>针对给定集合A和B，构造双射函数f:A$\rightarrow$B</strong></li><li><strong>证明有关函数的等式或者函数的单射、满射性质</strong></li><li><strong>证明集合等势或者优势</strong></li><li><strong>计算或者证明集合的基数</strong></li></ul><hr><h1 id="第9章-代数系统"><a href="#第9章-代数系统" class="headerlink" title="第9章 代数系统"></a>第9章 代数系统</h1><ol><li>二元运算及其性质<ul><li><strong>定义</strong>：设S为集合，函数f:SxS$\rightarrow$S称为S上的二元运算，简称二元运算。</li><li>验证一个运算是否为集合S上的二元运算：<ul><li>S中的任何两个元素都可以进行这种运算，且运算结果是唯一的</li><li>S中的任何两个元素的运算结果都属于S，即S对该运算是封闭的</li></ul></li><li><strong>一元运算定义</strong>：设S为集合，函数f:S$\rightarrow$S称为S上的一元运算，简称一元运算。</li><li>单位元：唯一</li><li>零元：唯一</li><li>逆元：唯一</li></ul></li><li>代数系统<ul><li><strong>定义</strong>：非空集合S和S上的k个一元或二元运算$f_1,f_2,…,f_k$组成的系统称作一个代数系统，简称代数，记作$<s,f_1,f_2,...f_k>$</s,f_1,f_2,...f_k></li><li><strong>同类型的代数系统</strong>：如果两个代数系统中运算的个数相同，对应运算的元数相同，且代数常数的个数也相同，则称这两个代数系统具有相同的构成成分，也称他们是同类型的代数系统。不一定具有相同的运算性质。</li><li><strong>子代数</strong>：设$V=<s,f_1,f_2,...f_k>$是代数系统，$B\subseteq S$，如果B对$f_1,f_2,…,f_k$都是封闭的，且B和S具有相同的代数常数，则称$<b,f_1,f_2,...f_k>$是V的子代数系统，简称子代数，有时将子代数系统简记为B。</b,f_1,f_2,...f_k></s,f_1,f_2,...f_k></li></ul></li><li>代数系统的同态与同构<ul><li>设$V_1=<a,\circ>$和$V_2=<b,*>$是同类型的代数系统，f:A$\rightarrow$B，且$\forall$x,y$\in$A有$f(x\circ y)=f(x)*f(y)$，则称f是$V_1$到$V_2$的同态映射，简称为同态。</b,*></a,\circ></li><li>单同态、满同态、同构；</li><li>自同态</li></ul></li></ol><hr><h1 id="第10章-群与环"><a href="#第10章-群与环" class="headerlink" title="第10章 群与环"></a>第10章 群与环</h1><p><table>          <tr>               <td>《S, o》</td>               <td>封闭性</td>               <td>结合律</td>               <td>含幺元</td>               <td>所有元素都有逆元</td>               <td>交换律</td>               <td>《a={a<sup>z</sup>}</td>               <td>消去律</td>               <td>含零元</td>          </tr>          <tr>               <td>代数系统</td>               <td>√</td>               <td></td>               <td></td>               <td></td>               <td></td>               <td></td>               <td></td>               <td></td>          </tr>          <tr>               <td>半群</td>               <td>√</td>               <td>√</td>               <td></td>               <td></td>               <td>交换半群</td>               <td></td>               <td></td>               <td></td>          </tr>          <tr>               <td>独异点</td>               <td>√</td>               <td>√</td>               <td>√</td>               <td></td>               <td></td>               <td></td>               <td></td>               <td></td>          </tr>          <tr>               <td>群</td>               <td>√</td>               <td>√</td>               <td>√</td>               <td>√</td>               <td></td>               <td></td>               <td>√</td>               <td>×</td>          </tr>          <tr>               <td>Abel群</td>               <td>√</td>               <td>√</td>               <td>√</td>               <td>√</td>               <td>√</td>               <td></td>               <td>√</td>               <td>×</td>          </tr>          <tr>               <td>循环群</td>               <td>√</td>               <td>√</td>               <td>√</td>               <td>√</td>               <td>√</td>               <td>√</td>               <td>√</td>               <td>×</td>          </tr>      </table></p><ol><li>群的定义及性质<ul><li><strong>定义</strong>：<ul><li>设$V=<s,\circ>$是代数系统，$\circ$为二元运算，如果$\circ$为二元运算，如果$\circ$是可结合的，则称V为半群；</s,\circ></li><li>设$V=<s,\circ>$是半群，若$e\in S$是关于$\circ$运算的单位元，则称V是幺半群，也称作独异点；</s,\circ></li><li>设$V=<s,\circ>$是独异点，$e\in S$是关于$\circ$运算的单位元，若$\forall a\in S$，有$a^{-1}\in S$，则称V是群，通常将群记作G；</s,\circ></li><li>若群G中的二元运算是可交换的，则称G为交换群或Abel群；</li><li>若存在$a\in G$使得$G=<a>$，则称G为循环群，称a为G的生成元；</a></li></ul></li><li>若群G是有穷集，则称G是有限群，否则是无限群。</li><li>群G的基数是群G的阶</li><li>只含单位元的群称为平凡群</li><li>设G为群，$a\in G$，使得等式$a^k=e$成立的最小正整数k称为a的阶，记作$|a|=k$，这时称a为k阶元。若不存在这样的正整数k，则称a为无限阶元。</li><li><strong>结论</strong>：设G为有限群，则G中阶大于2的元素为偶数个。</li></ul></li><li>子群与群的陪集分解<ul><li>定义</li><li>3个判定定理</li><li>由a生成的子群</li><li>中心</li><li>陪集、正规子群、H在G中的指数（$[G:H]$）</li><li><strong>拉格朗日定理</strong>：设G是有限群，H是G的子群，则$|G|=|H|*[G:H]$</li></ul></li><li>循环群与置换群<ul><li>循环群生成元个数</li><li>循环子群的定理</li><li>置换群：n元置换、k阶轮换、对换、奇置换偶置换(各$n!/2$)、n元对称群、n元交错群、n元置换群</li></ul></li><li>环与域<ul><li>定义</li><li>交换环、含幺环、无零因子环、整环、域</li><li><strong>费马小定理</strong>：如果p为素数，则对所有的$n!=0(mod p)$有$n^{p-1}=1(modp)$</li></ul></li></ol><h1 id="第11章-格与布尔代数"><a href="#第11章-格与布尔代数" class="headerlink" title="第11章 格与布尔代数"></a>第11章 格与布尔代数</h1><ol><li>格与布尔代数是具有两个二元运算的代数系统。</li><li>格：设<s,$\preccurlyeq$>是偏序集，如果$\forall x,y\in S$，{x, y}都有最小上界和最大下界，则称S关于偏序$\preccurlyeq$作为一个格。</s,$\preccurlyeq$></li><li>分配格、全上界、全下界、有界格、补元、有补格</li><li>布尔代数：如果一个格是有补分配格，则称他是布尔格或者布尔代数。</li></ol><h1 id="第12章-基本的组合计数公式"><a href="#第12章-基本的组合计数公式" class="headerlink" title="第12章 基本的组合计数公式"></a>第12章 基本的组合计数公式</h1><ol><li>加法法则与乘法法则<ul><li>设A为n元集，则：<ul><li>A上的自反关系个数：$2^{n^2-n}$</li><li>A上的对称关系个数：$2^{(n^2+n)/2}$</li><li>A上的反对称关系个数：$2^n3^{(n^2-n)/2}$</li><li>A上的函数个数：$n^n$</li><li>A上的双射函数的个数：$n!$</li></ul></li></ul></li><li>排列与组合<ul><li>$P(n,r)=n!/(n-r)!$</li><li>$C(n,r)=P(n,r)/r!$</li><li>环排列：$P(n,r)/r$</li></ul></li><li>二项式定理与组合恒等式</li></ol><h1 id="第13章-递推方程与生成函数"><a href="#第13章-递推方程与生成函数" class="headerlink" title="第13章 递推方程与生成函数"></a>第13章 递推方程与生成函数</h1><h1 id="第14章-图的基本概念"><a href="#第14章-图的基本概念" class="headerlink" title="第14章 图的基本概念"></a>第14章 图的基本概念</h1><ol><li>图<ul><li><strong>握手定理</strong>：在任何无向图中，所有顶点的度数之和等于边数的两倍。</li><li>任何图中，奇度顶点的个数是偶数。</li><li>同构</li><li>n阶无向完全图、n阶有向完全图、n阶竞赛图</li><li>k-正则图</li><li>子图、母图、真子图、导出的子图、生成的子图</li><li>补图、自补图</li><li>删除边、删除边集、删除点、删除点集、边的收缩、加新边</li></ul></li><li>通路与回路<ul><li>通路、回路、简单通路、简单回路、初级通路（路径）、初级回路（圈）、奇圈、偶圈</li></ul></li><li>图的连通性<ul><li>连通、连通图、非连通图、连通分支、连通分支数$p(G)$</li><li>点割集、割点、边割集、割边（桥）、点连通度、k-连通图、边连通度、k边-连通图</li><li>弱连通图、单项连通图、强连通图</li><li>强连通图判定定理：当且仅当D中存在经过每个顶点至少一次的回路</li><li>单向连通图判定定理：当且仅当D中存在经过每个顶点至少一次的通路</li><li>二部图、互补顶点子集、简单二部图、完全二部图</li><li>二部图判定定理：当且仅当D中无奇圈</li></ul></li></ol><h1 id="第15章-欧拉图与哈密顿图"><a href="#第15章-欧拉图与哈密顿图" class="headerlink" title="第15章 欧拉图与哈密顿图"></a>第15章 欧拉图与哈密顿图</h1><ol><li>欧拉图<ul><li>欧拉通路、欧拉回路、欧拉图、半欧拉图</li><li>规定平凡图为欧拉图</li><li>无向图G是欧拉图当且仅当G是连通图且没有奇度顶点</li><li>无向图G是半欧拉图当且仅当G是连通图且恰有两个奇度顶点</li><li>有向图D是欧拉图当且仅当D是强连通图且每个顶点的入度等于出度</li><li>有向图D是半欧拉图当且仅当D是单向连通图且恰有两个奇度顶点，其中一个顶点的入度比出度大1，一个顶点的出度比入度大1，其余顶点的入度等于出度。</li></ul></li><li>哈密顿图<ul><li>哈密顿通路、哈密顿回路、哈密顿图、半哈密顿图</li><li>规定平凡图为哈密顿图</li></ul></li></ol><h1 id="第16章-树"><a href="#第16章-树" class="headerlink" title="第16章 树"></a>第16章 树</h1><h1 id="第17章-平面图"><a href="#第17章-平面图" class="headerlink" title="第17章 平面图"></a>第17章 平面图</h1><h1 id="第18章-支配集、覆盖集、独立集、匹配与着色"><a href="#第18章-支配集、覆盖集、独立集、匹配与着色" class="headerlink" title="第18章 支配集、覆盖集、独立集、匹配与着色"></a>第18章 支配集、覆盖集、独立集、匹配与着色</h1><blockquote><p>均针对无向简单图</p></blockquote><ol><li>支配集、点覆盖集与点独立集<ul><li>支配集、极小支配集、最小支配集、支配数：分布式计算系统，设 $G=(V, E)$ 是无向简单图, $D \subseteq V$，若对于任意 $\boldsymbol{v} \in V-D$, 都存在 $u \in D$, 使得 $u v \in E$，则D是支配集<ul><li>完全图 $K_{n}(n \geq 3)$ 的支配数为1</li><li>完全二部图 $K_{m . n}$ 的支配数为 $\min (m, n)$</li></ul></li><li>点独立集、极大独立集、最大独立集、独立数：受干扰的通信系统，设 $G=(V, E, \gamma)$ 是一个无向图, $S \subseteq V$，若对任意 $\boldsymbol{u}, \boldsymbol{v} \in \boldsymbol{S}$, 都有 $\boldsymbol{u}$ 与 $\boldsymbol{v}$ 不相邻, 则称 $S$是 $G$ 的一个点独立集或简称独立集<ul><li>无向简单图的极大独立集都是极小支配集，反之不成立</li><li>完全图 $\boldsymbol{K}_{n}(n \geq 3)$ 的独立数为1</li><li>完全二部图 $K_{m . n}$ 的独立数为 $\max (m, n)$</li></ul></li><li>点覆盖、极小点覆盖、最小点覆盖、点覆盖数：小区监控，设 $G(V, E)$ 是简单图, $V^{<em>} \subseteq V$，如果对于任意 $e \in E$, 都存在 $v \in V^{</em>}$, 使得 $v$ 是 $e$ 的 一个端点, 则称 $V^{*}$ 为 $G$ 的一个点覆盖集，简称点覆盖<ul><li>点覆盖数&gt;=点支配数</li><li>点覆盖数+点独立数=点数</li><li>完全图 $\boldsymbol{K}_{\boldsymbol{n}}(n \geq \mathbf{3})$ 中点覆盖数是 $\boldsymbol{n}-\mathbf{1}$</li><li>完全二部图 $\boldsymbol{K}_{\boldsymbol{m} . n}$ 的点覆盖数是 $\min (m, n)$</li></ul></li></ul></li><li>边覆盖集与匹配<ul><li>边覆盖集、极小边覆盖、最小边覆盖、边覆盖数：设 $G(V, E)$ 是没有孤立顶点的简单图, $E^{<em>} \subseteq E$，如果对于任意 $\boldsymbol{v} \in V$, 都存在 $e \in E^{</em>}$, 使得 $\boldsymbol{v}$ 是 $\boldsymbol{e}$ 的 一个端点, 则称 $\boldsymbol{E}$ *为 $G$ 的一个边覆盖集, 简称边覆盖<ul><li>完全图 $K_{n}(n \geq 3)$ 中边覆盖数 $\rho(G)=[n / 2\rceil$</li><li>完全二部图 $K_{m, n}$ 的边覆盖数 $\rho(G)=\max (m, n)$</li><li>圈图 $C_{n}(n \geq 3)$ 的边覆盖数为 $\lceil n / 2\rceil$</li><li>任何完美匹配都是最小边覆盖</li></ul></li><li>边独立集（匹配）、极大匹配、最大匹配、匹配数、完美匹配：设 $G=(V, E)$ 是简单图, $M \subseteq E$ 。 如果 $M$ 中任何两条边都不邻接, 则称 $M$ 为 $G$ 中的一个匹配或边独立集<ul><li>完全图 $\boldsymbol{K}_{n}(n \geq \mathbf{3})$ 中匹配数为 $\lfloor n / 2\rfloor$</li><li>完全二部图 $K_{m . n}$ 的匹配数为 $\min (m, n)$</li><li>圈图 $C_{n}(n \geq 3)$ 的匹配数为 $\lfloor n / 2\rfloor$</li></ul></li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="课程" scheme="https://Dragonliu2018.github.io/categories/课程/"/>
    
    
  </entry>
  
  <entry>
    <title>概率论与数理统计</title>
    <link href="https://dragonliu2018.github.io/2021/07/24/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"/>
    <id>https://dragonliu2018.github.io/2021/07/24/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/</id>
    <published>2021-07-24T09:04:04.000Z</published>
    <updated>2021-07-26T08:17:48.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="第1章-概率论的基本概念"><a href="#第1章-概率论的基本概念" class="headerlink" title="第1章  概率论的基本概念"></a>第1章  概率论的基本概念</h1><h2 id="0x01-事件间的关系与事件的运算（维恩图）"><a href="#0x01-事件间的关系与事件的运算（维恩图）" class="headerlink" title="0x01 事件间的关系与事件的运算（维恩图）"></a><strong>0x01 事件间的关系与事件的运算（维恩图）</strong></h2><ol><li>包含关系和相等关系  </li><li>和事件 <script type="math/tex">A \bigcup B</script> ：A、B中至少有一个发生  </li><li>积事件 <script type="math/tex">A \bigcap B</script> ：A、B同时发生  </li><li>差事件 <script type="math/tex">A-B</script> ：A发生且B不发生  </li><li>事件的互不相容(互斥)<script type="math/tex">A \bigcap B = \emptyset</script> ：A与B不能同时发生  </li><li>对立事件(逆事件)<script type="math/tex">A \bigcap B 且 A \bigcap B = \emptyset</script>：A与B有且仅有一个发生  </li><li>事件的运算律：交换律、分配律、<strong>对偶律（德摩根律）</strong></li></ol><h2 id="0x02-概率的一些重要性质"><a href="#0x02-概率的一些重要性质" class="headerlink" title="0x02 概率的一些重要性质"></a><strong>0x02 概率的一些重要性质</strong></h2><ol><li>减法公式： <script type="math/tex">P(B-A)=P(B)-P(AB)</script> ，特别地：当 <script type="math/tex">A \subset B</script>时， <script type="math/tex">P(B-A)=P(B)-P(A)</script>   </li><li>加法公式： <script type="math/tex">P(A \bigcup B) = P(A)+P(B)-P(AB)</script> 推广：<a href="https://baike.baidu.com/item/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86" target="_blank" rel="noopener">容斥原理</a></li></ol><h2 id="0x03-古典概型（等可能概型）"><a href="#0x03-古典概型（等可能概型）" class="headerlink" title="0x03 古典概型（等可能概型）"></a><strong>0x03 古典概型（等可能概型）</strong></h2><ol><li>公式： <script type="math/tex">P = \frac{A中基本事件数}{S中基本事件总数} = \frac{k}{n}</script>   </li><li>加法原理、乘法原理  </li><li><strong>抓阄原理</strong>：总共有N个阄，其中m个有奖(m≤N)，有1～N个人抓阄，在不提前公布结果的情况下每个人中奖的概率相同，均为m/N。应用于商城抽奖、抽签等活动。  </li><li>实际推断原理:“小概率事件在一次试验中实际上是不可能发生的”  </li><li><strong>排列组合：</strong>优秀笔记：<a href="https://zhuanlan.zhihu.com/p/42859784" target="_blank" rel="noopener">我跳</a></li></ol><h2 id="0x04-条件概率"><a href="#0x04-条件概率" class="headerlink" title="0x04 条件概率"></a>0x04 条件概率</h2><ol><li>在古典概型中： <script type="math/tex">P(B | A) = \frac{n_{AB}}{n_A} = \frac {P(AB)}{P(A)}</script> (计算条件概率的两种方法)  </li><li>乘法定理（变形）：若 <script type="math/tex">P(A)>0</script> ，则 <script type="math/tex">P(AB) = P(A)P(B | A)</script>   推广:  <script type="math/tex">P(AB)>0</script> , 则有 <script type="math/tex">P(ABC)=P(A)P(B|A)P(C|AB)</script>   </li><li>全概率公式： <script type="math/tex">P(A) = \sum_{i=1}^n {P(A|B_i)P(B_i)}</script> （知原因推结果，找样本空间的划分）特例： <script type="math/tex">P(A) = P(AB)+P(A \overline B)</script>   </li><li>贝叶斯公式： <script type="math/tex">P(B_i|A) = \frac{P(AB_i)}{P(A)} = \frac{P(A|B_i)P(B_i)}{P(A)}</script> （知结果推原因）</li></ol><h2 id="0x05-独立性"><a href="#0x05-独立性" class="headerlink" title="0x05 独立性"></a><strong>0x05 独立性</strong></h2><ol><li>定义：<script type="math/tex">P(AB) = P(A)P(B)</script> 推广：P(AB)=P(A)P(B), P(AC)=P(A)P(C), P(BC)=P(B)P(C), P(ABC)=P(A)P(B)P(C)， 则称A,B,C为相互独立的事件。</li><li>若n个事件相互独立，必蕴含这n个事件两两相互独立, 反之不真。</li><li>定理一：设A,B是两事件,且P(A)&gt;0,则A,B相互独立的充要条件是:   P(B|A)=P(B).  </li><li>定理二：若A、B相互独立，则 <script type="math/tex">\overline {A}与B、\overline{A}与\overline{B}、A与\overline{B}</script> 也相互独立</li><li>$P(A) &gt; 0、P(B)&gt;0$时，A、B相互独立与互不相容不能同时成立。</li><li>事件A、B对立即: P(AB)=P(A)P(B);   </li><li>事件A、B互斥即: P(A+B)=P(A)+P(B)或等价地P(AB)=0，  </li><li>当事件A、B的概率都不为0时，对立与互斥两种情况确实不能同时发生。_</li></ol><h1 id="第2章-随机变量及其分布"><a href="#第2章-随机变量及其分布" class="headerlink" title="第2章 随机变量及其分布"></a>第2章 随机变量及其分布</h1><h2 id="0x01-随机变量"><a href="#0x01-随机变量" class="headerlink" title="0x01 随机变量"></a><strong>0x01 随机变量</strong></h2><ol><li><strong>定义</strong>：对于每个基本事件e都有一个实数X(e)对应，即X(e)是定义在S上的单值实函数，称为随机变量(r.v.)。</li><li><strong>统计规律性：</strong>分布律、分布列</li><li>求解分布列：①确定r.v.X的所有取值 ②求解对应概率 ③检验 <script type="math/tex">\sum_{k=0}^{n}p_k = 1</script> </li><li>判断是否构成分布律：非负性、规范性</li></ol><h2 id="0x02-重要的离散型r-v"><a href="#0x02-重要的离散型r-v" class="headerlink" title="0x02 重要的离散型r.v."></a><strong>0x02 重要的离散型r.v.</strong></h2><h3 id="01-0-1分布："><a href="#01-0-1分布：" class="headerlink" title="01. 0-1分布："></a>01. 0-1分布：</h3><h3 id="02-二项分布"><a href="#02-二项分布" class="headerlink" title="02. 二项分布"></a>02. 二项分布</h3><ul><li><strong>定义：</strong> <script type="math/tex">P(X=k)=  \begin{pmatrix} n \\ k\end{pmatrix} p^k(1-p)^{n-k}</script> ，k=0, 1, 2 … n，记作X~ b(n, p)</li><li><strong>公式：</strong> <script type="math/tex">\sum_{k=0}^{n} P(X=k) = ( p+(1-p) )^n</script> </li><li><strong>二项分布的最可能发生次数</strong>：大于前面，大于后面，构造不等式</li></ul><p><img alt="&#x56FE;1 &#x4E8C;&#x9879;&#x5206;&#x5E03;&#x7684;&#x6700;&#x53EF;&#x80FD;&#x53D1;&#x751F;&#x6B21;&#x6570;&#x89E3;&#x6CD5;" data-src="https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/Snipaste_2020-03-16_17-33-49.jpg" class="lozad"></p><h3 id="03-泊松分布"><a href="#03-泊松分布" class="headerlink" title="03. 泊松分布"></a><strong>03. 泊松分布</strong></h3><ul><li><strong>定义</strong>：若X的分布为 <script type="math/tex">P(X=k) = \frac{λ^ke^{-λ}}{k!}</script> ，k=0, 1, 2 … 其中λ&gt;0是常数，则称X服从参数为λ的泊松分布，记作 X~π(λ) 或 X~P(λ)</li><li><strong>公式：</strong> <script type="math/tex">\sum_{k=0}^{\infty}P(X=k) = \sum_{k=0}^{\infty}\frac{λ^ke^{-λ}}{k!} = e^{-λ}\sum_{k=0}^{\infty}\frac{λ^k}{k!} = 1</script>  　　　  <strong><strong><script type="math/tex">e^x = \sum_{k=0}^{\infty}\frac{x^k}{k!}</script> </strong></strong></li><li><strong>应用</strong>：某一地区一个时间间隔内发生的交通事故，一本书的印刷错误数等。</li><li><strong>泊松(Poisson)定理：</strong>设随机变量序列{ <script type="math/tex">X_n</script> }， <script type="math/tex">X_n</script> ~ <script type="math/tex">b(n, p_n)</script> ，则 <script type="math/tex">\lim_{n \to +\infty}P(X_n=k)=\lim_{n \to +\infty} \begin{pmatrix} n \\ k\end{pmatrix}p^k(1-p)^{n-k} = \frac{λ^ke^{-λ}}{k!}</script>，其中 <script type="math/tex">np_n = λ>0</script> ，k为任一固定的非负整数 ①  在定理的条件下, 二项分布的极限分布是泊松分布 ② 当n( <script type="math/tex">n \geq 10</script> )很大且p( <script type="math/tex">p\leq 0.01</script> )又较小时， <script type="math/tex">\begin{pmatrix} n \\ k\end{pmatrix}p^k(1-p)^{n-k}   \approx\frac{λ^ke^{-λ}}{k!}</script> ，其中 <script type="math/tex">np = λ</script> </li></ul><h3 id="04-几何分布"><a href="#04-几何分布" class="headerlink" title="04. 几何分布"></a>04. 几何分布</h3><ul><li><strong>定义</strong>：进行重复独立试验, 设每次试验成功的概率为p，失败的概率为1-    p=q(0&lt;p&lt;1), 将试验进行到出现一次成功为止, 以X表示所需的试验次数, 则X的分布律为: P{X=k}= <script type="math/tex">q^{k-1}p</script> ,    k=1, 2, …  称为X服从参数为p的几何分布。</li></ul><h2 id="0x03-分布函数"><a href="#0x03-分布函数" class="headerlink" title="0x03 分布函数"></a>0x03 分布函数</h2><ol><li><strong>定义</strong>：设随机变量 X, x为任意实数,  则 F(x)=P{ X ≤ x } 称为X的分布函数。</li><li><strong>性质 ①</strong> F(x)是单调不减函数 ② <script type="math/tex">0≤F(x)≤1,  F(-\infty)=0, F(+\infty)=1</script>  *③ F(x)至多有可列个间断点, 而在其间断点上也是右连续的,F(x+0)=F(x). </li><li>离散型r.v.X的分布函数是阶梯函数。</li><li>判断分布函数：非负规范性、单调不减性、右连续性</li><li>求端点值：该点的分布函数的右极限-左极限</li></ol><h2 id="0x04-连续型随机变量及其分布"><a href="#0x04-连续型随机变量及其分布" class="headerlink" title="0x04 连续型随机变量及其分布"></a>0x04 连续型随机变量及其分布</h2><ol><li><strong>定义</strong>：对于r.v.X的分布函数F(x)，存在非负可积函数f(x)，使对于任意的实数x，有 <script type="math/tex">F(x) = \int_{-\infty}^{x}f(t)dt</script> ，则f(x)为概率密度函数</li><li>连续型r.v.X的分布函数是连续函数</li><li><strong>性质</strong>： ① <script type="math/tex">f(x)≥0</script>  ②  <script type="math/tex">\int_{-\infty}^{+\infty}f(x)dx = 1</script>  ③ <script type="math/tex">\forall x_1<x_2，P(x_1<X\leq x_2) = F(x_2)-F(x_1)=\int_{x_1}^{x_2}f(x)dx</script>  ④ 若f(x)在x处连续，则有 <script type="math/tex">F'(x) = f(x)</script> </li><li><strong>定理</strong>：设X是连续型r.v.，任取指定的实数值a的概率均为0，P{X = a} = 0</li></ol><h2 id="0x05-常用的连续型r-v-分布"><a href="#0x05-常用的连续型r-v-分布" class="headerlink" title="0x05 常用的连续型r.v.分布"></a>0x05 常用的连续型r.v.分布</h2><h3 id="1-均匀分布"><a href="#1-均匀分布" class="headerlink" title="1. 均匀分布"></a>1. 均匀分布</h3><ul><li><strong>定义</strong>：设随机变量X在区间(a, b)上取值，且概率密度为： <script type="math/tex">f(x) =  \begin{cases}    \frac{1}{b-a},  & \text{$a<x<b$} \\    0, & \text{others}         \end{cases}</script> ，则称r.v.X在（a, b）上服从均匀分布，记作 <script type="math/tex">X</script> ~ <script type="math/tex">U(a,b)</script> </li><li><strong>分布函数</strong>： <script type="math/tex">F(x)= \begin{cases}   0  & \text{$x<a$} \\      \frac{x-a}{b-a} & \text{$a\leq x<b$}\\ 1 &{x\geq b} \end{cases}</script> </li></ul><h3 id="2-指数分布"><a href="#2-指数分布" class="headerlink" title="2. 指数分布"></a>2. 指数分布</h3><ul><li><strong>定义</strong>：设连续型r.v.X的概率密度为：<script type="math/tex">f(x) =  \begin{cases}   \frac{1}{θ}e^{-\frac{x}{θ}},  & {x\geq 0} \\   0, & {x<0}         \end{cases}，θ>0</script> 则称X服从参数为θ的指数分布。</li><li><strong>分布函数</strong>： <script type="math/tex">F(x) =  \begin{cases}   1-e^{-\frac{x}{θ}},  & {x\geq 0} \\   0, & {x<0}         \end{cases}</script> </li><li><strong>无记忆性</strong>： <script type="math/tex">P(X>s+t | X>s) = P(X>t)</script> </li></ul><h3 id="3-正态分布"><a href="#3-正态分布" class="headerlink" title="3. 正态分布"></a>3. 正态分布</h3><ul><li><strong>定义</strong>：设连续型r.v.X的概率密度为：<script type="math/tex">f(x)= \frac{1}{\sqrt{2π}σ} e^{\frac{-(x-μ)^2}{2σ^2}}，-\infty<x<+\infty</script> ，其中μ、σ(σ&gt;0)为常数，则称X服从参数为μ、σ的正态分布，记作X ~ N(μ, σ)</li><li>μ(期望)：位置参数，f(x)的图形关于 x = μ对称， <script type="math/tex">Max = f(μ) = \frac{1}{\sqrt{2π}σ}</script> </li><li>σ(均差)：影响f(x)的曲线形状和最大值</li><li><strong>分布函数</strong>： <script type="math/tex">F(x) = \int_{-\infty}^{x}\frac{1}{\sqrt{2π}σ} e^{\frac{-(t-μ)^2}{2σ^2}}dt</script></li></ul><h1 id="第3章-多维随机变量及其分布"><a href="#第3章-多维随机变量及其分布" class="headerlink" title="第3章 多维随机变量及其分布"></a>第3章 多维随机变量及其分布</h1><h1 id="第4章-随机变量的数字特征"><a href="#第4章-随机变量的数字特征" class="headerlink" title="第4章 随机变量的数字特征"></a>第4章 随机变量的数字特征</h1><ul><li>期望：EX</li><li>方差：$DX^2=E(X-E(X))^2=EX^2-(EX)^2$</li><li>协方差及相关系数</li></ul><h1 id="第5章-大数定律及中心极限定理"><a href="#第5章-大数定律及中心极限定理" class="headerlink" title="第5章 大数定律及中心极限定理"></a>第5章 大数定律及中心极限定理</h1><ul><li>大数定律：凡是用来阐明大量独立重复试验的平均结果具有稳定性的一系列定理，统称为大数定律。<ul><li>切比雪夫大数定律：设随机变量 $\boldsymbol{X}<em>{1}, \boldsymbol{X}</em>{2}, \cdots, \boldsymbol{X}<em>{n}, \cdots$ 相互独立, 并且具有相同的数学期望和方差：$\boldsymbol{E}\left(\boldsymbol{X}</em>{\boldsymbol{k}}\right)=\boldsymbol{\mu}, <script type="math/tex">\boldsymbol{D}\left(\boldsymbol{X}_{\boldsymbol{k}}\right)=\boldsymbol{\sigma}^{2},</script>(\boldsymbol{k}=1,2, \cdots)$, 作前 $\boldsymbol{n}$ 个随机变量的算术平均$\bar{X}=\frac{1}{n} \sum<em>{k=1}^{n} X</em>{k}$, 则对于任意正数 $\varepsilon$ 有$\lim <em>{n \rightarrow \infty} P{|\bar{X}-\mu|&lt;\varepsilon}=\lim </em>{n \rightarrow \infty} P\left{\frac{1}{n} \sum<em>{k=1}^{n} X</em>{k}-\mu&lt;\varepsilon\right}=1$<ul><li>切比雪夫不等式：设随机变量 $X$ 具有数学期望 $E(X)=\mu, D(X)=\sigma^{2}$, 则对于任意正数 $\varepsilon$, 不等式$P{|X-\mu| \geq \varepsilon} \leq \frac{\sigma^{2}}{\varepsilon^{2}}$成立</li><li>另一种叙述：设随机变量 $X<em>{1}, X</em>{2}, \cdots, X<em>{n}, \cdots$ 相互独立, 且具有相同的数学期望 和方差： $\boldsymbol{E}\left(\boldsymbol{X}</em>{k}\right)=\mu$,<br>$D\left(X<em>{k}\right)=\sigma^{2}(k=1,2, \cdots)$, 则序列 $\bar{X}=\frac{1}{n} \sum</em>{k=1}^{n} X_{k}$依概率收敛于 $\mu$, 即 $\bar{X} \stackrel{P}{\longrightarrow} \mu .$</li></ul></li><li>伯努利大数定律：设 $\boldsymbol{n}<em>{A}$ 是 $\boldsymbol{n}$ 次独立重复试验中事件 $\boldsymbol{A}$ 发生的次数， $\boldsymbol{p}$ 是事件 $\boldsymbol{A}$ 在每次试 验中发生的概率，则有$\frac{n</em>{A}}{n} \stackrel{P}{\longrightarrow} p $<ul><li>伯努利大数定律实际上告诉我们，频率依概率收敛于概率，这是我们在给出概率的定义时说过的内容，在这里得到了佐证。</li><li>伯努利大数定律是切比雪夫大数定律的特殊情形。</li></ul></li><li>辛钦大数定律：设随机变量 $X<em>{1}, X</em>{2}, \cdots, X<em>{n}, \cdots$, 相互独立，服从同一分布，且具有数学 期望 $E\left(X</em>{k}\right)=\mu(k=1,2, \ldots)$, 则$\frac{1}{n} \sum<em>{k=1}^{n} X</em>{k} \stackrel{P}{\longrightarrow} \mu$<ul><li>与定理一相比，不要求方差存在，但需服从同一分布；</li><li>伯努利大数定律是辛钦大数定律的特殊情况.</li></ul></li></ul></li><li>中心极限定理<ul><li>引入：在自然界与生产中，一些随机变量的取值会受到许多不确定因素的影响，如果这些因素彼此之间没有什么依存关系、且谁也没有特别突出的影响，那么，这些影响的累积效应将会使随机变量近似地服从正态分布.中心极限定理就是从数学上证明了这一现象。</li><li>独立同分布极限定理：设随机变量 $X<em>{1}, X</em>{2}, \cdots, X<em>{n}, \cdots$ 相互独立， 服从同一分布，且具有 数学期望和方差 $: E\left(X</em>{k}\right)=\mu,$$ D\left(X<em>{k}\right)=\sigma^{2}&gt;0(k=1,2, \cdots)$, 则随机变量之和的标准化变量$Y</em>{n}=\frac{\sum<em>{i=1}^{n} X</em>{i}-n \mu}{\sqrt{n} \sigma}$，当n很大时，随机变量近似地服从标准正态分布 $ \mathrm{N}(0,1)$</li></ul></li></ul><h1 id="第6章-样本及抽样分布"><a href="#第6章-样本及抽样分布" class="headerlink" title="第6章 样本及抽样分布"></a>第6章 样本及抽样分布</h1><h1 id="第7章-参数估计"><a href="#第7章-参数估计" class="headerlink" title="第7章 参数估计"></a>第7章 参数估计</h1><ul><li>点估计</li><li>区间估计</li></ul><h1 id="第8章-假设检验"><a href="#第8章-假设检验" class="headerlink" title="第8章 假设检验"></a>第8章 假设检验</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="课程" scheme="https://Dragonliu2018.github.io/categories/课程/"/>
    
    
  </entry>
  
  <entry>
    <title>TopK问题</title>
    <link href="https://dragonliu2018.github.io/2021/07/24/TopK%E9%97%AE%E9%A2%98/"/>
    <id>https://dragonliu2018.github.io/2021/07/24/TopK%E9%97%AE%E9%A2%98/</id>
    <published>2021-07-24T08:57:42.000Z</published>
    <updated>2021-09-21T13:44:44.773Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。</p><p>请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><blockquote><p>参考：<a href="https://zhuanlan.zhihu.com/p/76734219" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/76734219</a></p></blockquote><h2 id="思路1-排序"><a href="#思路1-排序" class="headerlink" title="思路1 排序"></a>思路1 排序</h2><p>将n个数排序之后，取出第k大的数即可。</p><p>时间复杂度：$O(n*log(n))$</p><p>分析：明明只需要TopK，却将全局都排序了，这也是这个方法复杂度非常高的原因。那能不能不全局排序，而只局部排序呢？</p><h2 id="思路2-局部排序"><a href="#思路2-局部排序" class="headerlink" title="思路2 局部排序"></a>思路2 局部排序</h2><p>不再全局排序，只对最大的k个排序。冒泡是一个很常见的排序方法，每冒一个泡，找出最大值，冒k个泡，就得到TopK。</p><p>时间复杂度：$O(n*k)$</p><p>分析：冒泡，将全局排序优化为了局部排序，非TopK的元素是不需要排序的，节省了计算资源。不少朋友会想到，需求是TopK，是不是这最大的k个元素也不需要排序呢？</p><h2 id="思路3-堆"><a href="#思路3-堆" class="headerlink" title="* 思路3 堆"></a>* 思路3 堆</h2><p>思路：只找到TopK，不排序TopK。先用前k个元素生成一个小顶堆，这个小顶堆用于存储，当前最大的k个元素。接着，从第k+1个元素开始扫描，和堆顶（堆中最小的元素）比较，如果被扫描的元素大于堆顶，则替换堆顶的元素，并调整堆，以保证堆内的k个元素，总是当前最大的k个元素。直到，扫描完所有n-k个元素，最终堆中的k个元素，就是TopK。</p><p>时间复杂度：$O(n*log(k))$</p><p>画外音：n个元素扫一遍，假设运气很差，每次都入堆调整，调整时间复杂度为堆的高度，即$lg(k)$，故整体时间复杂度是$n*lg(k)$。</p><p>分析：堆，将冒泡的TopK排序优化为了TopK不排序，节省了计算资源。堆，是求TopK的经典算法，那还有没有更快的方案呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="思路4-Partition"><a href="#思路4-Partition" class="headerlink" title="思路4 Partition"></a>思路4 Partition</h2><p>除了用来进行快速排序，partition 还可以用 $O(N)$ 的平均时间复杂度解决TopK问题。和快排一样，这里也用到了分而治之的思想。首先用 partition 将数组分为两部分，得到分界点下标 pos，然后分三种情况：</p><ul><li>pos == k-1，则找到第 K 大的值，arr[pos]；</li><li>pos &gt; k-1，则第 K 大的值在左边部分的数组。</li><li>pos &lt; k-1，则第 K 大的值在右边部分的数组。</li></ul><p>下面给出基于迭代的实现（这里寻找第 k 小的数字）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[low];</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">while</span> (low &lt; high &amp;&amp; nums[high] &lt;= pivot) high--;</span><br><span class="line">            nums[low] = nums[high];</span><br><span class="line">            <span class="keyword">while</span> (low &lt; high &amp;&amp; nums[low] &gt;= pivot) low++;</span><br><span class="line">            nums[high] = nums[low];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[low] = pivot;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>, end = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (begin &lt; end) &#123;</span><br><span class="line">            <span class="keyword">int</span> pos = partition(nums, begin, end);</span><br><span class="line">            <span class="keyword">if</span> (pos == k - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[pos];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pos &lt; k - <span class="number">1</span>) &#123;</span><br><span class="line">                begin = pos + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                end = pos - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[begin];<span class="comment">//数组长度为1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：考虑最坏情况下，每次 partition 将数组分为长度为 $N-1$ 和 $1$ 的两部分，然后在长的一边继续寻找第 K 大，此时时间复杂度为 $O(N^2 )$。不过如果在开始之前将数组进行随机打乱，那么可以尽量避免最坏情况的出现（随机选择算在是《算法导论》中一个经典的算法，其时间复杂度为O(n)，是一个线性复杂度的方法。）。而在最好情况下，每次将数组均分为长度相同的两半，运行时间 $T(N) = N + T(N/2)$，时间复杂度是 $O(N)$。</p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><ol><li><a href="https://leetcode-cn.com/problems/smallest-k-lcci/" target="_blank" rel="noopener">leetcode——面试题 17.14. 最小K个数</a></li><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="面试篇" scheme="https://Dragonliu2018.github.io/categories/面试篇/"/>
    
    <category term="数据结构和算法" scheme="https://Dragonliu2018.github.io/categories/数据结构和算法/"/>
    
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="https://dragonliu2018.github.io/2021/07/23/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>https://dragonliu2018.github.io/2021/07/23/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2021-07-23T01:41:17.000Z</published>
    <updated>2021-09-21T13:40:26.797Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-最大子序和"><a href="#1-最大子序和" class="headerlink" title="1 最大子序和"></a>1 最大子序和</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>链接：<a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-subarray/</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li><strong>状态</strong>：$dp[i]$ 代表以$nums[i]$结尾的最大和</li><li><strong>状态转移方程</strong>：$dp[i] = max(dp[i-1]+nums[i], nums[i])$</li><li><strong>答案</strong>：$max(dp[0…n-1])$</li></ol><ul><li><strong>时间复杂度</strong>：循环执行 n 次，每次花费常数的时间代价，故渐进时间复杂度为 $O(n)$。</li><li><strong>空间复杂度</strong>：$O(n)$，可用滚动数组优化到$O(1)$。</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> pre = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> ans = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            pre = max(nums[i], pre + nums[i]);</span><br><span class="line">            ans = max(ans, pre);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="2-最长上升子序列"><a href="#2-最长上升子序列" class="headerlink" title="2 最长上升子序列"></a>2 最长上升子序列</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><p>链接：<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-increasing-subsequence/</a></p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><ol><li><strong>状态</strong>：$dp[i]$ 代表以$nums[i]$结尾的最长严格递增子序列的长度</li><li><strong>状态转移方程</strong>：$dp[i] = max(dp[j]+1,dp[i])$，$j<i$且$nums[i]>nums[j]$</i$且$nums[i]></li><li><strong>答案</strong>：$max(dp[0…n-1])$</li></ol><ul><li><strong>时间复杂度</strong>： $O(n^2)$</li><li><strong>空间复杂度</strong>： $O(n)$</li></ul><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> dp[n];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                    dp[i] = max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *max_element(dp, dp + n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><ol><li><a href></a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构和算法" scheme="https://Dragonliu2018.github.io/categories/数据结构和算法/"/>
    
    
    <category term="dp" scheme="https://Dragonliu2018.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>双指针</title>
    <link href="https://dragonliu2018.github.io/2021/07/22/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    <id>https://dragonliu2018.github.io/2021/07/22/%E5%8F%8C%E6%8C%87%E9%92%88/</id>
    <published>2021-07-22T11:52:41.000Z</published>
    <updated>2021-09-21T13:41:44.310Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-无重复字符的最长子串"><a href="#1-无重复字符的最长子串" class="headerlink" title="1 无重复字符的最长子串"></a>1 无重复字符的最长子串</h1><p>题目来源：<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">leetcode-3 无重复字符的最长子串</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先区分子串与子序列：子串必须连续，子序列可以不连续。</p><p>两层循环$O(n^2)$不太行，减少重复查询，可以用<strong>双指针</strong>维护一个<strong>滑动窗口</strong>，同时用一个数组标记滑动窗口内出现的字符。</p><ul><li><strong>时间复杂度</strong>：$O(N)$，其中 $N$ 是字符串的长度。左指针和右指针分别会遍历整个字符串一次。</li><li><strong>空间复杂度</strong>：$O(|\Sigma|)$，其中 $\Sigma$ 表示字符集（即字符串中可以出现的字符），$|\Sigma|$ 表示字符集的大小。在本题中没有明确说明字符集，因此可以默认为所有 ASCII 码在 $[0, 128)$ 内的字符，即 $|\Sigma| = 128$。</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">128</span>;<span class="comment">//字符范围</span></span><br><span class="line">        <span class="keyword">int</span> foot[maxn] = &#123;<span class="number">0</span>&#125;;<span class="comment">//标记滑动窗口中已经有的字符</span></span><br><span class="line">        <span class="keyword">int</span> len = s.size();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;<span class="comment">//空串</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;<span class="comment">//双指针维护窗口</span></span><br><span class="line">        foot[s[start]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; len - <span class="number">1</span>) &#123;</span><br><span class="line">            end++;<span class="comment">//后面的指针前进</span></span><br><span class="line">            <span class="keyword">while</span> (end &lt; len) &#123;</span><br><span class="line">                <span class="keyword">if</span> (foot[s[end]] == <span class="number">0</span>) &#123;</span><br><span class="line">                    foot[s[end]] = <span class="number">1</span>;</span><br><span class="line">                    end++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            end--;<span class="comment">//后面的指针回退</span></span><br><span class="line">            ans = max(ans, end - start + <span class="number">1</span>);</span><br><span class="line">            foot[s[start]] = <span class="number">0</span>;<span class="comment">//前面的指针前移</span></span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><ol><li><a href></a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构和算法" scheme="https://Dragonliu2018.github.io/categories/数据结构和算法/"/>
    
    
  </entry>
  
  <entry>
    <title>栈-队列-链表</title>
    <link href="https://dragonliu2018.github.io/2021/07/22/%E6%A0%88-%E9%98%9F%E5%88%97-%E9%93%BE%E8%A1%A8/"/>
    <id>https://dragonliu2018.github.io/2021/07/22/%E6%A0%88-%E9%98%9F%E5%88%97-%E9%93%BE%E8%A1%A8/</id>
    <published>2021-07-22T09:38:10.000Z</published>
    <updated>2021-09-21T13:42:20.835Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-栈"><a href="#1-栈" class="headerlink" title="1 栈"></a>1 栈</h1><ol><li><a href></a></li></ol><h1 id="2-队列"><a href="#2-队列" class="headerlink" title="2 队列"></a>2 队列</h1><ol><li><a href></a></li></ol><h1 id="3-链表"><a href="#3-链表" class="headerlink" title="3 链表"></a>3 链表</h1><ol><li><a href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener">leetcode-2 两数相加 (简单)</a>：链表遍历</li><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构和算法" scheme="https://Dragonliu2018.github.io/categories/数据结构和算法/"/>
    
    
  </entry>
  
  <entry>
    <title>STL</title>
    <link href="https://dragonliu2018.github.io/2021/07/22/STL/"/>
    <id>https://dragonliu2018.github.io/2021/07/22/STL/</id>
    <published>2021-07-22T03:54:23.000Z</published>
    <updated>2021-09-21T13:44:26.319Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-vector-向量"><a href="#1-vector-向量" class="headerlink" title="1 vector(向量)"></a>1 vector(向量)</h1><p>vector是与数组相关的序列式容器，set模版类的定义在头文件\<vector\>中。当我们在程序中需要使用动态数组时， vector将会是理想的选择， vector可以在使用过程中动态地增长存储空间。</vector\></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; s;<span class="comment">// 定义⼀个空的vector对象，存储的是int类型的元素</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">s</span><span class="params">(n)</span></span>;<span class="comment">// 定义⼀个含有n个int元素的vector对象</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">s</span><span class="params">(first, last)</span></span>;<span class="comment">// 从由迭代器first和last定义的序列[first, last)中复制初值初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本操作</span></span><br><span class="line">s[i] <span class="comment">// 直接以下标⽅式访问容器中的元素，编号从0开始</span></span><br><span class="line">s.front() <span class="comment">// 返回⾸元素</span></span><br><span class="line">s.back() <span class="comment">// 返回尾元素</span></span><br><span class="line">s.push_back(x) <span class="comment">// 向表尾插⼊元素x</span></span><br><span class="line">s.pop_back() <span class="comment">// 删除表尾元素</span></span><br><span class="line">s.size() <span class="comment">// 返回表⻓</span></span><br><span class="line">s.empty() <span class="comment">// 表为空时，返回真，否则返回假</span></span><br><span class="line">s.begin() <span class="comment">// 返回指向⾸元素的随机存取迭代器</span></span><br><span class="line">s.end() <span class="comment">// 返回指向尾元素的下⼀个位置的随机存取迭代器</span></span><br><span class="line">s.insert(it, val) <span class="comment">// 向迭代器it指向的元素前插⼊新元素val</span></span><br><span class="line">s.insert(it, n, val) <span class="comment">// 向迭代器it指向的元素前插⼊n个新元素val</span></span><br><span class="line">s.insert(it, first, last)<span class="comment">// 向迭代器it指向的元素前插⼊迭代器first和last所指定的序列[first, last)</span></span><br><span class="line">s.erase(it) <span class="comment">// 删除由迭代器it所指向的元素</span></span><br><span class="line">s.erase(first, last) <span class="comment">// 删除由迭代器first和last所指定的序列[first, last)</span></span><br><span class="line">s.reserve(n) <span class="comment">// 预分配缓冲空间，使存储空间至少可容纳n个元素</span></span><br><span class="line">s.resize(n) <span class="comment">// 改变序列长度，超出的元素将会全部被删除，需要扩展(原空间小于n)的用元素默认值填满</span></span><br><span class="line">s.resize(n, val) <span class="comment">// 改变序列长度，超出的元素将会全部被删除，需要扩展(原空间小于n)的用元素val填满</span></span><br><span class="line">s.clear() <span class="comment">// 删除容器中的所有元素。resize和clear是对表的有效元素进行的操作，但不⼀定改变缓冲空间的⼤小</span></span><br><span class="line">s.swap(v) <span class="comment">// 将s与另⼀个vector对象进行交换</span></span><br><span class="line">s.assign(first, last)<span class="comment">// 将序列替换成由迭代器指示的[first, last)，不能是原序列中的⼀部分</span></span><br><span class="line"><span class="keyword">operator</span>: &gt; &lt; &gt;= &lt;= == != <span class="comment">//按照字典序⽐较两个序列</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 组合操作</span></span><br><span class="line">s.insert(s.begin(), x) <span class="comment">// 向表头插⼊元素x</span></span><br><span class="line">s.erase(s.begin()) <span class="comment">// 删除表头元素</span></span><br><span class="line">reverse(s.begin(), s.end()) <span class="comment">// 反转向量</span></span><br><span class="line">sort(s.begin(), s.end()) <span class="comment">// 排序</span></span><br></pre></td></tr></table></figure><h1 id="2-pair-二元组"><a href="#2-pair-二元组" class="headerlink" title="2 pair(二元组)"></a>2 pair(二元组)</h1><p>pair用来表示一个二元组或元素对，定义在头文件\<utility\>中。pair模版类需要两个参数：首元素的数据类型和尾元素的数据类型。 pair模版类对象有两个成员： first和second，分别表示首元素和尾元素。  </utility\></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line">pair&lt;<span class="keyword">double</span>, <span class="keyword">double</span>&gt; p;</span><br><span class="line">p = make_pair(<span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本操作</span></span><br><span class="line"><span class="keyword">operator</span>: &lt; &gt; &lt;= &gt;= == != <span class="comment">// 其规则是先⽐较first， first相等时再比较second，这符合⼤多数应⽤的逻辑</span></span><br></pre></td></tr></table></figure><h1 id="3-set-集合"><a href="#3-set-集合" class="headerlink" title="3 set(集合)"></a>3 set(集合)</h1><p>set是与集合相关的关联式容器，set模版类的定义在头文件\<set\>中。在set中每个元素的值都唯一，而且系统能根据元素的值自动进行排序(默认升序)。set中元素的值不能直接被改变。</set\></p><p>标准库提供set关联容器分为：</p><ol><li>按关键字有序保存元素：set(关键字即值，即只保存关键字的容器)；multiset(关键字可重复出现的set)；</li><li>无序集合：unordered_set(用哈希函数组织的set)；unordered_multiset(哈希组织的set，关键字可以重复出现)。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="built_in">set</span>&lt;T&gt; s;</span><br><span class="line"><span class="built_in">set</span>&lt;T&gt;::iterator it;<span class="comment">//迭代器</span></span><br><span class="line"><span class="keyword">int</span> arr[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="function"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ss</span><span class="params">(arr, arr+<span class="number">4</span>)</span></span>;<span class="comment">//数组初始化</span></span><br><span class="line"><span class="function"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ss</span><span class="params">(s)</span></span>;<span class="comment">//集合初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本操作</span></span><br><span class="line">s.begin() <span class="comment">// 返回指向第⼀个元素的迭代器，如果set为空则返回的迭代器不能解引用</span></span><br><span class="line">s.clear() <span class="comment">// 清除所有元素</span></span><br><span class="line">s.count(T) <span class="comment">// 返回某个元素的个数，多重集合也是返回个数</span></span><br><span class="line">s.empty() <span class="comment">// 如果集合为空，返回true(真）</span></span><br><span class="line">s.end() <span class="comment">// 返回指向最后⼀个元素之后的迭代器，不是最后⼀个元素</span></span><br><span class="line">s.equal_range(T) <span class="comment">// 返回集合中与给定值相等的上下限的两个迭代器(pair)</span></span><br><span class="line">s.erase(T) <span class="comment">// 删除迭代器指定位置的元素或与对象匹配的元素</span></span><br><span class="line">s.find(T) <span class="comment">// 返回⼀个指向被查找到元素的迭代器</span></span><br><span class="line">s.get_allocator() <span class="comment">// 返回集合的分配器</span></span><br><span class="line">s.insert(T) <span class="comment">// 在集合中插⼊元素</span></span><br><span class="line">s.lower_bound(T) <span class="comment">// 返回指向⼤于（或等于）某值的第⼀个元素的迭代器</span></span><br><span class="line">s.key_comp() <span class="comment">// 返回⼀个⽤于元素间值⽐较的函数，默认operator&lt;</span></span><br><span class="line">s.max_size() <span class="comment">// 返回集合能容纳的元素的最⼤限值</span></span><br><span class="line">s.rbegin() <span class="comment">// 返回指向集合中最后⼀个元素的反向迭代器</span></span><br><span class="line">s.rend() <span class="comment">// 返回指向集合中第⼀个元素的反向迭代器</span></span><br><span class="line">s.size() <span class="comment">// 集合中元素的数⽬</span></span><br><span class="line">s.swap(<span class="built_in">set</span>&lt;T&gt;) <span class="comment">// 交换两个集合变量</span></span><br><span class="line">s.upper_bound(T) <span class="comment">// 返回⼤于某个值元素的迭代器</span></span><br><span class="line">s.value_comp() <span class="comment">// 返回⼀个⽤于⽐较元素间的值的函数</span></span><br><span class="line"><span class="comment">//遍历输出</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> ptr = s.begin(); ptr != s.end(); ptr++) &#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; *ptr&lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 修改排序</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; u, <span class="keyword">const</span> <span class="keyword">int</span>&amp; v)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(u - v) &lt;= k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> u &lt; v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>, cmp&gt; se;</span><br></pre></td></tr></table></figure><h1 id="4-string-字符串"><a href="#4-string-字符串" class="headerlink" title="4 string(字符串)"></a>4 string(字符串)</h1><p>string类的定义在头文件$<string>$中。string类其实可以看作是一个字符的vector， vector上的各种操作都可以适用于string，另外，string类对象还支持字符串的拼合、转换等操作。  </string></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本操作</span></span><br><span class="line"><span class="keyword">operator</span> + <span class="comment">// 拼合</span></span><br><span class="line"><span class="comment">//string转char指针</span></span><br><span class="line"><span class="keyword">char</span> *p=(<span class="keyword">char</span>*)str.c_str();</span><br><span class="line"><span class="keyword">char</span>*p=(<span class="keyword">char</span>*)str.data();</span><br><span class="line"><span class="comment">// 关于输入</span></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt; str;<span class="comment">//接受空、回车格结尾的字符串</span></span><br><span class="line"><span class="built_in">cin</span>.ignore();<span class="comment">//配合使用，清除以回车结束的输入缓冲区的内容 </span></span><br><span class="line">getline(<span class="built_in">cin</span>, str);<span class="comment">//读取一行</span></span><br><span class="line"><span class="comment">//字串型的串流，用于按空格间隔的字串分割</span></span><br><span class="line"><span class="built_in">stringstream</span> ss;</span><br><span class="line">ss&lt;&lt; str;<span class="comment">//输入str到ss(屏幕)，看方向</span></span><br><span class="line">ss&gt;&gt; str;<span class="comment">//ss(屏幕)输入到str</span></span><br><span class="line"><span class="comment">//@brief: 指定单个分隔符（单个字符或子串）分割字符串</span></span><br><span class="line"><span class="comment">//@param: src 原字符串；delimiter 分隔符，单个字符或子串</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">splitStr</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; src, <span class="keyword">const</span> <span class="built_in">string</span>&amp; delimiter)</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vetStr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入参检查</span></span><br><span class="line"><span class="comment">// 1.原字符串为空或等于分隔符，返回空 vector</span></span><br><span class="line"><span class="keyword">if</span> (src == <span class="string">""</span> || src == delimiter) &#123;</span><br><span class="line"><span class="keyword">return</span> vetStr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2.分隔符为空返回单个元素为原字符串的 vector</span></span><br><span class="line"><span class="keyword">if</span> (delimiter == <span class="string">""</span>) &#123;</span><br><span class="line">vetStr.push_back(src);</span><br><span class="line"><span class="keyword">return</span> vetStr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span>::size_type startPos = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> index = src.find(delimiter);</span><br><span class="line"><span class="keyword">while</span> (index != <span class="built_in">string</span>::npos) &#123;</span><br><span class="line"><span class="keyword">auto</span> str = src.substr(startPos, index - startPos);</span><br><span class="line"><span class="keyword">if</span> (str != <span class="string">""</span>) &#123;</span><br><span class="line">vetStr.push_back(str);</span><br><span class="line">&#125;</span><br><span class="line">startPos = index + delimiter.length();</span><br><span class="line">index = src.find(delimiter, startPos);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 取最后一个子串</span></span><br><span class="line"><span class="keyword">auto</span> str = src.substr(startPos);</span><br><span class="line"><span class="keyword">if</span> (str != <span class="string">""</span>) &#123;</span><br><span class="line">vetStr.push_back(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> vetStr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//char字符处理</span></span><br><span class="line"><span class="built_in">isalpha</span>(ch);<span class="comment">//字母（不区分大小写）</span></span><br><span class="line"><span class="built_in">isupper</span>(ch);<span class="comment">//大写字母</span></span><br><span class="line"><span class="built_in">islower</span>();<span class="comment">//小写字母</span></span><br><span class="line"><span class="built_in">isdigit</span>();<span class="comment">//数字</span></span><br><span class="line"><span class="built_in">isalnum</span>();<span class="comment">//字母或数字</span></span><br><span class="line"><span class="built_in">toupper</span>();<span class="comment">//转大写</span></span><br><span class="line"><span class="built_in">tolower</span>();<span class="comment">//转小写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//string转int等类型</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stoi</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;  str, <span class="keyword">size_t</span>* idx = <span class="number">0</span>, <span class="keyword">int</span> base = <span class="number">10</span>)</span></span>;<span class="comment">//*idx是指向size_t类型对象的指针，其值由函数设置为数值后str中下一个字符的位置；base是指str的基数，默认十进制</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">stol</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;  str, <span class="keyword">size_t</span>* idx = <span class="number">0</span>, <span class="keyword">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">stoul</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;  str, <span class="keyword">size_t</span>* idx = <span class="number">0</span>, <span class="keyword">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">stoll</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;  str, <span class="keyword">size_t</span>* idx = <span class="number">0</span>, <span class="keyword">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">stoull</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;  str, <span class="keyword">size_t</span>* idx = <span class="number">0</span>, <span class="keyword">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">stof</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;  str, <span class="keyword">size_t</span>* idx = <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">stod</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;  str, <span class="keyword">size_t</span>* idx = <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">double</span> <span class="title">stold</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;  str, <span class="keyword">size_t</span>* idx = <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//int等类型转string</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span> <span class="params">(T)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//find函数</span></span><br><span class="line">str.find(tmp_str);<span class="comment">//返回下标位置，没有则返回str.npos</span></span><br><span class="line">str.find_first_of(tmp_str);<span class="comment">//第一次出现的位置</span></span><br><span class="line">str.find_last_of(tmp_str);<span class="comment">//最后一次出现的位置</span></span><br><span class="line">str.find(tmp_str, pos);<span class="comment">//从下标pos开始查找</span></span><br><span class="line">str.rfind(tmp_str);<span class="comment">//反向查找，与正向查找结合确定子串的唯一性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//取子串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">substr</span> <span class="params">(<span class="keyword">size_t</span> pos = <span class="number">0</span>, <span class="keyword">size_t</span> len = npos)</span> <span class="keyword">const</span></span>;<span class="comment">//在字符位置pos开始，跨越len个字符（或直到字符串的结尾，以先到者为准）对象的部分</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串大小写转化</span></span><br><span class="line">transform(s.begin(),s.end(),s.begin(),::<span class="built_in">tolower</span>);</span><br><span class="line">transform(s.begin(),s.end(),s.begin(),::<span class="built_in">toupper</span>);</span><br></pre></td></tr></table></figure><h1 id="5-list-列表"><a href="#5-list-列表" class="headerlink" title="5 list(列表)"></a>5 list(列表)</h1><p>list是由双向链表实现的，因此内存空间是不连续的。只能通过指针访问数据，所以list的随机存取非常没有效率，时间复杂度为$O(n)$；但由于链表的特点，能高效地进行插入和删除。</p><p>使用：</p><ul><li>需要高效的随机存取，而不在乎插入和删除的效率，使用vector;</li><li>如果需要大量的插入和删除，而不关心随机存取，则应使用list</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; l;<span class="comment">//声明一个空列表</span></span><br><span class="line"><span class="function"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">l</span><span class="params">(n)</span></span>;<span class="comment">//声明一个有n个元素的列表，每个元素都是由其默认构造函数T()构造出来的</span></span><br><span class="line"><span class="function"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">l</span><span class="params">(n,val)</span></span>;<span class="comment">//声明一个由n个元素的列表，每个元素都是由其复制构造函数T(val)得来的</span></span><br><span class="line"><span class="function"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">l</span><span class="params">()</span></span>;<span class="comment">//声明一个空列表</span></span><br><span class="line"><span class="function"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">l</span><span class="params">(first,last)</span></span>;<span class="comment">//声明一个列表，其元素的初始值由区间所指定的序列中的元素;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本操作</span></span><br><span class="line">l.begin() <span class="comment">// 得到一个指向容器起始位置的iterator</span></span><br><span class="line">l.end() <span class="comment">//返回list末端下一位置，如a[n]中的第n+1个位置a[n]，实际是不存在，经常作为循环结束判断条件使用</span></span><br><span class="line">l.push_back(x) <span class="comment">//list的末端插入x</span></span><br><span class="line">l.push_front(x) <span class="comment">// 从list的头部插入x</span></span><br><span class="line">l.empty() <span class="comment">// 利用empty() 判断list是否为空，空返回true</span></span><br><span class="line">l.resize(n) <span class="comment">//将l的长度改为n，超出的元素将被删除，如果需要扩展那么调用默认构造函数T()将元素加到list末端</span></span><br><span class="line">l.resize(n, val)<span class="comment">//扩展元素要调用构造函数T(val)函数进行元素构造，其余部分与resize相同</span></span><br><span class="line">l.clear() <span class="comment">//清空list中的所有元素</span></span><br><span class="line">l.front() <span class="comment">//获得list容器中的头部元素</span></span><br><span class="line">l.back() <span class="comment">//可以获得list容器的最后一个元素</span></span><br><span class="line">l.pop_back <span class="comment">// 删除最后一个元素</span></span><br><span class="line">l.pop_front() <span class="comment">// 删除第一个元素；序列必须不为空，当list为空时调用pop_back和pop_front会使程序崩掉</span></span><br><span class="line">l.assign() <span class="comment">//具体和vector中的操作类似</span></span><br><span class="line">l.swap(ll) <span class="comment">//交换两个链表，swap(l ,ll)也可</span></span><br><span class="line">merge() <span class="comment">//合并两个链表并使之默认升序(也可改)，l1.merge(l2，greater&lt;int&gt;()); 调用结束后l2变为空，l1中元素包含原来l1 和 l2中的元素，并且排好序，升序。其实默认是升序，greater&lt;int&gt;()可以省略，另外greater&lt;int&gt;()是可以变的，也可以不按升序排列。</span></span><br></pre></td></tr></table></figure><h1 id="6-stack-栈"><a href="#6-stack-栈" class="headerlink" title="6 stack(栈)"></a>6 stack(栈)</h1><p>stack模版类的定义在\<stack\>头文件中，stack模版类需要两个模版参数，一个是元素类型，另一个是容器类型，但是只有元素类型是必要的，在不指定容器类型时，默认容器的类型为deque。</stack\></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本操作</span></span><br><span class="line">s.push(x); <span class="comment">// ⼊栈</span></span><br><span class="line">s.pop(); <span class="comment">// 出栈，不返回值</span></span><br><span class="line">x = s.top(); <span class="comment">// 访问栈顶，</span></span><br><span class="line">s.empty(); <span class="comment">// 当栈空时，返回true</span></span><br><span class="line">s.size(); <span class="comment">// 访问栈中元素个数</span></span><br></pre></td></tr></table></figure><h1 id="7-queue-队列"><a href="#7-queue-队列" class="headerlink" title="7 queue(队列)"></a>7 queue(队列)</h1><p>queue模版类的定义在头文件\<queue\>中。queue与stack相似， queue模版类也需要两个模版参数，一个元素类型，一个容器类型，元素类型是必须的，容器类型是可选的。  </queue\></p><p>标准库提供queue分为：</p><ol><li>queue(队列)：queue从队首弹出，先入先出，并且queue只能从队首删除元素，但是两端都能访问。</li><li>deque(双向队列)：可以访问两端并且可以在队首和队尾删除和插入元素</li><li>priority_queue(优先队列)：优先队列与队列的差别在于优先队列不是按照入队的顺序出队，而是按照队列中元素的优先权出队列（默认为大者优先，也可以通过指定算子来指定自己的优先顺序）；priority_queue模版类有三个模版参数，第一个是元素类型，第二个是容器类型，第三个是比较算子。其中后两者都可以忽略，默认容器为vector，默认算子为less，即小的往前排，大的往后排（出队列时列尾元素先出队）。  </li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 队列定义</span></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列基本操作</span></span><br><span class="line">q.push(x); <span class="comment">// 从队尾⼊队列</span></span><br><span class="line">q.pop(); <span class="comment">// 从队首出队列</span></span><br><span class="line">q.front(); <span class="comment">// 访问队首元素</span></span><br><span class="line">q.back(); <span class="comment">// 访问队尾元素</span></span><br><span class="line">q.empty(); <span class="comment">// 如果队列为空，则返回true，否则返回false</span></span><br><span class="line">q.size(); <span class="comment">// 访问队列中的元素个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向队列定义</span></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; dq; <span class="comment">//创建一个int双端队列dq</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向队列基本操作</span></span><br><span class="line">dq.empty(); <span class="comment">//判断队列是否为空，为空返回true</span></span><br><span class="line">dq.push_front(s); <span class="comment">//将s从队头入队</span></span><br><span class="line">dq.push_back(s); <span class="comment">//将s从队尾入队，和普通队列方式一样</span></span><br><span class="line">dq.front(); <span class="comment">//只返回队头元素</span></span><br><span class="line">dq.back(); <span class="comment">//只返回队尾元素</span></span><br><span class="line">dq.pop_front(); <span class="comment">//将队头元素弹出</span></span><br><span class="line">dq.pop_back(); <span class="comment">//将队尾元素弹出</span></span><br><span class="line">dq.clear(); <span class="comment">//将队列清空</span></span><br><span class="line"><span class="comment">//组合操作</span></span><br><span class="line"><span class="comment">//C++中的queue自身是不支持clear操作的，但是双端队列deque是支持clear操作的。</span></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; empty;</span><br><span class="line">swap(empty, q);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优先队列定义</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; qq; <span class="comment">// 注意在两个尖括号之间⼀定要留空格，防止误判</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; qqq; <span class="comment">// 定义小的先出队列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 优先队列基本操作</span></span><br><span class="line">q.empty() <span class="comment">// 如果队列为空，则返回true，否则返回false</span></span><br><span class="line">q.size() <span class="comment">// 返回队列中元素的个数</span></span><br><span class="line">q.pop() <span class="comment">// 删除队首元素，但不返回其值</span></span><br><span class="line">q.top() <span class="comment">// 返回具有最高优先级的元素值，但不删除该元素</span></span><br><span class="line">q.push(x) <span class="comment">// 在基于优先级的适当位置插⼊新元素x</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 算子实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> x, y, z;</span><br><span class="line">T(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c) : x(a), y(b), z(c) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> T &amp;tOne, <span class="keyword">const</span> T &amp;tTwo)&#123;</span><br><span class="line"><span class="keyword">return</span> tOne.z &lt; tTwo.z; <span class="comment">// 按照z的顺序来决定tOne和tTwo的顺序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">priority_queue&lt;T&gt; q;</span><br><span class="line">q.push(T(<span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>));</span><br><span class="line">q.push(T(<span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>));</span><br><span class="line">q.push(T(<span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>));</span><br><span class="line">q.push(T(<span class="number">3</span>, <span class="number">3</span>, <span class="number">6</span>));</span><br><span class="line"><span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">T t = q.top();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; t.x &lt;&lt; <span class="string">" "</span> &lt;&lt; t.y &lt;&lt; <span class="string">" "</span> &lt;&lt; t.z &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8-map-字典"><a href="#8-map-字典" class="headerlink" title="8 map(字典)"></a>8 map(字典)</h1><p>map是与字典相关的关联式容器，map模版类的定义在头文件$<map>$中，用有序二叉树表存储类型为pair<const key, t>的元素对序列。  序列中的元素以const Key部分作为标识， map中所有元素的Key值必须是唯一的，multimap则允许有重复的Key值。unordered_map是无序 map 容器。</const></map></p><p>将map可以通过一个Key值来快速决定一个元素，因此非常适合于需要按照Key值查找元素的容器。map模版类需要四个模版参数，第一个是键值类型，第二个是元素类型，第三个是比较算子，第四个是分配器类型。其中键值类型和元素类型是必要的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字典定义</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字典基本操作</span></span><br><span class="line"><span class="comment">/* 向map中插⼊元素 */</span></span><br><span class="line">m[key] = value; <span class="comment">// [key]操作是map很有特色的操作,如果在map中存在键值为key的元素对, 则返回该元素对的值域部分,否则将会创建⼀个键值为key的元素对,值域为默认值。所以可以⽤该操作向map中插⼊元素对或修改已经存在的元素对的值域部分。</span></span><br><span class="line">m.insert(make_pair(key, value)); <span class="comment">// 也可以直接调用insert方法插⼊元素对,insert操作会返回⼀个pair,当map中没有与key相匹配的键值时,其first是指向插⼊元素对的迭代器,其second为true;若map中已经存在与key相等的键值时,其first是指向该元素对的迭代器,second为false，并且不会更新value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查找元素 */</span></span><br><span class="line"><span class="keyword">int</span> i = m[key]; <span class="comment">// key不存在时,会创建键值为key(当另⼀个元素是整型时m[key]=0)的元素对</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator it = m.find(key); <span class="comment">// 如果map中存在与key相匹配的键值时,find操作将返</span></span><br><span class="line"><span class="comment">//回指向该元素对的迭代器,否则,返回的迭代器等于map的end()(参见vector中提到的begin()和end()操作)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 删除元素 */</span></span><br><span class="line">m.erase(key); <span class="comment">// 删除与指定key键值相匹配的元素对,并返回被删除的元素的个数</span></span><br><span class="line">m.erase(it); <span class="comment">// 删除由迭代器it所指定的元素对,并返回指向下⼀个元素对的迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 其他操作 */</span></span><br><span class="line">m.size(); <span class="comment">// 返回元素个数</span></span><br><span class="line">m.empty(); <span class="comment">// 判断是否为空，空返回true</span></span><br><span class="line">m.clear(); <span class="comment">// 清空所有元素</span></span><br><span class="line"><span class="function">size_type <span class="title">count</span> <span class="params">(<span class="keyword">const</span> key_type&amp; k)</span> <span class="keyword">const</span></span>;<span class="comment">//按key搜索</span></span><br></pre></td></tr></table></figure><h1 id="9-bitset"><a href="#9-bitset" class="headerlink" title="9 bitset()"></a>9 bitset()</h1><p>bitset模版类的定义在\<bitset\>头文件中，用来方便地管理一系列的bit位类。 bitset除了可以访问指定下标的bit位以外，还可以把它们作为一个整数来进行某些统计。bitset模板类需要一个模版参数，用来明确指定含有多少位。  </bitset\></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">32</span>;</span><br><span class="line"><span class="built_in">bitset</span>&lt;MAXN&gt; bt; <span class="comment">// bt 包括 MAXN 位，下标 0 ~ MAXN - 1，默认初始化为 0</span></span><br><span class="line"><span class="function"><span class="built_in">bitset</span>&lt;MAXN&gt; <span class="title">bt1</span><span class="params">(<span class="number">0xf</span>)</span></span>; <span class="comment">// 0xf 表示十六进制数 f，对应二进制 1111，将 bt1 低 4 位初始化为 1</span></span><br><span class="line"><span class="function"><span class="built_in">bitset</span>&lt;MAXN&gt; <span class="title">bt2</span><span class="params">(<span class="number">012</span>)</span></span>; <span class="comment">// 012 表示八进制数 12，对应二进制 1010，即将 bt2 低 4 位初始化为 1010</span></span><br><span class="line"><span class="function"><span class="built_in">bitset</span>&lt;MAXN&gt; <span class="title">bt3</span><span class="params">(<span class="string">"1010"</span>)</span></span>; <span class="comment">// 将 bt3 低 4 位初始化为 1010</span></span><br><span class="line"><span class="function"><span class="built_in">bitset</span>&lt;MAXN&gt; <span class="title">bt4</span><span class="params">(s, pos, n)</span></span>; <span class="comment">// 将 01 字符串 s 的 pos 位开始的 n 位初始化 bt4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本操作</span></span><br><span class="line">bt.any() <span class="comment">// bt 中是否存在置为 1 的二进制位</span></span><br><span class="line">bt.none() <span class="comment">// bt 中不存在置为 1 的二进制位</span></span><br><span class="line">bt.count() <span class="comment">// bt 中置为 1 的二进制位的个数</span></span><br><span class="line">bt.size() <span class="comment">// bt 中二进制位的个数</span></span><br><span class="line">bt[pos] <span class="comment">// 访问 bt 中在 pos 处的二进制位</span></span><br><span class="line">bt.test(pos) <span class="comment">// bt 中在 pos 处的二进制位是否为 1</span></span><br><span class="line">bt.<span class="built_in">set</span>() <span class="comment">// 把 bt 中所有二进制位都置为 1</span></span><br><span class="line">bt.<span class="built_in">set</span>(pos) <span class="comment">// 把 bt 中在 pos 处的二进制位置为 1</span></span><br><span class="line">bt.reset() <span class="comment">// 把 bt 中所有二进制位都置为 0</span></span><br><span class="line">bt.reset(pos) <span class="comment">// 把 bt 中在pos处的二进制位置为0</span></span><br><span class="line">bt.flip() <span class="comment">// 把 bt 中所有二进制位逐位取反</span></span><br><span class="line">bt.flip(pos) <span class="comment">// 把 bt 中在 pos 处的二进制位取反</span></span><br><span class="line">bt[pos].flip() <span class="comment">// 同上</span></span><br><span class="line">bt.to_ulong() <span class="comment">// ⽤用 bt 中同样的二进制位返回⼀个 unsigned long 值</span></span><br><span class="line">bt.to_string()<span class="comment">//转字符串</span></span><br><span class="line">os &lt;&lt; bt <span class="comment">// 把 bt 中的位集输出到 os 流</span></span><br></pre></td></tr></table></figure><h1 id="10-iterator-迭代器"><a href="#10-iterator-迭代器" class="headerlink" title="10 iterator(迭代器)"></a>10 iterator(迭代器)</h1><p>iterator（迭代器）是用于访问容器中元素的指示器，从这个意义上说， iterator（迭代器）相当于数据结构中所说的“遍历指针”，也可以把iterator（迭代器）看作是一种泛化的指针。每种STL容器都有自己的iterator（迭代器）子类。</p><h1 id="11-algorithm"><a href="#11-algorithm" class="headerlink" title="11 algorithm"></a>11 algorithm</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">max_element(v.begin(),v.end()); <span class="comment">//返回容器最大值的迭代器</span></span><br><span class="line">min_element(v.begin(),v.end()); <span class="comment">//返回容器最小值的迭代器</span></span><br><span class="line">sort(v.begin(), v.end(), cmp); <span class="comment">//cmp可以自定义，默认升序排序</span></span><br><span class="line">reverse(v.begin(), v.end()); <span class="comment">//反转容器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">memset</span> <span class="params">( <span class="keyword">void</span> * ptr, <span class="keyword">int</span> value, <span class="keyword">size_t</span> num )</span></span>;<span class="comment">//将ptr所指向的某一块内存中的前num个字节的内容全部设置为ch指定的ASCII值， 第一个值为指定的内存地址，块的大小由第三个参数指定，这个函数通常为新申请的内存做初始化工作， 其返回值为指向s的指针，它是对较大的结构体或数组进行清零操作的一种最快方法。</span></span><br><span class="line">fill(begin, last, val);<span class="comment">//将[begin, last)赋值为val</span></span><br><span class="line"><span class="built_in">memcpy</span>(target, source, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*k);<span class="comment">//复制source数组的前k个到target</span></span><br><span class="line"><span class="built_in">memcpy</span>(target, source, <span class="keyword">sizeof</span>(source));<span class="comment">//复制source数组到target</span></span><br><span class="line">lower_bound(a, a+n, x);<span class="comment">//查找&gt;=x的第一个位置</span></span><br><span class="line">__gcd(<span class="keyword">int</span> x, <span class="keyword">int</span> y)<span class="comment">//求x与y的最大公约数</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构和算法" scheme="https://Dragonliu2018.github.io/categories/数据结构和算法/"/>
    
    
  </entry>
  
  <entry>
    <title>哈希表</title>
    <link href="https://dragonliu2018.github.io/2021/07/22/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <id>https://dragonliu2018.github.io/2021/07/22/%E5%93%88%E5%B8%8C%E8%A1%A8/</id>
    <published>2021-07-22T02:30:22.000Z</published>
    <updated>2021-09-21T13:41:08.779Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p>散列表（Hash Table），又称哈希表。是一种数据结构，特点是：数据元素的关键字与其存储地址直接相关，通过“散列函数（哈希函数）”：$Addr=H(key)$。</p><p>若不同的关键字通过散列函数映射到同一个值，则称它们为“同义词”</p><p>通过散列函数确定的位置已经存放了其他元素，则称这种情况为“冲突”</p><h1 id="常见的散列函数"><a href="#常见的散列函数" class="headerlink" title="常见的散列函数"></a>常见的散列函数</h1><ol><li>除留余数法——$H(key)=key\%p$，散列表表长为$m$，取一个不大于$m$但最接近或等于$m$的质数$p$</li><li>直接定址法——$H(key)=key$ 或$H(key)=a*key +b$，其中，a和b是常数。这种方法计算最简单，且不会产生冲突。它适合关键字的分布基本连续的情况，若关键字分布不连续，空位较多，则会造成存储空间的浪费。</li><li>数字分析法——选取数码分布较为均匀的若干位作为散列地址，如手机号码。</li><li>平方取中法——取关键字的平方值的中间几位作为散列地址。具体取多少位要视实际情况而定。这种方法得到的散列地址与关键字的每位都有关系，因此使得散列地址分布比较均匀，适用于关键字的每位取值都不够均匀或均小于散列地址所需的位数。如身份证号。</li></ol><h1 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h1><ol><li>拉链法：把所有“同义词”存储在一个链表中，Java中的HashMap、HashSet</li><li>开放定址法：可存放新表项的空闲地址既向它的同义词表项开放，又向它的非同义词表项开放。其数学递推公式为：$H<em>{i}=\left(H(k e y)+d</em>{i}\right) \% m$，$i=0,1,2, \ldots, k \quad(k \leqslant m-1)$，其中$m$表示散列表表长；$d_i$为增量序列；$i$可理解为“第$i$次发生冲突”<ul><li>线性探测法：$d_{i}=0,1,2,3, \ldots, m-1$; 即发生冲突时，每次往后探测相邻的下一个单元是否为空<ul><li>线性探测法很容易造成同义词、非同义词的“聚集（堆积）”现象，严重影响查找效率</li><li>产生原因——冲突后再探测一定是放在某个连续的位置</li></ul></li><li>平方探测法：当 $\mathrm{d}_{\mathrm{i}}=\mathbf{0}^{2}, \mathbf{1}^{2},-\mathbf{1}^{2}, \mathbf{2}^{2},-\mathbf{2}^{2}, \ldots, \mathbf{k}^{2},-\mathbf{k}^{2}$ 时，称为平方探测法，又称二次探测法其中 $\mathbf{k} \leq \mathbf{m} / \mathbf{2}$<ul><li>比起线性探测法更不易产生“聚集（堆积）”问题</li><li>散列表长度m必须是一个可以表示成$4j+3$的素数，才能探测到所有位置</li></ul></li><li>伪随机序列法：$\mathbf{d}<em>{\mathrm{i}}$ 是一个伪随机序列，如 $\mathrm{d}</em>{\mathrm{i}}=\mathbf{0 , 5 , 2 4 , 1 1 , \ldots}$</li></ul></li><li>再散列法：除了原始的散列函数$H(key)$之外，多准备几个散列函数，当散列函数冲突时，用下一个散列函数计算一个新地址，直到不冲突为止：$\mathrm{H}<em>{\mathrm{i}}=\mathrm{RH}</em>{\mathrm{i}}(\mathrm{Key}) \quad \mathrm{i}=1,2,3 \ldots ., \mathrm{k}$</li></ol><h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><ul><li>无序集合：unordered_set</li><li>无序字典：unordered_map</li></ul><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><ol><li><a href="https://www.luogu.com.cn/problem/P4305" target="_blank" rel="noopener">洛谷——P4305 [JLOI2011]不重复数字</a>：需要加快读</li><li><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">leetcode-1 两数之和 (简单)</a></li><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构和算法" scheme="https://Dragonliu2018.github.io/categories/数据结构和算法/"/>
    
    
    <category term="数据结构" scheme="https://Dragonliu2018.github.io/tags/数据结构/"/>
    
  </entry>
  
  <entry>
    <title>KMP算法</title>
    <link href="https://dragonliu2018.github.io/2021/04/10/KMP%E7%AE%97%E6%B3%95/"/>
    <id>https://dragonliu2018.github.io/2021/04/10/KMP%E7%AE%97%E6%B3%95/</id>
    <published>2021-04-10T09:18:30.000Z</published>
    <updated>2021-09-21T13:44:08.229Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-算法思想"><a href="#1-算法思想" class="headerlink" title="1 算法思想"></a>1 算法思想</h1><h2 id="1-1-思路"><a href="#1-1-思路" class="headerlink" title="1.1 思路"></a>1.1 思路</h2><p><strong>解决问题</strong>：当主串中第 i 个字符与模式中第 j 个字符失配（即比较不相等）时，主串中第 i 个字符（i 指针不回溯）应与模式中哪个字符再比较。</p><ol><li><p>$next[j]$：模式中第 j 个字符失配时，在模式中重新与主串比较的字符位置（最长公共前后缀长度+1，下标从 1 开始）</p><p>$\text { next }[j]=\left{\begin{array}{ll}<br>0 &amp; \text { 当 } j=1 \text { 时 } \<br>\operatorname{Max}\left{k \mid 1&lt;k&lt;j \text { 且 }^{\prime} p<em>{1} \cdots p</em>{k-1}^{\prime}={ }^{\prime} p<em>{j-k+1} \cdots p</em>{j-1}{ }^{\prime}\right} &amp;<br>\text { 当此集合不空时 } \<br>1 &amp; \text { 其他情况 }<br>\end{array}\right.$</p></li><li><p>计算next数组：仅取决于模式串本身而和相匹配的主串无关</p><ul><li>仿照kmp算法，如果$p[j] != p[next[j]]$，那么$next[j+1]$的可能次大值为$next[next[j]] + 1$，依次类推即可高效求出$next[j+1]$</li></ul></li><li><p>若在匹配过程中$s_i=p_j$，则 i 与 j 分别增 1；</p></li><li><p>否则，i 不变，j 退至 next[j] 的位置再比较；若 j 退到值为 0（即模式串的第一个字符失配），则从主串的下一个字符$s_{i+1}$起与模式串重新开始匹配；</p></li><li><p>重复执行step3、step4，直至结束。</p></li></ol><h2 id="1-2-优化"><a href="#1-2-优化" class="headerlink" title="1.2 优化"></a>1.2 优化</h2><p>修正next数组，$next[j]=k$，若模式中$p[j]=p[k]$，则$next[j] = next[k]$</p><h2 id="1-3-算法分析"><a href="#1-3-算法分析" class="headerlink" title="1.3 算法分析"></a>1.3 算法分析</h2><ul><li><strong>时间复杂度</strong>：$O(m+n)$</li><li><strong>空间复杂度</strong>：next数组，$O(m)$</li></ul><h1 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2 代码实现"></a>2 代码实现</h1><h2 id="2-1-C"><a href="#2-1-C" class="headerlink" title="2.1 C++"></a>2.1 C++</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">// string、next数组下标从1开始</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span>;</span><br><span class="line"><span class="keyword">int</span> next2[maxn];</span><br><span class="line"><span class="keyword">int</span> nextval[maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算next数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_next</span><span class="params">(<span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">    next2[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; p.size()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || p[i] == p[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            next2[i] = j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = next2[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算nextval数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_nextval</span><span class="params">(<span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">    nextval[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; p.size()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || p[i] == p[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">if</span> (p[i] != p[j])</span><br><span class="line">                nextval[i] = j;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                nextval[i] = nextval[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            j = nextval[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// KMP算法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//get_next(p);//计算next数组</span></span><br><span class="line">    get_nextval(p);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>;<span class="comment">//主串从第i个字符之后匹配</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; s.size() &amp;&amp; j &lt; p.size()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || s[i] == p[j]) &#123;<span class="comment">//模式串首字符失配或相同继续匹配</span></span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//失配</span></span><br><span class="line">            j = nextval[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &gt;= p.size())<span class="comment">//找到</span></span><br><span class="line">        <span class="keyword">return</span> i - p.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">string</span> s = <span class="string">" acabaabaabcacaabc"</span>, t = <span class="string">" abaabcac"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; kmp(s, t);</span><br><span class="line">    <span class="comment">/*for (int i = 1; i &lt; t.size(); i++) &#123;</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; next2[i] &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-Java"><a href="#2-2-Java" class="headerlink" title="2.2 Java"></a>2.2 Java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KMP</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxn = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[maxn];</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] nextval = <span class="keyword">new</span> <span class="keyword">int</span>[maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">KMP</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算next数组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get_next</span><span class="params">(String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">        next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; p.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span> || p.charAt(i) == p.charAt(j)) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">                next[i] = j;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算nextval数组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">get_nextval</span><span class="params">(String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">        nextval[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; p.length() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span> || p.charAt(i) == p.charAt(j)) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">                <span class="keyword">if</span> (p.charAt(i) != p.charAt(j))</span><br><span class="line">                    nextval[i] = j;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    nextval[i] = nextval[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                j = nextval[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// KMP算法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kmp</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//get_next(p);//计算next数组</span></span><br><span class="line">        get_nextval(p);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>;<span class="comment">//主串从第i个字符之后匹配</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; s.length() &amp;&amp; j &lt; p.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span> || s.charAt(i) == p.charAt(j)) &#123;<span class="comment">//模式串首字符失配或相同继续匹配</span></span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//失配</span></span><br><span class="line">                j = nextval[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= p.length())<span class="comment">//找到</span></span><br><span class="line">            <span class="keyword">return</span> i - p.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO自动生成的方法存根</span></span><br><span class="line">    KMP test = <span class="keyword">new</span> KMP();</span><br><span class="line">        String s = <span class="string">" acabaabaabcacaabc"</span>, t = <span class="string">" abaabcac"</span>;</span><br><span class="line">        System.out.println(test.kmp(s, t));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-题目列表"><a href="#3-题目列表" class="headerlink" title="3 题目列表"></a>3 题目列表</h1><div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td></tr></tbody></table></div><h1 id="4-参考"><a href="#4-参考" class="headerlink" title="4 参考"></a>4 参考</h1><ul><li><a href="https://www.bilibili.com/video/BV16X4y137qw?from=search&amp;seid=428213560995313343" target="_blank" rel="noopener">KMP算法之求next数组代码讲解</a></li><li></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构和算法" scheme="https://Dragonliu2018.github.io/categories/数据结构和算法/"/>
    
    
    <category term="字符串" scheme="https://Dragonliu2018.github.io/tags/字符串/"/>
    
  </entry>
  
  <entry>
    <title>搜索</title>
    <link href="https://dragonliu2018.github.io/2021/04/10/%E6%90%9C%E7%B4%A2/"/>
    <id>https://dragonliu2018.github.io/2021/04/10/%E6%90%9C%E7%B4%A2/</id>
    <published>2021-04-10T09:18:30.000Z</published>
    <updated>2021-09-21T13:41:49.133Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-DFS"><a href="#1-DFS" class="headerlink" title="1 DFS"></a>1 DFS</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(参数)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(满足条件)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> step)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        判断边界</span><br><span class="line">        &#123;</span><br><span class="line">            相应操作</span><br><span class="line">        &#125;</span><br><span class="line">        尝试每一种可能</span><br><span class="line">        &#123;</span><br><span class="line">               满足check条件</span><br><span class="line">               标记</span><br><span class="line">               继续下一步dfs(step+<span class="number">1</span>)</span><br><span class="line">               恢复初始状态（回溯的时候要用到）</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-BFS"><a href="#2-BFS" class="headerlink" title="2 BFS"></a>2 BFS</h1><p>BFS使用队列，把每个还没有搜索到的点一次放入队列，然后再弹出队列的头部元素当做当前遍历点。当不需要确定当前遍历层数时：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>.push(s)<span class="comment">//压入起点，初始队列可能有多个起点</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">queue</span> 不空：</span><br><span class="line">    cur = <span class="built_in">queue</span>.pop()</span><br><span class="line">    <span class="keyword">for</span> 节点 in cur的所有相邻节点：</span><br><span class="line">        <span class="keyword">if</span> 该节点有效且未访问过：</span><br><span class="line">            <span class="built_in">queue</span>.push(该节点)</span><br></pre></td></tr></table></figure><p>当需要确定遍历层数时，这里增加了level表示当前遍历到二叉树中的哪一层了，也可以理解为在一个图中，现在已经走了多少步了。size表示在开始遍历新的一层时，队列中有多少个元素，即有多少个点需要向前走一步。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>.push(s)<span class="comment">//压入起点</span></span><br><span class="line">level = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">queue</span> 不空：</span><br><span class="line">    size = <span class="built_in">queue</span>.size()</span><br><span class="line">    <span class="keyword">while</span> (size --) &#123;</span><br><span class="line">        cur = <span class="built_in">queue</span>.pop()</span><br><span class="line">        <span class="keyword">for</span> 节点 in cur的所有相邻节点：</span><br><span class="line">            <span class="keyword">if</span> 该节点有效且未被访问过：</span><br><span class="line">                <span class="built_in">queue</span>.push(该节点)</span><br><span class="line">    &#125;</span><br><span class="line">    level ++</span><br></pre></td></tr></table></figure><h1 id="3-二分"><a href="#3-二分" class="headerlink" title="3 二分"></a>3 二分</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在[l, h)范围内查找值v(l&gt;=0),返回下标,假设a数组已经按从⼩到⼤排序,失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bs</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> l, <span class="keyword">int</span> h, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="keyword">while</span> (l &lt; h)&#123;</span><br><span class="line">m = (l + h) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (a[m] == v)&#123;</span><br><span class="line"><span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a[m] &lt; v)&#123;</span><br><span class="line">l = m + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">h = m;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-双向搜索"><a href="#4-双向搜索" class="headerlink" title="4 双向搜索"></a>4 双向搜索</h1><p>起点是给出的，终点也是已知的，需要确定能否从起点到达终点，如果可以，需要多少步。</p><p>如果我们用常规的搜索方法，从起点开始往下搜，那得到的解答树可能非常庞大，这样漫无目的的搜索就像<strong>大海捞针</strong>。让我们切换一下思路，既然终点是已知的，我们何必让它闲着呢？我们完全可以<strong>分别</strong>从起点和终点出发，看它们能否<strong>相遇</strong>。</p><p>如果原本的解答树规模是 <img alt="[公式]" data-src="https://www.zhihu.com/equation?tex=a%5En" class="lozad"> ，使用双向搜索后，规模立刻缩小到了约 <img alt="[公式]" data-src="https://www.zhihu.com/equation?tex=2a%5E%7Bn%2F2%7D" class="lozad"> ，当 <img alt="[公式]" data-src="https://www.zhihu.com/equation?tex=n" class="lozad"> 较大时优化非常可观。</p><p>双向搜索主要有两种，双向BFS和双向迭代加深。</p><h2 id="4-1-双向BFS"><a href="#4-1-双向BFS" class="headerlink" title="4.1 双向BFS"></a>4.1 双向BFS</h2><p>与普通的BFS不同，双向BFS维护两个而不是一个队列，然后<strong>轮流</strong>拓展两个队列。同时，用<strong>数组</strong>（如果状态可以被表示为较小的整数）或<strong>哈希表</strong>记录当前的搜索情况，给从两个方向拓展的节点以不同的标记。当某点被两种标记同时标记时，搜索结束。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;T&gt; Q[<span class="number">3</span>]; <span class="comment">// T要替换为用来表示状态的类型，可能为int，string还有bitset等</span></span><br><span class="line"><span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">Q[<span class="number">1</span>].push(st); <span class="comment">// st为起始状态</span></span><br><span class="line">Q[<span class="number">2</span>].push(ed); <span class="comment">// ed为终止状态</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; D + <span class="number">2</span>; ++d) <span class="comment">// D为最大深度，最后答案为d-1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> dir = (d &amp; <span class="number">1</span>) + <span class="number">1</span>, sz = Q[dir].size(); <span class="comment">// 记录一下当前的搜索方向，1为正向，2为反向</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> x = Q[dir].front();</span><br><span class="line">        Q[dir].pop();</span><br><span class="line">        <span class="keyword">if</span> (H[x] + dir == <span class="number">3</span>) <span class="comment">// H是数组或哈希表，若H[x]+dir==3说明两个方向都搜到过这个点</span></span><br><span class="line">            found = <span class="literal">true</span>;</span><br><span class="line">        H[x] = dir;</span><br><span class="line">        <span class="comment">// 这里需要把当前状态能够转移到的新状态压入队列</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (found)</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-双向迭代加深"><a href="#4-2-双向迭代加深" class="headerlink" title="4.2 双向迭代加深"></a>4.2 双向迭代加深</h2><p>迭代加深算法是那种，听名字非常高端，思想和实现却都很简单的算法。就是控制dfs的最大深度，如果深度超过最大深度就返回。某个深度搜完后没有得到答案便令最大深度+1，然后重新开始搜索。</p><p>这听起来好像效果跟广搜差不多啊？还重复搜索了很多次。但是，由于搜索的时间复杂度几乎完全由解答树的最后一层确定（看上面第一张图就能感悟到），所以它与BFS在时间上只有常数级别的差距，以此换来的优势是：空间占用很小，有时候方便剪枝、方便传参等。</p><p>双向迭代加深就是相应地，从两个方向迭代加深搜索。先从起点开始搜0层，再从终点开始搜0层，然后从起点开始搜1层……</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> D;</span><br><span class="line"><span class="keyword">bool</span> found;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">dfs</span>(<span class="title">T</span> <span class="title">x</span>, <span class="title">int</span> <span class="title">d</span>, <span class="title">int</span> <span class="title">dir</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">if</span> (H[x] + dir == <span class="number">3</span>)</span><br><span class="line">        found = <span class="literal">true</span>;</span><br><span class="line">    H[x] = dir;</span><br><span class="line">    <span class="keyword">if</span> (d == D)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 这里需要递归搜索当前状态能够转移到的新状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在main函数中...</span></span><br><span class="line"><span class="keyword">while</span> (D &lt;= MAXD / <span class="number">2</span>) <span class="comment">// MAXD为题中要求的最大深度</span></span><br><span class="line">&#123;</span><br><span class="line">    dfs(st, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">// st为起始状态</span></span><br><span class="line">    <span class="keyword">if</span> (found)</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 题中所给最大深度为奇数时这里要判断一下</span></span><br><span class="line">    dfs(ed, <span class="number">0</span>, <span class="number">2</span>); <span class="comment">// ed为终止状态</span></span><br><span class="line">    <span class="keyword">if</span> (found)</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    D++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://zhuanlan.zhihu.com/p/119349440" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/119349440</a></p><h1 id="5-极大极小值搜索算法"><a href="#5-极大极小值搜索算法" class="headerlink" title="5 极大极小值搜索算法"></a>5 极大极小值搜索算法</h1><p>简单的对抗搜索</p><p>评估函数的返回值直接设定成题目中的评估得分即可</p><p>在博弈树搜索时，先手返回能向下递归所得的最大值，后手反之返回最小值</p><p>如果某种状态已经分出胜负或者平手，就说明该种状态就是博弈树中的叶子节点，需要计算评估得分进行返回</p><p>数据很小可以不用alpha-beta剪枝</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(x,a,b) for(int x=(a);x&lt;=(b);x++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn][maxn];<span class="comment">//棋盘 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//计算评估分数，-2000代表还能继续进行棋局</span></span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">    rep(i,<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">        rep(j,<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">            x+=(a[i][j]==<span class="number">0</span>);</span><br><span class="line">    rep(i,<span class="number">0</span>,<span class="number">2</span>)&#123;<span class="comment">//A或B获胜 </span></span><br><span class="line">        <span class="keyword">if</span>(a[i][<span class="number">0</span>]==<span class="number">1</span>&amp;&amp;a[i][<span class="number">1</span>]==<span class="number">1</span>&amp;&amp;a[i][<span class="number">2</span>]==<span class="number">1</span>) <span class="keyword">return</span> x+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[i][<span class="number">0</span>]==<span class="number">2</span>&amp;&amp;a[i][<span class="number">1</span>]==<span class="number">2</span>&amp;&amp;a[i][<span class="number">2</span>]==<span class="number">2</span>) <span class="keyword">return</span> -x<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">0</span>][i]==<span class="number">1</span>&amp;&amp;a[<span class="number">1</span>][i]==<span class="number">1</span>&amp;&amp;a[<span class="number">2</span>][i]==<span class="number">1</span>) <span class="keyword">return</span> x+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">0</span>][i]==<span class="number">2</span>&amp;&amp;a[<span class="number">1</span>][i]==<span class="number">2</span>&amp;&amp;a[<span class="number">2</span>][i]==<span class="number">2</span>) <span class="keyword">return</span> -x<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//A或B获胜 </span></span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">0</span>][<span class="number">0</span>]==<span class="number">1</span>&amp;&amp;a[<span class="number">1</span>][<span class="number">1</span>]==<span class="number">1</span>&amp;&amp;a[<span class="number">2</span>][<span class="number">2</span>]==<span class="number">1</span>) <span class="keyword">return</span> x+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">0</span>][<span class="number">2</span>]==<span class="number">1</span>&amp;&amp;a[<span class="number">1</span>][<span class="number">1</span>]==<span class="number">1</span>&amp;&amp;a[<span class="number">2</span>][<span class="number">0</span>]==<span class="number">1</span>) <span class="keyword">return</span> x+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">0</span>][<span class="number">0</span>]==<span class="number">2</span>&amp;&amp;a[<span class="number">1</span>][<span class="number">1</span>]==<span class="number">2</span>&amp;&amp;a[<span class="number">2</span>][<span class="number">2</span>]==<span class="number">2</span>) <span class="keyword">return</span> -x<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">0</span>][<span class="number">2</span>]==<span class="number">2</span>&amp;&amp;a[<span class="number">1</span>][<span class="number">1</span>]==<span class="number">2</span>&amp;&amp;a[<span class="number">2</span>][<span class="number">0</span>]==<span class="number">2</span>) <span class="keyword">return</span> -x<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//平局 </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-2000</span>;<span class="comment">//棋局未结束 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> dep)</span></span>&#123;</span><br><span class="line">    <span class="comment">//dep=0代表先手，1代表后手</span></span><br><span class="line">    <span class="keyword">int</span> res=check();</span><br><span class="line">    <span class="keyword">if</span>(res!=<span class="number">-2000</span>)<span class="comment">//棋局结束 </span></span><br><span class="line"><span class="keyword">return</span> res;<span class="comment">//叶子节点返回</span></span><br><span class="line">    <span class="keyword">int</span> Res = dep==<span class="number">0</span> ? <span class="number">-1000</span>:<span class="number">1000</span>;</span><br><span class="line">    rep(i,<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">        rep(j,<span class="number">0</span>,<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!a[i][j])&#123;</span><br><span class="line">                a[i][j] = dep==<span class="number">0</span> ? <span class="number">1</span>:<span class="number">2</span>;<span class="comment">//打标签 </span></span><br><span class="line">                <span class="keyword">if</span>( dep==<span class="number">0</span> )<span class="comment">//先手找最大</span></span><br><span class="line">Res = max(Res, dfs(dep^<span class="number">1</span>));<span class="comment">//按位异或实现01轮流下棋</span></span><br><span class="line">                <span class="keyword">else</span><span class="comment">//后手找最小</span></span><br><span class="line">Res = min(Res, dfs(dep^<span class="number">1</span>));</span><br><span class="line">                a[i][j] = <span class="number">0</span>;<span class="comment">//去标签 </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> Res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> T;<span class="comment">//测试组数 </span></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        rep(i,<span class="number">0</span>,<span class="number">2</span>)<span class="comment">//输入当前棋盘 </span></span><br><span class="line">            rep(j,<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">                <span class="built_in">cin</span>&gt;&gt; a[i][j];</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; dfs(<span class="number">0</span>)&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用用alpha-beta剪枝：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(x,a,b) for(int x=(a);x&lt;=(b);x++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn][maxn];<span class="comment">//棋盘 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//计算评估分数，-2000代表还能继续进行棋局</span></span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">    rep(i,<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">        rep(j,<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">            x+=(a[i][j]==<span class="number">0</span>);</span><br><span class="line">    rep(i,<span class="number">0</span>,<span class="number">2</span>)&#123;<span class="comment">//A或B获胜 </span></span><br><span class="line">        <span class="keyword">if</span>(a[i][<span class="number">0</span>]==<span class="number">1</span>&amp;&amp;a[i][<span class="number">1</span>]==<span class="number">1</span>&amp;&amp;a[i][<span class="number">2</span>]==<span class="number">1</span>) <span class="keyword">return</span> x+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[i][<span class="number">0</span>]==<span class="number">2</span>&amp;&amp;a[i][<span class="number">1</span>]==<span class="number">2</span>&amp;&amp;a[i][<span class="number">2</span>]==<span class="number">2</span>) <span class="keyword">return</span> -x<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">0</span>][i]==<span class="number">1</span>&amp;&amp;a[<span class="number">1</span>][i]==<span class="number">1</span>&amp;&amp;a[<span class="number">2</span>][i]==<span class="number">1</span>) <span class="keyword">return</span> x+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">0</span>][i]==<span class="number">2</span>&amp;&amp;a[<span class="number">1</span>][i]==<span class="number">2</span>&amp;&amp;a[<span class="number">2</span>][i]==<span class="number">2</span>) <span class="keyword">return</span> -x<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//A或B获胜 </span></span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">0</span>][<span class="number">0</span>]==<span class="number">1</span>&amp;&amp;a[<span class="number">1</span>][<span class="number">1</span>]==<span class="number">1</span>&amp;&amp;a[<span class="number">2</span>][<span class="number">2</span>]==<span class="number">1</span>) <span class="keyword">return</span> x+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">0</span>][<span class="number">2</span>]==<span class="number">1</span>&amp;&amp;a[<span class="number">1</span>][<span class="number">1</span>]==<span class="number">1</span>&amp;&amp;a[<span class="number">2</span>][<span class="number">0</span>]==<span class="number">1</span>) <span class="keyword">return</span> x+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">0</span>][<span class="number">0</span>]==<span class="number">2</span>&amp;&amp;a[<span class="number">1</span>][<span class="number">1</span>]==<span class="number">2</span>&amp;&amp;a[<span class="number">2</span>][<span class="number">2</span>]==<span class="number">2</span>) <span class="keyword">return</span> -x<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">0</span>][<span class="number">2</span>]==<span class="number">2</span>&amp;&amp;a[<span class="number">1</span>][<span class="number">1</span>]==<span class="number">2</span>&amp;&amp;a[<span class="number">2</span>][<span class="number">0</span>]==<span class="number">2</span>) <span class="keyword">return</span> -x<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//平局 </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-2000</span>;<span class="comment">//棋局未结束 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> dep, <span class="keyword">int</span> lval)</span></span>&#123;</span><br><span class="line"><span class="comment">//dep=0代表先手，1代表后手</span></span><br><span class="line">    <span class="comment">//lval表示如果父亲是先手就是父亲的alpha，否则是父亲的beta</span></span><br><span class="line">    <span class="keyword">int</span> res=check();</span><br><span class="line">    <span class="keyword">if</span>(res!=<span class="number">-2000</span>)<span class="comment">//棋局结束  </span></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">if</span>(dep==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> alpha=<span class="number">-1e9</span>;<span class="comment">//alpha表示先手能找到的最大值</span></span><br><span class="line">        rep(i,<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">            rep(j,<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">                <span class="keyword">if</span>(!a[i][j])&#123;</span><br><span class="line">                    a[i][j]=<span class="number">1</span>;</span><br><span class="line">                    alpha=max(alpha,dfs(dep^<span class="number">1</span>,alpha));</span><br><span class="line">                    a[i][j]=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span>(alpha&gt;lval) <span class="keyword">return</span> alpha;</span><br><span class="line">                    <span class="comment">//如果先手能找到的最大值比后手父亲能找到的最小值还大，后手父亲就肯定不选当前的子树，直接返回进行剪枝</span></span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">return</span> alpha;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> beta=<span class="number">1e9</span>;<span class="comment">//beta表示后手能找到的最小值</span></span><br><span class="line">        rep(i,<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">            rep(j,<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">                <span class="keyword">if</span>(!a[i][j])&#123;</span><br><span class="line">                    a[i][j]=<span class="number">2</span>;</span><br><span class="line">                    beta=min(beta,dfs(dep^<span class="number">1</span>,beta));</span><br><span class="line">                    a[i][j]=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span>(beta&lt;lval) <span class="keyword">return</span> beta;</span><br><span class="line">                    <span class="comment">//反之同理</span></span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">return</span> beta;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> T;<span class="comment">//测试组数 </span></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        rep(i,<span class="number">0</span>,<span class="number">2</span>)<span class="comment">//输入当前棋盘 </span></span><br><span class="line">            rep(j,<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">                <span class="built_in">cin</span>&gt;&gt; a[i][j];</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; dfs(<span class="number">0</span>, <span class="number">1e9</span>)&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p>1. </p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构和算法" scheme="https://Dragonliu2018.github.io/categories/数据结构和算法/"/>
    
    
    <category term="DFS" scheme="https://Dragonliu2018.github.io/tags/DFS/"/>
    
    <category term="BFS" scheme="https://Dragonliu2018.github.io/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="https://dragonliu2018.github.io/2021/04/10/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://dragonliu2018.github.io/2021/04/10/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2021-04-10T00:35:53.000Z</published>
    <updated>2021-09-21T13:41:32.386Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="table-container"><table><thead><tr><th style="text-align:center">排序算法</th><th style="text-align:center">最好时间复杂度</th><th style="text-align:center">平均时间复杂度</th><th style="text-align:center">最坏时间复杂度</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">直接插入排序</td><td style="text-align:center">有序：$O(n)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">逆序：$O(n^2)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">希尔排序</td><td style="text-align:center">复杂度未得到证明</td><td style="text-align:center">$O(n^{1.3-2})$</td><td style="text-align:center">d=1：$O(n^2)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">冒泡排序</td><td style="text-align:center">有序：$O(n)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">逆序：$O(n^2)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">快速排序</td><td style="text-align:center">划分均匀：$O(nlog_2n)$</td><td style="text-align:center">$O(nlog_2n)$</td><td style="text-align:center">有序：$O(n^2)$</td><td style="text-align:center">$O(log_2n\sim n)$</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">简单选择排序</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">堆排序</td><td style="text-align:center">$O(nlog_2n)$</td><td style="text-align:center">$O(nlog_2n)$</td><td style="text-align:center">$O(nlog_2n)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">归并排序</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">$O(nlog_2n)$</td><td style="text-align:center">$O(n)$</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">基数排序</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">$O(d(r+n))$</td><td style="text-align:center">$O(r)$</td><td style="text-align:center">稳定</td></tr></tbody></table></div><h1 id="1-直接插入排序（Insertion-Sort）"><a href="#1-直接插入排序（Insertion-Sort）" class="headerlink" title="1 直接插入排序（Insertion Sort）"></a>1 直接插入排序（Insertion Sort）</h1><p>插入排序的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><p>优化：先用折半查找找到应该插入的位置，再移动元素。</p><h1 id="2-希尔排序（Shell-Sort）"><a href="#2-希尔排序（Shell-Sort）" class="headerlink" title="2 希尔排序（Shell Sort）"></a>2 希尔排序（Shell Sort）</h1><p>先将待排序表分割成若干形如$L[i,i+d,i+2d,…,i+kd]$的特殊子表，对各个子表分别进行直接插入排序。缩小增量d，重复上述过程，直到d=1为止。（希尔本人建议：d初始值为n，然后每次将增量缩小一半）</p><p>适用性：仅适用于顺序表，不适用于链表</p><h1 id="3-冒泡排序（Bubble-Sort）"><a href="#3-冒泡排序（Bubble-Sort）" class="headerlink" title="3 冒泡排序（Bubble Sort）"></a>3 冒泡排序（Bubble Sort）</h1><p><strong>冒泡排序</strong>是一种交换排序，它的思路就是在待排序的数据中，两两比较相邻元素的大小，看是否满足大小顺序的要求，如果满足则不动，如果不满足则让它们互换。然后继续与下一个相邻元素的比较，一直到一次遍历完成。一次遍历的过程就被成为一次冒泡，一次冒泡的结束至少会让一个元素移动到了正确的位置。所以要想让所有元素都排序好，一次冒泡还不行，我们得重复N次去冒泡，这样最终就完成了N个数据的排序过程。</p><p>对一个长度为 $n$ 的排列 $p[i]$ 进行一轮冒泡排序的伪代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i = <span class="number">1</span> to n<span class="number">-1</span>:</span><br><span class="line"><span class="keyword">if</span> p[i] &gt; p[i + <span class="number">1</span>]:</span><br><span class="line">swap(p[i], p[i + <span class="number">1</span>])</span><br></pre></td></tr></table></figure><h1 id="4-快速排序（Quck-Sort）"><a href="#4-快速排序（Quck-Sort）" class="headerlink" title="4 快速排序（Quck Sort）"></a>4 快速排序（Quck Sort）</h1><p>快速排序是一种交换排序，它的思路：在待排序表$L[1…n]$中任取一个元素 pivot 作为枢轴（或基准，通常取首元素），通过一趟排序表划分为独立的两部分$L[1…k-1]$和$L[k+1…n]$，使得$L[1…k-1]$中的所有元素小于 pivot，$L[k+1…n]$中的所有元素大于等于 pivot，则 pivot放在了其最终位置$L[k]$上，这个过程称为一次“划分”。然后分别递归地对两个子表重复上述过程，直至每部分内只有一个元素或空为止，即所有元素放在了其最终位置上。</p><p>若每一次选中的“枢轴”将待排序序列划分为均匀的两个部分，则递归深度最小，算法效率最高。</p><p>优化：</p><ol><li>选头、中、尾、三个位置的元素，取中间值作为枢轴元素；</li><li>随机选一个元素作为枢轴元素。</li></ol><h1 id="5-简单选择排序（Selection-Sort）"><a href="#5-简单选择排序（Selection-Sort）" class="headerlink" title="5 简单选择排序（Selection Sort）"></a>5 简单选择排序（Selection Sort）</h1><p>选择排序：每一趟在待排序元素中选取关键字最小（或最大）的元素加入有序子序列。</p><p>适用性：既可以用于顺序表，也可用于链表</p><h1 id="6-堆排序（Heap-Sort）"><a href="#6-堆排序（Heap-Sort）" class="headerlink" title="6 堆排序（Heap Sort）"></a>6 堆排序（Heap Sort）</h1><p>堆排序是选择排序的一种，思路：每一趟将堆顶元素加入到有序子序列（与待排序序列中的最后一个元素交换），并将待排序元素序列再次调整为大根堆（小元素不断下坠）</p><p><strong>什么是堆？</strong></p><p>若$n$个关键字序列$L[1..n]$满足下面某一条性质，则称为堆（Heap）：</p><ol><li>若满足：$L(i)≥L(2i)$且$L(i)≥L(2i+1)$，$(1 \leq i \leq n / 2)$——大根堆（大顶堆）</li><li>若满足：$L(i)≤L(2i)$且$L(i)≤L(2i+1)$，$(1 \leq i \leq n / 2)$——小根堆（小顶堆）</li></ol><p><strong>建立大根堆</strong>：</p><ol><li>把所有非终端结点都检查一遍，是否满足大根堆的要求，如果不满足则进行调整</li><li>检查当前结点是否满足<code>根节点&gt;=左、右</code>，若不满足，将当前结点与更大的一个孩子互换</li><li>若元素互换破坏了下一级的堆，则采用相同的方法继续往下调整（小元素不断“下坠”）</li></ol><p>建堆$O(n)$，排序$O(nlogn)$</p><p><strong>在堆中插入新元素</strong>：</p><ol><li>对于大根堆，新元素放到表尾，与父结点相比，若新元素比父节点更大，则将二者互换。新元素就这样一路上升，直到无法继续上升。</li></ol><p><strong>在堆中删除元素</strong>：</p><ol><li>被删除元素用堆底元素代替，然后让该元素不断下坠，直到无法下坠为止。</li></ol><h1 id="7-归并排序（Merge-Sort）"><a href="#7-归并排序（Merge-Sort）" class="headerlink" title="7 归并排序（Merge Sort）"></a>7 归并排序（Merge Sort）</h1><p>把两个或多个已经有序的序列合并成一个。</p><p>核心操作：把数组内的两个有序序列归并为一个。</p><h1 id="8-基数排序（Radix-Sort）"><a href="#8-基数排序（Radix-Sort）" class="headerlink" title="8 基数排序（Radix Sort）"></a>8 基数排序（Radix Sort）</h1><p>假设长度为$n$的线性表中每个结点$a$的关键字由$d$元组$\left(k<em>{j}^{d-1}, k</em>{j}^{d-2}, k<em>{j}^{d-3}, \ldots, k</em>{j}^{1}, k<em>{j}^{0}\right)$组成，其中，$0 \leq k</em>{j}^{i} \leq r-1 \quad(0 \leq j&lt;n, 0 \leq i \leq d-1)$，$r$称为基数。</p><p><strong>基数排序得到递减序列的过程如下</strong>：</p><ol><li>初始化：设置$r$个空队列，$Q<em>{r-1}，Q</em>{r-2}…Q_0$</li><li>按照各个关键字位权重递增的次序（个、十、百），对$d$个关键字位分别做“分配”和“收集”</li><li>分配：顺序扫描各个元素，若当前处理的关键字位=x，则将元素插入$Q_x$队尾</li><li>收集：把$Q<em>{r-1}，Q</em>{r-2}…Q_0$各个队列中的结点依次出队并链接</li></ol><p><strong>注意</strong>：</p><ol><li>基数排序不是基于比较的排序算法；基数排序通常基于链式存储实现。</li><li>需要$r$个辅助队列，空间复杂度为$O(r)$，其中$r$为基数；</li><li>一趟分配$O(n)$，一趟收集$O(r)$，总共$d$趟分配、收集，总的时间复杂度=$O(d(n+r))$</li></ol><p><strong>基数排序擅长解决的问题</strong>：</p><ol><li>数据元素的关键字可以方便地拆分成$d$组，且$d$较小；</li><li>每组的关键字的取值范围不大，即$r$较小</li><li>数据元素个数$n$较大</li></ol><h1 id="9-外部排序"><a href="#9-外部排序" class="headerlink" title="9 外部排序"></a>9 外部排序</h1><p><strong>外部排序原理</strong>：</p><p>外部排序：数据元素太多，无法一次全部读入内存进行排序。</p><p>使用归并排序的方法，最少只需在内存中分配3块大小的缓冲区即可对任意一个大文件进行排序。</p><p><strong>步骤</strong>：</p><ol><li>构造初始归并段：归并排序要求各个子序列有序，每次读入两个块的内容，进行内部排序后写回磁盘；</li><li>第一趟归并：将两个归并段归并为一个，缓冲区1/2空了就要立即用归并段1/2的下一块补上</li><li>第二趟归并：与第一趟类似…</li></ol><p><strong>时间开销分析</strong>：</p><ol><li>外部排序时间开销=读写外存时间+内部排序所需时间+内部归并所需时间</li></ol><p><strong>优化</strong>：</p><ol><li>多路归并：采用多路归并可以减少归并趟数，从而减少磁盘I/O(读写)次数</li><li>减少初始归并段数量：生成初始归并段的“内存工作区”越大，初始归并段越长，则可减少初始归并段数量r</li></ol><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> arr[maxn] = &#123;<span class="number">0</span>, <span class="number">53</span>, <span class="number">17</span>, <span class="number">78</span>, <span class="number">9</span>, <span class="number">45</span>, <span class="number">65</span>, <span class="number">87</span>, <span class="number">32</span>&#125;;<span class="comment">//下标从1开始 </span></span><br><span class="line"><span class="keyword">int</span> n;<span class="comment">//数组长度 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//直接插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j, tmp;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">tmp = arr[i];</span><br><span class="line"><span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j] &gt; tmp) &#123;</span><br><span class="line">arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">arr[j + <span class="number">1</span>] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//希尔排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j, tmp, d;</span><br><span class="line"><span class="keyword">for</span> (d = n / <span class="number">2</span>; d &gt;= <span class="number">1</span>; d /= <span class="number">2</span>) &#123;<span class="comment">//增量 </span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> + d; i &lt;= n; i++) &#123;</span><br><span class="line">tmp = arr[i];</span><br><span class="line"><span class="keyword">for</span> (j = i - d; j &gt;= d; j -= d) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j] &gt; tmp) &#123;</span><br><span class="line">arr[j + d] = arr[j];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">arr[j + d] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//冒泡排序 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n - i; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">swap(arr[j], arr[j + <span class="number">1</span>]);</span><br><span class="line">flag = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag == <span class="literal">false</span>) &#123;<span class="comment">//无交换，表已经有序 </span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//快速排序——用arr[low]将子表划分</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> pivot = arr[low];<span class="comment">//第一个元素作为枢轴元素 </span></span><br><span class="line"><span class="keyword">while</span> (low &lt; high) &#123;<span class="comment">//用low、high搜索枢轴的最终位置 </span></span><br><span class="line"><span class="keyword">while</span> (low &lt; high &amp;&amp; arr[high] &gt;= pivot) &#123;</span><br><span class="line">high--;</span><br><span class="line">&#125; </span><br><span class="line">arr[low] = arr[high];<span class="comment">//比枢轴小的元素移动到左边 </span></span><br><span class="line"><span class="keyword">while</span> (low &lt; high &amp;&amp; arr[low] &lt;= pivot) &#123;</span><br><span class="line">low++;</span><br><span class="line">&#125; </span><br><span class="line">arr[high] = arr[low];<span class="comment">//比枢轴大的元素移动到左边 </span></span><br><span class="line">&#125;</span><br><span class="line">arr[low] = pivot;<span class="comment">//枢轴元素存放的最终位置</span></span><br><span class="line"><span class="keyword">return</span> low;<span class="comment">//返回存放枢轴的最终位置 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quck_sort</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line"><span class="keyword">int</span> pivot_pos = partition(low, high);</span><br><span class="line">quck_sort(low, pivot_pos - <span class="number">1</span>);</span><br><span class="line">quck_sort(pivot_pos + <span class="number">1</span>, high);</span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//简单选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">select_sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;<span class="comment">//进行n-1趟 </span></span><br><span class="line"><span class="keyword">int</span> mini = i;<span class="comment">//记录最小元素位置 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++) &#123;<span class="comment">//在arr[i+1...n]中选择最小元素 </span></span><br><span class="line"><span class="keyword">if</span> (arr[j] &lt; arr[mini]) &#123;</span><br><span class="line">mini = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mini != i) &#123;</span><br><span class="line">swap(arr[i], arr[mini]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//堆排序——将以 k 为根的子树调整为大根堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_adjust</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">arr[<span class="number">0</span>] = arr[k];<span class="comment">//arr[0]暂存子树的根节点 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> * k; i &lt;= len; i *= <span class="number">2</span>) &#123;<span class="comment">//沿key较大的子节点向下筛选 </span></span><br><span class="line"><span class="keyword">if</span> (i &lt; len &amp;&amp; arr[i] &lt; arr[i + <span class="number">1</span>]) &#123;<span class="comment">//比较左右孩子结点大小 </span></span><br><span class="line">i++;<span class="comment">//取key较大的子节点下标 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (arr[<span class="number">0</span>] &gt;= arr[i]) &#123;<span class="comment">//筛选结束 </span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">arr[k] = arr[i];<span class="comment">//将arr[i]调整到双亲结点上 </span></span><br><span class="line">k = i;<span class="comment">//修改k，以便继续向下筛选 </span></span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">arr[k] = arr[<span class="number">0</span>];<span class="comment">//被筛选节点的值放入最终位置 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//堆排序——建立大根堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_max_heap</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = len / <span class="number">2</span>; i &gt; <span class="number">0</span>; i--) &#123;<span class="comment">//从后往前调整非终端结点 </span></span><br><span class="line">heap_adjust(i, len);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">build_max_heap(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt; <span class="number">1</span>; i--) &#123;</span><br><span class="line">swap(arr[i], arr[<span class="number">1</span>]);</span><br><span class="line">heap_adjust(<span class="number">1</span>, i - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *b = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));<span class="comment">//辅助数组 </span></span><br><span class="line"><span class="comment">//归并排序——arr[low...mid]与arr[mid+1...high]各自有序，将两者合并</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j, k;</span><br><span class="line"><span class="keyword">for</span> (k = low; k &lt;= high; k++) &#123;<span class="comment">//将arr中所有元素复制到b </span></span><br><span class="line">b[k] = arr[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//合并 </span></span><br><span class="line"><span class="keyword">for</span> (i = low, j = mid + <span class="number">1</span>, k = low; i &lt;= mid &amp;&amp; j &lt;= high; k++) &#123;</span><br><span class="line"><span class="keyword">if</span> (b[i] &lt; b[j]) &#123;</span><br><span class="line">arr[k] = b[i++];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">arr[k] = b[j++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//没有归并完的部分复制到尾部 </span></span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid) arr[k++] = b[i++];</span><br><span class="line"><span class="keyword">while</span> (j &lt;= high) arr[k++] = b[j++]; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;<span class="comment">//从中间拆开 </span></span><br><span class="line">merge_sort(low, mid);<span class="comment">//对左半部分归并排序 </span></span><br><span class="line">merge_sort(mid + <span class="number">1</span>, high);<span class="comment">//对右半部分归并排序 </span></span><br><span class="line">merge(low, mid, high);<span class="comment">//归并 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//cin&gt;&gt; n;</span></span><br><span class="line">n = <span class="number">8</span>;</span><br><span class="line">merge_sort(<span class="number">1</span>, n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; arr[i]&lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><ol><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构和算法" scheme="https://Dragonliu2018.github.io/categories/数据结构和算法/"/>
    
    
  </entry>
  
  <entry>
    <title>欧拉路</title>
    <link href="https://dragonliu2018.github.io/2021/04/10/%E6%AC%A7%E6%8B%89%E8%B7%AF/"/>
    <id>https://dragonliu2018.github.io/2021/04/10/%E6%AC%A7%E6%8B%89%E8%B7%AF/</id>
    <published>2021-04-10T00:35:53.000Z</published>
    <updated>2021-09-21T13:41:24.718Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><ul><li><strong>欧拉回路</strong>：每条边只经过一次，而且回到起点</li><li><strong>欧拉路径</strong>：每条边只经过一次，不要求回到起点  </li><li><strong>欧拉回路判断</strong>：<ul><li><strong>无向图</strong>：连通(不考虑度为 0 的点)，没有奇度顶点</li><li><strong>有向图</strong>：强连通，每个顶点出度等于入度</li><li><strong>混合图(有无向边和有向边)</strong>：首先是基图连通(不考虑度为 0 的点)，然后需要借助网络流判定。<ol><li>首先给原图中的每条无向边随便指定一个方向（称为初始定向），将原图改为有向图 G’，然后的任务就是改变 G’ 中某些边的方向（当然是无向边转化来的，原混合图中的有向边不能动）使其满足每个点的入度等于出度。</li><li>设 $D[i]$ 为 $G’$ 中 (点 $i$ 的出度 - 点 $i $的入度）。可以发现，在改变 $G’$ 中边的方向的过程中，任何点的 $D$ 值的奇偶性都不会发生改变（设将边 $<i, j>$ 改为 $<j, i>$，则 $i $入度加 1 出度减 1，$j$ 入度减 1 出度加 1，两者之差加 2 或减 2，奇偶性不变）！而最终要求的是每个点的入度等于出度，即每个点的 $D$ 值都为 0，是偶数，故可得：若初始定向得到的 $G’$ 中任意一个点的$D$值是奇数，那么原图中一定不存在欧拉环！</j,></i,></li><li>若初始 $D$ 值都是偶数，则将 $G’$ 改装成网络：设立源点 $S$ 和汇点 $T$，对于每个 $D[i]&gt;0$ 的点$i$，连边 $<s, i>$，容量为 $D[i]/2$；对于每个 $D[j]<0$ 的点 $j$，连边 $<j, t>$，容量为 $-D[j]/2$； $G’$中的每条边在网络中仍保留，容量为 1（表示该边最多只能被改变方向一次）。求这个网络的最大流，若 $S$ 引出的所有边均满流，则原混合图是欧拉图，将网络中所有流量为 1 的中间边（就是不与 $S$ 或 $T$关联的边）在 $G’$ 中改变方向，形成的新图 $G”$ 一定是有向欧拉图；若 $S$ 引出的边中有的没有满流，则原混合图不是欧拉图。</0$></s,></li></ol></li></ul></li><li><strong>欧拉路径的判断</strong>：<ul><li><strong>无向图</strong>：连通(不考虑度为 0 的点)，没有奇度顶点或恰有两个奇度顶点</li><li><strong>有向图</strong>：基图连通(把边当成无向边，同样不考虑度为 0 的点)，每个顶点出度等于入度或<br>者有且仅有一个点的出度比入度多 1，有且仅有一个点的出度比入度少 1，其余出度等于入<br>度。</li><li><strong>混合图</strong>：如果存在欧拉回路，一定存在欧拉路径了。否则如果有且仅有两个点的（出度 -入<br>度）是奇数，那么给这个两个点加边，判断是否存在欧拉回路。  </li></ul></li></ul><p><a href="https://blog.csdn.net/richenyunqi/article/details/80382450/" target="_blank" rel="noopener">https://blog.csdn.net/richenyunqi/article/details/80382450/</a></p><h1 id="欧拉路径模板"><a href="#欧拉路径模板" class="headerlink" title="欧拉路径模板"></a>欧拉路径模板</h1><h2 id="1-递归"><a href="#1-递归" class="headerlink" title="1 递归"></a>1 递归</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无向图的欧拉路径</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;graph[maxn],path;<span class="comment">//图、欧拉路径的倒序</span></span><br><span class="line"><span class="keyword">int</span> N, M;<span class="comment">//顶点数、边数</span></span><br><span class="line"><span class="keyword">bool</span> visit[maxn][maxn];<span class="comment">//表示边是否已被访问</span></span><br><span class="line"><span class="comment">//顶点v的度数是否为奇数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">f</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v.size()%<span class="number">2</span>==<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//深度优先遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;graph[v].size();++i)&#123;<span class="comment">//遍历该点能到达的结点</span></span><br><span class="line">        <span class="keyword">int</span> w=graph[v][i];</span><br><span class="line">        <span class="keyword">if</span>(!visit[v][w])&#123;<span class="comment">//该边没有被访问过</span></span><br><span class="line">            visit[v][w]=visit[w][v]=<span class="literal">true</span>;<span class="comment">//该边已被访问</span></span><br><span class="line">            DFS(w);<span class="comment">//递归遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    path.push_back(v);<span class="comment">//加入欧拉路径中</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;M);<span class="comment">//输入点数、边数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;++i)&#123;<span class="comment">//输入边，无向图</span></span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">        graph[a].push_back(b);</span><br><span class="line">        graph[b].push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;++i)<span class="comment">//排序、题目要求输出字典序最小的一种方案</span></span><br><span class="line">        sort(graph[i].begin(),graph[i].end());</span><br><span class="line">    DFS(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> k=count_if(graph+<span class="number">1</span>,graph+N+<span class="number">1</span>,f);<span class="comment">//度数为奇数的顶点个数</span></span><br><span class="line">    <span class="comment">//连通、没有奇度顶点或恰有两个奇度顶点且起点为奇度顶点</span></span><br><span class="line">    <span class="keyword">if</span>(path.size()==M+<span class="number">1</span>&amp;&amp;(k==<span class="number">0</span>||(k==<span class="number">2</span>&amp;&amp;f(graph[<span class="number">1</span>]))))</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=path.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)<span class="comment">//反向输出路径</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,path[i]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-1"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-非递归"><a href="#2-非递归" class="headerlink" title="2 非递归"></a>2 非递归</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无向图的欧拉路径</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;graph[maxn],path;<span class="comment">//图、欧拉路径的倒序</span></span><br><span class="line"><span class="keyword">int</span> N, M;<span class="comment">//顶点数、边数</span></span><br><span class="line"><span class="keyword">bool</span> visit[maxn][maxn];<span class="comment">//表示边是否已被访问</span></span><br><span class="line"><span class="comment">//顶点v的度数是否为奇数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">f</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v.size()%<span class="number">2</span>==<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;M);<span class="comment">//输入点数、边数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;++i)&#123;<span class="comment">//输入边，无向图</span></span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">        graph[a].push_back(b);</span><br><span class="line">        graph[b].push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;++i)<span class="comment">//排序、题目要求输出字典序最小的一种方案</span></span><br><span class="line">        sort(graph[i].begin(),graph[i].end());</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;s;</span><br><span class="line">    s.push(<span class="number">1</span>);<span class="comment">//1号顶点(起点)入栈</span></span><br><span class="line">    <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> v=s.top(),i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;graph[v].size();++i)&#123;<span class="comment">//遍历该点能到达的结点</span></span><br><span class="line">            <span class="keyword">int</span> w=graph[v][i];</span><br><span class="line">            <span class="keyword">if</span>(!visit[v][w])&#123;<span class="comment">//该边没有被访问过</span></span><br><span class="line">                s.push(w);<span class="comment">//顶点w入栈</span></span><br><span class="line">                visit[v][w]=visit[w][v]=<span class="literal">true</span>;<span class="comment">//该边已被访问</span></span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//跳出循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i==graph[v].size())&#123;<span class="comment">//没有还未访问的边</span></span><br><span class="line">            path.push_back(v);<span class="comment">//顶点v加入欧拉序列</span></span><br><span class="line">            s.pop();<span class="comment">//出栈</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k=count_if(graph+<span class="number">1</span>,graph+N+<span class="number">1</span>,f);<span class="comment">//度数为奇数的顶点个数</span></span><br><span class="line">    <span class="comment">//连通、没有奇度顶点或恰有两个奇度顶点且起点为奇度顶点</span></span><br><span class="line">    <span class="keyword">if</span>(path.size()==M+<span class="number">1</span>&amp;&amp;(k==<span class="number">0</span>||(k==<span class="number">2</span>&amp;&amp;f(graph[<span class="number">1</span>]))))</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i=path.rbegin();i!=path.rend();++i)<span class="comment">//倒序输出</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,*i);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-1"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构和算法" scheme="https://Dragonliu2018.github.io/categories/数据结构和算法/"/>
    
    
    <category term="图论" scheme="https://Dragonliu2018.github.io/tags/图论/"/>
    
  </entry>
  
  <entry>
    <title>背包dp</title>
    <link href="https://dragonliu2018.github.io/2021/04/10/%E8%83%8C%E5%8C%85dp/"/>
    <id>https://dragonliu2018.github.io/2021/04/10/%E8%83%8C%E5%8C%85dp/</id>
    <published>2021-04-10T00:35:53.000Z</published>
    <updated>2021-09-21T13:38:42.119Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>转载：<a href="https://www.cnblogs.com/jbelial/articles/2116074.html" target="_blank" rel="noopener">dd大牛的《背包九讲》</a>、<a href="https://www.kancloud.cn/kancloud/pack/70124" target="_blank" rel="noopener">背包问题九讲</a>、<a href="https://zhuanlan.zhihu.com/p/139368825" target="_blank" rel="noopener">知乎转载</a></p></blockquote><h1 id="P01-01背包"><a href="#P01-01背包" class="headerlink" title="P01: 01背包"></a>P01: 01背包</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>有N件物品和一个容量为V的背包。第i件物品的费用/体积是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的体积总和不超过背包容量，且价值总和最大。</p><h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>这是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放。</p><p>用子问题定义状态：即$f[i][v]$表示前i件物品恰放入一个容量为v的背包可以获得的最大价值。则其状态转移方程便是：$f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]}$。</p><p>这个方程非常重要，基本上所有跟背包相关的问题的方程都是由它衍生出来的。所以有必要将它详细解释一下：“将前i件物品放入容量为v的背包中”这个子问题，若只考虑第i件物品的策略（放或不放），那么就可以转化为一个只牵扯前i-1件物品的问题。如果不放第i件物品，那么问题就转化为“前i-1件物品放入容量为v的背包中”；如果放第i件物品，那么问题就转化为“前i-1件物品放入剩下的容量为v-c[i]的背包中”，此时能获得的最大价值就是$f [i-1][v-c[i]]$再加上通过放入第i件物品获得的价值$w[i]$。</p><p>注意$f[i][v]$有意义当且仅当存在一个前i件物品的子集，其费用总和为v。所以按照这个方程递推完毕后，最终的答案并不一定是$f[N] [V]$，而是$f[N][0…V]$的最大值。如果将状态的定义中的“恰”字去掉，在转移方程中就要再加入一项$f[i][v-1]$，这样就可以保证$f[N] [V]$就是最后的答案。</p><h2 id="优化——空间复杂度"><a href="#优化——空间复杂度" class="headerlink" title="优化——空间复杂度"></a>优化——空间复杂度</h2><p>以上方法的时间和空间复杂度均为$O(N*V)$，其中时间复杂度基本已经不能再优化了，但空间复杂度却可以优化到$O(V)$。</p><p>先考虑上面讲的基本思路如何实现，肯定是有一个主循环$i=1…N$，每次算出来二维数组$f[i][0..V]$的所有值。那么，如果只用一个数组$f [0..V]$，能不能保证第$i$次循环结束后$f[v]$中表示的就是我们定义的状态$f[i][v]$呢？$f[i][v]$是由$f[i-1][v]$和$f[i-1] [v-c[i]]$两个子问题递推而来，能否保证在推$f[i][v]$时（也即在第$i$次主循环中推$f[v]$时）能够得到$f[i-1][v]$和$f[i-1][v -c[i]]$的值呢？事实上，这要求在每次主循环中我们以$v=V..0$的顺序推$f[v]$，这样才能保证推$f[v]$时$f[v-c[i]]$保存的是状态$f[i -1][v-c[i]]$的值。伪代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i=<span class="number">1.</span>.N</span><br><span class="line"><span class="keyword">for</span> v=V.<span class="number">.0</span></span><br><span class="line">f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;;</span><br></pre></td></tr></table></figure><p>其中的$f[v]=max{f[v],f[v-c[i]]+w[i]}$一句恰就相当于我们的转移方程$f[i][v]=max{f[i-1][v],f[i- 1][v-c[i]]+w[i]}$，因为现在的$f[v-c[i]]$就相当于原来的$f[i-1][v-c[i]]$。如果将v的循环顺序从上面的逆序改成顺序的话，那么则成了$f[i][v]$由$f[i][v-c[i]]$推知，与本题意不符，但它却是另一个重要的背包问题P02最简捷的解决方案，故学习只用一维数组解01背包问题是十分必要的。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">5</span>;<span class="comment">//物品最大数量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv = <span class="number">1e3</span> + <span class="number">5</span>;<span class="comment">//背包最大体积</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[maxv];<span class="comment">//背包</span></span><br><span class="line"><span class="keyword">int</span> volume[maxn], value[maxn];<span class="comment">//每个物品的体积和价值</span></span><br><span class="line"><span class="keyword">int</span> n, v;<span class="comment">//总物品数、背包体积</span></span><br><span class="line"><span class="comment">//01背包 每种物品仅有一件，可以选择放或不放</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zero_one_park</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> vol)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = v; j &gt;= vol; j--) &#123;</span><br><span class="line">        dp[j] = max(dp[j], dp[j - vol] + val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt; n&gt;&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt; volume[i]&gt;&gt; value[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        zero_one_park(value[i], volume[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; dp[v]&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>01背包问题是最基本的背包问题，它包含了背包问题中设计状态、方程的最基本思想，另外，别的类型的背包问题往往也可以转换成01背包问题求解。故一定要仔细体会上面基本思路的得出方法，状态转移方程的意义，以及最后怎样优化的空间复杂度。</p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol><li><a href="https://www.acwing.com/problem/content/2/" target="_blank" rel="noopener">acwing模板题——01背包问题</a></li></ol><h1 id="P02-完全背包问题"><a href="#P02-完全背包问题" class="headerlink" title="P02: 完全背包问题"></a>P02: 完全背包问题</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</p><h2 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a>基本思路</h2><p>这个问题非常类似于01背包问题，所不同的是每种物品有无限件。也就是从每种物品的角度考虑，与它相关的策略已并非取或不取两种，而是有取0件、取1件、取2件……等很多种。如果仍然按照解01背包时的思路，令$f[i][v]$表示前$i$种物品恰放入一个容量为$v$的背包的最大权值。仍然可以按照每种物品不同的策略写出状态转移方程，像这样：$f[i][v]=max{f[i-1][v-k<em>c[i]]+k</em>w[i]|0&lt;=k<em>c[i]&lt;= v}$。这跟01背包问题一样有$O(N</em>V)$个状态需要求解，但求解每个状态的时间则不是常数了，求解状态$f[i][v]$的时间是$O(v/c[i])$，总的复杂度是超过$O(VN)$的。</p><p>将01背包问题的基本思路加以改进，得到了这样一个清晰的方法。这说明01背包问题的方程的确是很重要，可以推及其它类型的背包问题。但我们还是试图改进这个复杂度。</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="一个简单有效的优化"><a href="#一个简单有效的优化" class="headerlink" title="一个简单有效的优化"></a>一个简单有效的优化</h3><p>完全背包问题有一个很简单有效的优化，是这样的：若两件物品$i、j$满足$c[i]&lt;=c[j]$且$w[i]&gt;=w[j]$，则将物品$j$去掉，不用考虑。这个优化的正确性显然：任何情况下都可将价值小费用高的$j$换成物美价廉的$i$，得到至少不会更差的方案。对于随机生成的数据，这个方法往往会大大减少物品的件数，从而加快速度。然而这个并不能改善最坏情况的复杂度，因为有可能特别设计的数据可以一件物品也去不掉。</p><h3 id="转化为01背包问题求解"><a href="#转化为01背包问题求解" class="headerlink" title="转化为01背包问题求解"></a>转化为01背包问题求解</h3><p>既然01背包问题是最基本的背包问题，那么我们可以考虑把完全背包问题转化为01背包问题来解。最简单的想法是，考虑到第i种物品最多选$V/c [i]$件，于是可以把第$i$种物品转化为$V/c[i]$件费用及价值均不变的物品，然后求解这个01背包问题。这样完全没有改进基本思路的时间复杂度，但这毕竟给了我们将完全背包问题转化为01背包问题的思路：将一种物品拆成多件物品。</p><p>更高效的转化方法是：把第i种物品拆成费用为$c[i]<em>2^k$、价值为$w[i]</em>2^k$的若干件物品，其中$k$满足$c[i]*2^k&lt;V$。这是二进制的思想，因为不管最优策略选几件第$i$种物品，总可以表示成若干个$2^k$件物品的和。这样把每种物品拆成$O(log(V/c[i]))$件物品，是一个很大的改进。但我们有更优的$O(VN)$的算法。 </p><h3 id="O-VN-的算法"><a href="#O-VN-的算法" class="headerlink" title="$O(VN)$的算法"></a>$O(VN)$的算法</h3><p>这个算法使用一维数组，先看伪代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i=<span class="number">1.</span>.N </span><br><span class="line">    <span class="keyword">for</span> v=<span class="number">0.</span>.V </span><br><span class="line">        f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;;</span><br></pre></td></tr></table></figure><p>你会发现，这个伪代码与P01的伪代码只有v的循环次序不同而已。为什么这样一改就可行呢？首先想想为什么P01中要按照$v=V..0$的逆序来循环。这是因为要保证第$i$次循环中的状态$f[i][v]$是由状态$f[i-1][v-c[i]]$递推而来。换句话说，这正是为了保证每件物品只选一次，保证在考虑“选入第$i$件物品”这件策略时，依据的是一个绝无已经选入第$i$件物品的子结果$f[i-1][v-c[i]]$。而现在完全背包的特点恰是每种物品可选无限件，所以在考虑“加选一件第$i$种物品”这种策略时，却正需要一个可能已选入第$i$种物品的子结果$f[i][v-c[i]]$，所以就可以并且必须采用$v= 0..V$的顺序循环。这就是这个简单的程序为何成立的道理。</p><p>这个算法也可以以另外的思路得出。例如，基本思路中的状态转移方程可以等价地变形成这种形式：$f[i][v]=max{f[i-1][v],f[i][v-c[i]]+w[i]}$，将这个方程用一维数组实现，便得到了上面的伪代码。</p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">5</span>;<span class="comment">//物品最大数量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv = <span class="number">1e3</span> + <span class="number">5</span>;<span class="comment">//背包最大体积</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[maxv];<span class="comment">//背包</span></span><br><span class="line"><span class="keyword">int</span> volume[maxn], value[maxn];<span class="comment">//每个物品的体积和价值</span></span><br><span class="line"><span class="keyword">int</span> n, v;<span class="comment">//总物品数、背包体积</span></span><br><span class="line"><span class="comment">//完全背包 每种物品都有无限件可用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">complete_park</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> vol)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = vol; j &lt;= v; j++) &#123;</span><br><span class="line">        dp[j] = max(dp[j], dp[j - vol] + val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt; n&gt;&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt; volume[i]&gt;&gt; value[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        complete_park(value[i], volume[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; dp[v]&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>完全背包问题也是一个相当基础的背包问题，它有两个状态转移方程，分别在“基本思路”以及“O(VN)的算法“的小节中给出。希望你能够对这两个状态转移方程都仔细地体会，不仅记住，也要弄明白它们是怎么得出来的，最好能够自己想一种得到这些方程的方法。事实上，对每一道动态规划题目都思考其方程的意义以及如何得来，是加深对动态规划的理解、提高动态规划功力的好方法。</p><h2 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h2><ol><li><a href="https://www.acwing.com/problem/content/3/" target="_blank" rel="noopener">acwing模板题——完全背包问题</a></li></ol><h1 id="P03-多重背包问题"><a href="#P03-多重背包问题" class="headerlink" title="P03: 多重背包问题"></a>P03: 多重背包问题</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>有N种物品和一个容量为V的背包。第i种物品最多有n[i]件可用，每件费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</p><h2 id="基本思路-2"><a href="#基本思路-2" class="headerlink" title="基本思路"></a>基本思路</h2><p>这题目和完全背包问题很类似。基本的方程只需将完全背包问题的方程略微一改即可，因为对于第$i$种物品有$n[i]+1$种策略：取0件，取1件……取 $n[i]$件。令$f[i][v]$表示前$i$种物品恰放入一个容量为$v$的背包的最大权值，则：$f[i][v]=max{f[i-1][v-k<em>c[i]]+ k</em>w[i]|0&lt;=k&lt;=n[i]}$。复杂度是$O(V*∑n[i])$。</p><h2 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h2><h3 id="转化为01背包问题"><a href="#转化为01背包问题" class="headerlink" title="转化为01背包问题"></a>转化为01背包问题</h3><p>另一种好想好写的基本方法是转化为01背包求解：把第$i$种物品换成$n[i]$件01背包中的物品，则得到了物品数为$∑n[i]$的01背包问题，直接求解，复杂度仍然是$O(V*∑n[i])$。</p><p>但是我们期望将它转化为01背包问题之后能够像完全背包一样降低复杂度。仍然考虑二进制的思想，我们考虑把第$i$种物品换成若干件物品，使得原问题中第i种物品可取的每种策略——取$0..n[i]$件——均能等价于取若干件代换以后的物品。另外，取超过$n[i]$件的策略必不能出现。</p><p>方法是：将第$i$种物品分成若干件物品，其中每件物品有一个系数，这件物品的费用和价值均是原来的费用和价值乘以这个系数。使这些系数分别为 $1,2,4,…,2^{k-1},n[i]-2^k+1$，且$k$是满足$n[i]-2^k+1&gt;0$的最大整数。例如，如果$n[i]$为$13$，就将这种物品分成系数分别为$1,2,4,6$的四件物品。</p><p>分成的这几件物品的系数和为$n[i]$，表明不可能取多于$n[i]$件的第i种物品。另外这种方法也能保证对于$0..n[i]$间的每一个整数，均可以用若干个系数的和表示，这个证明可以分$0..2^{k-1}$和$2^k..n[i]$两段来分别讨论得出，并不难，希望你自己思考尝试一下。</p><p>这样就将第$i$种物品分成了$O(log n[i])$种物品，将原问题转化为了复杂度为$O(V*∑log n[i])$的01背包问题，是很大的改进。</p><h3 id="O-VN-的算法-1"><a href="#O-VN-的算法-1" class="headerlink" title="* $O(VN)$的算法"></a>* $O(VN)$的算法</h3><p>多重背包问题同样有$O(VN)$的算法。这个算法基于基本算法的状态转移方程，但应用单调队列的方法使每个状态的值可以以均摊$O(1)$的时间求解。由于用单调队列优化的DP已超出了NOIP的范围，故本文不再展开讲解。我最初了解到这个方法是在楼天成的“男人八题”幻灯片上。</p><h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">5</span>;<span class="comment">//物品最大数量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv = <span class="number">1e3</span> + <span class="number">5</span>;<span class="comment">//背包最大体积</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[maxv];<span class="comment">//背包</span></span><br><span class="line"><span class="keyword">int</span> volume[maxn], value[maxn], c[maxn];<span class="comment">//每个物品的体积和价值、数量</span></span><br><span class="line"><span class="keyword">int</span> n, v;<span class="comment">//总物品数、背包体积</span></span><br><span class="line"><span class="comment">//01背包 每种物品仅有一件，可以选择放或不放</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zero_one_park</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> vol)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = v; j &gt;= vol; j--) &#123;</span><br><span class="line">        dp[j] = max(dp[j], dp[j - vol] + val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//完全背包 每种物品都有无限件可用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">complete_park</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> vol)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = vol; j &lt;= v; j++) &#123;</span><br><span class="line">        dp[j] = max(dp[j], dp[j - vol] + val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//多重背包 每种物品都有限件可用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multiple_park</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> vol, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vol * amount &gt;= v) &#123;<span class="comment">//该种物品足以装满背包，转化为完全背包</span></span><br><span class="line">        complete_park(val, vol);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//转化为01背包，将第i种物品分成若干件物品</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; amount) &#123;</span><br><span class="line">            zero_one_park(k * val, k * vol);</span><br><span class="line">            amount -= k;</span><br><span class="line">            k &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (amount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            zero_one_park(amount * val, amount * vol);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt; n&gt;&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt; volume[i]&gt;&gt; value[i]&gt;&gt; c[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        multiple_park(value[i], volume[i], c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; dp[v]&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><p>这里我们看到了将一个算法的复杂度由$O(V<em>∑n[i])$改进到$O(V</em>∑log n[i])$的过程，还知道了存在应用超出NOIP范围的知识的O(VN)算法。希望你特别注意“拆分物品”的思想和方法，自己证明一下它的正确性，并用尽量简洁的程序来实现。</p><h2 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h2><ol><li><a href="https://www.acwing.com/problem/content/4/" target="_blank" rel="noopener">acwing模板题——多重背包问题 I</a></li><li><a href="https://www.acwing.com/problem/content/5/" target="_blank" rel="noopener">acwing模板题——多重背包问题 II</a>：本题考查多重背包的二进制优化方法。</li></ol><h1 id="P04-混合三种背包问题"><a href="#P04-混合三种背包问题" class="headerlink" title="P04: 混合三种背包问题"></a>P04: 混合三种背包问题</h1><h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h2><p>如果将P01、P02、P03混合起来。也就是说，有的物品只可以取一次（01背包），有的物品可以取无限次（完全背包），有的物品可以取的次数有一个上限（多重背包）。应该怎么求解呢？</p><h2 id="01背包与完全背包的混合"><a href="#01背包与完全背包的混合" class="headerlink" title="01背包与完全背包的混合"></a>01背包与完全背包的混合</h2><p>考虑到在P01和P02中最后给出的伪代码只有一处不同，故如果只有两类物品：一类物品只能取一次，另一类物品可以取无限次，那么只需在对每个物品应用转移方程时，根据物品的类别选用顺序或逆序的循环即可，复杂度是$O(VN)$。伪代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i=<span class="number">1.</span>.N</span><br><span class="line"><span class="keyword">if</span> 第i件物品是<span class="number">01</span>背包</span><br><span class="line"><span class="keyword">for</span> v=V.<span class="number">.0</span></span><br><span class="line">f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> 第i件物品是完全背包</span><br><span class="line"><span class="keyword">for</span> v=<span class="number">0.</span>.V</span><br><span class="line">f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;;</span><br></pre></td></tr></table></figure><h2 id="再加上多重背包"><a href="#再加上多重背包" class="headerlink" title="再加上多重背包"></a>再加上多重背包</h2><p>如果再加上有的物品最多可以取有限次，那么原则上也可以给出$O(VN)$的解法：遇到多重背包类型的物品用单调队列解即可。但如果不考虑超过NOIP范围的算法的话，用P03中将每个这类物品分成$O(log n[i])$个01背包的物品的方法也已经很优了。</p><h2 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h2><p>有人说，困难的题目都是由简单的题目叠加而来的。这句话是否公理暂且存之不论，但它在本讲中已经得到了充分的体现。本来01背包、完全背包、多重背包都不是什么难题，但将它们简单地组合起来以后就得到了这样一道一定能吓倒不少人的题目。但只要基础扎实，领会三种基本背包问题的思想，就可以做到把困难的题目拆分成简单的题目来解决。</p><h2 id="练习-3"><a href="#练习-3" class="headerlink" title="练习"></a>练习</h2><ol><li><a href="acwing.com/problem/content/7/">acwing模板题——混合背包问题</a></li></ol><h1 id="P05-二维费用的背包问题"><a href="#P05-二维费用的背包问题" class="headerlink" title="P05: 二维费用的背包问题"></a>P05: 二维费用的背包问题</h1><h2 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h2><p>二维费用的背包问题是指：对于每件物品，具有两种不同的费用；选择这件物品必须同时付出这两种代价；对于每种代价都有一个可付出的最大值（背包容量）。问怎样选择物品可以得到最大的价值。设这两种代价分别为代价1和代价2，第i件物品所需的两种代价分别为$a[i]$和$b[i]$。两种代价可付出的最大值（两种背包容量）分别为$V$和$U$。物品的价值为$w[i]$。</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>费用加了一维，只需状态也加一维即可。设$f[i][v][u]$表示前$i$件物品付出两种代价分别为$v$和$u$时可获得的最大价值。状态转移方程就是：$f [i][v][u]=max{f[i-1][v][u],f[i-1][v-a[i]][u-b[i]]+w[i]}$。如前述方法，可以只使用二维的数组：当每件物品只可以取一次时变量$v$和$u$采用逆序的循环，当物品有如完全背包问题时采用顺序的循环。当物品有如多重背包问题时拆分物品。</p><h2 id="物品总个数的限制"><a href="#物品总个数的限制" class="headerlink" title="物品总个数的限制"></a>物品总个数的限制</h2><p>有时，“二维费用”的条件是以这样一种隐含的方式给出的：最多只能取$M$件物品。这事实上相当于每件物品多了一种“件数”的费用，每个物品的件数费用均为$1$，可以付出的最大件数费用为$M$。换句话说，设$f[v][m]$表示付出费用$v$、最多选$m$件时可得到的最大价值，则根据物品的类型（01、完全、多重）用不同的方法循环更新，最后在$f[0..V][0..M]$范围内寻找答案。</p><p>另外，如果要求“恰取M件物品”，则在$f[0..V][M]$范围内寻找答案。</p><h2 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">5</span>;<span class="comment">//物品最大数量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv = <span class="number">1e2</span> + <span class="number">5</span>;<span class="comment">//背包最大体积</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxw = <span class="number">1e2</span> + <span class="number">5</span>;<span class="comment">//背包最大承受重量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[maxv][maxw];<span class="comment">//背包</span></span><br><span class="line"><span class="keyword">int</span> volume[maxn], value[maxn], weight[maxn];<span class="comment">//每个物品的体积和价值、重量</span></span><br><span class="line"><span class="keyword">int</span> n, v, w;<span class="comment">//总物品数、背包体积、背包承受重量</span></span><br><span class="line"><span class="comment">//二维01背包</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">two_dimension_park</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> wei, <span class="keyword">int</span> vol)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = v; j &gt;= vol; j--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = w; k &gt;= wei; k--) &#123;</span><br><span class="line">            dp[j][k] = max(dp[j][k], dp[j - vol][k - wei] + val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt; n&gt;&gt; v&gt;&gt; w;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt; volume[i]&gt;&gt; weight[i]&gt;&gt; value[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        two_dimension_park(value[i], weight[i],volume[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; dp[v][w]&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h2><p>事实上，当发现由熟悉的动态规划题目变形得来的题目时，在原来的状态中加一维以满足新的限制是一种比较通用的方法。希望你能从本讲中初步体会到这种方法。</p><h2 id="练习-4"><a href="#练习-4" class="headerlink" title="练习"></a>练习</h2><ol><li><a href="https://www.acwing.com/problem/content/8/" target="_blank" rel="noopener">acwing模板题——二维费用的背包问题</a></li></ol><h1 id="P06-分组背包问题"><a href="#P06-分组背包问题" class="headerlink" title="P06: 分组背包问题"></a>P06: 分组背包问题</h1><h2 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h2><p>有$N$件物品和一个容量为$V$的背包。第$i$件物品的费用是$c[i]$，价值是$w[i]$。这些物品被划分为若干组，每组中的物品互相冲突，最多选一件。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</p><h2 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h2><p>这个问题变成了每组物品有若干种策略：是选择本组的某一件，还是一件都不选。也就是说设$f[k][v]$表示前$k$组物品花费费用$v$能取得的最大权值，则有$f[k][v]=max{f[k-1][v],f[k-1][v-c[i]]+w[i]|物品i属于第k组}$。</p><p>使用一维数组的伪代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 所有的组k</span><br><span class="line">    <span class="keyword">for</span> v=V.<span class="number">.0</span></span><br><span class="line">        <span class="keyword">for</span> 所有的i属于组k</span><br><span class="line">            f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;</span><br></pre></td></tr></table></figure><p>注意这里的三层循环的顺序，“for v=V..0”这一层循环必须在“for 所有的i属于组k”之外。这样才能保证每一组内的物品最多只有一个会被添加到背包中。</p><p>另外，显然可以对每组中的物品应用P02中“一个简单有效的优化”。</p><h2 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e2</span> + <span class="number">5</span>;<span class="comment">//物品最大数量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv = <span class="number">1e2</span> + <span class="number">5</span>;<span class="comment">//背包最大体积</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[maxv];<span class="comment">//背包</span></span><br><span class="line"><span class="keyword">int</span> volume[maxn], value[maxn];<span class="comment">//每个物品的体积和价值</span></span><br><span class="line"><span class="keyword">int</span> n, v;<span class="comment">//物品组数、背包体积</span></span><br><span class="line"><span class="comment">//分组背包 物品被划分为若干组，每组最多选一件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">group_park</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> vol)</span> </span>&#123;<span class="comment">//物品组数、背包最大容量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t;<span class="comment">//每组的个数</span></span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt; t;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; i++) &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt; volume[i]&gt;&gt; value[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从前k组中选</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = vol; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= t; l++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (volume[l] &lt;= j) &#123;</span><br><span class="line">                    dp[j] = max(dp[j], dp[j - volume[l]] + value[l]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt; n&gt;&gt; v;</span><br><span class="line">    group_park(n, v);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; dp[v]&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h2><p>分组的背包问题将彼此互斥的若干物品称为一个组，这建立了一个很好的模型。不少背包问题的变形都可以转化为分组的背包问题（例如P07），由分组的背包问题进一步可定义“泛化物品”的概念，十分有利于解题。</p><h2 id="练习-5"><a href="#练习-5" class="headerlink" title="练习"></a>练习</h2><ol><li><a href="acwing.com/problem/content/9/">acwing模板题——分组背包问题</a></li><li><a href="https://ac.nowcoder.com/acm/problem/14602" target="_blank" rel="noopener">牛客——xinjun与阴阳师</a></li></ol><h1 id="P07-有依赖的背包问题"><a href="#P07-有依赖的背包问题" class="headerlink" title="* P07: 有依赖的背包问题"></a>* P07: 有依赖的背包问题</h1><h2 id="简化的问题"><a href="#简化的问题" class="headerlink" title="简化的问题"></a>简化的问题</h2><p>这种背包问题的物品间存在某种“依赖”的关系。也就是说，$i$依赖于$j$，表示若选物品$i$，则必须选物品$j$。为了简化起见，我们先设没有某个物品既依赖于别的物品，又被别的物品所依赖；另外，没有某件物品同时依赖多件物品。</p><h2 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h2><p>这个问题由NOIP2006金明的预算方案一题扩展而来。遵从该题的提法，将不依赖于别的物品的物品称为“主件”，依赖于某主件的物品称为“附件”。由这个问题的简化条件可知所有的物品由若干主件和依赖于每个主件的一个附件集合组成。</p><p>按照背包问题的一般思路，仅考虑一个主件和它的附件集合。可是，可用的策略非常多，包括：一个也不选，仅选择主件，选择主件后再选择一个附件，选择主件后再选择两个附件……无法用状态转移方程来表示如此多的策略。（事实上，设有$n$个附件，则策略有$2^n+1$个，为指数级）</p><p>考虑到所有这些策略都是互斥的（也就是说，你只能选择一种策略），所以一个主件和它的附件集合实际上对应于 P06 中的一个物品组，每个选择了主件又选择了若干个附件的策略对应于这个物品组中的一个物品，其费用和价值都是这个策略中的物品的值的和。但仅仅是这一步转化并不能给出一个好的算法，因为物品组中的物品还是像原问题的策略一样多。</p><p>再考虑P06中的一句话： <em>可以对每组中的物品应用P02中“一个简单有效的优化”</em>。 这提示我们，对于一个物品组中的物品，所有费用相同的物品只留一个价值最大的，不影响结果。所以，我们可以对主件$i$的“附件集合”先进行一次01背包，得到费用依次为$0..V-c[i]$所有这些值时相应的最大价值$f’[0..V-c[i]]$。那么这个主件及它的附件集合相当于$V-c[i]+1$个物品的物品组，其中费用为$c[i]+k$的物品的价值为$f’[k]+w[i]$。也就是说原来指数级的策略中有很多策略都是冗余的，通过一次01背包后，将主件$i$转化为$V-c[i]+1$个物品的物品组，就可以直接应用P06的算法解决问题了。</p><h2 id="较一般的问题"><a href="#较一般的问题" class="headerlink" title="较一般的问题"></a>较一般的问题</h2><p>更一般的问题是：依赖关系以图论中“森林”的形式给出（森林即多叉树的集合），也就是说，主件的附件仍然可以具有自己的附件集合，限制只是每个物品最多只依赖于一个物品（只有一个主件）且不出现循环依赖。</p><p>解决这个问题仍然可以用将每个主件及其附件集合转化为物品组的方式。唯一不同的是，由于附件可能还有附件，就不能将每个附件都看作一个一般的01背包中的物品了。若这个附件也有附件集合，则它必定要被先转化为物品组，然后用分组的背包问题解出主件及其附件集合所对应的附件组中各个费用的附件所对应的价值。</p><p>事实上，这是一种树形DP，其特点是每个父节点都需要对它的各个儿子的属性进行一次DP以求得自己的相关属性。这已经触及到了“泛化物品”的思想。看完P08后，你会发现这个“依赖关系树”每一个子树都等价于一件泛化物品，求某节点为根的子树对应的泛化物品相当于求其所有儿子的对应的泛化物品之和。</p><h2 id="具体思路"><a href="#具体思路" class="headerlink" title="具体思路"></a>具体思路</h2><p>dfs在遍历到 $x$ 结点时，先考虑一定选上根节点 $x$ ，因此初始化 $f[x][v[x]…m] = w[x]$<br>在分组背包部分：<br>$j$ 的范围 $[ m , v[x] ] $小于$v[x]$则没有意义因为连根结点都放不下；<br>$k$的范围$ [ 0 , j-v[x] ]$，当大于$j-v[x]$时分给该子树的容量过多，剩余的容量连根节点的物品都放不下了；</p><h2 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">5</span>;<span class="comment">//物品最大数量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv = <span class="number">1e2</span> + <span class="number">5</span>;<span class="comment">//背包最大体积</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxv];<span class="comment">//dp[x][v]表达选择以x为子树的物品，在容量不超过v时所获得的最大价值</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tree[maxn];<span class="comment">//树，存放依赖关系</span></span><br><span class="line"><span class="keyword">int</span> volume[maxn], value[maxn];<span class="comment">//每个物品的体积和价值</span></span><br><span class="line"><span class="keyword">int</span> n, v, root;<span class="comment">//总物品数、背包容量、树根结点</span></span><br><span class="line"><span class="comment">//有依赖的背包</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = volume[x]; i &lt;= v; i++) dp[x][i] = value[x];<span class="comment">//点x必须选，所以初始化dp[x][value[x] ~ v]= value[x]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tree[x].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> son = tree[x][i];</span><br><span class="line">        dfs(son);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = v; j &gt;= volume[x]; j--) &#123;<span class="comment">//j的范围为value[x]~v, 小于value[x]无法选择以x为子树的物品</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= j - volume[x]; k++) &#123;<span class="comment">//分给子树son的空间不能大于j-value[x],不然都无法选根物品x</span></span><br><span class="line">                dp[x][j] = max(dp[x][j], dp[x][j - k] + dp[son][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt; n&gt;&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> fa;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt; volume[i]&gt;&gt; value[i]&gt;&gt; fa;</span><br><span class="line">        <span class="keyword">if</span> (fa == <span class="number">-1</span>)</span><br><span class="line">            root = i;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tree[fa].push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; dp[root][v];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h2><p>NOIP2006的那道背包问题我做得很失败，写了上百行的代码，却一分未得。后来我通过思考发现通过引入“物品组”和“依赖”的概念可以加深对这题的理解，还可以解决它的推广问题。用物品组的思想考虑那题中极其特殊的依赖关系：物品不能既作主件又作附件，每个主件最多有两个附件，可以发现一个主件和它的两个附件等价于一个由四个物品组成的物品组，这便揭示了问题的某种本质。</p><p>我想说：失败不是什么丢人的事情，从失败中全无收获才是。</p><h2 id="练习-6"><a href="#练习-6" class="headerlink" title="练习"></a>练习</h2><ol><li><a href="https://www.acwing.com/problem/content/10/" target="_blank" rel="noopener">acwing模板题——有依赖的背包问题</a></li></ol><h1 id="P08-泛化物品"><a href="#P08-泛化物品" class="headerlink" title="* P08: 泛化物品"></a>* P08: 泛化物品</h1><h2 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h2><h2 id="算法-3"><a href="#算法-3" class="headerlink" title="算法"></a>算法</h2><h2 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h2><h2 id="练习-7"><a href="#练习-7" class="headerlink" title="练习"></a>练习</h2><h1 id="P09-背包问题问法的变化"><a href="#P09-背包问题问法的变化" class="headerlink" title="P09: 背包问题问法的变化"></a>P09: 背包问题问法的变化</h1><h2 id="输出方案"><a href="#输出方案" class="headerlink" title="输出方案"></a>输出方案</h2><h2 id="输出字典序最小的最优方案"><a href="#输出字典序最小的最优方案" class="headerlink" title="输出字典序最小的最优方案"></a>输出字典序最小的最优方案</h2><p>这里“字典序最小”的意思是$1…N$号物品的选择方案排列出来以后字典序最小。以输出01背包最小字典序的方案为例。</p><p>题目要求输出字典序最小的解，假设存在一个包含第1个物品的最优解，为了确保字典序最小那么我们必然要选第一个。那么问题就转化成从$2～N$这些物品中找到最优解。之前的$f(i,j)$记录的都是前$i$个物品总容量为$j$的最优解，那么我们现在将$f(i,j)$定义为从第$i$个元素到最后一个元素总容量为$j$的最优解。接下来考虑状态转移：</p><p>$f(i,j)=max{f(i+1,j),f(i+1,j−v[i])+w[i]}$<br>两种情况，第一种是不选第$i$个物品，那么最优解等同于从第$i+1$个物品到最后一个元素总容量为$j$的最优解；第二种是选了第$i$个物品，那么最优解等于当前物品的价值$w[i]$加上从第$i+1$个物品到最后一个元素总容量为$j−v[i]$的最优解。</p><p>计算完状态表示后，考虑如何的到最小字典序的解。首先$f(1,m)$肯定是最大价值，那么我们便开始考虑能否选取第1个物品呢。</p><p>如果$f(1,m)=f(2,m−v[1])+w[1]$，说明选取了第1个物品可以得到最优解。</p><p>如果$f(1,m)=f(2,m)$，说明不选取第一个物品才能得到最优解。</p><p>如果$f(1,m)=f(2,m)=f(2,m−v[1])+w[1]$，说明选不选都可以得到最优解，但是为了考虑字典序最小，我们也需要选取该物品。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">5</span>;<span class="comment">//物品最大数量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv = <span class="number">1e3</span> + <span class="number">5</span>;<span class="comment">//背包最大体积</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxv];<span class="comment">//从第i个元素到最后一个元素总容量为j的最优解</span></span><br><span class="line"><span class="keyword">int</span> volume[maxn], value[maxn];<span class="comment">//每个物品的体积和价值</span></span><br><span class="line"><span class="keyword">int</span> n, v;<span class="comment">//总物品数、背包体积</span></span><br><span class="line"><span class="comment">//01背包 每种物品仅有一件，可以选择放或不放</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">optimal_park</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> vol, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= v; j++) &#123;</span><br><span class="line">        dp[i][j] = dp[i + <span class="number">1</span>][j];</span><br><span class="line">        <span class="keyword">if</span>(j &gt;= vol)</span><br><span class="line">            dp[i][j] = max(dp[i][j], dp[i + <span class="number">1</span>][j - vol] + val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt; n&gt;&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt; volume[i]&gt;&gt; value[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        optimal_park(value[i], volume[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出</span></span><br><span class="line">    <span class="keyword">int</span> cur_v = v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++) &#123;   </span><br><span class="line">        <span class="keyword">if</span> (i == n &amp;&amp; cur_v &gt;= volume[i]) &#123;<span class="comment">//如果是最后一个元素，特判一下，防止越界即可</span></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt; i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur_v &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//判断下标是否越界</span></span><br><span class="line">        <span class="keyword">if</span> (cur_v - volume[i]&gt;=<span class="number">0</span> &amp;&amp; dp[i][cur_v] == dp[i + <span class="number">1</span>][cur_v - volume[i]] + value[i]) &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt; i&lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            cur_v = cur_v - volume[i];<span class="comment">//选了第i个物品，剩余容量就要减小。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求方案总数"><a href="#求方案总数" class="headerlink" title="求方案总数"></a>求方案总数</h2><h2 id="最优方案的总数"><a href="#最优方案的总数" class="headerlink" title="最优方案的总数"></a>最优方案的总数</h2><p>这里的最优方案是指物品总价值最大的方案。以01背包为例。</p><p>时间复杂度 $O(nm)$<br>定义两个数组：$f[maxv]$，$cnt[maxv]$：$f[i]$ 用来存储背包容积为 $i$ 时的最佳方案的总价值，$cnt[i]$为背包容积为 $i$ 时总价值为最佳的方案数。</p><p>先初始化所有的 $cnt[i]$ 为 1，因为背包里什么也不装也是一种方案。</p><p>外层循环 $n$ 次，每次读入新物品的 $v,w$</p><p>求出装新物品时的总价值，与不装新物品时作对比</p><p>如果装新物品的方案总价值更大，那么用 $f[j−v]+w$ 来更新 $f[j]$，用 $cnt[j−v]$ 更新 $cnt[j]$<br>如果总价值相等，那么最大价值的方案数就多了 $cnt[j−v]$ 种。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">5</span>;<span class="comment">//物品最大数量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv = <span class="number">1e3</span> + <span class="number">5</span>;<span class="comment">//背包最大体积</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod  = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[maxv], cnt[maxv];<span class="comment">//背包，最优方案总数</span></span><br><span class="line"><span class="keyword">int</span> volume[maxn], value[maxn];<span class="comment">//每个物品的体积和价值</span></span><br><span class="line"><span class="keyword">int</span> n, v;<span class="comment">//总物品数、背包体积</span></span><br><span class="line"><span class="comment">//01背包 求解最优方案总数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">optimal_sum_park</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> vol)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = v; j &gt;= vol; j--) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = dp[j - vol] + val;</span><br><span class="line">        <span class="keyword">if</span> (tmp &gt; dp[j]) &#123;</span><br><span class="line">            dp[j] = tmp;</span><br><span class="line">            cnt[j] = cnt[j - vol];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tmp == dp[j]) &#123;</span><br><span class="line">            cnt[j] = (cnt[j] + cnt[j - vol]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt; n&gt;&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt; volume[i]&gt;&gt; value[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= v; i++) &#123;</span><br><span class="line">        cnt[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        optimal_sum_park(value[i], volume[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; cnt[v]&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结-8"><a href="#小结-8" class="headerlink" title="小结"></a>小结</h2><p>显然，这里不可能穷尽背包类动态规划问题所有的问法。甚至还存在一类将背包类动态规划问题与其它领域（例如数论、图论）结合起来的问题，在这篇论背包问题的专文中也不会论及。但只要深刻领会前述所有类别的背包问题的思路和状态转移方程，遇到其它的变形问法，只要题目难度还属于NOIP，应该也不难想出算法。</p><p>触类旁通、举一反三，应该也是一个OIer应有的品质吧。</p><h2 id="练习-8"><a href="#练习-8" class="headerlink" title="练习"></a>练习</h2><ol><li><a href="https://www.acwing.com/problem/content/11/" target="_blank" rel="noopener">acwing模板题——背包问题求方案数</a></li><li><a href></a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构和算法" scheme="https://Dragonliu2018.github.io/categories/数据结构和算法/"/>
    
    
    <category term="dp" scheme="https://Dragonliu2018.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>最短路</title>
    <link href="https://dragonliu2018.github.io/2021/04/09/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    <id>https://dragonliu2018.github.io/2021/04/09/%E6%9C%80%E7%9F%AD%E8%B7%AF/</id>
    <published>2021-04-09T11:06:45.000Z</published>
    <updated>2021-09-21T13:42:35.580Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>　　最短路问题分为两类：<strong>单源最短路</strong>和<strong>多源最短路</strong>。前者只需要求一个<strong>固定的起点</strong>到各个顶点的最短路径，后者则要求得出<strong>任意两个顶点</strong>之间的最短路径。</p><ul><li><strong>单源 Dijkstra算法</strong>：<ul><li><strong>优点</strong>：时间复杂度稳定$O(n^2)$，堆优化能达到$O(ElogE)$；也可解决多源最短路，总的时间复杂度也是$O(n^3)$</li><li><strong>缺点</strong>：不能处理负边</li></ul></li><li><strong>单源 Bellman-Ford算法</strong>：<ul><li><strong>优点</strong>：其优于Dijkstra算法的方面是边的权值可以为负数、实现简单</li><li><strong>缺点</strong>：时间复杂度过高，高达$O(V*E)$；但算法可以进行若干种优化，提高了效率。</li></ul></li><li><strong>单源 SPFA算法</strong>：<ul><li><strong>优点</strong>：快于Bellman-Ford，据说随机数据下期望时间复杂度是$O(m+nlogn)$</li><li><strong>缺点</strong>：时间复杂度<strong>不稳定</strong>，最坏情况可以被卡成Bellman-Ford，也就是$O(V*E)$</li></ul></li><li><strong>全源 Floyd算法</strong>：<ul><li><strong>优点</strong>：算法简洁，可以解决负权图</li><li><strong>缺点</strong>：时间复杂度为$O(n^3)$，空间复杂度为$O(n^2)$，都比较高，所以只适用于数据规模较小的情形；不能解决负环图</li></ul></li><li><strong>全源 Johnson算法</strong>：<ul><li><strong>优点</strong>：相对于Floyd算法时间复杂度低，$O(nmlogm)$；</li><li><strong>缺点</strong>：无负环图、算法较繁琐</li></ul></li><li><strong>BFS算法</strong>：<ul><li><strong>优点</strong>：</li><li><strong>缺点</strong>：只能解决无权图</li></ul></li></ul><h1 id="1-单源-Dijkstra算法"><a href="#1-单源-Dijkstra算法" class="headerlink" title="1 单源 Dijkstra算法"></a>1 单源 Dijkstra算法</h1><p><strong>贪心</strong>的思想，不断取出<strong>离顶点最近</strong>而<strong>没有被访问过</strong>的点，松弛它和它能到达的所有点。</p><blockquote><p>对于每个顶点v∈V，都设置一个属性d[v]，用来描述从源点s到v的最短路径上权值的上界，称为最短路径估计（shortest-pathestimate）。</p><p>π[v]代表S到v的当前最短路径中v点之前的一个点的编号,我们用下面的Θ(V)时间的过程来对最短路径估计和前趋进行初始化。</p><p>在松弛一条边(u,v)的过程中，要测试是否可以通过u，对迄今找到的v的最短路径进行改进；如果可以改进的话，则更新d[v]和π[v]。一次松弛操作可以减小最短路径估计的值d[v]，并更新v的前趋域$π[v]$(S到v的当前最短路径中v点之前的一个点的编号)。</p></blockquote><p><strong>打印路径</strong>：只需要用一个pre[]数组存储每个点的<strong>父节点</strong>即可。（单源最短路的起点是固定的，所以每条路有且仅有一个祖先节点，一步步溯源上去的路径是唯一的。相反，这里不能存<strong>子节点</strong>，因为从源点下去，有很多条最短路径）</p><p>参考：<a href="https://zhuanlan.zhihu.com/p/96621396" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/96621396</a></p><p><strong>朴素Dijkstra</strong>：时间复杂度是 $O(n^2+m)$, $n$ 表示点数，$m$ 表示边数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e2</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g[maxn][maxn];  <span class="comment">// 存储每条边</span></span><br><span class="line"><span class="keyword">int</span> dist[maxn];  <span class="comment">// 存储1号点到每个点的最短距离</span></span><br><span class="line"><span class="keyword">bool</span> st[maxn];   <span class="comment">// 存储每个点的最短路是否已经确定</span></span><br><span class="line"><span class="keyword">int</span> n;<span class="comment">//点数</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 求1号点到n号点的最短路，如果不存在则返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ ) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">-1</span>;     <span class="comment">// 在还未确定最短路的点中，寻找距离最小的点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用t更新其他点的距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            dist[j] = min(dist[j], dist[t] + g[t][j]);</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>堆优化Dijkstra</strong>：时间复杂度 $O(mlogn)$, $n$ 表示点数，$m$ 表示边数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1.5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;      <span class="comment">// 点的数量</span></span><br><span class="line"><span class="keyword">int</span> h[maxn], w[maxn], e[maxn], ne[maxn], idx;  <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="keyword">int</span> dist[maxn];        <span class="comment">// 存储所有点到1号点的距离</span></span><br><span class="line"><span class="keyword">bool</span> st[maxn];     <span class="comment">// 存储每个点的最短距离是否已确定</span></span><br><span class="line"><span class="comment">//加边</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    w[idx] = c; <span class="comment">// 有重边也不要紧，假设1-&gt;2有权重为2和3的边，再遍历到点1的时候2号点的距离会更新两次放入堆中</span></span><br><span class="line">    e[idx] = y; <span class="comment">// 这样堆中会有很多冗余的点，但是在弹出的时候还是会弹出最小值2+x（x为之前确定的最短路径），并</span></span><br><span class="line">    ne[idx] = h[x]; <span class="comment">// 标记st为true，所以下一次弹出3+x会continue不会向下执行。</span></span><br><span class="line">    h[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 求1号点到n号点的最短距离，如果不存在，则返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;PII, <span class="built_in">vector</span>&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;</span><br><span class="line">    heap.push(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;);      <span class="comment">// first存储距离，second存储节点编号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (heap.size()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.top();</span><br><span class="line">        heap.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ver = t.second, distance = t.first;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[ver]; i != <span class="number">-1</span>; i = ne[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; distance + w[i]) &#123;</span><br><span class="line">                dist[j] = distance + w[i];</span><br><span class="line">                heap.push(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-单源-Bellman-Ford算法"><a href="#2-单源-Bellman-Ford算法" class="headerlink" title="2 单源 Bellman-Ford算法"></a>2 单源 Bellman-Ford算法</h1><p>一维数组dist[]来存储每个点到起点的距离，初始化dist[S]  = 0，其他初始化为INF。</p><p>找到从起点到某个点的最短路，设起点为S，终点为D，那这条最短路一定是$S-&gt;P_1-&gt;P_2-&gt;…-&gt;D$的形式，假设<strong>没有负权环</strong>，那这条路径上的点的总个数一定<strong>不大于n</strong>。</p><p>定义对点x, y的松弛操作是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dist[y] = min(dist[y], dist[x] + e[x][y]);<span class="comment">//这里的e[x][y]表示x、y之间的距离，具体形式可能根据存图方法不同而改变</span></span><br></pre></td></tr></table></figure><p>松弛操作就相当于考察能否<strong>经由x点</strong>使<strong>起点到y点</strong>的距离变短。</p><p>所以要找到最短路，只需要进行以下步骤：</p><ol><li>先松弛$S$, $P_1$，此时$dist[P_1]$必然等于$e[S][P_1]$</li><li>再松弛$P_1, P_2$，因为$S-&gt;P_1-&gt;P_2$是最短路的一部分，<strong>最短路的子路也是最短路</strong>（这是显然的），所以$dist[P_2]$不可能小于$dist[P_1]+e[P_1][P_2]$，因此它会被更新为$dist[P1]+e[P1][P2]$，即$e[S][P1]+e[P1][P2]$。</li><li>再松弛$P2, P3$，……以此类推，最终$dist[D]$必然等于$e[S][P1]+e[P1][P2]+…$，这恰好就是最短路径。</li></ol><p><strong>把所有边松弛n-1遍！</strong></p><p><a href="https://zhuanlan.zhihu.com/p/96621396" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/96621396</a></p><p><a href="https://blog.csdn.net/luomingjun12315/article/details/50377525" target="_blank" rel="noopener">https://blog.csdn.net/luomingjun12315/article/details/50377525</a></p><h1 id="3-单源-SPFA算法"><a href="#3-单源-SPFA算法" class="headerlink" title="3 单源 SPFA算法"></a>3 单源 SPFA算法</h1><p><strong>SPFA算法</strong>，也就是<strong>队列优化</strong>的Bellman-Ford算法，维护一个队列。</p><h1 id="4-全源-Floyd算法"><a href="#4-全源-Floyd算法" class="headerlink" title="4 全源 Floyd算法"></a>4 全源 Floyd算法</h1><p>求出每一对顶点之间的最短路径。Floyd本质上是一个<strong>动态规划</strong>的思想，每一次循环更新<strong>经由k点，i到j的最短路径</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算法结束后，d[a][b]表示a到b的最短距离，path存放路径信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//初始化：</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (i == j) d[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> d[i][j] = inf;</span><br><span class="line">    <span class="comment">//memset(path, -1, sizeof path);</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//dp </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k ++ ) &#123;<span class="comment">//考虑以k为中转点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ ) &#123;</span><br><span class="line">                <span class="keyword">if</span> (d[i][j] &gt; d[i][k] + d[k][j]) &#123;<span class="comment">//以k为中转点的路径更短</span></span><br><span class="line">                d[i][j] = d[i][k] + d[k][j];<span class="comment">//更新最短路径长度</span></span><br><span class="line">                    <span class="comment">//path[i][j] = k;//中转点</span></span><br><span class="line">                &#125;     </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-全源-Johnson算法"><a href="#5-全源-Johnson算法" class="headerlink" title="5 全源 Johnson算法"></a>5 全源 Johnson算法</h1><h1 id="6-BFS算法"><a href="#6-BFS算法" class="headerlink" title="6 BFS算法"></a>6 BFS算法</h1><p>该算法求单源最短路径只适用于无权图，或所有边的权值都相同的图。</p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><ol><li><a href="https://www.acwing.com/problem/content/851/" target="_blank" rel="noopener">acwing模板题目——Dijkstra求最短路 I</a></li><li><a href="https://www.acwing.com/problem/content/852/" target="_blank" rel="noopener">Dijkstra求最短路 II</a></li><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构和算法" scheme="https://Dragonliu2018.github.io/categories/数据结构和算法/"/>
    
    
    <category term="图论" scheme="https://Dragonliu2018.github.io/tags/图论/"/>
    
  </entry>
  
  <entry>
    <title>并查集</title>
    <link href="https://dragonliu2018.github.io/2021/04/09/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>https://dragonliu2018.github.io/2021/04/09/%E5%B9%B6%E6%9F%A5%E9%9B%86/</id>
    <published>2021-04-09T10:04:48.000Z</published>
    <updated>2021-09-21T13:39:31.377Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="简介"><a href="#简介" class="headerlink" title="简介　　"></a>简介　　</h1><p>英文：Disjoint Set，即“不相交集合”。将编号分别为$1…N$的$N$个对象划分为不相交集合，在每个集合中，选择其中某个元素代表所在集合。常见两种操作：</p><ol><li>合<strong>并</strong>两个集合；</li><li><strong>查</strong>找某元素属于哪个集合。</li></ol><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="1-无优化"><a href="#1-无优化" class="headerlink" title="1 无优化"></a>1 无优化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>;</span><br><span class="line"><span class="keyword">int</span> node[maxn];<span class="comment">//每个节点的父节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n; i++ )&#123;</span><br><span class="line">        node[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找当前元素所在树的根节点(代表元素)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == node[x])</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> find(node[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//合并x和y所在的集合</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> root_x = find(x);<span class="comment">//找到根节点</span></span><br><span class="line">    <span class="keyword">int</span> root_y = find(y);</span><br><span class="line">    <span class="keyword">if</span> (root_x == root_y)<span class="comment">//两者根节点相同</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    node[root_x] = root_y;<span class="comment">//将x的根节点与y的根节点相连</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断xy是否属于一个集合</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">same</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> find(x) == find(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-优化-路径压缩-按秩合并"><a href="#2-优化-路径压缩-按秩合并" class="headerlink" title="2 优化(路径压缩+按秩合并)"></a>2 优化(路径压缩+按秩合并)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>;</span><br><span class="line"><span class="keyword">int</span> node[maxn];<span class="comment">//每个节点的父节点</span></span><br><span class="line"><span class="keyword">int</span> Rank[maxn];<span class="comment">//树的高度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        node[i] = i;</span><br><span class="line">        Rank[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//路径压缩</span></span><br><span class="line"><span class="comment">//查找当前元素所在树的根节点(代表元素)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == node[x])</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> node[x] = find(node[x]);<span class="comment">//在第一次查找时，将节点直连到根节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按秩合并</span></span><br><span class="line"><span class="comment">//合并x和y所在的集合</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> root_x = find(x);<span class="comment">//找到根节点</span></span><br><span class="line">    <span class="keyword">int</span> root_y = find(y);</span><br><span class="line">    <span class="keyword">if</span> (root_x == root_y)<span class="comment">//两者根节点相同</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="comment">//判断两棵树的高度，然后在决定谁为子树</span></span><br><span class="line">    <span class="keyword">if</span> (Rank[root_x] &lt; Rank[root_y])</span><br><span class="line">        node[root_x] = root_y;<span class="comment">//将x的根节点接到y的根节点下</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        node[root_y] = root_x;<span class="comment">//将y的根节点与x的根节点下</span></span><br><span class="line">        <span class="keyword">if</span> (Rank[root_x] == Rank[root_y])<span class="comment">//树的高度相同</span></span><br><span class="line">            Rank[root_x]++;<span class="comment">//root_x树高度+1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断xy是否属于一个集合</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">same</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> find(x) == find(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>直接实现的话，时间复杂度最坏可以到$O(n)$。<br>两个常见优化，启发式合并，路径压缩。</p><ul><li>启发式合并：把大小较小的集合挂在较大的集合上。（有的写法是考虑深度而不是大小）</li><li>路径压缩：询问过的点到根节点的路径，都直接挂在根节点上。</li></ul><p>实现其中任意一个时间复杂度变为$O(\log n)$。<br>实现其中两个，时间复杂度变为$O(\alpha(n))$，其中$\alpha(n)$是阿克曼函数的反函数，可以认为非常小。</p><p>多数情况下为了简单，都实现路径压缩（只需要一句赋值）而不实现启发式合并（需要记录大小）</p><p>在某些题目中由于会爆栈，需要使用非递归的find函数。</p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><ol><li><a href="https://www.luogu.com.cn/problem/P3367" target="_blank" rel="noopener">洛谷——P3367 【模板】并查集</a></li><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构和算法" scheme="https://Dragonliu2018.github.io/categories/数据结构和算法/"/>
    
    
    <category term="数据结构" scheme="https://Dragonliu2018.github.io/tags/数据结构/"/>
    
  </entry>
  
  <entry>
    <title>关键路径</title>
    <link href="https://dragonliu2018.github.io/2021/04/09/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/"/>
    <id>https://dragonliu2018.github.io/2021/04/09/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/</id>
    <published>2021-04-09T09:13:18.000Z</published>
    <updated>2021-09-21T13:40:54.375Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><strong>概念</strong>：</p><ol><li>AOE网（Activity On Edge Network，用顶点表示活动的网）：在带权有向图中，以顶点表示事件，以有向边表示活动，以边上的权值表示完成该活动的开销（如完成活动所需的时间），称之为用边表示活动的网络。</li><li>在AOE网中仅有一个入度为0的顶点，称为开始顶点（源点），它表示整个工程的开始；也仅有一个出度为0的顶点，称为结束顶点（汇点），它表示整个工程的结束。</li><li>从源点到汇点的有向路径可能有多条，所有路径中，具有最大路径长度的路径称为关键路径，而把关键路径上的活动称为关键活动。</li><li>完成整个工程的最短时间就是关键路径的长度，若关键活动不能按时完成，则整个工程的完成时间就会延长。</li></ol><p><strong>性质</strong>：</p><ol><li>只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始；</li><li>只有在进入某顶点的各有向边所代表的活动都已结束时，该顶点所代表的事件才能发生。另外，有些活动是可以并行进行的。</li></ol><p><strong>求解关键路径的一些定义</strong>：</p><ul><li>事件$v_k$的最早发生时间$ve{(k)}$——决定了所有以$v_k$开始的活动能够开工的最早时间</li><li>活动$a_i$的最早开始时间$e(i)$——指该活动弧的起点所表示的事件的最早发生时间</li><li>事件$v_k$的最迟发生时间$vl(k)$——它是指在不推迟整个工程完成的前提下，该事件最迟必须发生的时间。</li><li>活动$a_i$的最迟开始时间$l(i)$——它是指该活动弧的终点所表示事件的最迟发生时间与该活动所需时间之差。</li><li>活动$a_i$的时间余量$d(i)=l(i)-e(i)$，表示在不增加完成整个工程所需总时间的情况下，活动$a_i$可以拖延的时间</li><li>若一个活动的时间余量为零，则说明该活动必须要如期完成，$d(i)=0$的活动$a_i$是关键活动；由关键活动组成的路径就是关键路径。</li></ul><p><strong>求解关键路径的步骤</strong>：</p><ol><li><p>求所有事件的最早发生时间$ve()$</p><ul><li>按拓扑排序序列，依次求各个顶点的 $v e(k)$ :<br>$v e($ 源点 $)=0$<br>$v e(k)=\operatorname{Max}\left{v \mathrm{e}(j)+\operatorname{Weight}\left(v<em>{j}, v</em>{k}\right)\right}, \quad v<em>{j}$ 为 $v</em>{k}$ 的任意前驱</li></ul></li><li><p>求所有事件的最迟发生时间$vl()$</p><ul><li><p>按逆拓扑排序序列，依次求各个顶点的 $v l(\boldsymbol{k})$ :<br>$v l($ 汇点 $)=v e( 汇点)$ </p><p>$v l(k)=\operatorname{Min}\left{v l(j)-\operatorname{Weight}\left(v<em>{k}, v</em>{j}\right)\right}, v<em>{j}$ 为 $v</em>{k}$ 的任意后继</p></li></ul></li><li><p>求所有活动的最早发生时间$e()$</p><ul><li>若边 $<v_{k}, v_{j}>$ 表示活动 $a_{i}$, 则有 $e(i)=v e(k)$</v_{k},></li></ul></li><li><p>求所有活动的最迟发生时间$l()$</p><ul><li>若边 $<v_{k}, v_{j}>$ 表示活动 $a<em>{i}$, 则有 $l(i)=v l(j)-$ Weight $\left(v</em>{k}, v_{j}\right)$</v_{k},></li></ul></li><li><p>求所有活动的时间余量$d()$</p><ul><li>$d(i)=l(i)-e(i)$</li></ul></li></ol><p><strong>关键活动、关键路径的特性</strong>：</p><ol><li>若关键活动耗时增加，则整个工程的工期将增长</li><li>缩短关键活动的时间，可以缩短整个工程的工期</li><li>当缩短到一定程度时，关键活动可能会变成非关键活动</li><li>可能有多条关键路径，只提高一条关键路径上的关键活动速度并不能缩短整个工程的工期，只有加快那些包括在所有关键路径上的关键活动才能达到缩短工期的目的。</li></ol><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><ol><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构和算法" scheme="https://Dragonliu2018.github.io/categories/数据结构和算法/"/>
    
    
    <category term="图论" scheme="https://Dragonliu2018.github.io/tags/图论/"/>
    
  </entry>
  
  <entry>
    <title>拓扑排序</title>
    <link href="https://dragonliu2018.github.io/2021/04/09/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    <id>https://dragonliu2018.github.io/2021/04/09/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</id>
    <published>2021-04-09T09:13:18.000Z</published>
    <updated>2021-09-21T13:41:58.695Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>有向无环图：若一个有向图中不存在环，则称为有向无环图，简称DAG图（Directed Acyclic Graph）</p><p>AOV网（Activity On Vertex Network，用顶点表示活动的网）：用DAG表示一个工程，顶点表示活动，有向边$<v_i,v_j>$表示活动$V_i$必须先于$V_j$进行。</v_i,v_j></p><p>拓扑排序是一个有向无环图(DAG)的所有顶点的线性序列，且该序列必须满足下面两个条件：</p><ol><li>每个顶点出现且只出现一次。</li><li>若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。</li></ol><p><strong>实现</strong>：</p><ol><li>从AOV网中选择一个没有前驱（入度为0）的顶点并输出；</li><li>从网中删除该顶点和所有以它为起点的有向边；</li><li>重复1和2直到当前的AOV网为空或当前网中不存在无前驱的顶点为止（说明有回路）。</li></ol><p><strong>逆拓扑序</strong>：</p><ol><li>从AOV网中选择一个没有后继（出度为0）的顶点并输出；</li><li>从网中删除该顶点和所有以它为终点的有向边；</li><li>重复1和2直到当前的AOV网为空。</li></ol><p><strong>思路</strong>：</p><ol><li>用一种容器（比如栈，队列，集合）维护当前所有入度为0的点。</li><li>每次从容器中取出一个点，删掉他和他的出边，这可能导致一些点入度为0，将新的入度为0的点加入容器。</li></ol><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>邻接表：时间复杂度 $O(n+m)$, $n$ 表示点数，$m$ 表示边数</p><p>邻接矩阵：时间复杂度 $O(n^2)$</p><p>也可以使用dfs实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxe = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;      <span class="comment">// 点的数量</span></span><br><span class="line"><span class="keyword">int</span> h[maxn], e[maxe], ne[maxe], idx;  <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="keyword">int</span> d[maxn];<span class="comment">//每个点的入度 </span></span><br><span class="line"><span class="keyword">int</span> print[maxn];<span class="comment">//拓扑序列 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//加边</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    e[idx] = y; <span class="comment">// 这样堆中会有很多冗余的点，但是在弹出的时候还是会弹出最小值2+x（x为之前确定的最短路径），并</span></span><br><span class="line">    ne[idx] = h[x]; <span class="comment">// 标记st为true，所以下一次弹出3+x会continue不会向下执行。</span></span><br><span class="line">    h[x] = idx++;</span><br><span class="line">    d[y]++;<span class="comment">//入度 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拓扑排序 </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">topsort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;<span class="comment">//存储入度为0的点 </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// d[i] 存储点i的入度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!d[i])<span class="comment">//将所有入度为0的点入栈 </span></span><br><span class="line">            s.push(i);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;<span class="comment">//记录当前已经输出的顶点数 </span></span><br><span class="line">    <span class="keyword">while</span> (!s.empty()) &#123;<span class="comment">//栈不空，存在入度为0的顶点 </span></span><br><span class="line">        <span class="keyword">int</span> t = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        print[cnt++] = t; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (-- d[j] == <span class="number">0</span>)</span><br><span class="line">                s.push(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。</span></span><br><span class="line">    <span class="keyword">return</span> cnt == n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><ol><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构和算法" scheme="https://Dragonliu2018.github.io/categories/数据结构和算法/"/>
    
    
    <category term="图论" scheme="https://Dragonliu2018.github.io/tags/图论/"/>
    
  </entry>
  
</feed>
