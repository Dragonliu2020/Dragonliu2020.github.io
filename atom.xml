<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dragon Liu</title>
  
  
  <link href="https://dragonliu2022.github.io/atom.xml" rel="self"/>
  
  <link href="https://dragonliu2022.github.io/"/>
  <updated>2022-09-07T15:05:54.463Z</updated>
  <id>https://dragonliu2022.github.io/</id>
  
  <author>
    <name>Dragon Liu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>北航健康上报打卡</title>
    <link href="https://dragonliu2022.github.io/2022/09/07/%E5%8C%97%E8%88%AA%E5%81%A5%E5%BA%B7%E4%B8%8A%E6%8A%A5%E6%89%93%E5%8D%A1/"/>
    <id>https://dragonliu2022.github.io/2022/09/07/%E5%8C%97%E8%88%AA%E5%81%A5%E5%BA%B7%E4%B8%8A%E6%8A%A5%E6%89%93%E5%8D%A1/</id>
    <published>2022-09-07T03:25:13.000Z</published>
    <updated>2022-09-07T15:05:54.463Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-引言"><a class="markdownIt-Anchor" href="#1-引言"></a> 1 引言</h1><p><strong>需求</strong>：打卡很容易忘记，想自动化处理此事。</p><p><strong>声明</strong>：学习与技术讨论，勿实操！！！</p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><blockquote><p>思路主要参考：<a href="https://github.com/mottled233/buaa_daily_report" target="_blank" rel="noopener">https://github.com/mottled233/buaa_daily_report</a></p></blockquote><ol><li>在Windows下编写脚本，使用chrome+selenium，模拟浏览器点击；<ul><li>打开网页并登陆</li><li>进行打卡</li></ul></li><li>通过 <strong>win10toast</strong> 实现在 Win10 系统中发送桌面消息通知；</li><li>借助<code>Server酱+PushDeer</code> 推送打卡结果至手机；</li><li>最终，使用Windows自带的<code>任务计划程序</code>实现定时执行脚本。</li></ol><h1 id="3-实现"><a class="markdownIt-Anchor" href="#3-实现"></a> 3 实现</h1><h2 id="31-打卡脚本"><a class="markdownIt-Anchor" href="#31-打卡脚本"></a> 3.1 打卡脚本</h2><p><strong>daily_report.py</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.chrome.options <span class="keyword">import</span> Options</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.action_chains <span class="keyword">import</span> ActionChains</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"></span><br><span class="line">user = <span class="string">"xxx"</span>  <span class="comment"># 你的统一认证账号</span></span><br><span class="line">passwd = <span class="string">"xxx"</span>  <span class="comment"># 你的统一认证密码</span></span><br><span class="line">position = (<span class="string">"39.97812"</span>, <span class="string">"116.343936"</span>)  <span class="comment"># 定位，经纬度, 这个经纬度是大运村三号楼</span></span><br><span class="line">SCKEY = <span class="string">"xxx"</span>  <span class="comment"># 微信推送api，到http://sc.ftqq.com/ 免费申请，不需要请留空</span></span><br><span class="line">max_attempt = <span class="number">5</span>  <span class="comment"># 失败重复五次</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_config</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    日志文件配置</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    log_file = <span class="string">"log.log"</span></span><br><span class="line">    formatter = logging.Formatter(<span class="string">"%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s"</span>)</span><br><span class="line">    logger = logging.getLogger(<span class="string">"main"</span>)</span><br><span class="line">    fh = logging.FileHandler(log_file, mode=<span class="string">'w'</span>)</span><br><span class="line">    fh.setFormatter(formatter)</span><br><span class="line">    ch = logging.StreamHandler()</span><br><span class="line">    ch.setFormatter(formatter)</span><br><span class="line">    logger.addHandler(fh)</span><br><span class="line">    logger.addHandler(ch)</span><br><span class="line">    logger.setLevel(logging.INFO)</span><br><span class="line">    <span class="keyword">return</span> logger</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sign_in</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    模拟签到</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    logger.info(<span class="string">"正在进行验证..."</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Step1 测试能否进入网页以及用户名密码是否正确</span></span><br><span class="line">    chrome_options = Options()</span><br><span class="line">    chrome_options.add_argument(<span class="string">'--headless'</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">'--disable-gpu'</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">'--no-sandbox'</span>)</span><br><span class="line">    browser = webdriver.Chrome(chrome_options=chrome_options)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        url = <span class="string">"https://app.buaa.edu.cn/uc/wap/login?redirect=https%3A%2F%2Fapp.buaa.edu.cn%2Fsite%2FbuaaStudentNcov%2Findex"</span></span><br><span class="line">        browser.get(url)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 账号密码</span></span><br><span class="line">        user_name_input = browser.find_element_by_css_selector(</span><br><span class="line">            <span class="string">'#app &gt; div.content &gt; div:nth-child(1) &gt; input[type=text]'</span>)</span><br><span class="line">        user_name_input.send_keys(user)</span><br><span class="line">        user_pwd_input = browser.find_element_by_css_selector(</span><br><span class="line">            <span class="string">'#app &gt; div.content &gt; div:nth-child(2) &gt; input[type=password]'</span>)</span><br><span class="line">        user_pwd_input.send_keys(passwd)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        logger.info(<span class="string">"打开打卡网页失败，请确认网络"</span>)</span><br><span class="line">        send_message(<span class="string">"北航打卡：打开打卡网页失败，请确认网络"</span>)</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    logger.info(<span class="string">"成功打开打卡网页"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 点击登录按钮</span></span><br><span class="line">    login_button = browser.find_element_by_css_selector(<span class="string">'#app &gt; div.btn'</span>)</span><br><span class="line">    ActionChains(browser).move_to_element(login_button).click(login_button).perform()</span><br><span class="line">    browser.implicitly_wait(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 跳转并点击获取位置按钮</span></span><br><span class="line">    <span class="comment"># 这样写是为了等待跳转页面加载出来</span></span><br><span class="line">    fail_cnt = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        location_button = browser.find_elements_by_css_selector(</span><br><span class="line">            <span class="string">'body &gt; div.buaaStudentNcov &gt; div.buaaStudentNcov-bg &gt; div &gt; div:nth-child(5) &gt; div &gt; div.warp-list-choose &gt; div.warp-list.two-warp-list.warp-list-margin &gt; div.title-input.title-input-mergin-left'</span>)</span><br><span class="line">        <span class="keyword">if</span> len(location_button) &gt; <span class="number">0</span>:</span><br><span class="line">            logger.info(<span class="string">"登录成功"</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 出现密码错误提示框</span></span><br><span class="line">            <span class="keyword">if</span> len(browser.find_elements_by_css_selector(<span class="string">'div.wapat-btn-box'</span>)) &gt; <span class="number">0</span>:</span><br><span class="line">                send_message(<span class="string">"北航打卡：打卡失败，用户名密码错误，程序已退出，请检查"</span>)</span><br><span class="line">                logger.info(<span class="string">"打卡失败，用户名密码错误，请检查"</span>)</span><br><span class="line">                exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 若只是反应慢，重试</span></span><br><span class="line">            <span class="keyword">if</span> fail_cnt &gt;= max_attempt:</span><br><span class="line">                send_message(<span class="string">"北航打卡：登录超时超过最大尝试次数，请检查网络或打卡系统已崩溃"</span>)</span><br><span class="line">                logger.info(<span class="string">"登录超时超过最大尝试次数"</span>)</span><br><span class="line">                exit(<span class="number">0</span>)</span><br><span class="line">            time.sleep(<span class="number">10</span>)</span><br><span class="line">            browser.get(<span class="string">"https://app.buaa.edu.cn/site/buaaStudentNcov/index"</span>)</span><br><span class="line">            logger.info(<span class="string">"登录超时，正在重试"</span>)</span><br><span class="line">            fail_cnt += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Step2 签到</span></span><br><span class="line">    browser.execute_script(<span class="string">"window.navigator.geolocation.getCurrentPosition=function(success)&#123;"</span> +</span><br><span class="line">                           <span class="string">"var position = &#123;\"coords\" : &#123;\"latitude\": \""</span> + position[<span class="number">0</span>] + <span class="string">"\",\"longitude\": \""</span></span><br><span class="line">                           + position[<span class="number">1</span>] + <span class="string">"\"&#125;&#125;;"</span> +</span><br><span class="line">                           <span class="string">"success(position);&#125;"</span>)</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    location_button = browser.find_element(By.XPATH, <span class="string">"/html/body/div[1]/div[1]/div/div[5]/div/div[2]/div[2]/div[2]/input"</span>)</span><br><span class="line">    ActionChains(browser).move_to_element(location_button).click(location_button).perform()</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    location = location_button.get_attribute(<span class="string">'value'</span>)</span><br><span class="line">    logger.info(<span class="string">f"成功输入经纬度，定位<span class="subst">&#123;location&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">    browser.implicitly_wait(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            submit_button = browser.find_element(By.XPATH, <span class="string">'/html/body/div[1]/div[1]/div/div[6]'</span>)</span><br><span class="line">            <span class="keyword">if</span> submit_button.text.find(<span class="string">"您已提交过信息"</span>) != <span class="number">-1</span>:</span><br><span class="line">                result = <span class="string">"打卡失败，您已经提交过"</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span> submit_button.text.find(<span class="string">"未到填报时间"</span>) != <span class="number">-1</span>:</span><br><span class="line">                result = <span class="string">"未到填报时间"</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            submit_button.click()</span><br><span class="line">            result = <span class="string">'提交成功'</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                reason = browser.find_element_by_css_selector(<span class="string">'#wapat &gt; div &gt; div.wapat-title'</span>).text</span><br><span class="line">                result = <span class="string">f'打卡失败，原因：<span class="subst">&#123;reason&#125;</span>'</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    browser.save_screenshot(<span class="string">'location_test.png'</span>)</span><br><span class="line">    logger.info(result)</span><br><span class="line">    datee = datetime.date.today()</span><br><span class="line">    send_message(<span class="string">"北航打卡："</span> + <span class="string">f"<span class="subst">&#123;result&#125;</span> <span class="subst">&#123;datee&#125;</span>"</span>)</span><br><span class="line">    sleep(<span class="number">50</span>)</span><br><span class="line">    browser.quit()</span><br><span class="line">    logger.info(<span class="string">"流程结束"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_message</span><span class="params">(msg)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    发送信息到手机，将结果写入临时文件，便于Windows消息提醒</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> SCKEY == <span class="string">""</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    payload = &#123;<span class="string">'text'</span>: msg&#125;</span><br><span class="line">    requests.get(<span class="string">f"https://sc.ftqq.com/<span class="subst">&#123;SCKEY&#125;</span>.send"</span>, params=payload)</span><br><span class="line"></span><br><span class="line">    f = open(<span class="string">"result.txt"</span>, <span class="string">"w"</span>)</span><br><span class="line">    f.write(msg)</span><br><span class="line">    f.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    logger = log_config()</span><br><span class="line">    sign_in()</span><br></pre></td></tr></table></figure><hr><p><strong>关于位置经纬度获取</strong>：</p><ol><li><p>打开网页版高德地图：<a href="https://www.amap.com/" target="_blank" rel="noopener">https://www.amap.com/</a></p></li><li><p>选择指定位置，右键，选择<code>这是哪儿</code>；</p></li><li><p>选择<code>更多</code>里面的<code>分享</code>；</p></li><li><p>复制链接，在新的标签页打开，URL会自动补全，其中包含经纬度信息：<code>lng=116.343936&amp;lat=39.97812</code></p><blockquote><ul><li><p>表示东经116.343936度，北纬39.97812度；</p></li><li><p>上面脚本中的<code>position</code>变量是由维度和经度组成的二元组</p></li></ul></blockquote></li></ol><p><strong>关于手机信息推送</strong>：</p><ol><li><p>上面脚本中的变量<code>SCKEY</code>是填<a href="https://sct.ftqq.com/sendkey" target="_blank" rel="noopener">Server酱的Key</a>：</p><img src="https://s3.bmp.ovh/imgs/2022/09/07/b9866e6c7db775c2.png" width="550" height="200" alt="图片名称" align="center" id="221"></li><li><p>为了手机通知明显，通道配置使用PushDeer，<a href="http://www.pushdeer.com/" target="_blank" rel="noopener">手机安装PushDeer</a>，配置pushkey：</p><img src="https://s3.bmp.ovh/imgs/2022/09/07/90b81e137f8ae056.png" width="550" height="300" alt="图片名称" align="center" id="222"></li></ol><h2 id="32-windows消息提醒脚本"><a class="markdownIt-Anchor" href="#32-windows消息提醒脚本"></a> 3.2 Windows消息提醒脚本</h2><p><strong>buaa_notice.py</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> winrt.windows.ui.notifications <span class="keyword">import</span> ToastNotificationManager, ToastNotification</span><br><span class="line"><span class="keyword">import</span> winrt.windows.data.xml.dom <span class="keyword">as</span> dom</span><br><span class="line"></span><br><span class="line">notifier = ToastNotificationManager.create_toast_notifier(<span class="string">r'xxx'</span>) <span class="comment"># python.exe路径</span></span><br><span class="line"></span><br><span class="line">title = <span class="string">"北航打卡"</span></span><br><span class="line">f = open(<span class="string">"result.txt"</span>, <span class="string">"r"</span>)</span><br><span class="line">desp = f.read()</span><br><span class="line">f.close()</span><br><span class="line">tString = <span class="string">"""&lt;toast duration='short'&gt;&lt;audio src  = 'ms-winsoundevent:Notification.Reminder' loop = 'false' silent = 'false'/&gt;&lt;visual&gt;&lt;binding template='ToastText02'&gt;&lt;text id="1"&gt;"""</span> + title + <span class="string">"""&lt;/text&gt;&lt;text id="2"&gt;"""</span> + desp + <span class="string">"""&lt;/text&gt;&lt;/binding&gt;&lt;/visual&gt;&lt;/toast&gt;"""</span></span><br><span class="line"></span><br><span class="line">xDoc = dom.XmlDocument()</span><br><span class="line">xDoc.load_xml(tString)</span><br><span class="line">notifier.show(ToastNotification(xDoc))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    print(<span class="string">"打卡成功！"</span>)</span><br></pre></td></tr></table></figure><h2 id="33-定时执行脚本"><a class="markdownIt-Anchor" href="#33-定时执行脚本"></a> 3.3 定时执行脚本</h2><p><strong>buaa.bat</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python daily_report.py</span><br><span class="line">python buaa_notice.py</span><br></pre></td></tr></table></figure><p>如何配置，参考<a href="https://dragonliu2020.github.io/2022/04/10/Dukou%E7%BD%91%E7%AB%99%E8%87%AA%E5%8A%A8%E5%8C%96%E7%AD%BE%E5%88%B0/" target="_blank" rel="noopener">Dukou网站自动化签到</a></p><h1 id="4-参考"><a class="markdownIt-Anchor" href="#4-参考"></a> 4 参考</h1><ul><li><a href="https://github.com/mottled233/buaa_daily_report" target="_blank" rel="noopener">北航每日自动打卡脚本 v1.1</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Python" scheme="https://dragonliu2022.github.io/categories/Python/"/>
    
    <category term="爬虫" scheme="https://dragonliu2022.github.io/categories/Python/爬虫/"/>
    
    
    <category term="selenium" scheme="https://dragonliu2022.github.io/tags/selenium/"/>
    
  </entry>
  
  <entry>
    <title>《人月神话》笔记</title>
    <link href="https://dragonliu2022.github.io/2022/07/26/%E3%80%8A%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    <id>https://dragonliu2022.github.io/2022/07/26/%E3%80%8A%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D%E3%80%8B%E7%AC%94%E8%AE%B0/</id>
    <published>2022-07-26T14:14:23.000Z</published>
    <updated>2022-07-26T15:35:55.871Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-焦油坑"><a class="markdownIt-Anchor" href="#1-焦油坑"></a> 1 焦油坑</h1><ul><li><p>编程系统产品（Programming Systems Product）开发的工作量是供个人使用的、独立开发的构件程序的九倍。我估计软件构件产品化引起了 3 倍工作量，将软件构件整合成完整系统所需要的设计、集成和测试又强加了 3 倍的工作量，这些高成本的构件在根本上是相互独立的。</p></li><li><p>编程行业“满足我们内心深处的创造渴望和愉悦所有人的共有情感”，提供了五种乐趣：</p></li><li><p>创建事物的快乐</p></li><li><p>开发对其他人有用的东西的乐趣</p></li><li><p>将可以活动、相互啮合的零部件组装成类似迷宫的东西，这个过程所体现出令人神魂颠倒的魅力</p></li><li><p>面对不重复的任务，不间断学习的乐趣</p></li><li><p>工作在如此易于驾驭的介质上的乐趣——纯粹的思维活动，其存在、移动和运转方式完全不同于实际物体</p></li><li><p>同样，这个行业具有一些内在固有的苦恼：</p></li><li><p>将做事方式调整到追求完美，是学习编程的最困难部分</p></li><li><p>由其他人来设定目标，并且必须依靠自己无法控制的事物（特别是程序）；权威不等同于责任</p></li><li><p>实际情况看起来要比这一点好一些：真正的权威来自于每次任务的完成</p></li><li><p>任何创造性活动都伴随着枯燥艰苦的劳动，编程也不例外</p></li><li><p>人们通常期望项目在接近结束时，（bug、工作时间）能收敛得快一些，然而软件项目的情况却是越接近完成，收敛得越慢</p></li><li><p>产品在即将完成时总面临着陈旧过时的威胁</p></li></ul><h1 id="2-人月神话"><a class="markdownIt-Anchor" href="#2-人月神话"></a> 2 人月神话</h1><ul><li><p>简化的Brooks 法则：向进度落后的项目中增加人手，只会使进度更加落后。（Adding manpower to a late software project makes it later）</p><p>这就是除去了神话色彩的人月。项目的时间依赖于顺序上的限制，人员的数量依赖于单个子任务的数量。在众多软件项目中，缺乏合理的时间进度是造成项目滞后的最主要原因，它比其他所有因素加起来的影响还要大。</p></li><li><p>良好的烹饪需要时间，某些任务无法在不损害结果的情况下加快速度。</p></li><li><p>所有的编程人员都是乐观主义者：“一切都将运作良好”。</p></li><li><p>由于编程人员通过纯粹的思维活动来开发，所以我们期待在实现过程中不会碰到困难。</p></li><li><p>但是，我们的构思是有缺陷的，因此总会有 bug。</p></li><li><p>我们围绕成本核算的估计技术，混淆了工作量和项目进展。人月是危险和带有欺骗性的神话，因为它暗示人员数量和时间是可以相互替换的。</p></li><li><p>在若干人员中分解任务会引发额外的沟通工作量——培训和相互沟通。</p></li><li><p>关于进度安排，我的经验是为 1/3 计划、1/6 编码、1/4 构件测试以及 1/4 系统测试。</p></li><li><p>作为一个学科，我们缺乏数据估计。</p></li><li><p>因为我们对自己的估计技术不确定，所以在管理和客户的压力下，我们常常缺乏坚持的勇气。</p></li><li><p>向软件项目中增派人手从三个方面增加了项目必要的总体工作量：任务重新分配本身和所造成的工作中断；培训新人员；额外的相互沟通。</p></li></ul><h1 id="3-外科手术队伍"><a class="markdownIt-Anchor" href="#3-外科手术队伍"></a> 3 外科手术队伍</h1><ul><li>这就是小型、精干队伍概念上的问题：对于真正意义上的大型系统，它太慢了。</li><li>同样有两年经验而且在受到同样的培训的情况下，优秀的专业程序员的工作效率是较差程序员的十倍。（Sackman、Erikson 和 Grand）</li><li>Sackman、Erikson 和 Grand 的数据显示经验和实际表现之间没有相互联系。我怀疑这种现象是否普遍成立。</li><li>小型、精干队伍是最好的——尽可能的少。</li><li>两个人的团队，其中一个项目经理，常常是最佳的人员使用方法。[留意一下上帝对婚姻的设计。]</li><li>对于真正意义上的大型系统，小型精干的队伍太慢了。</li><li>实际上，绝大多数大型编程系统的经验显示出，一拥而上的开发方法是高成本、速度缓慢、不充分的，开发出的产品无法进行概念上的集成。</li><li>一位首席程序员、类似于外科手术队伍的团队架构提供了一种方法——既能获得由少数头脑产生的产品完整性，又能得到多位协助人员的总体生产率，还彻底地减少了沟通的工作量。</li></ul><h1 id="4-贵族专制-民主政治和系统设计"><a class="markdownIt-Anchor" href="#4-贵族专制-民主政治和系统设计"></a> 4 贵族专制、民主政治和系统设计</h1><ul><li>“概念完整性是系统设计中最重要的考虑因素”。</li><li>“功能与理解上的复杂程度的比值才是系统设计的最终测试标准”，而不仅仅是丰富的功能。[该比值是对易用性的一种测量，由简单和复杂应用共同验证。]</li><li>为了获得概念完整性，设计必须由一个人或者具有共识的小型团队来完成。</li><li>“对于非常大型的项目，将设计方法、体系结构方面的工作与具体实现相分离是获得概念完整性的强有力方法。”[同样适用于小型项目。]</li><li>“如果要得到系统概念上的完整性，那么必须控制这些概念。这实际上是一种无需任何歉意的贵族专制统治。”</li><li>纪律、规则对行业是有益的。外部的体系结构规定实际上是增强，而不是限制实现小组的创造性。</li><li>概念上统一的系统能更快地开发和测试。</li><li>体系结构（architecture）、设计实现（implementation）、物理实现（realization）的许多工作可以并发进行。[软件和硬件设计同样可以并行。]</li></ul><h1 id="5-画蛇添足"><a class="markdownIt-Anchor" href="#5-画蛇添足"></a> 5 画蛇添足</h1><ul><li>尽早交流和持续沟通能使结构师有较好的成本意识，以及使开发人员获得对设计的信心，并且不会混淆各自的责任分工。</li><li>结构师如何成功地影响实现：<ul><li>牢记是开发人员承担创造性的实现责任；结构师只能提出建议。</li><li>时刻准备着为所指定的说明建议一种实现的方法，准备接受任何其他可行的方法。</li><li>对上述的建议保持低调和平静。</li><li>准备对所建议的改进放弃坚持。</li><li>听取开发人员在体系结构上改进的建议。</li></ul></li><li>第二个系统是人们所设计的最危险的系统，通常的倾向是过分地进行设计。</li><li>OS/360 是典型的画蛇添足（second-system effect）的例子。[Windows NT 似乎是90 年代的例子。]</li><li>为功能分配一个字节和微秒的优先权值是一个很有价值的规范化方法。</li></ul><h1 id="6-贯彻执行"><a class="markdownIt-Anchor" href="#6-贯彻执行"></a> 6 贯彻执行</h1><ul><li>即使是大型的设计团队，设计结果也必须由一个或两个人来完成，以确保这些决定是一致的。</li><li>必须明确定义体系结构中与先前定义不同的地方，重新定义的详细程度应该与原先的说明一致。</li><li>出于精确性的考虑，我们需要形式化的设计定义，同样，我们需要记叙性定义来加深理解。</li><li>必须采用形式化定义和记叙性定义中的一种作为标准，另一种作为辅助措施；它们都可以作为表达的标准。</li><li>设计实现，包括模拟仿真，可以充当一种形式化定义的方法；这种方法有一些严重的缺点。</li><li>直接整合是一种强制推行软件的结构性标准的方法。[硬件上也是如此——考虑内建在 ROM 中的 Mac WIMP 接口。]</li><li>“如果起初至少有两种以上的实现，那么（体系结构）定义会更加整洁，会更加规范。”</li><li>允许体系结构师对实现人员的询问做出电话应答解释是非常重要的，并且必须进行日志记录和整理发布。[电子邮件是一种可选的介质。]</li><li>“项目经理最好的朋友就是他每天要面对的敌人——独立的产品测试机构/小组。”</li></ul><h1 id="7-为什么巴比伦塔会失败"><a class="markdownIt-Anchor" href="#7-为什么巴比伦塔会失败"></a> 7 为什么巴比伦塔会失败？</h1><ul><li>巴比伦塔项目的失败是因为缺乏交流，以及交流的结果——组织。</li><li>“因为左手不知道右手在做什么，从而进度灾难、功能的不合理和系统缺陷纷纷出现。”由于对其他人的各种假设，团队成员之间的理解开始出现偏差。</li><li>团队应该以尽可能多的方式进行相互之间的交流：非正式、常规项目会议，会上进行简要的技术陈述、共享的正式项目工作手册。[以及电子邮件。]</li><li>项目工作手册“不是独立的一篇文档，它是对项目必须产生的一系列文档进行组织的一种结构。”</li><li>“项目所有的文档都必须是该（工作手册）结构的一部分。”</li><li>需要尽早和仔细地设计工作手册结构。</li><li>事先制订了良好结构的工作手册“可以将后来书写的文字放置在合适的章节中”，并且可以提高产品手册的质量。</li><li>“每一个团队成员应该了解所有的材料（工作手册）。”[我想说的是，每个团队成员应该能够看到所有材料，网页即可满足要求。]</li><li>实时更新是至关重要的。</li><li>工作手册的使用者应该将注意力集中在上次阅读后的变更，以及关于这些变更重要性的评述。</li><li>OS/360 项目工作手册开始采用的是纸介质，后来换成了微缩胶片。</li><li>今天[即使在 1975 年]，共享的电子手册是能更好达到所有这些目标、更加低廉、更加简单的机制。</li><li>仍然需要用变更条和修订日期[或具备同等功能的方法]来标记文字；仍然需要后进先出（LIFO）的电子化变更小结。</li><li>Parnas 强烈地认为使每个人看到每件事的目标是完全错误的；各个部分应该被封装，从而没有人需要或者允许看到其他部分的内部结构，只需要了解接口。</li><li>Parnas 的建议的确是灾难的处方。[Parnas 让我认可了该观点，使我彻底地改变了想法。]</li><li>团队组织的目标是为了减少必要的交流和协作量。</li><li>为了减少交流，组织结构包括了人力划分（division of labor）和限定职责范围（specialization of function）。</li><li>传统的树状组织结构反映了权力的结构原理——不允许双重领导。</li><li>组织中的交流是网状，而不是树状结构，因而所有的特殊组织机制（往往体现成组织结构图中的虚线部分）都是为了进行调整，以克服树状组织结构中交流缺乏的困难。</li><li>每个子项目具有两个领导角色——产品负责人、技术主管或结构师。这两个角色的职能有着很大的区别，需要不同的技能。</li><li>两种角色中的任意组合可以是非常有效的：<ul><li>产品负责人和技术主管是同一个人。</li><li>产品负责人作为总指挥，技术主管充当其左右手。</li><li>技术主管作为总指挥，产品负责人充当其左右手。</li></ul></li></ul><h1 id="8-胸有成竹"><a class="markdownIt-Anchor" href="#8-胸有成竹"></a> 8 胸有成竹</h1><ul><li>仅仅通过对编码部分的估计，然后乘以任务其他部分的相对系数，是无法得出对整项工作的精确估计的。</li><li>构建独立小型程序的数据不适用于编程系统项目。</li><li>程序开发呈程序规模的指数增长。</li><li>一些发表的研究报告显示指数约为 1.5。[Boehm 的数据并不完全一致，在 1.05 和1.2 之间变化。]</li><li>Portman 的 ICL 数据显示相对于其他活动开销，全职程序员仅将 50％的时间用于编程和调试。</li><li>IBM 的 Aron 数据显示，生产率是系统各个部分交互的函数，在 1.5K 千代码行/人年至 10K 千代码行/人年的范围内变化。</li><li>Harr 的 Bell 实验室数据显示对于已完成的产品，操作系统类的生产率大约是0.6KLOC/人年，编译类工作的生产率大约为 2.2KLOC/人年。</li><li>Brooks 的 OS/360S 数据与 Harr 的数据一致：操作系统 0.6～0.8KLOC/人年，编译器 2～3 KLOC/人年。</li><li>Corbato 的 MIT 项目 MULTICS 数据显示，在操作系统和编译器混合类型上的生产率 是 1.2KLOC/人年，但这些是 PL/I 的代码行，而其他所有的数据是汇编代码行。</li><li>在基本语句级别，生产率看上去是个常数。</li><li>当使用适当的高级语言时，程序编制的生产率可以提高 5 倍。</li></ul><h1 id="9-削足适履"><a class="markdownIt-Anchor" href="#9-削足适履"></a> 9 削足适履</h1><ul><li>除了运行时间以外，所占据的内存空间也是主要开销。特别是对于操作系统，它的很多程序是永久驻留在内存中。</li><li>即便如此，花费在驻留程序所占据内存上的金钱仍是物有所值的，比其他任何在配置上投资的效果要好。规模本身不是坏事，但不必要的规模是不可取的。</li><li>软件开发人员必须设立规模目标，控制规模，发明一些减少规模的方法——就如同硬件开发人员为减少元器件所做的一样。</li><li>规模预算不仅仅在占据内存方面是明确的，同时还应该指明程序对磁盘的访问次数。</li><li>规模预算必须与分配的功能相关联；在指明模块大小的同时，确切定义模块的功能。</li><li>在大型的团队中，各个小组倾向于不断地局部优化，以满足自己的目标，而较少考虑队用户的整体影响。这种方向性的问题是大型项目的主要危险。</li><li>在整个实现的过程期间，系统结构师必须保持持续的警觉，确保连贯的系统完整性。</li><li>培养开发人员从系统整体出发、面向用户的态度是软件编程管理人员最重要的职能。</li><li>在早期应该制订策略，以决定用户可选项目的粗细程度，因为将它们作为整体大包能够节省内存空间。[常常还可以节约市场成本。]</li><li>临时空间的尺寸，以及每次磁盘访问的程序数量是很关键的决策，因为性能是规模的非线性函数。[这个整体决策已显得过时——起初是由于虚拟内存，后来则是成本低廉的内存。现在的用户通常会购买能容纳主要应用程序所有代码的内存。]</li><li>为了取得良好的空间－时间折衷，开发队伍需要得到特定与某种语言或者机型的编程技能培训，特别是在使用新语言或者新机器时。</li><li>编程需要技术积累，每个项目需要自己的标准组件库。</li><li>库中的每个组件需要有两个版本，运行速度较快和短小精炼的。[现在看来有些过时。]</li><li>精炼、充分和快速的程序。往往是战略性突破的结果，而不仅仅技巧上的提高。</li><li>这种突破常常是一种新型算法。</li><li>更普遍的是，战略上突破常来自于数据或表的重新表达。数据的表现形式是编程的根本。</li></ul><h1 id="10-提纲挈领"><a class="markdownIt-Anchor" href="#10-提纲挈领"></a> 10 提纲挈领</h1><ul><li>“前提：在一片文件的汪洋中，少数文档形成了关键的枢纽，每个项目管理的工作都围绕着它们运转。它们是经理们的主要个人工具。”</li><li>对于计算机硬件开发项目，关键文档是目标、手册、进度、预算、组织机构图、空间分配、以及机器本身的报价、预测和价格。</li><li>对于大学科系，关键文档类似：目标、课程描述、学位要求、研究报告、课程表和课程的安排、预算、教室分配、教师和研究生助手的分配。</li><li>对于软件项目，要求是相同的：目标、用户手册、内部文档、进度、预算、组织机构图和工作空间分配。</li><li>因此，即使是小型项目，项目经理也应该在项目早期规范化上述的一系列文档。</li><li>以上集合中每一个文档的准备工作都将注意力集中在对讨论的思索和提炼，而书写这项活动需要上百次的细小决定，正是由于它们的存在，人们才能从令人迷惑的现象中得到清晰、确定的策略。</li><li>对每个关键文档的维护提供了状态监督和预警机制。</li><li>每个文档本身就可以作为检查列表或者数据库。</li><li>项目经理的基本职责是使每个人都向着相同的方向前进。</li><li>项目经理的主要日常工作是沟通，而不是做出决定；文档使各项计划和决策在整个团队范围内得到交流。</li><li>只有一小部分管理人员的时间——可能只有 20%——用来从自己头脑外部获取信息。</li><li>出于这个原因，广受吹捧的市场概念——支持管理人员的“完备信息管理系统”并不基于反映管理人员行为的有效模型。</li></ul><h1 id="11-未雨绸缪"><a class="markdownIt-Anchor" href="#11-未雨绸缪"></a> 11 未雨绸缪</h1><ul><li>化学工程师已经认识到无法一步将实验室工作台上的反应过程移到工厂中，需要一个实验性工厂（pilot planet）来为提高产量和在缺乏保护的环境下运作提供宝贵经验。</li><li>对于编程产品而言，这样的中间步骤是同样必要的，但是软件工程师在着手发布产品之前，却并不会常规地进行试验性系统的现场测试。[现在，这已经成为了一项普遍的实践，beta 版本。它不同于有限功能的原型，alpha 版本，后者同样是我所倡导的实践。]</li><li>对于大多数项目，第一个开发的系统并不合用。它可能太慢、太大，而且难以使用，或者三者兼而有之。</li><li>系统的丢弃和重新设计可以一步完成，也可以一块块地实现。这是个必须完成的步骤。</li><li>将开发的第一个系统——丢弃原型——发布给用户，可以获得时间，但是它的代价高昂——对于用户，使用极度痛苦；对于重新开发的人员，分散了精力；对于产品，影响了声誉，即使最好的再设计也难以挽回名声。</li><li>因此，为舍弃而计划，无论如何，你一定要这样做。</li><li>“开发人员交付的是用户满意程度，而不仅仅是实际的产品。”（Cosgrove）</li><li>用户的实际需要和用户感觉会随着程序的构建、测试和使用而变化。</li><li>软件产品易于掌握的特性和不可见性，导致了它的构建人员（特别容易）面临着永恒的需求变更。</li><li>目标上（和开发策略上）的一些正常变化无可避免，事先为它们做准备总比假设它们不会出现要好得多。</li><li>为变更计划软件产品的技术，特别是细致的模块接口文档——非常地广为人知，但并没有相同规模的实践。尽可能地使用表驱动技术同样是有所帮助的。[现在内存的成本和规模使这项技术越来越出众。]</li><li>高级语言的使用、编译时操作、通过引用的声明整合和自文档技术能减少变更引起的错误。</li><li>采用定义良好的数字化版本将变更量子（阶段）化。[当今的标准实践。]</li><li>程序员不愿意为设计书写文档的原因，不仅仅是由于惰性。更多的是源于设计人员的踌躇——要为自己尝试性的设计决策进行辩解。（Cosgrove）</li><li>为变更组建团队比为变更进行设计更加困难。</li><li>只要管理人员和技术人才的天赋允许，老板必须对他们的能力培养给予极大的关注，使管理人员和技术人才具有互换性；特别是希望能在技术和管理角色之间自由地分配人手的时候。</li><li>具有两条晋升线的高效组织机构，存在着一些社会性的障碍，人们必须警惕和积极地同它做持续的斗争。</li><li>很容易为不同的晋升线建立相互一致的薪水级别，但要同等威信的建立需要一些强烈的心理措施：相同的办公室、一样的支持和技术调动的优先补偿。</li><li>组建外科手术队伍式的软件开发团队是对上述问题所有方面的彻底冲击。对于灵活组织架构问题，这的确是一个长期行之有效的解决方案。</li><li>程序维护基本上不同于硬件的维护；它主要由各种变更组成，如修复设计缺陷、新增功能、或者是使用环境或者配置变换引起的调整。</li><li>对于一个广泛使用的程序，其维护总成本通常是开发成本的 40％或更多。</li><li>维护成本受用户数目的严重影响。用户越多，所发现的错误也越多。</li><li>Campbell 指出了一个显示产品生命期中每月 bug 数的有趣曲线，它先是下降，然后攀升。</li><li>缺陷修复总会以（20－50）%的机率引入新的 bug。</li><li>在每次修复之后，必须重新运行先前所有的测试用例，从而确保系统不会以更隐蔽的方式被破坏。</li><li>能消除、至少是能指明副作用的程序设计方法，对维护成本有很大的影响。</li><li>同样，设计实现的人员越少、接口越少，产生的错误也就越少。</li><li>Lehman 和 Belady 发现模块数量随大型操作系统（OS/360）版本号的增加呈线性增长，但是受到影响的模块以版本号指数的级别增长。</li><li>所有修改都倾向于破坏系统的架构，增加了系统的混乱程度。即使是最熟练的软件维护工作，也只是放缓了系统退化到不可修复混乱的进程，从中必须要重新进行设计。[许多程序升级的真正需要，如性能等，尤其会冲击它的内部结构边界。原有边界引发的不足常常在日后才会出现。]</li></ul><h1 id="12-干将莫邪"><a class="markdownIt-Anchor" href="#12-干将莫邪"></a> 12 干将莫邪</h1><ul><li>项目经理应该制订一套策略，以及为通用工具的开发分配资源，与此同时，他还必须意识到专业工具的需求。</li><li>开发操作系统的队伍需要自己的目标机器，进行调试开发工作。相对于最快的速度而言，它更需要最大限度的内存，还需要安排一名系统程序员，以保证机器上的标准软件是即时更新和实时可用的。</li><li>同时还需要配备调试机器或者软件，以便在调试过程中，所有类型的程序参数可以被自动计数和测量。</li><li>目标机器的使用需求量是一种特殊曲线：刚开始使用率非常低，突然出现爆发性的增长，接着趋于平缓。</li><li>同天文工作者一样，系统调试总是大部分在夜间完成。</li><li>抛开理论不谈，一次分配给某个小组连续的目标时间块被证明是最好的安排方法，比不同小组的穿插使用更为有效。</li><li>尽管技术不断变化，这种采用时间块来安排匮乏计算机资源的方式仍得以延续20 年[在 1975 年]，是因为它的生产率最高。[在 1995 年依然如此]</li><li>如果目标机器是新产品，则需要一个目标机器的逻辑仿真装置。这样，可以更 快地得到辅助调试平台。即使在真正机器出现之后，仿真装置仍可提供可靠的调试平台。</li><li>主程序库应该被划分成（1）一系列独立的私有开发库；（2）正处在系统测试下的系统集成子库；（3）发布版本。正式的分离和进度提供了控制。</li><li>在编制程序的项目中，节省最大工作量的工具可能是文本编辑系统。</li><li>系统文档中的巨大容量带来了新的不理解问题[例如，看看 Unix]，但是它比大多数未能详细描述编程系统特性的短小文章更加可取。</li><li>自顶向下、彻底地开发一个性能仿真装置。尽可能早地开始这项工作，仔细地听取 “它们表达的意见”。</li><li>只有懒散和惰性会妨碍高级语言和交互式编程的广泛应用。[如今它们已经在全世界使用。]</li><li>高级语言不仅仅提升了生产率，而且还改进了调试：bug 更少，以及更容易寻找。</li><li>传统的反对意见——功能、目标代码的尺寸、目标代码的速度，随着语言和编译器技术的进步已不再成为问题。</li><li>现在可供合理选择的语言是 PL/I。[不再正确。]</li><li>某些应用上，批处理系统决不会被交互式系统所替代。[依然成立。]</li><li>调试是系统编程中很慢和较困难的部分，而漫长的调试周转时间是调试的祸根。</li><li>有限的数据表明了系统软件开发中，交互式编程的生产率至少是原来的两倍。</li></ul><h1 id="13-整体部分"><a class="markdownIt-Anchor" href="#13-整体部分"></a> 13 整体部分</h1><ul><li>第 4、5、6 章所意味的煞费苦心、详尽体系结构工作不但使产品更加易于使用，而且使开发更容易进行以及 bug 更不容易产生。</li><li>V.A.Vyssotsky 提出，“许许多多的失败完全源于那些产品未精确定义的地方。”</li><li>在编写任何代码之前，规格说明必须提交给测试小组，以详细地检查说明的完整性和明确性。开发人员自己不会完成这项工作。（Vyssotsky）</li><li>“十年内[1965～1975]，Wirth 的自顶向下进行设计[逐步细化]将会是最重要的新型形式化软件开发方法。”</li><li>Wirth 主张在每个步骤中，尽可能使用级别较高的表达方法。</li><li>好的自顶向下设计从四个方面避免了 bug。</li><li>有时必须回退，推翻顶层设计，重新开始。</li><li>结构化编程中，程序的控制结构仅由支配代码块（相对于任意的跳转）的给定集合所组成。这种方法出色地避免了 bug，是一种正确的思考方式。</li><li>Gold 结果显示了，在交互式调试过程中，第一次交互取得的工作进展是后续交互的三倍。这实际上获益于在调试开始之前仔细地调试计划。[我认为在 1995 年依然如此。]</li><li>我发现对良好终端系统的正确使用，往往要求每两小时的终端会话对应于两小时的桌面工作：1 小时会话后的清理和文档工作；1 小时为下一次计划变更和测试。</li><li>系统调试（相对于单元测试）花费的时间会比预料的更长。</li><li>系统调试的困难程度证明了需要一种完备系统化和可计划的方法。</li><li>系统调试仅仅应该在所有部件能够运作之后开始。（这既不同于为了查出接口bug 所采取 “合在一起尝试” 的方法；也不同于在所有构件单元的 bug 已知，但未修复的情况下，即开始系统调试的做法。）[对于多个团队尤其如此。]</li><li>开发大量的辅助调试平台（scaffolding 脚手架）和测试代码是很值得的，代码量甚至可能会有测试对象的一半。</li><li>必须有人对变更进行控制和文档化，团队成员应使用开发库的各种受控拷贝来工作。</li><li>系统测试期间，一次只添加一个构件。</li><li>Lehman 和 Belady 出示了证据，变更的阶段（量子）要么很大，间隔很宽；要么小和频繁。后者很容易变得不稳定。[Microsoft 的一个团队使用了非常小的阶段（量子）。结果是每天晚上需要重新编译生成增长中的系统。]</li></ul><h1 id="14-祸起萧墙"><a class="markdownIt-Anchor" href="#14-祸起萧墙"></a> 14 祸起萧墙</h1><ul><li>里程碑有明显边界和没有歧义，比它容易被老板核实更为重要。如果里程碑定义得非常明确，以致于无法自欺欺人时，很少有人会就里程碑的进展弄虚作假。但是如果里程碑很模糊，老板就常常会得到一份与实际情况不符的报告。毕竟，没有人愿意承受坏消息。这种做法只是为了起到缓和的作用，并没有任何蓄意的欺骗。</li><li>“项目是怎样延迟了整整一年的时间？…一次一天。”</li><li>一天一天的进度落后比起重大灾难，更难以识别、更不容易防范和更加难以弥补。</li><li>根据一个严格的进度表来控制项目的第一个步骤是制订进度表，进度表由里程碑和日期组成。</li><li>里程碑必须是具体的、特定的、可度量的事件，能进行清晰能定义。</li><li>如果里程碑定义得非常明确，以致于无法自欺欺人时，程序员很少会就里程碑的进展弄虚作假。</li><li>对于大型开发项目中的估计行为，政府的承包商所做的研究显示：每两周进行仔细修订的活动时间估计，随着开始时间的临近不会有太大的变化；期间内对时间长短的过 高估计，会随着活动的进行持续下降；过低估计直到计划的结束日期之前大约三周左右，才有所变化。</li><li>慢性进度偏离是士气杀手。[Microsoft 的 Jim McCarthy 说：“如果你错过了一个最终期限（deadline），确保制订下一条 deadline。”]</li><li>进取对于杰出的软件开发团队，同优秀的棒球队伍一样，是不可缺少的必要品德。</li><li>不存在关键路径进度的替代品，使人们能够辨别计划偏移的情况。</li><li>PERT 的准备工作是 PERT 图使用中最有价值的部分。它包括了整个网状结构的展开、任务之间依赖关系的识别、各个任务链的估计。这些都要求在项目早期进行非常专业的计划。</li><li>第一份 PERT 图总是很恐怖的，不过人们总是不断进行努力，运用才智制订下一份 PERT 图。</li><li>PERT 图为前面那个泄气的借口，“其他的部分反正会落后”，提供了答案。</li><li>每个老板同时需要采取行动的异常信息以及用来进行分析和早期预警的状态数据。</li><li>状态的获取是困难的，因为下属经理有充分的理由不提供信息共享。</li><li>老板的不良反应肯定会对信息的完全公开造成压制；相反，仔细区分状态报告、毫无惊慌地接收报告、决不越俎代庖，将能鼓励诚实的汇报。</li><li>必须有评审的机制，从而所有成员可以通过它了解真正的状态。出于这个目的，里程碑的计划和完成文档是关键。</li><li>Vyssotsky：我发现在里程碑报告中很容易记录“计划（老板的日期）”和“估计（最基层经理的日期）”的日期。项目经理必须停止对这些日期的怀疑。”</li><li>对于大型项目，一个对里程碑报告进行维护的计划和控制（Plan and Control）小组是非常可贵的。</li></ul><h1 id="15-另外一面"><a class="markdownIt-Anchor" href="#15-另外一面"></a> 15 另外一面</h1><ul><li>对于软件编程产品来说，程序向用户所呈现的面貌与提供给机器识别的内容同样重要。</li><li>即使对于完全开发给自己使用的程序，描述性文字也是必须的，因为它们会被用户－作者所遗忘。</li><li>培训和管理人员基本上没有能向编程人员成功地灌输对待文档的积极态度——文档能在整个生命周期对克服懒惰和进度的压力起促进激励作用。</li><li>这样的失败并不都是因为缺乏热情或者说服力，而是没能正确地展示如何有效和经济地编制文档。</li><li>大多数文档只提供了很少的总结性内容。必须放慢脚步，稳妥地进行。</li><li>由于关键的用户文档包含了跟软件相关的基本决策，所以它的绝大部分需要在程序编制之前书写，它包括了 9 项内容（参见相应章节）。</li><li>每一份发布的程序拷贝应该包括一些测试用例，其中一部分用于校验输入数据，一部分用于边界输入数据，另一部分用于无效的输入数据。</li><li>对于必须修改程序的人而言，他们所需要程序内部结构文档，同样要求一份清晰明了的概述，它包括了 5 项内容（参见相应章节）。</li><li>流程图是被吹捧得最过分的一种程序文档。详细逐一记录的流程图是一件令人生厌的事情，而且高级语言的出现使它显得陈旧过时。（流程图是图形化的高级语言。）</li><li>如果这样，很少有程序需要一页纸以上的流程图。[在这一点上，MILSPEC 军用标准实在错得很厉害。]</li><li>即使的确需要一张程序结构图，也并不需要遵照 ANSI 的流程图标准。</li><li>为了使文档易于维护，将它们合并至源程序是至关重要的，而不是作为独立文档进行保存。</li><li>最小化文档负担的 3 个关键思路：<ul><li>借助那些必须存在的语句，如名称和声明等，来附加尽可能多的“文档”信息。</li><li>使用空格和格式来表现从属和嵌套关系，提高程序的可读性。</li><li>以段落注释，特别是模块标题的形式，向程序中插入必要的记叙性文字。</li></ul></li><li>程序修改人员所使用的文档中，除了描述事情如何以外，还应阐述它为什么那样。对于加深理解，目的是非常关键的，但即使是高级语言的语法，也不能表达目的。</li><li>在线系统的高级语言（应该使用的工具）中，自文档化技术发现了它的绝佳应用和强大功能</li></ul><h1 id="16-没有银弹-软件工程中的根本和次要问题"><a class="markdownIt-Anchor" href="#16-没有银弹-软件工程中的根本和次要问题"></a> 16 没有银弹－软件工程中的根本和次要问题</h1><ul><li>所有软件活动包括根本任务——打造由抽象软件实体构成的复杂概念结构，次要任务——使用编程语言表达这些抽象实体，在空间和时间限制内将它们映射成机器语言。</li></ul><h1 id="17-再论没有银弹"><a class="markdownIt-Anchor" href="#17-再论没有银弹"></a> 17 再论《没有银弹》</h1><ul><li>重用是一件说起来容易，做起来难的事情。它同时需要良好的设计和文档。即使我们看到了并不十分常见的优秀设计，但如果没有好的文档，我们也不会看到能重用的构件。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="软件开发" scheme="https://dragonliu2022.github.io/categories/软件开发/"/>
    
    <category term="阅读" scheme="https://dragonliu2022.github.io/categories/阅读/"/>
    
    
  </entry>
  
  <entry>
    <title>《鸟哥的Linux私房菜基础学习篇（第四版）》第4章笔记与习题</title>
    <link href="https://dragonliu2022.github.io/2022/07/25/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E7%AC%AC%E5%9B%9B%E7%89%88%EF%BC%89%E3%80%8B%E7%AC%AC4%E7%AB%A0%E7%AC%94%E8%AE%B0%E4%B8%8E%E4%B9%A0%E9%A2%98/"/>
    <id>https://dragonliu2022.github.io/2022/07/25/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E7%AC%AC%E5%9B%9B%E7%89%88%EF%BC%89%E3%80%8B%E7%AC%AC4%E7%AB%A0%E7%AC%94%E8%AE%B0%E4%B8%8E%E4%B9%A0%E9%A2%98/</id>
    <published>2022-07-25T15:53:32.000Z</published>
    <updated>2022-07-28T02:43:25.458Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>第4章：首次登录与在线求助</p></blockquote><h1 id="1-笔记"><a class="markdownIt-Anchor" href="#1-笔记"></a> 1 笔记</h1><h2 id="11-x-window-与命令行模式的切换"><a class="markdownIt-Anchor" href="#11-x-window-与命令行模式的切换"></a> 1.1 X Window 与命令行模式的切换</h2><p>Linux 预设的情况下会提供六个Terminal 来让使用者登入， 切换的方式为使用：</p><ul><li><code>[Ctrl] + [Alt] + [F2] ~ [F6]</code>：命令行模式登入 tty2 ~ tty6 终端；</li><li><code>[Ctrl] + [Alt] + [F1]</code> ：图形用户界面模式 tty1。</li></ul><p>纯文本界面下 (不能有 X 存在) 启动窗口界面的作法：<code>startx</code></p><p>在 X 的环境下想要『强制』重新启动 X 的组合按键为：『[alt]+[ctrl]+[backspace]』；</p><h2 id="12-基本命令操作"><a class="markdownIt-Anchor" href="#12-基本命令操作"></a> 1.2 基本命令操作</h2><ul><li><p>显示日期与时间的命令date：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[dragon@192 ~]$ date</span><br><span class="line">2022年 07月 27日 星期三 22:12:06 CST</span><br><span class="line">[dragon@192 ~]$ date +%Y/%m/%d</span><br><span class="line">2022/07/27</span><br><span class="line">[dragon@192 ~]$ date +%H:%M:%S</span><br><span class="line">22:12:57</span><br></pre></td></tr></table></figure></li><li><p>显示日历的命令cal：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[dragon@192 ~]$ cal</span><br><span class="line">      七月 2022     </span><br><span class="line">日 一 二 三 四 五 六</span><br><span class="line">                1  2</span><br><span class="line"> 3  4  5  6  7  8  9</span><br><span class="line">10 11 12 13 14 15 16</span><br><span class="line">17 18 19 20 21 22 23</span><br><span class="line">24 25 26 27 28 29 30</span><br><span class="line">31</span><br><span class="line"></span><br><span class="line">[dragon@192 ~]$ cal [month] [year]</span><br></pre></td></tr></table></figure></li><li><p>计算器bc：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bc</span><br></pre></td></tr></table></figure></li></ul><h2 id="13-热键"><a class="markdownIt-Anchor" href="#13-热键"></a> 1.3 热键</h2><ul><li><code>[Tab]</code><ul><li>命令补全</li><li>文件补全</li><li>选项/参数补全</li></ul></li><li><code>Ctrl + C</code>：中断目前程序</li><li><code>Ctrl + Q</code>：<ul><li>键盘输入结束</li><li>相当于输入 exit</li></ul></li><li><code>[shift]+{[PageUP]|[Page Down]}</code>：命令行界面翻页</li></ul><h2 id="14-在线求助"><a class="markdownIt-Anchor" href="#14-在线求助"></a> 1.4 在线求助</h2><h3 id="141-help"><a class="markdownIt-Anchor" href="#141-help"></a> 1.4.1 --help</h3><p>eg: date的基本用法与选项参数：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><h3 id="142-man-page"><a class="markdownIt-Anchor" href="#142-man-page"></a> 1.4.2 man page</h3><p>date的 manual(操作说明)：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[dragon@192 ~]$ man date</span><br><span class="line">DATE(1)</span><br><span class="line"><span class="comment"># 括号内的数字</span></span><br><span class="line"><span class="comment"># 1表示用户在 shell 环境中可以操作的指令或可执行文件</span></span><br><span class="line"><span class="comment"># 5表示配置文件或者是某些文件的格式</span></span><br><span class="line"><span class="comment"># 8表示系统管理员可用的管理指令</span></span><br></pre></td></tr></table></figure><p>常用的按键：</p><table><thead><tr><th style="text-align:center">按键</th><th style="text-align:center">进行工作</th></tr></thead><tbody><tr><td style="text-align:center">空格键</td><td style="text-align:center">向下翻一页</td></tr><tr><td style="text-align:center">[Page Down]</td><td style="text-align:center">向下翻一页</td></tr><tr><td style="text-align:center">[Page Up]</td><td style="text-align:center">向上翻一页</td></tr><tr><td style="text-align:center">[Home]</td><td style="text-align:center">去到第一页</td></tr><tr><td style="text-align:center">[End]</td><td style="text-align:center">去到最后一页</td></tr><tr><td style="text-align:center">/string</td><td style="text-align:center">向『下』搜寻 string 这个字符串，如果要搜寻 vbird 的话，就输入 /vbird</td></tr><tr><td style="text-align:center">?string</td><td style="text-align:center">向『上』搜寻 string 这个字符串</td></tr><tr><td style="text-align:center">n, N</td><td style="text-align:center">利用 / 或 ? 来搜寻字符串时，可以用 n 来继续下一个搜寻 (不论是 / 或 ?) ，可以利用 N 来进行『反向』搜寻。举例来说，我以 /vbird 搜寻 vbird 字符串， 那么可以 n 继续往下查询，用 N 往上查询。若以 ?vbird 向上查询 vbird 字符串， 那我可以用 n 继续『向上』查询，用 N 反向查询。</td></tr><tr><td style="text-align:center">q</td><td style="text-align:center">结束这次的 man page</td></tr></tbody></table><h3 id="143-info-page"><a class="markdownIt-Anchor" href="#143-info-page"></a> 1.4.3 info page</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info date</span><br></pre></td></tr></table></figure><h2 id="15-关机"><a class="markdownIt-Anchor" href="#15-关机"></a> 1.5 关机</h2><h3 id="151-sync"><a class="markdownIt-Anchor" href="#151-sync"></a> 1.5.1 sync</h3><p>数据同步写入磁盘</p><h3 id="152-shutdown"><a class="markdownIt-Anchor" href="#152-shutdown"></a> 1.5.2 shutdown</h3><p>shutdown 指令会通知系统内的各个程序 (processes)，并且将通知系统中的一些服务来关闭。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]<span class="comment"># shutdown -h now</span></span><br><span class="line">立刻关机，其中 now 相当于时间为 0 的状态</span><br><span class="line">[root@study ~]<span class="comment"># shutdown -h 20:25</span></span><br><span class="line">系统在今天的 20:25 分会关机，若在 21:25 才下达此指令，则隔天才关机</span><br><span class="line">[root@study ~]<span class="comment"># shutdown -h +10</span></span><br><span class="line">系统再过十分钟后自动关机</span><br><span class="line">[root@study ~]<span class="comment"># shutdown -r now</span></span><br><span class="line">系统立刻重新启动</span><br><span class="line">[root@study ~]<span class="comment"># shutdown -r +30 'The system will reboot' 再过三十分钟系统会重新启动，并显示后面的讯息给所有在在线的使用者</span></span><br><span class="line">[root@study ~]<span class="comment"># shutdown -k now 'This system will reboot' </span></span><br><span class="line">仅发出警告信件的参数！系统并不会关机啦！吓唬人！</span><br></pre></td></tr></table></figure><h3 id="153-reboot-halt-poweroff"><a class="markdownIt-Anchor" href="#153-reboot-halt-poweroff"></a> 1.5.3 reboot &amp; halt &amp; poweroff</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]<span class="comment"># sync; sync; sync; reboot  # 先数据同步写入磁盘 后重启</span></span><br><span class="line">[root@study ~]<span class="comment"># halt # 系统停止～屏幕可能会保留系统已经停止的讯息！</span></span><br><span class="line">[root@study ~]<span class="comment"># poweroff # 系统关机，所以没有提供额外的电力，屏幕空白！</span></span><br></pre></td></tr></table></figure><h1 id="2-习题"><a class="markdownIt-Anchor" href="#2-习题"></a> 2 习题</h1><h2 id="21-简单的查询一下physical-console-virtual-console-terminal-的说明为何"><a class="markdownIt-Anchor" href="#21-简单的查询一下physical-console-virtual-console-terminal-的说明为何"></a> 2.1 简单的查询一下，Physical console / Virtual console / Terminal 的说明为何？</h2><p>console 有『控制台』的意思在里面，因此你可以这样看的：</p><ul><li>实体控制面板：实体的屏幕、键盘、鼠标等界面，让妳可以使用该配备来操作系统的环境，就称为实体控制面板(Physical console)</li><li>虚拟控制台：由系统衍生出的虚拟控制面板，你可以透过该虚拟控制面板搭配你自己系统的实体配备，来操作远程系统的环境。每个虚拟控制台都是独立运作的。</li><li>终端机：你可以用该界面来取得一个可以控制系统的 shell 环境。</li></ul><p>由这些定义来看，一般来说，我们取得可以与系统互动的环境，大致上都称为 terminal 就是了。</p><h2 id="22-man-page-显示的内容的文件是放置在哪些目录中"><a class="markdownIt-Anchor" href="#22-man-page-显示的内容的文件是放置在哪些目录中"></a> 2.2 man page 显示的内容的文件是放置在哪些目录中？</h2><p>放置在 /usr/share/man/ 与 /usr/local/man 等默认目录中。</p><h2 id="23-当我输入-man-date-时在我的终端机却出现一些乱码请问可能的原因为何如何修正"><a class="markdownIt-Anchor" href="#23-当我输入-man-date-时在我的终端机却出现一些乱码请问可能的原因为何如何修正"></a> 2.3 当我输入 man date 时，在我的终端机却出现一些乱码，请问可能的原因为何？如何修正？</h2><p>如果没有其他错误的发生，那么发生乱码可能是因为语系的问题所致。 可以利用 <code>export LANG=en_US.utf8</code> 或者是 <code>export LC_ALL=en_US.utf8</code> 等设定来修订这个问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="操作系统" scheme="https://dragonliu2022.github.io/categories/操作系统/"/>
    
    <category term="Linux" scheme="https://dragonliu2022.github.io/categories/操作系统/Linux/"/>
    
    <category term="阅读" scheme="https://dragonliu2022.github.io/categories/阅读/"/>
    
    
  </entry>
  
  <entry>
    <title>《鸟哥的Linux私房菜基础学习篇（第四版）》第3章笔记与习题</title>
    <link href="https://dragonliu2022.github.io/2022/07/25/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E7%AC%AC%E5%9B%9B%E7%89%88%EF%BC%89%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0%E4%B8%8E%E4%B9%A0%E9%A2%98/"/>
    <id>https://dragonliu2022.github.io/2022/07/25/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E7%AC%AC%E5%9B%9B%E7%89%88%EF%BC%89%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0%E4%B8%8E%E4%B9%A0%E9%A2%98/</id>
    <published>2022-07-25T07:56:57.000Z</published>
    <updated>2022-07-25T15:52:56.618Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>第3章：安装 CentOS 7.x</p></blockquote><h1 id="1-笔记"><a class="markdownIt-Anchor" href="#1-笔记"></a> 1 笔记</h1><p><code>见博客 VMware安装CentOS 7虚拟机(待补充)</code></p><p><a href="https://blog.csdn.net/renfeigui0/article/details/102497359" target="_blank" rel="noopener">VMware安装Centos7系统（中文图形化模式）</a></p><hr><ul><li>root 的密码等设置都会被记录到 /root/anaconda-ks.cfg，你未来想要重建一个一模一样的系统时，就可以参考该文件来制作。你也可以 google 一下，找 kickstart 这个关键词。</li><li>CentOS 7 默认使用 xfs 作为文件系统</li></ul><h1 id="2-习题"><a class="markdownIt-Anchor" href="#2-习题"></a> 2 习题</h1><h2 id="11-linux-的目录配置以树状目录来配置至于磁盘分区槽partition则需要与树状目录相配合-请问在预设的情况下在安装的时候系统会要求你一定要分区出来的两个-partition-为何"><a class="markdownIt-Anchor" href="#11-linux-的目录配置以树状目录来配置至于磁盘分区槽partition则需要与树状目录相配合-请问在预设的情况下在安装的时候系统会要求你一定要分区出来的两个-partition-为何"></a> 1.1 Linux 的目录配置以『树状目录』来配置，至于磁盘分区槽(partition)则需要与树状目录相配合！ 请问，在预设的情况下，在安装的时候系统会要求你一定要分区出来的两个 Partition 为何？</h2><p>就是根目录『/』与 内存交换空间『Swap』</p><h2 id="12-预设使用-mbr-分区方式的情况下在第二颗-sata-磁盘中分区六个有用的分区-具有-filesystem-的-此外已知有两个-primary-的分区类型请问六个分区的文件名"><a class="markdownIt-Anchor" href="#12-预设使用-mbr-分区方式的情况下在第二颗-sata-磁盘中分区六个有用的分区-具有-filesystem-的-此外已知有两个-primary-的分区类型请问六个分区的文件名"></a> 1.2 预设使用 MBR 分区方式的情况下，在第二颗 SATA 磁盘中，分区『六个有用』的分区 (具有 filesystem 的) ，此外，已知有两个 primary 的分区类型！请问六个分区的文件名？</h2><p>/dev/sdb1(primary)</p><p>/dev/sdb2(primary)</p><p>/dev/sdb3(extended)</p><p>/dev/sdb5(logical 底下皆为 logical)</p><p>/dev/sdb6</p><p>/dev/sdb7</p><p>/dev/sdb8</p><p>请注意，5-8 这四个 logical 容量相加的总和为 /dev/sdb3！</p><h2 id="13-什么是-gmt-时间北京时间差几个钟头"><a class="markdownIt-Anchor" href="#13-什么是-gmt-时间北京时间差几个钟头"></a> 1.3 什么是 GMT 时间？北京时间差几个钟头？</h2><p>GMT 时间指的是格林尼治时间，称为标准的时间，而北京时间较 GMT 快了 8 小时！</p><h2 id="14-软件磁盘阵列的装置文件名为何"><a class="markdownIt-Anchor" href="#14-软件磁盘阵列的装置文件名为何"></a> 1.4 软件磁盘阵列的装置文件名为何？</h2><p>RAID : /dev/md[0-127];</p><h2 id="15-如果我的磁盘分区时使用-mbr-方式且设定了四个-primary-分区但是磁盘还有空间请问我还能不能使用这些空间"><a class="markdownIt-Anchor" href="#15-如果我的磁盘分区时使用-mbr-方式且设定了四个-primary-分区但是磁盘还有空间请问我还能不能使用这些空间"></a> 1.5 如果我的磁盘分区时使用 MBR 方式，且设定了四个 Primary 分区，但是磁盘还有空间，请问我还能不能使用这些空间？</h2><p>不行！因为最多只有四个 Primary 的磁盘分区槽，没有多的可以进行分区了！且由于没有 Extended ，所以自然不能再使用 Logical 分区。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="操作系统" scheme="https://dragonliu2022.github.io/categories/操作系统/"/>
    
    <category term="Linux" scheme="https://dragonliu2022.github.io/categories/操作系统/Linux/"/>
    
    <category term="阅读" scheme="https://dragonliu2022.github.io/categories/阅读/"/>
    
    
  </entry>
  
  <entry>
    <title>MBR分区表为什么最大只能识别2TB硬盘容量</title>
    <link href="https://dragonliu2022.github.io/2022/07/25/MBR%E5%88%86%E5%8C%BA%E8%A1%A8%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%80%E5%A4%A7%E5%8F%AA%E8%83%BD%E8%AF%86%E5%88%AB2TB%E7%A1%AC%E7%9B%98%E5%AE%B9%E9%87%8F/"/>
    <id>https://dragonliu2022.github.io/2022/07/25/MBR%E5%88%86%E5%8C%BA%E8%A1%A8%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%80%E5%A4%A7%E5%8F%AA%E8%83%BD%E8%AF%86%E5%88%AB2TB%E7%A1%AC%E7%9B%98%E5%AE%B9%E9%87%8F/</id>
    <published>2022-07-25T02:50:37.000Z</published>
    <updated>2022-07-25T04:05:23.169Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>转载：<a href="https://www.cnblogs.com/harrymore/p/13782261.html" target="_blank" rel="noopener">MBR分区表为什么最大只能识别2TB硬盘容量</a></p></blockquote><p>MBR磁盘分区是一种使用最为广泛的分区结构，它也被称为DOS分区结构，但它并不仅仅应用于Windows系统平台，也应用于Linux，基于X86的UNIX等系统平台。它位于磁盘的0号扇区（一扇区等于512字节），是一个重要的扇区（简称MBR扇区）。</p><p>MBR扇区由以下几个部分组成：</p><ul><li>主要启动记录区(Master Boot Record, MBR)：可以安装开机管理程序的地方，有 446 bytes；</li><li>分区表(partition table)：记录整颗硬盘分区的状态，有 64 bytes</li><li>MBR结束标志：占MBR扇区最后2个字节，一直为<code>55 AA</code></li></ul><img src="https://s2.loli.net/2022/07/25/EKj3h5ZiObAMRkV.png" width="700" height="200" alt="图片名称" align="center" id="213"><p>可以看到分区表只有64字节，最多只能有4个主分区或者3个主分区1个扩展分区。</p><p>那么每个分区表项占有16个字节，如果是记录起始扇区id，也不止2T的容量啊。这就需要了解一下分区表的结构和硬盘的寻址方式了。</p><p>如下图所示，为MBR分区表的详细结构：</p><img src="https://s2.loli.net/2022/07/25/dzhYBJjuk5AOC6R.gif" width="700" height="500" alt="图片名称" align="center" id="214"><p>可以看到，这里使用了柱面（cylinder），磁头（header），扇区（sector）三个变量进行寻址，这种寻址方式称为CHS，这里表示的地址已经不是物理地址，而是逻辑地址了，又称为LARGE寻址方式，在这种方式下，</p><p>硬盘容量=磁头数×柱面数×扇区数×扇区大小（一般为512byte）</p><p>那如果磁头数足够多，岂不是可以管理无限的容量？答案当然是否定的，我们看到上表的最后两项：</p><p>可以看到两个以4字节表示分区之前以及本分区的扇区数，也就是可以表示的最大扇区数为：</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mn>3</mn><mn>2</mn></mrow></msup><mo>=</mo><mn>4</mn><mn>2</mn><mn>9</mn><mn>4</mn><mn>9</mn><mn>6</mn><mn>7</mn><mn>2</mn><mn>9</mn><mn>6</mn></mrow><annotation encoding="application/x-tex">2^{32}=4294967296</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathrm">2</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">3</span><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord mathrm">4</span><span class="mord mathrm">2</span><span class="mord mathrm">9</span><span class="mord mathrm">4</span><span class="mord mathrm">9</span><span class="mord mathrm">6</span><span class="mord mathrm">7</span><span class="mord mathrm">2</span><span class="mord mathrm">9</span><span class="mord mathrm">6</span></span></span></span></p><p>而每个标准扇区的容量为512字节，于是能表示的最大容量为：</p><p>4294967296*512 Bytes<br>=2199023255552 Bytes（<strong>硬盘厂商采用1:1000进行单位换算，因此也有2.2TB一说</strong>）<br>=2147483648 KB<br>=2097152 MB<br>=2048 GB<br>=2TB</p><p>在网上还可以找到另外一个答案：</p><p>由于它（MBR）是为32位操作系统设计的，这就限制了它的寻址范围为2的32次方个扇区……</p><p>其实这种说法是不严谨的，准确来说，MBR分区表最大能容纳2T容量的主要原因，是因为分区表中的本分区表之前使用的扇区数以及分区的总扇区数这两个字段为4字节，因此导致的限制。</p><p>尽管后来为了支持更多的分区，引入了扩展分区及逻辑分区的概念。但每个分区项仍然用16个字节存储。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="操作系统" scheme="https://dragonliu2022.github.io/categories/操作系统/"/>
    
    <category term="基础" scheme="https://dragonliu2022.github.io/categories/操作系统/基础/"/>
    
    
  </entry>
  
  <entry>
    <title>《鸟哥的Linux私房菜基础学习篇（第四版）》第2章笔记与习题</title>
    <link href="https://dragonliu2022.github.io/2022/07/24/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E7%AC%AC%E5%9B%9B%E7%89%88%EF%BC%89%E3%80%8B%E7%AC%AC2%E7%AB%A0%E7%AC%94%E8%AE%B0%E4%B8%8E%E4%B9%A0%E9%A2%98/"/>
    <id>https://dragonliu2022.github.io/2022/07/24/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E7%AC%AC%E5%9B%9B%E7%89%88%EF%BC%89%E3%80%8B%E7%AC%AC2%E7%AB%A0%E7%AC%94%E8%AE%B0%E4%B8%8E%E4%B9%A0%E9%A2%98/</id>
    <published>2022-07-24T06:45:20.000Z</published>
    <updated>2022-07-25T15:44:52.714Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>第2章：主机规划与磁盘分区</p></blockquote><h1 id="1-笔记"><a class="markdownIt-Anchor" href="#1-笔记"></a> 1 笔记</h1><h2 id="11-分区表格式"><a class="markdownIt-Anchor" href="#11-分区表格式"></a> 1.1 分区表格式</h2><h3 id="111-mbrms-dos分区表"><a class="markdownIt-Anchor" href="#111-mbrms-dos分区表"></a> 1.1.1 MBR（MS-DOS）分区表</h3><p>早期的 Linux 系统为了兼容 Windows 的磁盘，因此使用的是支持 Windows 的 MBR(Master Boot Record, 主引导记录) 的方式来处理启动引导程序与分区表。而启动引导程序纪录区与分区表则通通放在磁盘的第一个扇区，这个扇区通常是 512bytes 的大小 (旧的磁盘扇区都是 512bytes)，所以说，第一个扇区的 512bytes 会有这两个数据：</p><ul><li>主引导纪录(Master Boot Record, MBR)：可以安装启动引导程序的地方，有 446 bytes</li><li>分区表(partition table)：记录整块硬盘分区的状态，有 64 bytes，最多仅能有四组记录区，每组记录区记录了该区段的启始与结束的柱面号码。</li></ul><h4 id="1111-主要分区"><a class="markdownIt-Anchor" href="#1111-主要分区"></a> 1.1.1.1 主要分区</h4><p>示意图如下图所示：</p><img src="https://s2.loli.net/2022/07/25/rT5yQlPSRLsf7Yc.png" width="500" height="500" alt="图片名称" align="center" id="211"><p>假设硬盘设备文件名为<code>/dev/sda</code>时，那么这四个分区在Linux系统中的设备文件名如下所示，重点在于文件名后面会再接一个数字，这个数字与该分区所在的位置有关。</p><ul><li><code>P1:/dev/sda1</code></li><li><code>P2:/dev/sda2</code></li><li><code>P3:/dev/sda3</code></li><li><code>P4:/dev/sda4</code></li></ul><p>分区表的四个分区的记录被称为主要(Primary)或扩展(Extended)分区。</p><p>其实所谓的『分区』只是针对那个 64 bytes 的分区表进行设定而已。</p><p>分区的最小单位『通常』为柱面(cylinder)。</p><p>当系统要写入磁盘时，一定会参考磁盘分区表，才能针对某个分区进行数据的处理。</p><h4 id="1112-主要分区扩展分区"><a class="markdownIt-Anchor" href="#1112-主要分区扩展分区"></a> 1.1.1.2 主要分区+扩展分区</h4><p>示意图如下图所示：</p><img src="https://s2.loli.net/2022/07/25/OgnT9G1leRIqDfh.png" width="500" height="500" alt="图片名称" align="center" id="212"><p>硬盘的四个分区记录区仅使用到两个，P1 为主要分区，而 P2 则为扩展分区。扩展分区的目的是使用额外的扇区来记录分区信息，扩展分区本身并不能被拿来格式化。然后我们可以透过扩展分区所指向的那个区块继续作分区的记录。</p><p>如上图右下方那个区块有继续分区出五个分区， 这五个由扩展分区继续切出来的分区，就被称为逻辑分区(logical partition)。</p><p>上述的分区在 Linux 系统中的设备文件名分别如下：</p><ul><li><code>P1:/dev/sda1</code></li><li><code>P1:/dev/sda2</code></li><li><code>P1:/dev/sda5</code></li><li><code>P1:/dev/sda6</code></li><li><code>P1:/dev/sda7</code></li><li><code>P1:/dev/sda8</code></li><li><code>P1:/dev/sda9</code></li></ul><p><strong>前面四个号码都是保留给 Primary 或 Extended 用的，所以逻辑分区的设备名称号码就由 5 号开始。</strong></p><h4 id="1113-主要分区-vs-扩展分区-vs-逻辑分区"><a class="markdownIt-Anchor" href="#1113-主要分区-vs-扩展分区-vs-逻辑分区"></a> 1.1.1.3 主要分区 vs 扩展分区 vs 逻辑分区</h4><ul><li>主要分区与扩展分区最多可以有四个(硬盘的限制)</li><li>扩展分区最多只能有一个(操作系统的限制)</li><li>逻辑分区是由扩展分区持续切割出来的分区；</li><li>能够被格式化后，作为数据存取的分区为主要分区与逻辑分区，扩展分区无法格式化；</li><li>逻辑分区的数量依操作系统而不同，在 Linux 系统中 SATA 硬盘已经可以突破 63 个以上的分区限制；</li><li>如果扩展分区被破坏，所有逻辑分区将会被删除， 因为逻辑分区的信息都记录在扩展分区里面；</li><li>考虑到磁盘的连续性，一般建议将 Extended 的柱面号码分配在最后面的柱面内。</li></ul><h4 id="1114-mbr缺点"><a class="markdownIt-Anchor" href="#1114-mbr缺点"></a> 1.1.1.4 MBR缺点</h4><ul><li>操作系统无法使用 2.2T 以上的磁盘容量；虽然 Linux kernel 现在已经可以透过某些机制让磁盘分区高过 63 个以上，但是这样就得要割出较多个分区，不易操作。<code>见博客 MBR分区表为什么最大只能识别2TB硬盘容量</code></li><li>MBR 仅有一个区块，若被破坏后，经常无法或很难恢复。</li><li>MBR 内的存放启动引导程序的区块仅 446bytes，无法存储较多的程序代码。</li></ul><h3 id="112-gptguid-partition-table磁盘分区表"><a class="markdownIt-Anchor" href="#112-gptguid-partition-table磁盘分区表"></a> 1.1.2 GPT（GUID partition table）磁盘分区表</h3><p>因为过去一个扇区大小就是 512bytes 而已，不过目前已经有 4K 的扇区设计出现。为了兼容于所有的磁盘，因此在扇区的定义上面， 大多会使用所谓的逻辑区块地址(Logical Block Address, LBA)来处理。GPT 将磁盘所有区块以此 LBA(默认为 512bytes) 来规划，而第一个 LBA 称为 LBA0 (从0 开始编号)。</p><p>与 MBR 仅使用第一个 512bytes 区块来纪录不同， GPT 使用了 34 个 LBA 区块来纪录分区信息。同时与过去 MBR 仅有一的区块，被干掉就死光光的情况不同， GPT 除了前面 34 个 LBA 之外，整个磁盘的最后 33 个 LBA 也拿来作为另一个备份。这样或许会比较安全些吧！详细的结构如下图所示：</p><img src="https://s2.loli.net/2022/07/25/rMfqtWbePZXUKJn.png" width="400" height="500" alt="图片名称" align="center" id="215"><p><strong>LBA0 (MBR 兼容区块)</strong></p><p>与 MBR 模式相似的，这个兼容区块也分为两部分，一个就是跟之前 446 bytes 相似的区块，储存了第一阶段的启动引导程序。而在原本的分区表的记录区内，这个兼容模式仅放入一个特殊标志的分区，用来表示此磁盘为 GPT 格式之意。而不懂 GPT 分区表的磁盘管理程序， 就不会认识这颗磁盘，除非用户有特别要求要处理这颗磁盘，否则该管理软件不能修改此分区信息，进一步保护了此磁盘。</p><p><strong>LBA1 (GPT 表头纪录)</strong></p><p>这部分纪录了分区表本身的位置与大小，同时纪录了备份用的 GPT 分区 (就是前面谈到的在最后 34 个 LBA 区块) 放置的位置， 同时放置了分区表的校验码 (CRC32)，操作系统可以根据这个校验码来判断 GPT 是否正确。若有错误，还可以透过这个记录区来取得备份的 GPT(磁盘最后的那个备份区块) 来恢复 GPT 的正常运作。</p><p><strong>LBA2-33 (实际纪录分区信息处)</strong></p><p>从 LBA2 区块开始，每个 LBA 都可以记录 4 组分区记录，所以在默认的情况下，总共可以有 4*32 = 128 组分区记录。因为每个 LBA 有 512bytes，因此每组记录用到 128 bytes 的空间，除了每组记录所需要的标识符与相关的记录之外，GPT 在每组记录中分别提供了 64bits 来记载开始/结束的扇区号码，因此，GPT 分区表对于单一分区来说， 他的最大容量限制就会在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mn>6</mn><mn>4</mn></mrow></msup><mo>∗</mo><mn>5</mn><mn>1</mn><mn>2</mn><mi>b</mi><mi>y</mi><mi>t</mi><mi>e</mi><mi>s</mi><mo>=</mo><msup><mn>2</mn><mrow><mn>6</mn><mn>3</mn></mrow></msup><mo>∗</mo><mn>1</mn><mi>K</mi><mi>b</mi><mi>y</mi><mi>t</mi><mi>e</mi><mi>s</mi><mo>=</mo><msup><mn>2</mn><mrow><mn>3</mn><mn>3</mn></mrow></msup><mo>∗</mo><mi>T</mi><mi>B</mi><mo>=</mo><mn>8</mn><mi>Z</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">2^{64} * 512bytes = 2^{63} * 1Kbytes = 2^{33}*TB = 8 ZB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathrm">2</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">6</span><span class="mord mathrm">4</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">∗</span><span class="mord mathrm">5</span><span class="mord mathrm">1</span><span class="mord mathrm">2</span><span class="mord mathit">b</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mord mathit">t</span><span class="mord mathit">e</span><span class="mord mathit">s</span><span class="mrel">=</span><span class="mord"><span class="mord mathrm">2</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">6</span><span class="mord mathrm">3</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">∗</span><span class="mord mathrm">1</span><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="mord mathit">b</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mord mathit">t</span><span class="mord mathit">e</span><span class="mord mathit">s</span><span class="mrel">=</span><span class="mord"><span class="mord mathrm">2</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">3</span><span class="mord mathrm">3</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">∗</span><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="mrel">=</span><span class="mord mathrm">8</span><span class="mord mathit" style="margin-right:0.07153em;">Z</span><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span>，要注意 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi>Z</mi><mi>B</mi><mo>=</mo><msup><mn>2</mn><mrow><mn>3</mn><mn>0</mn></mrow></msup><mi>T</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">1ZB = 2^{30}TB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mord mathit" style="margin-right:0.07153em;">Z</span><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="mrel">=</span><span class="mord"><span class="mord mathrm">2</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">3</span><span class="mord mathrm">0</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span></p><hr><p>现在 GPT 分区默认可以提供多达 128 组记录，而在 Linux 本身的内核设备记录中，针对单一磁盘来说，虽然过去最多只能到达 15 个分区，不过由于 Linux kernel 透过 udev 等方式的处理，现在 Linux 也已经没有这个限制在了。 此外，GPT 分区已经没有所谓的主、扩展、逻辑分区的概念，既然每笔纪录都可以独立存在，当然每个都可以视为是主分区，每一个分区都可以拿来格式化使用。</p><h2 id="12-启动程序"><a class="markdownIt-Anchor" href="#12-启动程序"></a> 1.2 启动程序</h2><h3 id="121-bios-搭配-mbrgpt-的启动流程"><a class="markdownIt-Anchor" href="#121-bios-搭配-mbrgpt-的启动流程"></a> 1.2.1 <strong>BIOS</strong> <strong>搭配</strong> <strong>MBR/GPT</strong> 的启动流程</h3><p><strong>整个启动流程到操作系统之前</strong>：</p><ol><li><strong>BIOS</strong>：开机主动执行的固件，会认识第一个可启动的设备</li><li><strong>MBR</strong>：第一个可启动设备的第一个扇区内的主引导记录块，内含启动引导代码；</li><li><strong>启动引导程序(boot loader)</strong>：一个可读取内核文件来执行的软件；</li><li><strong>内核文件</strong>：开始启动操作系统</li></ol><p><strong>Boot loader 的主要任务</strong>：</p><ul><li><strong>提供选项</strong>：用户可以选择不同的启动选项，这也是多重引导的重要功能；</li><li><strong>加载内核文件</strong>：直接指向可使用的程序区段来开始操作系统；</li><li><strong>转交其他启动引导程序</strong>：将启动管理功能转交给其他启动引导程序负责。</li></ul><p><strong>多重引导</strong>：</p><p>启动引导程序除了可以安装在 MBR 之外， 还可以安装在每个分区的启动扇区(boot sector)。</p><p>假设你的个人计算机只有一个硬盘，里面切成四个分区，其中第一、二分区分别安装了 Windows 及 Linux， 你要如何在开机的时候选择用 Windows 还是 Linux 开机呢？假设MBR内安装的是可同时认识Windows/Linux操作系统的启动引导程序，那么整个流程如下：</p><img src="https://s2.loli.net/2022/07/25/kVbaMHKR6CWAoz1.png" width="600" height="400" alt="图片名称" align="center" id="216"><ul><li>每个分区都拥有自己的启动扇区(boot sector)</li><li>图中的系统分区为第一及第二分区，</li><li>实际可启动的内核文件是放置到各分区内的</li><li>loader 只会认识自己的系统分区内的可启动的内核文件，以及其他 loader 而已；</li><li>loader 可直接指向或者是间接将管理权转交给另一个管理程序。</li></ul><p><strong>如果要安装多重引导，最好先安装 Windows 再安装 Linux，原因如下：</strong></p><ul><li>Linux 在安装的时候，你可以选择启动引导程序安装在 MBR 或各别分区的启动扇区， 而且 Linux 的loader 可以手动设定选单(就是上图的 M1, M2…)，所以你可以在 Linux 的 boot loader 里面加入 Windows 开机的选项；</li><li>Windows 在安装的时候，他的安装程序会主动的覆盖掉 MBR 以及自己所在分区的启动扇区，你没有选择的机会， 而且他没有让我们自己选择选单的功能。</li></ul><p>因此，如果先安装 Linux 再安装 Windows 的话，那 MBR 的开机管理程序就只会有 Windows 的项目，而不会有 Linux 的项目 (因为原本在 MBR 内的 Linux 的启动引导程序就会被覆盖掉)。 那需要重新安装 Linux 一次吗？当然不需要，你只要用尽各种方法来处理 MBR 的内容即可。 例如利用 Linux 的恢复模式来修复 MBR。</p><h3 id="122-uefi-bios-搭配-gpt-启动的流程"><a class="markdownIt-Anchor" href="#122-uefi-bios-搭配-gpt-启动的流程"></a> 1.2.2 <strong>UEFI BIOS</strong> <strong>搭配</strong> <strong>GPT</strong> 启动的流程</h3><p>我们现在知道 GPT 可以提供到 64bit 的寻址，然后也能够使用较大的区块来处理启动引导程序，但是 BIOS 其实不懂 GPT 。还得要通过 GPT 提供兼容模式才能够读写这个磁盘设备，而且 BIOS 仅为 16 位的程序，在与现阶段新的操作系统接轨方面有点弱掉。为了解决这个问题，因此就有了 UEFI (Unified Extensible Firmware Interface) 这个统一可扩展固件接口的产生。</p><table><thead><tr><th style="text-align:center">比较项目</th><th style="text-align:center">传统 BIOS</th><th style="text-align:center">UEFI</th></tr></thead><tbody><tr><td style="text-align:center">使用程序语言</td><td style="text-align:center">汇编语言</td><td style="text-align:center">C 语言</td></tr><tr><td style="text-align:center">硬件资源控制</td><td style="text-align:center">使用中断 (IRQ) 管理<br>不可变的内存存取<br>不可变得输入/输出存取</td><td style="text-align:center">使用驱动程序与协议</td></tr><tr><td style="text-align:center">处理器运作环境</td><td style="text-align:center">16 位</td><td style="text-align:center">CPU 保护模式</td></tr><tr><td style="text-align:center">扩充方式</td><td style="text-align:center">通过 IRQ 连接</td><td style="text-align:center">直接加载驱动程序</td></tr><tr><td style="text-align:center">第三方厂商支持</td><td style="text-align:center">较差</td><td style="text-align:center">较佳且可支持多平台</td></tr><tr><td style="text-align:center">图形化能力</td><td style="text-align:center">较差</td><td style="text-align:center">较佳</td></tr><tr><td style="text-align:center">内置简化操作系统环境</td><td style="text-align:center">不支持</td><td style="text-align:center">支持</td></tr></tbody></table><p>与 BIOS 模式相比，虽然 UEFI 可以直接取得 GPT 的分区表，不过最好依旧拥有 BIOS boot 的分区支持， 同时，为了与 windows 兼容，并且提供其他第三方厂商所使用的 UEFI 应用程序存储的空间，你必须要格式化一个 FAT 的文件系统分区， 大约提供 512MB 到 1G 左右的容量，以让其他 UEFI 执行较为方便。</p><h2 id="13-文件系统与目录树的关系挂载"><a class="markdownIt-Anchor" href="#13-文件系统与目录树的关系挂载"></a> 1.3 文件系统与目录树的关系(挂载)</h2><p>所谓的『挂载』就是利用一个目录当成进入点，将磁盘分区的数据放置在该目录下； 也就是说，进入该目录就可以读取该分区的意思。这个操作称为『挂载』，那个进入点的目录我们称为『挂载点』。</p><h1 id="2-习题"><a class="markdownIt-Anchor" href="#2-习题"></a> 2 习题</h1><p>略</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="操作系统" scheme="https://dragonliu2022.github.io/categories/操作系统/"/>
    
    <category term="Linux" scheme="https://dragonliu2022.github.io/categories/操作系统/Linux/"/>
    
    <category term="阅读" scheme="https://dragonliu2022.github.io/categories/阅读/"/>
    
    
  </entry>
  
  <entry>
    <title>《鸟哥的Linux私房菜基础学习篇（第四版）》第1章笔记与习题</title>
    <link href="https://dragonliu2022.github.io/2022/07/24/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E7%AC%AC%E5%9B%9B%E7%89%88%EF%BC%89%E3%80%8B%E7%AC%AC1%E7%AB%A0%E7%AC%94%E8%AE%B0%E4%B8%8E%E4%B9%A0%E9%A2%98/"/>
    <id>https://dragonliu2022.github.io/2022/07/24/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E7%AC%AC%E5%9B%9B%E7%89%88%EF%BC%89%E3%80%8B%E7%AC%AC1%E7%AB%A0%E7%AC%94%E8%AE%B0%E4%B8%8E%E4%B9%A0%E9%A2%98/</id>
    <published>2022-07-24T02:49:40.000Z</published>
    <updated>2022-07-24T06:44:57.196Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>第1章：Linux是什么与如何学习</p></blockquote><h1 id="1-笔记"><a class="markdownIt-Anchor" href="#1-笔记"></a> 1 笔记</h1><blockquote><p>另外，不要再说没兴趣了。没有花时间去了解一下，不要跟人家说你没兴趣！而且，兴趣也是靠培养来的！除了某些特殊人物之外， 没有花时间去培养兴趣，怎么可能会有兴趣。</p></blockquote><h1 id="2-习题"><a class="markdownIt-Anchor" href="#2-习题"></a> 2 习题</h1><h2 id="11-你在你的主机上面安装了一张网络卡但是开机之后系统却无法使用你确定网络卡是好的那么可能的问题出在哪里该如何解决"><a class="markdownIt-Anchor" href="#11-你在你的主机上面安装了一张网络卡但是开机之后系统却无法使用你确定网络卡是好的那么可能的问题出在哪里该如何解决"></a> 1.1 你在你的主机上面安装了一张网络卡，但是开机之后，系统却无法使用，你确定网络卡是好的，那么可能的问题出在哪里？该如何解决？</h2><p>因为所有的硬件都没有问题，所以，可能出问题的地方在于系统的核心(kernel) 不支持这张网络卡。解决的方法：</p><ol><li>到网络卡的开发商网站</li><li>下载支持你主机操作系统的驱动程序</li><li>安装网卡驱动程序后，就可以使用了。</li></ol><h2 id="12-一个操作系统至少要能够完整的控制整个硬件请问操作系统应该要控制硬件的哪些单元"><a class="markdownIt-Anchor" href="#12-一个操作系统至少要能够完整的控制整个硬件请问操作系统应该要控制硬件的哪些单元"></a> 1.2 一个操作系统至少要能够完整的控制整个硬件，请问，操作系统应该要控制硬件的哪些单元？</h2><p>根据硬件的运作，以及数据在主机上面的运算情况与写入/读取情况，我们知道至少要能够控制：</p><ol><li>input/output control</li><li>device control</li><li>process management</li><li>file management等等</li></ol><h2 id="13-我在-windows-上面玩的游戏可不可以拿到-linux-去玩"><a class="markdownIt-Anchor" href="#13-我在-windows-上面玩的游戏可不可以拿到-linux-去玩"></a> 1.3 我在 Windows 上面玩的游戏，可不可以拿到 Linux 去玩？</h2><p>当然不行！因为游戏也是一个应用程序 (application)，他必须要使用到核心所提供的工具来开发他的游戏， 所以这个游戏是不可在不同的平台间运作的。除非这个游戏已经进行了移植。</p><h2 id="14-linux-本身仅是一个核心与相关的核心工具而已不过他已经可以驱动所有的硬件-所以可以算是一个很普通的操作系统了-经过其他应用程序的开发之后被整合成为-linux-distribitions-请问众多的distributions-之间有何异同"><a class="markdownIt-Anchor" href="#14-linux-本身仅是一个核心与相关的核心工具而已不过他已经可以驱动所有的硬件-所以可以算是一个很普通的操作系统了-经过其他应用程序的开发之后被整合成为-linux-distribitions-请问众多的distributions-之间有何异同"></a> 1.4 Linux 本身仅是一个核心与相关的核心工具而已，不过，他已经可以驱动所有的硬件， 所以，可以算是一个很普通的操作系统了。经过其他应用程序的开发之后，被整合成为 Linux distribitions。请问众多的distributions 之间，有何异同？</h2><p><strong>相同</strong>：</p><ol><li>同样使用 <a href="http://www.kernel.org" target="_blank" rel="noopener">http://www.kernel.org</a> 所释出的核心；</li><li>支持同样的标准，如 FHS、LSB 等；</li><li>使用几乎相同的自由软件 (例如 GNU 里面的 gcc/glibc/vi/apache/bind/sendmail… )；</li><li>几乎相同的操作接口 (例如均使用 bash/KDE/GNOME 等等)。</li></ol><p><strong>不同</strong>：</p><ol><li>使用的 kernel 与各软件的版本可能会不同；</li><li>各开发商加入的应用工具不同，使用的套件管理模式不同(dpkg 与 RPM)</li></ol><h2 id="15-unix-是谁写出来的-gnu-计划是谁发起的"><a class="markdownIt-Anchor" href="#15-unix-是谁写出来的-gnu-计划是谁发起的"></a> 1.5 Unix 是谁写出来的？ GNU 计划是谁发起的？</h2><p>Unix 是 Ken Thompson 写的，1973 年再由 Dennis Ritchie 以 C 语言改写成功。</p><p>至于 GNU 与 FSF 则是 Richard Stallman 发起的。</p><h2 id="16-gnu-的全名为何他主要由那个基金会支持"><a class="markdownIt-Anchor" href="#16-gnu-的全名为何他主要由那个基金会支持"></a> 1.6 GNU 的全名为何？他主要由那个基金会支持？</h2><p>GNU 是 GNU is Not Unix 的简写，是个无穷循环！</p><p>另外，这个计划是由自由软件基金会 (Free Software Foundation, FSF) 所支持的！ 两者都是由 Stallman 先生所发起的！</p><h2 id="17-何谓多人-multi-user-多任务-multitask"><a class="markdownIt-Anchor" href="#17-何谓多人-multi-user-多任务-multitask"></a> 1.7 何谓多人 ( Multi-user ) 多任务 ( Multitask )？</h2><p>Multiuser 指的是 Linux 允许多人同时连上主机之外，每个用户皆有其各人的使用环境，并且可以同时使用系统的资源！</p><p>Multitask 指的是多任务环境，在 Linux 系统下， CPU 与其他例如网络资源可以同时进行多项工作， Linux 最大的特色之一即在于其多任务时，资源分配较为平均！</p><h2 id="18-简单说明-gnu-general-public-license-gpl-与-open-source-的精神"><a class="markdownIt-Anchor" href="#18-简单说明-gnu-general-public-license-gpl-与-open-source-的精神"></a> 1.8 简单说明 GNU General Public License ( GPL ) 与 Open Source 的精神：</h2><ol><li>GPL 的授权之软件，乃为自由软件（Free software），任何人皆可拥有他；</li><li>开发 GPL 的团体(或商业企业)可以经由该软件的服务来取得服务的费用；</li><li>经过 GPL 授权的软件，其属于 Open source 的情况，所以应该公布其原始码；</li><li>任何人皆可修改经由 GPL 授权过的软件，使符合自己的需求；</li><li>经过修改过后 Open source 应该回馈给 Linux 社群。</li></ol><h2 id="19-什么是-posix-为何说-linux-使用-posix-对于发展有很好的影响"><a class="markdownIt-Anchor" href="#19-什么是-posix-为何说-linux-使用-posix-对于发展有很好的影响"></a> 1.9 什么是 POSIX ?为何说 Linux 使用 POSIX 对于发展有很好的影响？</h2><p>POSIX 是一种标准规范，主要针对在 Unix 操作系统上面跑的程序来进行规范。若你的操作系统符合 POSIX ，则符合 POSIX 的程序就可以在你的操作系统上面运作。</p><p>Linux 由于支持 POSIX ，因此很多 Unix 上的程序可以直接在 Linux 上运作， 因此程序的移植相当简易！也让大家容易转换平台，提升 Linux 的使用率。</p><h2 id="110-简单说明-linux-成功的因素"><a class="markdownIt-Anchor" href="#110-简单说明-linux-成功的因素"></a> 1.10 简单说明 Linux 成功的因素？</h2><ol><li>藉由 Minix 操作系统开发的 Unix like ，没有版权的纠纷；</li><li>藉助于 GNU 计划所提供的各项工具软件， gcc/bash 等；</li><li>藉由 Internet 广为流传；</li><li>藉由支持 POSIX 标准，让核心能够适合所有软件的开发；</li><li>托瓦兹强调务实，虚拟团队的自然形成！</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="操作系统" scheme="https://dragonliu2022.github.io/categories/操作系统/"/>
    
    <category term="Linux" scheme="https://dragonliu2022.github.io/categories/操作系统/Linux/"/>
    
    <category term="阅读" scheme="https://dragonliu2022.github.io/categories/阅读/"/>
    
    
  </entry>
  
  <entry>
    <title>《鸟哥的Linux私房菜基础学习篇（第四版）》第0章笔记与习题</title>
    <link href="https://dragonliu2022.github.io/2022/07/23/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E7%AC%AC%E5%9B%9B%E7%89%88%EF%BC%89%E3%80%8B%E7%AC%AC0%E7%AB%A0%E7%AC%94%E8%AE%B0%E4%B8%8E%E4%B9%A0%E9%A2%98/"/>
    <id>https://dragonliu2022.github.io/2022/07/23/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E7%AC%AC%E5%9B%9B%E7%89%88%EF%BC%89%E3%80%8B%E7%AC%AC0%E7%AB%A0%E7%AC%94%E8%AE%B0%E4%B8%8E%E4%B9%A0%E9%A2%98/</id>
    <published>2022-07-23T04:44:36.000Z</published>
    <updated>2022-07-24T02:49:22.897Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>第0章：计算机概论</p></blockquote><h1 id="1-笔记"><a class="markdownIt-Anchor" href="#1-笔记"></a> 1 笔记</h1><h2 id="11-cpu架构risc和cisc"><a class="markdownIt-Anchor" href="#11-cpu架构risc和cisc"></a> 1.1 CPU架构：RISC和CISC</h2><ul><li><p><strong>精简指令集</strong> <strong>(Reduced Instruction Set Computer, RISC)</strong>：</p><ul><li>指令集较为精简，每个指令的运行时间都很短，完成的操作也很简单，指令的执行效能较佳；</li><li>但是若要做复杂的事情，就要由多个指令来完成。</li><li>常见的 RISC 指令集 CPU 主要有甲骨文 (Oracle) 公司的 SPARC 系列、 IBM 公司的 Power Architecture (包括 PowerPC) 系列、与ARM公司 (ARM Holdings) 的 ARM CPU 系列等。</li><li>常使用的各厂牌手机、PDA、导航系统、网络设备(交换器、路由器等)等，几乎都是使用 ARM 架构的CPU。<code>目前世界上使用范围最广的 CPU 可能就是 ARM 这种架构。</code></li></ul></li><li><p><strong>复杂指令集(Complex Instruction Set Computer, CISC)</strong></p><ul><li>CISC 在指令集的每个小指令可以执行一些较低阶的硬件操作，指令数目多而且复杂， 每条指令的长度并不相同。</li><li>因为指令执行较为复杂，所以每条指令花费的时间较长， 但每条个别指令可以处理的工作较为丰富。</li><li>常见的 CISC 微指令集 CPU 主要有 AMD、Intel、VIA 等的 x86 架构的 CPU；被大量运用到个人电脑。</li></ul></li></ul><h2 id="12-硬盘容量例题"><a class="markdownIt-Anchor" href="#12-硬盘容量例题"></a> 1.2 硬盘容量例题</h2><p><strong>问题</strong>：</p><p>假设你今天购买了一块 500GB 的硬盘，但是格式化完毕后却只剩下 460GB 左右的容量，这是什么原因？</p><p><strong>回答</strong>：</p><p>因为一般硬盘制造商会使用十进制的单位，所以 500GB 代表为 <code>500*1000*1000*1000</code> 字节之意。 转成文件的容量单位时使用二进制(1024 为底)，所以就成为 466GB 左右的容量了。</p><p>硬盘厂商并非要骗人，只是因为硬盘的最小物理量为 512B，最小的组成单位为扇区(sector)， 通常硬盘容量的计算采用『多少个 sector』，所以才会使用十进制来处理的。</p><h2 id="13-cpu频率"><a class="markdownIt-Anchor" href="#13-cpu频率"></a> 1.3 CPU频率</h2><p>频率就是 CPU 每秒钟可以进行的工作次数。</p><p>注意，不同的 CPU 之间不能单纯地以频率来判断运算性能。这是因为每块 CPU 的指令集不同，架构也不见得一样，可使用的二级缓存及其运算机制可能也不同， 加上每次频率能够进行的工作指令数也不同，所以，频率目前仅能用来比较同款 CPU 的速度。</p><h2 id="14-超线程-hyper-threading-ht"><a class="markdownIt-Anchor" href="#14-超线程-hyper-threading-ht"></a> 1.4 <strong>超线程</strong> <strong>(Hyper-Threading, HT)</strong></h2><p>在每一个 CPU 内部将重要的寄存器 (register) 分成两组， 而让程序分别使用这两组寄存器。也就是说，可以有两个程序『同时竞争 CPU 的运算单元』，而非通过操作系统的多任务切换。 这一过程就会让 CPU 好像『同时有两个内核』的样子。因此，虽然大部分 i7 等级的 CPU 其实只有四个物理内核，但通过 HT 技术， 则操作系统可以检测到八个内核，并且让每个内核逻辑上分离，就可以同时运作八个程序。</p><h2 id="15-内存"><a class="markdownIt-Anchor" href="#15-内存"></a> 1.5 内存</h2><ul><li><strong>DRAM</strong>(动态随机存取内存，Dynamic Random Access Memory)：随机存取内存只有在通电时才能记录与使用，断电后数据就消失，因此我们也称这种 RAM 为挥发性内存。<ul><li>SDRAM</li><li>DDR SDRAM：DDR 是所谓的双倍数据传送速度(Double Data Rate)， 他可以在一次工作周期中进行两次数据的传输。</li><li>多通道设计</li></ul></li><li><strong>SRAM</strong>(静态随机存取内存，Static Random Access Memory)：二级缓存（L2 Cache）</li><li><strong>ROM</strong>(只读存储器，Read Only Memory)：<ul><li>CMOS芯片，BIOS(Basic Input Output System)是一个程序，这个程序是写死到主板上面的一个存储芯片（ROM）中， 这个存储芯片（ROM）在没有通电时也能够记录数据</li><li>固件(firmware)很多也是使用 ROM 来进行软件的写入</li></ul></li></ul><h2 id="16-磁盘分区"><a class="markdownIt-Anchor" href="#16-磁盘分区"></a> 1.6 磁盘分区</h2><ul><li>MBR模式（MS-DOS 兼容模式）：旧式的，通过 柱面号码来划分</li><li>GPT模式：较新的，磁盘的分区通常使用扇区号码来划分</li></ul><h1 id="2-课后题"><a class="markdownIt-Anchor" href="#2-课后题"></a> 2 课后题</h1><p>略</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="操作系统" scheme="https://dragonliu2022.github.io/categories/操作系统/"/>
    
    <category term="Linux" scheme="https://dragonliu2022.github.io/categories/操作系统/Linux/"/>
    
    <category term="阅读" scheme="https://dragonliu2022.github.io/categories/阅读/"/>
    
    
  </entry>
  
  <entry>
    <title>Python读取表格日期类型</title>
    <link href="https://dragonliu2022.github.io/2022/07/20/Python%E8%AF%BB%E5%8F%96%E8%A1%A8%E6%A0%BC%E6%97%A5%E6%9C%9F%E7%B1%BB%E5%9E%8B/"/>
    <id>https://dragonliu2022.github.io/2022/07/20/Python%E8%AF%BB%E5%8F%96%E8%A1%A8%E6%A0%BC%E6%97%A5%E6%9C%9F%E7%B1%BB%E5%9E%8B/</id>
    <published>2022-07-20T15:57:48.000Z</published>
    <updated>2022-07-21T16:48:37.597Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-问题"><a class="markdownIt-Anchor" href="#1-问题"></a> 1 问题</h1><p>读取excel表格，但是日期类型的cell取出来是个数字，需要改成日期类型。</p><h1 id="2-解决"><a class="markdownIt-Anchor" href="#2-解决"></a> 2 解决</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 转化为元组形式</span></span><br><span class="line">xlrd.xldate_as_tuple(table.cell(<span class="number">2</span>,<span class="number">2</span>).value, <span class="number">0</span>)</span><br><span class="line">(<span class="number">2014</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接转化为datetime对象</span></span><br><span class="line">xlrd.xldate.xldate_as_datetime(table.cell(<span class="number">2</span>,<span class="number">2</span>).value, <span class="number">1</span>)</span><br><span class="line">datetime.datetime(<span class="number">2018</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 没有转化</span></span><br><span class="line">table.cell(<span class="number">2</span>,<span class="number">2</span>).value</span><br><span class="line"><span class="number">41828.0</span></span><br></pre></td></tr></table></figure><h1 id="x-参考"><a class="markdownIt-Anchor" href="#x-参考"></a> X 参考</h1><ul><li><a href="https://blog.csdn.net/orangleliu/article/details/38476881" target="_blank" rel="noopener">[Python]xlrd 读取excel 日期类型2种方式</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Python" scheme="https://dragonliu2022.github.io/categories/Python/"/>
    
    <category term="基础" scheme="https://dragonliu2022.github.io/categories/Python/基础/"/>
    
    
  </entry>
  
  <entry>
    <title>Python读取xlsx表格文件失败</title>
    <link href="https://dragonliu2022.github.io/2022/07/20/Python%E8%AF%BB%E5%8F%96xlsx%E8%A1%A8%E6%A0%BC%E6%96%87%E4%BB%B6%E5%A4%B1%E8%B4%A5/"/>
    <id>https://dragonliu2022.github.io/2022/07/20/Python%E8%AF%BB%E5%8F%96xlsx%E8%A1%A8%E6%A0%BC%E6%96%87%E4%BB%B6%E5%A4%B1%E8%B4%A5/</id>
    <published>2022-07-20T15:46:50.000Z</published>
    <updated>2022-07-21T16:48:41.135Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-报错"><a class="markdownIt-Anchor" href="#1-报错"></a> 1 报错</h1><p>报错信息如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xlrd.biffh.XLRDError: Excel xlsx file; not supported</span><br></pre></td></tr></table></figure><h1 id="2-解决"><a class="markdownIt-Anchor" href="#2-解决"></a> 2 解决</h1><h2 id="21-调低xlrd版本推荐"><a class="markdownIt-Anchor" href="#21-调低xlrd版本推荐"></a> 2.1 调低xlrd版本（推荐）</h2><p>xlrd过高，卸载旧版本重新安装1.2.0：</p><table><thead><tr><th>版本</th><th>支持</th></tr></thead><tbody><tr><td>xlrd 1.2</td><td>支持 .xls 、 .xlsx 文件</td></tr><tr><td>xlrd 2.0</td><td>只支持.xls文件</td></tr></tbody></table><p>在cmd中执行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip uninstall xlrd</span><br><span class="line">pip install xlrd==1.2.0</span><br></pre></td></tr></table></figure><p>再运行代码出现下面的报错：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AttributeError: <span class="string">'ElementTree'</span> object has no attribute <span class="string">'getiterator'</span></span><br></pre></td></tr></table></figure><p>在新版python3.9中，windows中使用的更新删除了getiterator方法，所以我们老版本的xlrd库调用getiterator方法时会报错。</p><ol><li>找出Python安装目录<code>python\Lib\site-packages\xlrd</code>下的<code>xlsx.py</code>文件；</li><li>如果找不到文件地址，可以在 cmd 输入 <code>pip show xlrd</code> 即可找到xlrd的文件地址；</li><li>将两个地方的<code>getiterator()</code>改成<code>iter()</code>；</li><li>然后重新载入程序就解决了。</li></ol><h2 id="22-调低excel版本"><a class="markdownIt-Anchor" href="#22-调低excel版本"></a> 2.2 调低excel版本</h2><p>excel文件的版本过高，复制源文件，另存为：xls格式。</p><h1 id="x-参考"><a class="markdownIt-Anchor" href="#x-参考"></a> X 参考</h1><ul><li><a href="https://blog.csdn.net/sinat_37868031/article/details/113376079?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-113376079-blog-111904690.pc_relevant_multi_platform_whitelistv3&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-113376079-blog-111904690.pc_relevant_multi_platform_whitelistv3&amp;utm_relevant_index=1" target="_blank" rel="noopener">xlrd.biffh.XLRDError: Excel xlsx file； not supported，两种解决方案</a></li><li><a href="https://blog.csdn.net/suhao0911/article/details/110950742" target="_blank" rel="noopener">AttributeError: ‘ElementTree‘ object has no attribute ‘getiterator‘</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Python" scheme="https://dragonliu2022.github.io/categories/Python/"/>
    
    <category term="基础" scheme="https://dragonliu2022.github.io/categories/Python/基础/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux无法识别移动硬盘</title>
    <link href="https://dragonliu2022.github.io/2022/07/15/Linux%E6%97%A0%E6%B3%95%E8%AF%86%E5%88%AB%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98/"/>
    <id>https://dragonliu2022.github.io/2022/07/15/Linux%E6%97%A0%E6%B3%95%E8%AF%86%E5%88%AB%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98/</id>
    <published>2022-07-15T15:34:58.000Z</published>
    <updated>2022-07-21T17:00:19.810Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-引入"><a class="markdownIt-Anchor" href="#1-引入"></a> 1 引入</h1><p>Centos7 插入 ntfs 类型的移动硬盘/U盘时，无法访问，提示如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error mounting xxx at xxx: Filesystem <span class="built_in">type</span> ntfs not configured <span class="keyword">in</span> kernel</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：redhat系统使用yum包管理工具，因此下面的解决方法也适用。</p></blockquote><h1 id="2-解决方法1"><a class="markdownIt-Anchor" href="#2-解决方法1"></a> 2 解决方法1</h1><ol><li><p>由于 centos 默认没有ntfs的源，因此需要先加源：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo</span><br></pre></td></tr></table></figure></li><li><p>更新源列表到本地：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum update</span><br></pre></td></tr></table></figure></li><li><p>进行安装：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install ntfs-3g</span><br></pre></td></tr></table></figure><p>安装之后无需重启就可以正常使用移动硬盘/U盘了。</p></li></ol><h1 id="3-解决方法2"><a class="markdownIt-Anchor" href="#3-解决方法2"></a> 3 解决方法2</h1><p>如果只是复制文件到主机，那么只需要cp指令即可：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp &lt;源文件地址&gt; &lt;目标地址&gt;</span><br></pre></td></tr></table></figure><blockquote><p>该方法是从软件杯初审老师哪里学到的。</p></blockquote><h1 id="x-参考"><a class="markdownIt-Anchor" href="#x-参考"></a> X 参考</h1><ul><li><a href="https://blog.csdn.net/chy555chy/article/details/113747253" target="_blank" rel="noopener">centos7 filesystem type ntfs not configured in kernel</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="环境与工具" scheme="https://dragonliu2022.github.io/categories/环境与工具/"/>
    
    <category term="操作系统" scheme="https://dragonliu2022.github.io/categories/操作系统/"/>
    
    <category term="Linux" scheme="https://dragonliu2022.github.io/categories/操作系统/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux创建桌面快捷方式</title>
    <link href="https://dragonliu2022.github.io/2022/07/15/Linux%E5%88%9B%E5%BB%BA%E6%A1%8C%E9%9D%A2%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F/"/>
    <id>https://dragonliu2022.github.io/2022/07/15/Linux%E5%88%9B%E5%BB%BA%E6%A1%8C%E9%9D%A2%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F/</id>
    <published>2022-07-15T11:10:16.000Z</published>
    <updated>2022-07-21T17:00:10.691Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-引入"><a class="markdownIt-Anchor" href="#1-引入"></a> 1 引入</h1><p>在windows下创建桌面快捷方式比较容易，右键即可。在Linux下创建快捷方式就比较麻烦了，整理下。</p><blockquote><p>这种方法在centos7和redhat系统中测试成功；</p><p>在Ubuntu上失败，有个拙劣的方法：将下面的<code>go2dir.sh</code>和<code>go2url,sh</code>脚本放到桌面，当作快捷方式。</p></blockquote><h1 id="2-跳转指定文件夹"><a class="markdownIt-Anchor" href="#2-跳转指定文件夹"></a> 2 跳转指定文件夹</h1><ol><li><p>新建shell脚本<code>go2dir.sh</code>，具有文件夹跳转功能，内容如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"> </span><br><span class="line">nautilus /home/dragon/cpp</span><br></pre></td></tr></table></figure><p>nautilus是终端命令，后面是指定要跳转的文件夹路径。</p><p>将脚本添加执行权限：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x go2dir.sh</span><br></pre></td></tr></table></figure></li><li><p>在桌面上新建<code>GotoDir.desktop</code>文件，内容如下，关注<code>Exec</code>和<code>Icon</code>变量，代表脚本和图标：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Encoding=UTF-8</span><br><span class="line">Name=GotoDir</span><br><span class="line">Comment=Go To My Dir</span><br><span class="line">Exec=/home/dragon/go2dir.sh</span><br><span class="line">Icon=/home/dragon/go2dir.png</span><br><span class="line">Terminal=<span class="literal">false</span></span><br><span class="line">StartupNotify=<span class="literal">true</span></span><br><span class="line">Type=Application</span><br><span class="line">Categories=Application;Development;</span><br></pre></td></tr></table></figure><ol start="2"><li>在桌面上双击快捷方式，即可实现一键跳转指定文件夹。</li></ol></li></ol><h1 id="3-跳转指定网页url"><a class="markdownIt-Anchor" href="#3-跳转指定网页url"></a> 3 跳转指定网页(url)</h1><ol><li><p>新建shell脚本<code>go2url.sh</code>，具有网页跳转功能（火狐浏览器），内容如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"> </span><br><span class="line">firefox --new-window www.baidu.com</span><br></pre></td></tr></table></figure><p>nautilus是终端命令，后面是指定要跳转的文件夹路径。</p><p>将脚本添加执行权限：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x go2url.sh</span><br></pre></td></tr></table></figure></li><li><p>在桌面上新建<code>GotoUrl.desktop</code>文件，内容如下，关注<code>Exec</code>和<code>Icon</code>变量，代表脚本和图标：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Encoding=UTF-8</span><br><span class="line">Name=GotoUrl</span><br><span class="line">Comment=Go To My Url</span><br><span class="line">Exec=/home/dragon/go2url.sh</span><br><span class="line">Icon=/home/dragon/go2url.png</span><br><span class="line">Terminal=<span class="literal">false</span></span><br><span class="line">StartupNotify=<span class="literal">true</span></span><br><span class="line">Type=Application</span><br><span class="line">Categories=Application;Development;</span><br></pre></td></tr></table></figure></li><li><p>在桌面上双击快捷方式，即可实现一键跳转指定网页。</p></li></ol><h1 id="x-参考"><a class="markdownIt-Anchor" href="#x-参考"></a> X 参考</h1><ul><li><a href="https://blog.csdn.net/libaineu2004/article/details/83757377" target="_blank" rel="noopener">CentOS 7 新建桌面快捷方式，实现一键跳转到指定的文件夹路径</a></li><li><a href="https://zditect.com/article/2115540.html" target="_blank" rel="noopener">从命令行 Linux 启动 Firefox</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="环境与工具" scheme="https://dragonliu2022.github.io/categories/环境与工具/"/>
    
    <category term="操作系统" scheme="https://dragonliu2022.github.io/categories/操作系统/"/>
    
    <category term="Linux" scheme="https://dragonliu2022.github.io/categories/操作系统/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Windows下配置多个Git/Github账号</title>
    <link href="https://dragonliu2022.github.io/2022/07/05/Windows%E4%B8%8B%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AAGit-Github%E8%B4%A6%E5%8F%B7/"/>
    <id>https://dragonliu2022.github.io/2022/07/05/Windows%E4%B8%8B%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AAGit-Github%E8%B4%A6%E5%8F%B7/</id>
    <published>2022-07-05T04:53:24.000Z</published>
    <updated>2022-07-05T14:18:11.143Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-引入"><a class="markdownIt-Anchor" href="#1-引入"></a> 1 引入</h1><p>一般情况下，一台电脑配置一个Git账号。但是当需要两个或以上的Github账号时，来回切换非常麻烦，所以需要配置多个Git账号。</p><table><thead><tr><th style="text-align:center">Github账号</th><th style="text-align:center">邮箱</th><th style="text-align:center">Git SSH KEY</th></tr></thead><tbody><tr><td style="text-align:center">User1</td><td style="text-align:center"><a href="mailto:User1@email.com" target="_blank" rel="noopener">User1@email.com</a></td><td style="text-align:center">id_rsa_User1</td></tr><tr><td style="text-align:center">User2</td><td style="text-align:center"><a href="mailto:User2@email.com" target="_blank" rel="noopener">User2@email.com</a></td><td style="text-align:center">id_rsa_User2</td></tr></tbody></table><h1 id="2-生成ssh-key"><a class="markdownIt-Anchor" href="#2-生成ssh-key"></a> 2 生成SSH KEY</h1><ol><li><p>打开CMD或者GIT Bash，生成第一个账号的KEY：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">E:\&gt;ssh-keygen -t rsa -f <span class="string">"C:\Users\Dragon Liu\.ssh\id_rsa_User1"</span> -C <span class="string">"User1@email.com"</span></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved <span class="keyword">in</span> C:\Users\Dragon Liu\.ssh\id_rsa_User1.</span><br><span class="line">Your public key has been saved <span class="keyword">in</span> C:\Users\Dragon Liu\.ssh\id_rsa_User1.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:QtnbRf80ayMhPJvBE1lUHsDvhdLhgSeA7kdofqzLT/Y User1@email.com</span><br><span class="line">The key<span class="string">'s randomart image is:</span></span><br><span class="line"><span class="string">+---[RSA 3072]----+</span></span><br><span class="line"><span class="string">|         ..o*=oo |</span></span><br><span class="line"><span class="string">|       o. oo+o= .|</span></span><br><span class="line"><span class="string">|      o... B.*o*.|</span></span><br><span class="line"><span class="string">|     .  +o..O =++|</span></span><br><span class="line"><span class="string">|      .+So.o o.+o|</span></span><br><span class="line"><span class="string">|       .o +   o..|</span></span><br><span class="line"><span class="string">|         +o      |</span></span><br><span class="line"><span class="string">|       ..o .     |</span></span><br><span class="line"><span class="string">|        oo. E    |</span></span><br><span class="line"><span class="string">+----[SHA256]-----+</span></span><br></pre></td></tr></table></figure></li><li><p>生成第二个账号的KEY：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">E:\&gt;ssh-keygen -t rsa -f <span class="string">"C:\Users\Dragon Liu\.ssh\id_rsa_User2"</span> -C <span class="string">"User2@email.com"</span></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved <span class="keyword">in</span> C:\Users\Dragon Liu\.ssh\id_rsa_User2.</span><br><span class="line">Your public key has been saved <span class="keyword">in</span> C:\Users\Dragon Liu\.ssh\id_rsa_User2.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:Ib6+x8PwGBbgMhBg0l/4IGWBCaTF81mY9BIUjrr8DI8 User2@email.com</span><br><span class="line">The key<span class="string">'s randomart image is:</span></span><br><span class="line"><span class="string">+---[RSA 3072]----+</span></span><br><span class="line"><span class="string">|BB.*O*           |</span></span><br><span class="line"><span class="string">|=.B+*oo          |</span></span><br><span class="line"><span class="string">|...*oBo .        |</span></span><br><span class="line"><span class="string">| .o =oo. .       |</span></span><br><span class="line"><span class="string">|.  o  ..S        |</span></span><br><span class="line"><span class="string">|..    +.         |</span></span><br><span class="line"><span class="string">|.o   ..B         |</span></span><br><span class="line"><span class="string">|  *  .. *        |</span></span><br><span class="line"><span class="string">| E +  oo .       |</span></span><br><span class="line"><span class="string">+----[SHA256]-----+</span></span><br></pre></td></tr></table></figure></li><li><p>进入当前用户的.ssh目录查看，生成id_rsa私钥文件和id_rsa.pub公钥文件，如下截图：</p><img src="https://s2.loli.net/2022/07/05/5Qoa8DRf41pGL2A.png" width="600" height="400" alt="图片名称" align="center" id="207"></li></ol><h1 id="3-添加至github"><a class="markdownIt-Anchor" href="#3-添加至github"></a> 3 添加至Github</h1><ol><li><p>用户User1和User2分别登陆Github，点击<code>settings</code>，选择<code>SSH and GPG keys</code>，点击<code>New SSH key</code>：</p><img src="https://s2.loli.net/2022/07/05/bCyVkL3mYHnGteK.png" width="700" height="300" alt="图片名称" align="center" id="208"></li><li><p><code>Title</code>随便填，<code>Key</code>填<code>id_rsa_xxx.pub</code>的内容（公钥）：</p><img src="https://s2.loli.net/2022/07/05/1N5dJFMWxTKG3pE.png" width="600" height="300" alt="图片名称" align="center" id="209"></li></ol><h1 id="4-配置config文件"><a class="markdownIt-Anchor" href="#4-配置config文件"></a> 4 配置config文件</h1><ol><li><p>在.ssh目录下创建一个<code>config</code>文件，每个账号配置一个Host节点。主要配置项说明：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host &lt;主机别名&gt;</span><br><span class="line">    HostName &lt;服务器真实地址&gt;</span><br><span class="line">    IdentityFile &lt;私钥文件路径&gt;</span><br><span class="line">    PreferredAuthentications &lt;认证方式&gt;</span><br><span class="line">    User &lt;用户名&gt;</span><br></pre></td></tr></table></figure></li><li><p>配置文件内容：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置User1</span></span><br><span class="line">Host User1.github.com</span><br><span class="line">    HostName github.com</span><br><span class="line">    IdentityFile <span class="string">"C:\\Users\\Dragon Liu\\.ssh\\id_rsa_User1"</span></span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    User User1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置User2</span></span><br><span class="line">Host User2.github.com</span><br><span class="line">    HostName github.com</span><br><span class="line">    IdentityFile <span class="string">"C:\\Users\\Dragon Liu\\.ssh\\id_rsa_User2"</span></span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    User User2</span><br></pre></td></tr></table></figure></li><li><p>配置完成后，在cmd或者Git Bash中输入以下命令测试该用户的SSH密钥是否生效：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@User1.github.com</span><br><span class="line">ssh -T git@User2.github.com</span><br></pre></td></tr></table></figure></li></ol><h1 id="5-使用"><a class="markdownIt-Anchor" href="#5-使用"></a> 5 使用</h1><ol><li><p>为各仓库单独配置用户名和邮箱：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name <span class="string">"User1"</span></span><br><span class="line">git config user.email <span class="string">"User1@email.com"</span></span><br></pre></td></tr></table></figure></li><li><p>远程仓库地址需要修改：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原来的</span></span><br><span class="line">git@github.com:xxx/xxxxx.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行修改</span></span><br><span class="line">git remote rm origin</span><br><span class="line">git remote add origin git@User1.github.com:xxx/xxxxx.git</span><br></pre></td></tr></table></figure></li></ol><h1 id="x-参考"><a class="markdownIt-Anchor" href="#x-参考"></a> X 参考</h1><ul><li><a href="https://blog.csdn.net/q13554515812/article/details/83506172" target="_blank" rel="noopener">配置多个Git账号（windows 10）</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="环境与工具" scheme="https://dragonliu2022.github.io/categories/环境与工具/"/>
    
    
    <category term="Git" scheme="https://dragonliu2022.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Lab3实验总结</title>
    <link href="https://dragonliu2022.github.io/2022/06/05/Lab3%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    <id>https://dragonliu2022.github.io/2022/06/05/Lab3%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/</id>
    <published>2022-06-05T12:52:07.000Z</published>
    <updated>2022-07-21T17:04:00.070Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-前言"><a class="markdownIt-Anchor" href="#1-前言"></a> 1 前言</h1><p>这个编程实验需要实现一个简单的cache, 并尝试实现各种替换算法来优化程序的性能. 在代码目录下执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><p>来编译, 生成可执行文件 <code>a.out</code> . 其运行方式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./a.out [-r seed] [trace]</span><br></pre></td></tr></table></figure><p>其中 <code>seed</code> 是随机种子, 可以用于确定性回放帮助调试, 缺省时会用系统时间作为种子; <code>trace</code> 是 <code>bz2</code> 压缩格式的访存序列, 缺省时会产生随机访存序列来测试.</p><blockquote><p>具体见讲义：<a href="https://zhong-kangwei.gitee.io/ics-pa-gitbook-2022/lab3.html" target="_blank" rel="noopener">https://zhong-kangwei.gitee.io/ics-pa-gitbook-2022/lab3.html</a></p></blockquote><h1 id="2-实现"><a class="markdownIt-Anchor" href="#2-实现"></a> 2 实现</h1><h2 id="init_cache-20分"><a class="markdownIt-Anchor" href="#init_cache-20分"></a> init_cache （20分）</h2><ul><li><p>cache结构设计</p><ul><li><p>思路</p><p>主存<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn><mn>2</mn><mi>K</mi><mi>B</mi><mo>=</mo><msup><mn>2</mn><mrow><mn>1</mn><mn>5</mn></mrow></msup><mi>B</mi></mrow><annotation encoding="application/x-tex">32KB=2^{15}B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">3</span><span class="mord mathrm">2</span><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="mrel">=</span><span class="mord"><span class="mord mathrm">2</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">1</span><span class="mord mathrm">5</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span>，块<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>6</mn><mn>4</mn><mi>B</mi><mo>=</mo><msup><mn>2</mn><mn>6</mn></msup><mi>B</mi></mrow><annotation encoding="application/x-tex">64B=2^6B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">6</span><span class="mord mathrm">4</span><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="mrel">=</span><span class="mord"><span class="mord mathrm">2</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">6</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span>，cache容量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mn>6</mn><mi>K</mi><mi>B</mi><mo>=</mo><msup><mn>2</mn><mrow><mn>1</mn><mn>4</mn></mrow></msup><mi>B</mi></mrow><annotation encoding="application/x-tex">16KB=2^{14}B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mord mathrm">6</span><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="mrel">=</span><span class="mord"><span class="mord mathrm">2</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">1</span><span class="mord mathrm">4</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span>，行数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mn>6</mn><mi>K</mi><mi>B</mi><mi mathvariant="normal">/</mi><mn>6</mn><mn>4</mn><mi>B</mi><mo>=</mo><msup><mn>2</mn><mn>8</mn></msup><mi>B</mi></mrow><annotation encoding="application/x-tex">16KB/64B=2^8B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mord mathrm">6</span><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="mord mathrm">/</span><span class="mord mathrm">6</span><span class="mord mathrm">4</span><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="mrel">=</span><span class="mord"><span class="mord mathrm">2</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">8</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span>；由于四路组相联，所以cache组号占<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>8</mn></msup><mi>B</mi><mi mathvariant="normal">/</mi><mn>4</mn><mo>=</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">2^8B/4=6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathrm">2</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">8</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="mord mathrm">/</span><span class="mord mathrm">4</span><span class="mrel">=</span><span class="mord mathrm">6</span></span></span></span>位，所以Tag占<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mn>5</mn><mo>−</mo><mn>6</mn><mo>−</mo><mn>6</mn><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">15-6-6=3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mord mathrm">5</span><span class="mbin">−</span><span class="mord mathrm">6</span><span class="mbin">−</span><span class="mord mathrm">6</span><span class="mrel">=</span><span class="mord mathrm">3</span></span></span></span>位。</p></li><li><p>代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="keyword">bool</span> valid_bit:<span class="number">1</span>;<span class="comment">//valid bit</span></span><br><span class="line"><span class="keyword">bool</span> tag:<span class="number">3</span>;<span class="comment">//Tag</span></span><br><span class="line"><span class="keyword">bool</span> data[<span class="number">64</span>];<span class="comment">//block: data</span></span><br><span class="line"><span class="keyword">bool</span> dirty_bit:<span class="number">1</span>;<span class="comment">//dirty bit</span></span><br><span class="line">&#125;Cache;</span><br><span class="line"></span><br><span class="line">Cache *cache = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>cache初始化</p><ul><li><p>思路<br>算出总行数，然后遍历cache并将所有valid bit置为无效即可。</p></li><li><p>代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_cache</span><span class="params">(<span class="keyword">int</span> total_size_width, <span class="keyword">int</span> associativity_width)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> lines = exp2( total_size_width - BLOCK_WIDTH );<span class="comment">//number of lines??</span></span><br><span class="line"><span class="comment">//printf("%d\n", lines);</span></span><br><span class="line">cache = <span class="built_in">malloc</span>( lines * <span class="keyword">sizeof</span>(Cache) );<span class="comment">//init a cache</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Set all valid bits as invalid</span></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>; i &lt; lines; i++ )&#123;</span><br><span class="line">cache[i].valid_bit = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="cache_read-30分"><a class="markdownIt-Anchor" href="#cache_read-30分"></a> cache_read (30分)</h2><ul><li><p>思路：首先将主存地址进行划分，然后分情况讨论：</p><ul><li>命中成功，在相关cache组中找到符合条件(tag位相同且有效位有效)的cache行，则直接从cache中读出；</li><li>命中失败，但在该组中有空闲行，则到主存读取一块信息并设置标记位；</li><li>命中失败且在该组中未找到空闲行，则任意替代该组的某一行并设置cache。</li></ul></li><li><p>代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//get data from cache</span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">get_data</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> offset)</span></span>&#123;</span><br><span class="line"><span class="keyword">uint32_t</span> ret = cache[num].data[offset] + </span><br><span class="line">(cache[num].data[offset + <span class="number">1</span>] &lt;&lt; <span class="number">8</span>) + </span><br><span class="line">(cache[num].data[offset + <span class="number">2</span>] &lt;&lt; <span class="number">16</span>) + </span><br><span class="line">(cache[num].data[offset + <span class="number">3</span>] &lt;&lt; <span class="number">24</span>);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">cache_read</span><span class="params">(<span class="keyword">uintptr_t</span> addr)</span> </span>&#123;</span><br><span class="line">try_increase(<span class="number">1</span>);<span class="comment">//visit cache times ++</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Memory address division</span></span><br><span class="line">addr = addr &amp; <span class="number">0x7FFF</span>;</span><br><span class="line"><span class="keyword">uint32_t</span> tag, cache_group_num, block_offset, block_num;</span><br><span class="line">block_offset = addr &amp; <span class="number">0x3C</span>;<span class="comment">//block addr: 6 bits, 4 bytes alignment</span></span><br><span class="line">cache_group_num = (addr &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x3F</span>;<span class="comment">//cache group number: 6 bits</span></span><br><span class="line">tag = (addr &gt;&gt; <span class="number">12</span>) &amp; <span class="number">0x7</span>;<span class="comment">//tag: 3 bits</span></span><br><span class="line">block_num = (tag &lt;&lt; <span class="number">6</span>) | cache_group_num;<span class="comment">//memory block number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint32_t</span> paddr, ret_data;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;<span class="comment">//flag hit or not</span></span><br><span class="line"><span class="keyword">int</span> start = cache_group_num * <span class="number">4</span>;<span class="comment">//the start of a group</span></span><br><span class="line"><span class="keyword">int</span><span class="built_in">end</span>   = start + <span class="number">3</span>;          <span class="comment">//the end of a group</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Find the corresponding group</span></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = start ; i &lt;= <span class="built_in">end</span> ; i++ )&#123;</span><br><span class="line"><span class="comment">//Successful hit</span></span><br><span class="line"><span class="keyword">if</span>( cache[i].tag == tag &amp;&amp; cache[i].valid_bit )&#123;</span><br><span class="line">hit_increase(<span class="number">1</span>);</span><br><span class="line">flag = <span class="literal">true</span>;</span><br><span class="line">ret_data = get_data(i, block_offset);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//failed hit</span></span><br><span class="line"><span class="keyword">if</span>( !flag )&#123;</span><br><span class="line"><span class="keyword">bool</span> flg = <span class="literal">false</span>;<span class="comment">// flag that is there a free line</span></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = start ; i &lt;= <span class="built_in">end</span>; i++ )&#123;</span><br><span class="line"><span class="comment">//find a free line</span></span><br><span class="line"><span class="keyword">if</span>( !cache[i].valid_bit  )&#123;</span><br><span class="line">flg = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//set cache</span></span><br><span class="line">mem_read(block_num, cache[i].data);<span class="comment">//read data from memory</span></span><br><span class="line">cache[i].tag = tag;</span><br><span class="line">cache[i].valid_bit = <span class="literal">true</span>;</span><br><span class="line">cache[i].dirty_bit = <span class="literal">false</span>;</span><br><span class="line">ret_data = get_data(i, block_offset); </span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cannot find a free line, </span></span><br><span class="line"><span class="keyword">if</span>( !flg )&#123;</span><br><span class="line"><span class="keyword">int</span> rand_line = start + rand()%<span class="number">4</span>;<span class="comment">//find a random line</span></span><br><span class="line"><span class="comment">//if dirty, write first</span></span><br><span class="line"><span class="keyword">if</span>( cache[rand_line].dirty_bit )&#123;</span><br><span class="line">paddr = ( cache[rand_line].tag &lt;&lt; <span class="number">6</span> ) | cache_group_num ;</span><br><span class="line">mem_write(paddr, cache[rand_line].data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//set cache</span></span><br><span class="line">mem_read(block_num, cache[rand_line].data);</span><br><span class="line">cache[rand_line].tag = tag;</span><br><span class="line">cache[rand_line].valid_bit = <span class="literal">true</span>;</span><br><span class="line">cache[rand_line].dirty_bit = <span class="literal">false</span>;</span><br><span class="line">ret_data = get_data(rand_line, block_offset);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret_data;</span><br><span class="line"></span><br><span class="line"><span class="comment">//return 0;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="cache_write-30分"><a class="markdownIt-Anchor" href="#cache_write-30分"></a> cache_write (30分)</h2><ul><li><p>思路：首先将主存地址进行划分，然后分情况讨论(与读类似)：</p><ul><li>命中成功，在相关cache组中找到符合条件(tag位相同且有效位有效)的cache行，则根据写掩码写入cache并置脏位；</li><li>命中失败，但在该组中有空闲行，则根据写掩码写入cache并设置标记位；</li><li>命中失败且在该组中未找到空闲行，则随机取一行；判断脏位是否为1，若为1则将当前的cache行写回主存，然后根据写掩码写入cache并设置cache。</li></ul></li><li><p>代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//set the data of cache by wmask</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_cache</span><span class="params">(<span class="keyword">int</span> num , <span class="keyword">uint32_t</span> offset , <span class="keyword">uint32_t</span> wmask , <span class="keyword">uint32_t</span> data)</span></span>&#123;</span><br><span class="line"><span class="keyword">uint32_t</span> standard_data;</span><br><span class="line">standard_data = get_data(num, offset); </span><br><span class="line">standard_data = ( standard_data &amp; ( ~ wmask) ) | (data &amp; wmask);</span><br><span class="line"></span><br><span class="line">cache[num].data[offset]     = standard_data         &amp; <span class="number">0xFF</span>;</span><br><span class="line">cache[num].data[offset + <span class="number">1</span>] = (standard_data &gt;&gt;  <span class="number">8</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line">cache[num].data[offset + <span class="number">2</span>] = (standard_data &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line">cache[num].data[offset + <span class="number">3</span>] = (standard_data &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cache_write</span><span class="params">(<span class="keyword">uintptr_t</span> addr, <span class="keyword">uint32_t</span> data, <span class="keyword">uint32_t</span> wmask)</span> </span>&#123;</span><br><span class="line">try_increase(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//Memory address division</span></span><br><span class="line">addr = addr &amp; <span class="number">0x7FFF</span>;</span><br><span class="line"><span class="keyword">uint32_t</span> tag, cache_group_num, block_offset, block_num;</span><br><span class="line">block_offset = addr &amp; <span class="number">0x3C</span>;</span><br><span class="line">cache_group_num = (addr &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x3F</span>;</span><br><span class="line">tag = (addr &gt;&gt; <span class="number">12</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">    block_num = (tag &lt;&lt; <span class="number">6</span>) | cache_group_num;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint32_t</span> paddr;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;<span class="comment">// flag write hit or not</span></span><br><span class="line"><span class="keyword">int</span> start = cache_group_num * <span class="number">4</span>;<span class="comment">//the start of a group</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">end</span>   = start + <span class="number">3</span>;<span class="comment">//the end of a group</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Find the corresponding group</span></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = start ; i &lt;= <span class="built_in">end</span>; i++ )&#123;</span><br><span class="line"><span class="comment">//successful hit</span></span><br><span class="line"><span class="keyword">if</span>( cache[i].tag == tag &amp;&amp; cache[i].valid_bit )&#123;</span><br><span class="line">hit_increase(<span class="number">1</span>);</span><br><span class="line">flag = <span class="literal">true</span>;</span><br><span class="line">set_cache(i, block_offset, wmask, data);<span class="comment">//write data</span></span><br><span class="line">cache[i].dirty_bit = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//failed hit</span></span><br><span class="line"><span class="keyword">if</span>( !flag )&#123;</span><br><span class="line"><span class="keyword">bool</span> flg = <span class="literal">false</span>;<span class="comment">//flag that is there a free line</span></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = start ; i &lt;= <span class="built_in">end</span>; i++ )&#123;</span><br><span class="line"><span class="comment">//find a free line</span></span><br><span class="line"><span class="keyword">if</span>( !cache[i].valid_bit )&#123;</span><br><span class="line">flg = <span class="literal">true</span>;</span><br><span class="line">mem_read(block_num, cache[i].data);<span class="comment">//read data from memory</span></span><br><span class="line">set_cache(i, block_offset, wmask, data);<span class="comment">//write data to cache</span></span><br><span class="line">cache[i].tag = tag;</span><br><span class="line">cache[i].valid_bit = <span class="literal">true</span>;</span><br><span class="line">cache[i].dirty_bit = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cannot find a free line</span></span><br><span class="line"><span class="keyword">if</span>( !flg )&#123;</span><br><span class="line"><span class="keyword">int</span> rand_line = start + rand()%<span class="number">4</span>;<span class="comment">//find a random line</span></span><br><span class="line"><span class="comment">//if dirty, write first</span></span><br><span class="line"><span class="keyword">if</span>( cache[rand_line].dirty_bit )&#123;</span><br><span class="line">paddr = ( cache[rand_line].tag &lt;&lt; <span class="number">6</span> ) | cache_group_num;</span><br><span class="line">mem_write(paddr, cache[rand_line].data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//set cache</span></span><br><span class="line">mem_read(block_num, cache[rand_line].data);</span><br><span class="line">set_cache(rand_line, block_offset, wmask , data);</span><br><span class="line">cache[rand_line].tag = tag;</span><br><span class="line">cache[rand_line].valid_bit = <span class="literal">true</span>;</span><br><span class="line">cache[rand_line].dirty_bit = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="最终结果截图20分"><a class="markdownIt-Anchor" href="#最终结果截图20分"></a> 最终结果截图（20分）</h2><img src="https://s2.loli.net/2022/06/05/TkSoKYvaZm7dDq1.jpg" width="800" height="200" alt="图片名称" align="center" id="206"><h2 id="思考题"><a class="markdownIt-Anchor" href="#思考题"></a> 思考题</h2><ul><li><strong>问</strong>：数据对齐和存储层次结构：想一想, 为什么编译器为变量分配存储空间的时候一般都会对齐? 访问一个没有对齐的存储空间会经历怎么样的过程?</li><li><strong>答</strong>：需要字节对齐的根本原因在于CPU访问数据的效率问题。若存储空间未对齐，则可能出现多次访存，然后组合成目标数据，因此带来指令执行效率的降低。</li><li><strong>参考</strong>：<ul><li><a href="https://blog.csdn.net/hunanchenxingyu/article/details/53942407" target="_blank" rel="noopener">为什么需要字节对齐</a></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="计组" scheme="https://dragonliu2022.github.io/categories/计组/"/>
    
    
    <category term="Lab" scheme="https://dragonliu2022.github.io/tags/Lab/"/>
    
  </entry>
  
  <entry>
    <title>Java中调用Python程序</title>
    <link href="https://dragonliu2022.github.io/2022/05/29/Java%E4%B8%AD%E8%B0%83%E7%94%A8Python%E7%A8%8B%E5%BA%8F/"/>
    <id>https://dragonliu2022.github.io/2022/05/29/Java%E4%B8%AD%E8%B0%83%E7%94%A8Python%E7%A8%8B%E5%BA%8F/</id>
    <published>2022-05-29T14:28:07.000Z</published>
    <updated>2022-05-29T14:28:07.991Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>gdb调试</title>
    <link href="https://dragonliu2022.github.io/2022/05/27/gdb%E8%B0%83%E8%AF%95/"/>
    <id>https://dragonliu2022.github.io/2022/05/27/gdb%E8%B0%83%E8%AF%95/</id>
    <published>2022-05-27T05:24:18.000Z</published>
    <updated>2022-07-21T17:10:34.740Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-前言"><a class="markdownIt-Anchor" href="#1-前言"></a> 1 前言</h1><p>gdb调试是必须要掌握的基本技能。</p><h1 id="2-安装gdb-peda"><a class="markdownIt-Anchor" href="#2-安装gdb-peda"></a> 2 安装gdb-peda</h1><p>gdb-peda是gdb的插件，加强gdb调试能力。</p><p>安装方法如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ <span class="built_in">set</span> disassembly-flavor att$ git <span class="built_in">clone</span> htgdb-peda$ <span class="built_in">set</span> disassembly-flavor atttps://github.com/longld/peda.git ~/peda</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"source ~/peda/peda.py"</span> &gt;&gt; ~/.gdbinit</span><br></pre></td></tr></table></figure><p>安装插件后汇编指令格式改为了intel模式，不太习惯，改变为AT&amp;T格式：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 改为AT&amp;T格式</span></span><br><span class="line">gdb-peda$ <span class="built_in">set</span> disassembly-flavor att</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改为Intel格式</span></span><br><span class="line">gdb-peda$ <span class="built_in">set</span> disassembly-flavor intel</span><br></pre></td></tr></table></figure><p><strong>参考</strong>：<a href="https://blog.csdn.net/counsellor/article/details/81290335" target="_blank" rel="noopener">gdb-peda安装</a></p><p>此外，GDB dashboard插件也不错：<a href="https://github.com/cyrus-and/gdb-dashboard" target="_blank" rel="noopener">链接</a></p><h1 id="3-文档"><a class="markdownIt-Anchor" href="#3-文档"></a> 3 文档</h1><ul><li><a href="https://wizardforcel.gitbooks.io/100-gdb-tips/content/index.html" target="_blank" rel="noopener">《100个gdb小技巧》</a></li><li><a href="https://sourceware.org/gdb/current/onlinedocs/gdb/" target="_blank" rel="noopener">gdb手册</a></li></ul><h1 id="4-gdb卡片"><a class="markdownIt-Anchor" href="#4-gdb卡片"></a> 4 GDB卡片</h1><img src="https://s2.loli.net/2022/05/27/joJaNUkKdB5Pnew.png" width="1000" height="800" alt="图片名称" align="center" id="204"><img src="https://s2.loli.net/2022/05/27/yrgOVkfGmJQxjDT.png" width="1000" height="800" alt="图片名称" align="center" id="205"><h1 id="5-常见指令"><a class="markdownIt-Anchor" href="#5-常见指令"></a> 5 常见指令</h1><h1 id="x-参考"><a class="markdownIt-Anchor" href="#x-参考"></a> X 参考</h1><ul><li><a href="https://blog.csdn.net/tianya_lu/article/details/123648314" target="_blank" rel="noopener">gdb基本命令(非常详细)</a></li><li><a href="https://www.cnblogs.com/qq78292959/archive/2012/07/20/2600865.html" target="_blank" rel="noopener">EAX、ECX、EDX、EBX寄存器的作用</a></li><li><a href="https://www.xianwaizhiyin.net/?p=1035" target="_blank" rel="noopener">X86汇编入门-寄存器32位 - 弦外之音</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="环境与工具" scheme="https://dragonliu2022.github.io/categories/环境与工具/"/>
    
    
    <category term="gdb" scheme="https://dragonliu2022.github.io/tags/gdb/"/>
    
  </entry>
  
  <entry>
    <title>PA答疑之a4指令码报错</title>
    <link href="https://dragonliu2022.github.io/2022/05/27/PA%E7%AD%94%E7%96%91%E4%B9%8Ba4%E6%8C%87%E4%BB%A4%E7%A0%81%E6%8A%A5%E9%94%99/"/>
    <id>https://dragonliu2022.github.io/2022/05/27/PA%E7%AD%94%E7%96%91%E4%B9%8Ba4%E6%8C%87%E4%BB%A4%E7%A0%81%E6%8A%A5%E9%94%99/</id>
    <published>2022-05-27T05:06:36.000Z</published>
    <updated>2022-07-21T17:02:55.432Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-问题"><a class="markdownIt-Anchor" href="#1-问题"></a> 1 问题</h1><p>PA3.1在运行/bin/bmptest时，遇到提示a4这条指令没有实现的情况：</p><img src="https://s2.loli.net/2022/05/27/yOt4KiAgJuleBNQ.png" width="500" height="400" alt="图片名称" align="center" id="202"><h1 id="2-解决"><a class="markdownIt-Anchor" href="#2-解决"></a> 2 解决</h1><h2 id="21-法1"><a class="markdownIt-Anchor" href="#21-法1"></a> 2.1 法1</h2><p>在 navy-apps/Makefile.compile 修改o2为o0即可，这是关闭了代码优化，避免了⼀些数据未保存。</p><p>在navy-apps里make clean后再重新编译。</p><h2 id="22-法2"><a class="markdownIt-Anchor" href="#22-法2"></a> 2.2 法2</h2><p>实现a4指令：（<code>胡宇轩学弟</code>提供）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">make_EHelper(movsb)&#123;</span><br><span class="line">  vaddr_write(cpu.edi,<span class="number">1</span>,vaddr_read(cpu.esi,<span class="number">1</span>));</span><br><span class="line">  t0 = <span class="number">1</span>;</span><br><span class="line">  rtl_add(&amp;cpu.edi,&amp;cpu.edi,&amp;t0);</span><br><span class="line">  rtl_add(&amp;cpu.esi,&amp;cpu.esi,&amp;t0);</span><br><span class="line">  print_asm(<span class="string">"movbx"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DF等于0是递增，等于1是递减，具体实现见386手册：</p><img src="https://s2.loli.net/2022/05/27/AimEsOoM9XalY8c.png" width="600" height="400" alt="图片名称" align="center" id="203">]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="计组" scheme="https://dragonliu2022.github.io/categories/计组/"/>
    
    
    <category term="PA" scheme="https://dragonliu2022.github.io/tags/PA/"/>
    
  </entry>
  
  <entry>
    <title>64位Ubuntu运行或调试32位程序</title>
    <link href="https://dragonliu2022.github.io/2022/05/26/64%E4%BD%8DUbuntu%E8%BF%90%E8%A1%8C32%E4%BD%8D%E7%A8%8B%E5%BA%8F/"/>
    <id>https://dragonliu2022.github.io/2022/05/26/64%E4%BD%8DUbuntu%E8%BF%90%E8%A1%8C32%E4%BD%8D%E7%A8%8B%E5%BA%8F/</id>
    <published>2022-05-26T05:20:32.000Z</published>
    <updated>2022-07-21T17:10:48.300Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-问题"><a class="markdownIt-Anchor" href="#1-问题"></a> 1 问题</h1><p>最近在做lab2，使用64位的Ubuntu发现无法调试和运行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  lab ./bomb </span><br><span class="line">zsh: no such file or directory: ./bomb</span><br></pre></td></tr></table></figure><h1 id="2-解决"><a class="markdownIt-Anchor" href="#2-解决"></a> 2 解决</h1><p>ubuntu 64位下可以兼容32位程序的运行，但是必须要有32位基础库的支持才行。下面进行安装：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg --add-architecture i386</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install libc6:i386 libncurses5:i386 libstdc++6:i386</span><br><span class="line">sudo apt install lib32z1</span><br></pre></td></tr></table></figure><p>安装完成后可以运行和调试了：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  lab ./bomb </span><br><span class="line">Welcome to my fiendish little bomb. You have 6 phases with</span><br><span class="line"><span class="built_in">which</span> to blow yourself up. Have a nice day!</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">➜  lab gdb ./bomb</span><br><span class="line">GNU gdb (Ubuntu 9.2-0ubuntu1~20.04.1) 9.2</span><br><span class="line">Copyright (C) 2020 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br><span class="line">Type <span class="string">"show copying"</span> and <span class="string">"show warranty"</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">"x86_64-linux-gnu"</span>.</span><br><span class="line">Type <span class="string">"show configuration"</span> <span class="keyword">for</span> configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line"></span><br><span class="line">For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">"help"</span>.</span><br><span class="line">Type <span class="string">"apropos word"</span> to search <span class="keyword">for</span> commands related to <span class="string">"word"</span>...</span><br><span class="line">Reading symbols from ./bomb...</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><h1 id="x-参考"><a class="markdownIt-Anchor" href="#x-参考"></a> X 参考</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/357653128" target="_blank" rel="noopener">ubuntu 64下运行32位程序</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="计组" scheme="https://dragonliu2022.github.io/categories/计组/"/>
    
    
    <category term="Ubuntu" scheme="https://dragonliu2022.github.io/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>MLP的pytorch实现</title>
    <link href="https://dragonliu2022.github.io/2022/05/16/MLP%E7%9A%84pytorch%E5%AE%9E%E7%8E%B0/"/>
    <id>https://dragonliu2022.github.io/2022/05/16/MLP%E7%9A%84pytorch%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-05-16T13:40:45.000Z</published>
    <updated>2022-07-21T17:16:53.655Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-问题"><a class="markdownIt-Anchor" href="#1-问题"></a> 1 问题</h1><p>xxx</p><h1 id="2-实现"><a class="markdownIt-Anchor" href="#2-实现"></a> 2 实现</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_digits</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset, DataLoader</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score, precision_score, recall_score, f1_score, classification_report, confusion_matrix</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> label_binarize</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> roc_curve, auc</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">np.random.seed(<span class="number">0</span>)</span><br><span class="line">torch.manual_seed(<span class="number">0</span>)</span><br><span class="line">torch.cuda.manual_seed_all(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"加载数据"</span>)</span><br><span class="line">digits = load_digits()</span><br><span class="line">data, label = digits.data, digits.target</span><br><span class="line"><span class="comment"># print(data.shape, label.shape)</span></span><br><span class="line">train_data, test_data, train_label, test_label = train_test_split(data, label, test_size=<span class="number">.3</span>, random_state=<span class="number">123</span>)</span><br><span class="line">print(<span class="string">'训练数据：'</span>, train_data.shape)</span><br><span class="line">print(<span class="string">'测试数据：'</span>, test_data.shape)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"定义相关参数"</span>)</span><br><span class="line">epochs = <span class="number">30</span></span><br><span class="line">batch_size = train_data.shape[<span class="number">0</span>]</span><br><span class="line">device = torch.device(<span class="string">"cuda:0"</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">"cpu"</span>)</span><br><span class="line">input_dim = data.shape[<span class="number">1</span>]</span><br><span class="line">hidden_dim = <span class="number">256</span></span><br><span class="line">output_dim = len(set(label))</span><br><span class="line"></span><br><span class="line">print(<span class="string">"构建数据集"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DigitsDataset</span><span class="params">(Dataset)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, input_data, input_label)</span>:</span></span><br><span class="line">    data = []</span><br><span class="line">    <span class="keyword">for</span> i,j <span class="keyword">in</span> zip(input_data, input_label):</span><br><span class="line">      data.append((i,j))</span><br><span class="line">    self.data = data</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> len(self.data)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">    d, l = self.data[index]</span><br><span class="line">    <span class="keyword">return</span> d, l</span><br><span class="line"></span><br><span class="line">trainDataset = DigitsDataset(train_data, train_label)</span><br><span class="line">testDataset = DigitsDataset(test_data, test_label)</span><br><span class="line"><span class="comment"># print(trainDataset[0])</span></span><br><span class="line"><span class="comment"># print(trainDataset[0])</span></span><br><span class="line">trainDataLoader = DataLoader(trainDataset, batch_size=batch_size, shuffle=<span class="literal">True</span>, num_workers=<span class="number">0</span>)  <span class="comment"># 2改为0</span></span><br><span class="line">testDataLoader = DataLoader(testDataset, batch_size=batch_size, shuffle=<span class="literal">False</span>, num_workers=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, input_dim, hidden_dim, output_dim)</span>:</span></span><br><span class="line">    super(Model, self).__init__()</span><br><span class="line">    self.fc1 = nn.Linear(input_dim, hidden_dim)</span><br><span class="line">    self.relu = nn.ReLU()</span><br><span class="line">    self.fc2 = nn.Linear(hidden_dim, output_dim)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">    x = self.fc1(x)</span><br><span class="line">    x = self.relu(x)</span><br><span class="line">    x = self.fc2(x)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">model = Model(input_dim, hidden_dim, output_dim)</span><br><span class="line">print(model)</span><br><span class="line">model.to(device)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"定义损失函数、优化器"</span>)</span><br><span class="line">criterion = nn.CrossEntropyLoss()</span><br><span class="line">optimizer = torch.optim.SGD(model.parameters(), lr=<span class="number">0.01</span>, momentum=<span class="number">0.9</span>, weight_decay=<span class="number">1e-4</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"初始化相关参数"</span>)</span><br><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> model.parameters():</span><br><span class="line">  nn.init.normal_(param, mean=<span class="number">0</span>, std=<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(<span class="string">"开始训练主循环"</span>)</span><br><span class="line">total_step = len(trainDataLoader)</span><br><span class="line"></span><br><span class="line">model.train()</span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(epochs):</span><br><span class="line">  tot_loss = <span class="number">0.0</span></span><br><span class="line">  tot_acc = <span class="number">0.0</span></span><br><span class="line">  train_preds = []</span><br><span class="line">  train_trues = []</span><br><span class="line">  <span class="comment"># model.train()</span></span><br><span class="line">  <span class="keyword">for</span> i,(train_data_batch, train_label_batch) <span class="keyword">in</span> enumerate(trainDataLoader):</span><br><span class="line">    train_data_batch = train_data_batch.float().to(device) <span class="comment"># 将double数据转换为float</span></span><br><span class="line">    train_label_batch = train_label_batch.to(device)</span><br><span class="line">    outputs = model(train_data_batch)</span><br><span class="line">    <span class="comment"># _, preds = torch.max(outputs.data, 1)</span></span><br><span class="line">    loss = criterion(outputs, train_label_batch.type(torch.LongTensor))</span><br><span class="line">    <span class="comment"># print(loss)</span></span><br><span class="line">    <span class="comment">#反向传播优化网络参数</span></span><br><span class="line">    loss.backward()</span><br><span class="line">    optimizer.step()</span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line">    <span class="comment">#累加每个step的损失</span></span><br><span class="line">    tot_loss += loss.data</span><br><span class="line">    train_outputs = outputs.argmax(dim=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    train_preds.extend(train_outputs.detach().cpu().numpy())</span><br><span class="line">    train_trues.extend(train_label_batch.detach().cpu().numpy())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># tot_acc += (outputs.argmax(dim=1) == train_label_batch).sum().item()</span></span><br><span class="line"></span><br><span class="line">  sklearn_accuracy = accuracy_score(train_trues, train_preds)</span><br><span class="line">  sklearn_precision = precision_score(train_trues, train_preds, average=<span class="string">'micro'</span>)</span><br><span class="line">  sklearn_recall = recall_score(train_trues, train_preds, average=<span class="string">'micro'</span>)</span><br><span class="line">  sklearn_f1 = f1_score(train_trues, train_preds, average=<span class="string">'micro'</span>)</span><br><span class="line">  print(<span class="string">"[sklearn_metrics] Epoch:&#123;&#125; loss:&#123;:.4f&#125; accuracy:&#123;:.4f&#125; precision:&#123;:.4f&#125; recall:&#123;:.4f&#125; f1:&#123;:.4f&#125;"</span>.format(epoch, tot_loss, sklearn_accuracy, sklearn_precision, sklearn_recall, sklearn_f1))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_confusion_matrix</span><span class="params">(trues, preds)</span>:</span></span><br><span class="line">  labels = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">  conf_matrix = confusion_matrix(trues, preds, labels=labels)</span><br><span class="line">  <span class="keyword">return</span> conf_matrix</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_confusion_matrix</span><span class="params">(conf_matrix)</span>:</span></span><br><span class="line">  plt.imshow(conf_matrix, cmap=plt.cm.Greens)</span><br><span class="line">  indices = range(conf_matrix.shape[<span class="number">0</span>])</span><br><span class="line">  labels = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">  plt.xticks(indices, labels)</span><br><span class="line">  plt.yticks(indices, labels)</span><br><span class="line">  plt.colorbar()</span><br><span class="line">  plt.xlabel(<span class="string">'y_pred'</span>)</span><br><span class="line">  plt.ylabel(<span class="string">'y_true'</span>)</span><br><span class="line">  <span class="comment"># 显示数据</span></span><br><span class="line">  <span class="keyword">for</span> first_index <span class="keyword">in</span> range(conf_matrix.shape[<span class="number">0</span>]):</span><br><span class="line">    <span class="keyword">for</span> second_index <span class="keyword">in</span> range(conf_matrix.shape[<span class="number">1</span>]):</span><br><span class="line">      plt.text(first_index, second_index, conf_matrix[first_index, second_index])</span><br><span class="line">  plt.savefig(<span class="string">'heatmap_confusion_matrix.jpg'</span>)</span><br><span class="line">  plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test_preds = []</span><br><span class="line">test_trues = []</span><br><span class="line">model.eval()</span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">  <span class="keyword">for</span> i,(test_data_batch, test_data_label) <span class="keyword">in</span> enumerate(testDataLoader):</span><br><span class="line">    test_data_batch = test_data_batch.float().to(device) <span class="comment"># 将double数据转换为float</span></span><br><span class="line">    test_data_label = test_data_label.to(device)</span><br><span class="line">    test_outputs = model(test_data_batch)</span><br><span class="line">    test_outputs = test_outputs.argmax(dim=<span class="number">1</span>)</span><br><span class="line">    test_preds.extend(test_outputs.detach().cpu().numpy())</span><br><span class="line">    test_trues.extend(test_data_label.detach().cpu().numpy())</span><br><span class="line"></span><br><span class="line">  sklearn_precision = precision_score(test_trues, test_preds, average=<span class="string">'micro'</span>)</span><br><span class="line">  sklearn_recall = recall_score(test_trues, test_preds, average=<span class="string">'micro'</span>)</span><br><span class="line">  sklearn_f1 = f1_score(test_trues, test_preds, average=<span class="string">'micro'</span>)</span><br><span class="line">  print(classification_report(test_trues, test_preds))</span><br><span class="line">  conf_matrix = get_confusion_matrix(test_trues, test_preds)</span><br><span class="line">  print(conf_matrix)</span><br><span class="line">  plot_confusion_matrix(conf_matrix)</span><br><span class="line">  print(<span class="string">"[sklearn_metrics] accuracy:&#123;:.4f&#125; precision:&#123;:.4f&#125; recall:&#123;:.4f&#125; f1:&#123;:.4f&#125;"</span>.format(sklearn_accuracy, sklearn_precision, sklearn_recall, sklearn_f1))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Press the green button in the gutter to run the script.</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    start = time.time()</span><br><span class="line">    print(<span class="string">'train-mlp'</span>)</span><br><span class="line">    end = time.time()</span><br><span class="line">    print((end - start) / <span class="number">60</span>, <span class="string">"min"</span>)  <span class="comment"># 秒</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="人工智能" scheme="https://dragonliu2022.github.io/categories/人工智能/"/>
    
    
  </entry>
  
  <entry>
    <title>sklean常见机器学习分类器</title>
    <link href="https://dragonliu2022.github.io/2022/05/16/sklean%E5%B8%B8%E8%A7%81%E5%88%86%E7%B1%BB%E5%99%A8/"/>
    <id>https://dragonliu2022.github.io/2022/05/16/sklean%E5%B8%B8%E8%A7%81%E5%88%86%E7%B1%BB%E5%99%A8/</id>
    <published>2022-05-16T12:28:16.000Z</published>
    <updated>2022-07-21T17:17:00.759Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-问题"><a class="markdownIt-Anchor" href="#1-问题"></a> 1 问题</h1><p>使用python的机器学习库sklearn实现常见的机器学习分类算法，如决策树、随机森林等。</p><h1 id="2-代码实现"><a class="markdownIt-Anchor" href="#2-代码实现"></a> 2 代码实现</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rf_train</span><span class="params">()</span>:</span></span><br><span class="line">    api_train = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>]])</span><br><span class="line">    type_train = np.array([<span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line">    api_test = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>]])</span><br><span class="line">    type_test = np.array([<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    clf = DecisionTreeClassifier(random_state=<span class="number">0</span>)</span><br><span class="line">    rfc = RandomForestClassifier(random_state=<span class="number">0</span>)</span><br><span class="line">    clf = clf.fit(api_train, type_train)</span><br><span class="line">    rfc = rfc.fit(api_train, type_train)</span><br><span class="line">    score_c = clf.score(api_test, type_test)</span><br><span class="line">    score_r = rfc.score(api_test, type_test)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"Single Tree:&#123;&#125;"</span>.format(score_c), <span class="string">"Random Forest:&#123;&#125;"</span>.format(score_r))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    start = time.time()</span><br><span class="line">    print(<span class="string">'最终版-随机森林'</span>)</span><br><span class="line"></span><br><span class="line">    end = time.time()</span><br><span class="line">    print((end - start) / <span class="number">60</span>, <span class="string">"min"</span>)  <span class="comment"># 秒</span></span><br></pre></td></tr></table></figure><h1 id="x-参考"><a class="markdownIt-Anchor" href="#x-参考"></a> X 参考</h1><ul><li><a href="https://blog.csdn.net/weixin_41571493/article/details/83011147" target="_blank" rel="noopener">【机器学习】Sklearn 常用分类器（全）</a></li><li></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="人工智能" scheme="https://dragonliu2022.github.io/categories/人工智能/"/>
    
    
  </entry>
  
</feed>
