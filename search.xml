<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hexo迁移到新电脑</title>
      <link href="/2021/09/21/Hexo%E8%BF%81%E7%A7%BB%E5%88%B0%E6%96%B0%E7%94%B5%E8%84%91/"/>
      <url>/2021/09/21/Hexo%E8%BF%81%E7%A7%BB%E5%88%B0%E6%96%B0%E7%94%B5%E8%84%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="0-情景导入"><a href="#0-情景导入" class="headerlink" title="0 情景导入"></a>0 情景导入</h1><p>换了一台电脑，将旧电脑的hexo博客写作环境迁移到新电脑上。</p><h1 id="1-Git下载及配置"><a href="#1-Git下载及配置" class="headerlink" title="1 Git下载及配置"></a>1 Git下载及配置</h1><ol><li>从官网Git下载git并安装，下面设置无密push+pull；</li><li>打开git bash，在用户主目录(其他目录也可)下运行：<code>ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</code> 把其中的邮件地址换成自己的邮件地址，然后一路回车；</li><li>最后完成后，会在用户主目录下生成.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH key密钥对，id_rsa是私钥，千万不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人；</li><li>登陆GitHub，打开「Settings」-&gt;「SSH and GPG keys」，然后点击「new SSH key」，填上任意Title，在Key文本框里粘贴公钥id_rsa.pub文件的内容（千万不要粘贴成私钥了！），最后点击「Add SSH Key」，你就应该看到已经添加的Key。 </li><li>注意：不要在git版本库中运行ssh，然后又将它提交，这样就把密码泄露出去了</li></ol><h1 id="2-安装Node-js"><a href="#2-安装Node-js" class="headerlink" title="2 安装Node.js"></a>2 安装Node.js</h1><ol><li>Hexo基于Node.js，Node.js下载地址：<a href="https://link.zhihu.com/?target=https%3A//nodejs.org/en/download/" target="_blank" rel="noopener">Download | Node.js</a> 下载安装包，注意安装Node.js会包含环境变量及npm的安装，安装后，检测Node.js是否安装成功，在命令行中输入 <code>node -v</code>；</li><li>检测npm是否安装成功，在命令行中输入<code>npm -v</code></li></ol><h1 id="3-安装Hexo"><a href="#3-安装Hexo" class="headerlink" title="3 安装Hexo"></a>3 安装Hexo</h1><p>新建文件夹，在此文件夹内使用npm命令全局安装Hexo，输入：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>输入<code>hexo -v</code>检查是否安装成功。</p><blockquote><p>npm加速：</p><ol><li><p>装cnpm</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;    npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ol></blockquote><p>&gt;</p><blockquote><ol><li><p>使用cnpm</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;    cnpm install xxx</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ol></blockquote><p>&gt;</p><blockquote><p>参考：<a href="https://cloud.tencent.com/developer/article/1372949" target="_blank" rel="noopener">npm使用国内镜像加速的几种方法</a></p></blockquote><h1 id="4-复制原电脑上的数据"><a href="#4-复制原电脑上的数据" class="headerlink" title="4 复制原电脑上的数据"></a>4 复制原电脑上的数据</h1><h2 id="4-1-需要复制的"><a href="#4-1-需要复制的" class="headerlink" title="4.1 需要复制的"></a>4.1 需要复制的</h2><ul><li>_config.yml：站点配置</li><li>package.json：说明使用那些包</li><li>scaffolds：文章的模板</li><li>source：自己写的博客文件</li><li>themes：主题</li><li>.gitignore：限定在提交的时候哪些文件可以忽略</li></ul><h2 id="4-2-需要删除的"><a href="#4-2-需要删除的" class="headerlink" title="4.2 需要删除的"></a>4.2 需要删除的</h2><ul><li>.git：无论是在站点根目录下，还是主题目录下的.git文件，都可以删掉。</li><li>node_modules：在用<code>npm install</code>会重新生成</li><li>public：<code>hexo g</code>会重新生成</li><li>.deploy_git：在使用hexo d时也会重新生成</li><li>db.json文件</li></ul><p>其实上面这些文件也就是.gitignore文件里面记载的可以忽略的内容。</p><h1 id="5-npm-install"><a href="#5-npm-install" class="headerlink" title="5 npm install"></a>5 npm install</h1><p>在git bash中切换目录到新拷贝的文件夹里，使用<code>npm install</code> 命令，进行模块安装。很明显我们这里<font color="red">没用hexo init初始化</font>，因为有的文件我们已经拷贝生成过来了，所以不必用hexo init去整体初始化，如果不慎在此时用了hexo init，则站点的配置文件_config.yml里面内容会被清空使用默认值，所以这一步一定要慎重，不要用hexo init。</p><h1 id="6-安装其他必要组件"><a href="#6-安装其他必要组件" class="headerlink" title="6 安装其他必要组件"></a>6 安装其他必要组件</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save <span class="comment"># 为了使用hexo d来部署到git上 </span></span><br><span class="line">npm install hexo-generator-feed --save <span class="comment"># 为了建立RSS订阅</span></span><br><span class="line">npm install hexo-generator-sitemap --save <span class="comment"># 为了建立站点地图</span></span><br></pre></td></tr></table></figure><p>插件安装后，有的需要对配置文件_config.yml进行配置，具体怎么配置，可以参考上面插件在github主页上的具体说明</p><h1 id="7-验证"><a href="#7-验证" class="headerlink" title="7 验证"></a>7 验证</h1><p>首先本地执行，在博客根目录下执行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>此时可访问浏览器：<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> ，查看是否转移成功。</p><p>接下来验证部署，执行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><p>在线访问出错，无法访问。开始排查：</p><ol><li><p>.deploy_git文件夹内的文件大小均为0kb，也就是生成了一些空文件；</p></li><li><font color="pink">public文件夹内的文件大小均为0kb，但是本地可以正常访问，不知道为啥</font></li><li><p>其实在执行<code>hexo s</code>时，后台存在报错</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">INFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</span><br><span class="line">(node:23336) Warning: Accessing non-existent property <span class="string">'lineno'</span> of module exports inside circular dependency</span><br><span class="line">(Use `node --trace-warnings ...` to show <span class="built_in">where</span> the warning was created)</span><br><span class="line">(node:23336) Warning: Accessing non-existent property <span class="string">'column'</span> of module exports inside circular dependency</span><br><span class="line">(node:23336) Warning: Accessing non-existent property <span class="string">'filename'</span> of module exports inside circular dependency</span><br><span class="line">(node:23336) Warning: Accessing non-existent property <span class="string">'lineno'</span> of module exports inside circular dependency</span><br><span class="line">(node:23336) Warning: Accessing non-existent property <span class="string">'column'</span> of module exports inside circular dependency</span><br><span class="line">(node:23336) Warning: Accessing non-existent property <span class="string">'filename'</span> of module exports inside circular dependency</span><br></pre></td></tr></table></figure><p>解决方法：Node版本太高，切换一个低版本Node可以（我这里是14.17.6切换成12.5.0就没有这个问题了）</p></li><li><p>问题已解决，可以在线访问博客了。</p></li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/26625249" target="_blank" rel="noopener">GitHub+Hexo 搭建个人网站详细教程</a></li><li><a href="https://www.zhihu.com/question/21193762" target="_blank" rel="noopener">使用hexo，如果换了电脑怎么更新博客？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 未定义 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TopK问题</title>
      <link href="/2021/07/24/TopK%E9%97%AE%E9%A2%98/"/>
      <url>/2021/07/24/TopK%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。</p><p>请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><blockquote><p>参考：<a href="https://zhuanlan.zhihu.com/p/76734219" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/76734219</a></p></blockquote><h2 id="思路1-排序"><a href="#思路1-排序" class="headerlink" title="思路1 排序"></a>思路1 排序</h2><p>将n个数排序之后，取出第k大的数即可。</p><p>时间复杂度：$O(n*log(n))$</p><p>分析：明明只需要TopK，却将全局都排序了，这也是这个方法复杂度非常高的原因。那能不能不全局排序，而只局部排序呢？</p><h2 id="思路2-局部排序"><a href="#思路2-局部排序" class="headerlink" title="思路2 局部排序"></a>思路2 局部排序</h2><p>不再全局排序，只对最大的k个排序。冒泡是一个很常见的排序方法，每冒一个泡，找出最大值，冒k个泡，就得到TopK。</p><p>时间复杂度：$O(n*k)$</p><p>分析：冒泡，将全局排序优化为了局部排序，非TopK的元素是不需要排序的，节省了计算资源。不少朋友会想到，需求是TopK，是不是这最大的k个元素也不需要排序呢？</p><h2 id="思路3-堆"><a href="#思路3-堆" class="headerlink" title="* 思路3 堆"></a>* 思路3 堆</h2><p>思路：只找到TopK，不排序TopK。先用前k个元素生成一个小顶堆，这个小顶堆用于存储，当前最大的k个元素。接着，从第k+1个元素开始扫描，和堆顶（堆中最小的元素）比较，如果被扫描的元素大于堆顶，则替换堆顶的元素，并调整堆，以保证堆内的k个元素，总是当前最大的k个元素。直到，扫描完所有n-k个元素，最终堆中的k个元素，就是TopK。</p><p>时间复杂度：$O(n*log(k))$</p><p>画外音：n个元素扫一遍，假设运气很差，每次都入堆调整，调整时间复杂度为堆的高度，即$lg(k)$，故整体时间复杂度是$n*lg(k)$。</p><p>分析：堆，将冒泡的TopK排序优化为了TopK不排序，节省了计算资源。堆，是求TopK的经典算法，那还有没有更快的方案呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="思路4-Partition"><a href="#思路4-Partition" class="headerlink" title="思路4 Partition"></a>思路4 Partition</h2><p>除了用来进行快速排序，partition 还可以用 $O(N)$ 的平均时间复杂度解决TopK问题。和快排一样，这里也用到了分而治之的思想。首先用 partition 将数组分为两部分，得到分界点下标 pos，然后分三种情况：</p><ul><li>pos == k-1，则找到第 K 大的值，arr[pos]；</li><li>pos &gt; k-1，则第 K 大的值在左边部分的数组。</li><li>pos &lt; k-1，则第 K 大的值在右边部分的数组。</li></ul><p>下面给出基于迭代的实现（这里寻找第 k 小的数字）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[low];</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">while</span> (low &lt; high &amp;&amp; nums[high] &lt;= pivot) high--;</span><br><span class="line">            nums[low] = nums[high];</span><br><span class="line">            <span class="keyword">while</span> (low &lt; high &amp;&amp; nums[low] &gt;= pivot) low++;</span><br><span class="line">            nums[high] = nums[low];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[low] = pivot;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>, end = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (begin &lt; end) &#123;</span><br><span class="line">            <span class="keyword">int</span> pos = partition(nums, begin, end);</span><br><span class="line">            <span class="keyword">if</span> (pos == k - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[pos];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pos &lt; k - <span class="number">1</span>) &#123;</span><br><span class="line">                begin = pos + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                end = pos - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[begin];<span class="comment">//数组长度为1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：考虑最坏情况下，每次 partition 将数组分为长度为 $N-1$ 和 $1$ 的两部分，然后在长的一边继续寻找第 K 大，此时时间复杂度为 $O(N^2 )$。不过如果在开始之前将数组进行随机打乱，那么可以尽量避免最坏情况的出现（随机选择算在是《算法导论》中一个经典的算法，其时间复杂度为O(n)，是一个线性复杂度的方法。）。而在最好情况下，每次将数组均分为长度相同的两半，运行时间 $T(N) = N + T(N/2)$，时间复杂度是 $O(N)$。</p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><ol><li><a href="https://leetcode-cn.com/problems/smallest-k-lcci/" target="_blank" rel="noopener">leetcode——面试题 17.14. 最小K个数</a></li><li></li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试篇 </category>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="/2021/07/23/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2021/07/23/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-最大子序和"><a href="#1-最大子序和" class="headerlink" title="1 最大子序和"></a>1 最大子序和</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>链接：<a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-subarray/</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li><strong>状态</strong>：$dp[i]$ 代表以$nums[i]$结尾的最大和</li><li><strong>状态转移方程</strong>：$dp[i] = max(dp[i-1]+nums[i], nums[i])$</li><li><strong>答案</strong>：$max(dp[0…n-1])$</li></ol><ul><li><strong>时间复杂度</strong>：循环执行 n 次，每次花费常数的时间代价，故渐进时间复杂度为 $O(n)$。</li><li><strong>空间复杂度</strong>：$O(n)$，可用滚动数组优化到$O(1)$。</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> pre = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> ans = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            pre = max(nums[i], pre + nums[i]);</span><br><span class="line">            ans = max(ans, pre);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="2-最长上升子序列"><a href="#2-最长上升子序列" class="headerlink" title="2 最长上升子序列"></a>2 最长上升子序列</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><p>链接：<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-increasing-subsequence/</a></p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><ol><li><strong>状态</strong>：$dp[i]$ 代表以$nums[i]$结尾的最长严格递增子序列的长度</li><li><strong>状态转移方程</strong>：$dp[i] = max(dp[j]+1,dp[i])$，$j<i$且$nums[i]>nums[j]$</i$且$nums[i]></li><li><strong>答案</strong>：$max(dp[0…n-1])$</li></ol><ul><li><strong>时间复杂度</strong>： $O(n^2)$</li><li><strong>空间复杂度</strong>： $O(n)$</li></ul><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> dp[n];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                    dp[i] = max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *max_element(dp, dp + n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双指针</title>
      <link href="/2021/07/22/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
      <url>/2021/07/22/%E5%8F%8C%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-无重复字符的最长子串"><a href="#1-无重复字符的最长子串" class="headerlink" title="1 无重复字符的最长子串"></a>1 无重复字符的最长子串</h1><p>题目来源：<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">leetcode-3 无重复字符的最长子串</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先区分子串与子序列：子串必须连续，子序列可以不连续。</p><p>两层循环$O(n^2)$不太行，减少重复查询，可以用<strong>双指针</strong>维护一个<strong>滑动窗口</strong>，同时用一个数组标记滑动窗口内出现的字符。</p><ul><li><strong>时间复杂度</strong>：$O(N)$，其中 $N$ 是字符串的长度。左指针和右指针分别会遍历整个字符串一次。</li><li><strong>空间复杂度</strong>：$O(|\Sigma|)$，其中 $\Sigma$ 表示字符集（即字符串中可以出现的字符），$|\Sigma|$ 表示字符集的大小。在本题中没有明确说明字符集，因此可以默认为所有 ASCII 码在 $[0, 128)$ 内的字符，即 $|\Sigma| = 128$。</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">128</span>;<span class="comment">//字符范围</span></span><br><span class="line">        <span class="keyword">int</span> foot[maxn] = &#123;<span class="number">0</span>&#125;;<span class="comment">//标记滑动窗口中已经有的字符</span></span><br><span class="line">        <span class="keyword">int</span> len = s.size();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;<span class="comment">//空串</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;<span class="comment">//双指针维护窗口</span></span><br><span class="line">        foot[s[start]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; len - <span class="number">1</span>) &#123;</span><br><span class="line">            end++;<span class="comment">//后面的指针前进</span></span><br><span class="line">            <span class="keyword">while</span> (end &lt; len) &#123;</span><br><span class="line">                <span class="keyword">if</span> (foot[s[end]] == <span class="number">0</span>) &#123;</span><br><span class="line">                    foot[s[end]] = <span class="number">1</span>;</span><br><span class="line">                    end++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            end--;<span class="comment">//后面的指针回退</span></span><br><span class="line">            ans = max(ans, end - start + <span class="number">1</span>);</span><br><span class="line">            foot[s[start]] = <span class="number">0</span>;<span class="comment">//前面的指针前移</span></span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><ol><li><a href></a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>STL</title>
      <link href="/2021/07/22/STL/"/>
      <url>/2021/07/22/STL/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-vector-向量"><a href="#1-vector-向量" class="headerlink" title="1 vector(向量)"></a>1 vector(向量)</h1><p>vector是与数组相关的序列式容器，set模版类的定义在头文件\<vector\>中。当我们在程序中需要使用动态数组时， vector将会是理想的选择， vector可以在使用过程中动态地增长存储空间。</vector\></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; s;<span class="comment">// 定义⼀个空的vector对象，存储的是int类型的元素</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">s</span><span class="params">(n)</span></span>;<span class="comment">// 定义⼀个含有n个int元素的vector对象</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">s</span><span class="params">(first, last)</span></span>;<span class="comment">// 从由迭代器first和last定义的序列[first, last)中复制初值初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本操作</span></span><br><span class="line">s[i] <span class="comment">// 直接以下标⽅式访问容器中的元素，编号从0开始</span></span><br><span class="line">s.front() <span class="comment">// 返回⾸元素</span></span><br><span class="line">s.back() <span class="comment">// 返回尾元素</span></span><br><span class="line">s.push_back(x) <span class="comment">// 向表尾插⼊元素x</span></span><br><span class="line">s.pop_back() <span class="comment">// 删除表尾元素</span></span><br><span class="line">s.size() <span class="comment">// 返回表⻓</span></span><br><span class="line">s.empty() <span class="comment">// 表为空时，返回真，否则返回假</span></span><br><span class="line">s.begin() <span class="comment">// 返回指向⾸元素的随机存取迭代器</span></span><br><span class="line">s.end() <span class="comment">// 返回指向尾元素的下⼀个位置的随机存取迭代器</span></span><br><span class="line">s.insert(it, val) <span class="comment">// 向迭代器it指向的元素前插⼊新元素val</span></span><br><span class="line">s.insert(it, n, val) <span class="comment">// 向迭代器it指向的元素前插⼊n个新元素val</span></span><br><span class="line">s.insert(it, first, last)<span class="comment">// 向迭代器it指向的元素前插⼊迭代器first和last所指定的序列[first, last)</span></span><br><span class="line">s.erase(it) <span class="comment">// 删除由迭代器it所指向的元素</span></span><br><span class="line">s.erase(first, last) <span class="comment">// 删除由迭代器first和last所指定的序列[first, last)</span></span><br><span class="line">s.reserve(n) <span class="comment">// 预分配缓冲空间，使存储空间至少可容纳n个元素</span></span><br><span class="line">s.resize(n) <span class="comment">// 改变序列长度，超出的元素将会全部被删除，需要扩展(原空间小于n)的用元素默认值填满</span></span><br><span class="line">s.resize(n, val) <span class="comment">// 改变序列长度，超出的元素将会全部被删除，需要扩展(原空间小于n)的用元素val填满</span></span><br><span class="line">s.clear() <span class="comment">// 删除容器中的所有元素。resize和clear是对表的有效元素进行的操作，但不⼀定改变缓冲空间的⼤小</span></span><br><span class="line">s.swap(v) <span class="comment">// 将s与另⼀个vector对象进行交换</span></span><br><span class="line">s.assign(first, last)<span class="comment">// 将序列替换成由迭代器指示的[first, last)，不能是原序列中的⼀部分</span></span><br><span class="line"><span class="keyword">operator</span>: &gt; &lt; &gt;= &lt;= == != <span class="comment">//按照字典序⽐较两个序列</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 组合操作</span></span><br><span class="line">s.insert(s.begin(), x) <span class="comment">// 向表头插⼊元素x</span></span><br><span class="line">s.erase(s.begin()) <span class="comment">// 删除表头元素</span></span><br><span class="line">reverse(s.begin(), s.end()) <span class="comment">// 反转向量</span></span><br><span class="line">sort(s.begin(), s.end()) <span class="comment">// 排序</span></span><br></pre></td></tr></table></figure><h1 id="2-pair-二元组"><a href="#2-pair-二元组" class="headerlink" title="2 pair(二元组)"></a>2 pair(二元组)</h1><p>pair用来表示一个二元组或元素对，定义在头文件\<utility\>中。pair模版类需要两个参数：首元素的数据类型和尾元素的数据类型。 pair模版类对象有两个成员： first和second，分别表示首元素和尾元素。  </utility\></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line">pair&lt;<span class="keyword">double</span>, <span class="keyword">double</span>&gt; p;</span><br><span class="line">p = make_pair(<span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本操作</span></span><br><span class="line"><span class="keyword">operator</span>: &lt; &gt; &lt;= &gt;= == != <span class="comment">// 其规则是先⽐较first， first相等时再比较second，这符合⼤多数应⽤的逻辑</span></span><br></pre></td></tr></table></figure><h1 id="3-set-集合"><a href="#3-set-集合" class="headerlink" title="3 set(集合)"></a>3 set(集合)</h1><p>set是与集合相关的关联式容器，set模版类的定义在头文件\<set\>中。在set中每个元素的值都唯一，而且系统能根据元素的值自动进行排序(默认升序)。set中元素的值不能直接被改变。</set\></p><p>标准库提供set关联容器分为：</p><ol><li>按关键字有序保存元素：set(关键字即值，即只保存关键字的容器)；multiset(关键字可重复出现的set)；</li><li>无序集合：unordered_set(用哈希函数组织的set)；unordered_multiset(哈希组织的set，关键字可以重复出现)。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="built_in">set</span>&lt;T&gt; s;</span><br><span class="line"><span class="built_in">set</span>&lt;T&gt;::iterator it;<span class="comment">//迭代器</span></span><br><span class="line"><span class="keyword">int</span> arr[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="function"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ss</span><span class="params">(arr, arr+<span class="number">4</span>)</span></span>;<span class="comment">//数组初始化</span></span><br><span class="line"><span class="function"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ss</span><span class="params">(s)</span></span>;<span class="comment">//集合初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本操作</span></span><br><span class="line">s.begin() <span class="comment">// 返回指向第⼀个元素的迭代器，如果set为空则返回的迭代器不能解引用</span></span><br><span class="line">s.clear() <span class="comment">// 清除所有元素</span></span><br><span class="line">s.count(T) <span class="comment">// 返回某个元素的个数，多重集合也是返回个数</span></span><br><span class="line">s.empty() <span class="comment">// 如果集合为空，返回true(真）</span></span><br><span class="line">s.end() <span class="comment">// 返回指向最后⼀个元素之后的迭代器，不是最后⼀个元素</span></span><br><span class="line">s.equal_range(T) <span class="comment">// 返回集合中与给定值相等的上下限的两个迭代器(pair)</span></span><br><span class="line">s.erase(T) <span class="comment">// 删除迭代器指定位置的元素或与对象匹配的元素</span></span><br><span class="line">s.find(T) <span class="comment">// 返回⼀个指向被查找到元素的迭代器</span></span><br><span class="line">s.get_allocator() <span class="comment">// 返回集合的分配器</span></span><br><span class="line">s.insert(T) <span class="comment">// 在集合中插⼊元素</span></span><br><span class="line">s.lower_bound(T) <span class="comment">// 返回指向⼤于（或等于）某值的第⼀个元素的迭代器</span></span><br><span class="line">s.key_comp() <span class="comment">// 返回⼀个⽤于元素间值⽐较的函数，默认operator&lt;</span></span><br><span class="line">s.max_size() <span class="comment">// 返回集合能容纳的元素的最⼤限值</span></span><br><span class="line">s.rbegin() <span class="comment">// 返回指向集合中最后⼀个元素的反向迭代器</span></span><br><span class="line">s.rend() <span class="comment">// 返回指向集合中第⼀个元素的反向迭代器</span></span><br><span class="line">s.size() <span class="comment">// 集合中元素的数⽬</span></span><br><span class="line">s.swap(<span class="built_in">set</span>&lt;T&gt;) <span class="comment">// 交换两个集合变量</span></span><br><span class="line">s.upper_bound(T) <span class="comment">// 返回⼤于某个值元素的迭代器</span></span><br><span class="line">s.value_comp() <span class="comment">// 返回⼀个⽤于⽐较元素间的值的函数</span></span><br><span class="line"><span class="comment">//遍历输出</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> ptr = s.begin(); ptr != s.end(); ptr++) &#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; *ptr&lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 修改排序</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; u, <span class="keyword">const</span> <span class="keyword">int</span>&amp; v)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(u - v) &lt;= k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> u &lt; v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>, cmp&gt; se;</span><br></pre></td></tr></table></figure><h1 id="4-string-字符串"><a href="#4-string-字符串" class="headerlink" title="4 string(字符串)"></a>4 string(字符串)</h1><p>string类的定义在头文件$<string>$中。string类其实可以看作是一个字符的vector， vector上的各种操作都可以适用于string，另外，string类对象还支持字符串的拼合、转换等操作。  </string></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本操作</span></span><br><span class="line"><span class="keyword">operator</span> + <span class="comment">// 拼合</span></span><br><span class="line"><span class="comment">//string转char指针</span></span><br><span class="line"><span class="keyword">char</span> *p=(<span class="keyword">char</span>*)str.c_str();</span><br><span class="line"><span class="keyword">char</span>*p=(<span class="keyword">char</span>*)str.data();</span><br><span class="line"><span class="comment">// 关于输入</span></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt; str;<span class="comment">//接受空、回车格结尾的字符串</span></span><br><span class="line"><span class="built_in">cin</span>.ignore();<span class="comment">//配合使用，清除以回车结束的输入缓冲区的内容 </span></span><br><span class="line">getline(<span class="built_in">cin</span>, str);<span class="comment">//读取一行</span></span><br><span class="line"><span class="comment">//字串型的串流，用于按空格间隔的字串分割</span></span><br><span class="line"><span class="built_in">stringstream</span> ss;</span><br><span class="line">ss&lt;&lt; str;<span class="comment">//输入str到ss(屏幕)，看方向</span></span><br><span class="line">ss&gt;&gt; str;<span class="comment">//ss(屏幕)输入到str</span></span><br><span class="line"><span class="comment">//@brief: 指定单个分隔符（单个字符或子串）分割字符串</span></span><br><span class="line"><span class="comment">//@param: src 原字符串；delimiter 分隔符，单个字符或子串</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">splitStr</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; src, <span class="keyword">const</span> <span class="built_in">string</span>&amp; delimiter)</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vetStr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入参检查</span></span><br><span class="line"><span class="comment">// 1.原字符串为空或等于分隔符，返回空 vector</span></span><br><span class="line"><span class="keyword">if</span> (src == <span class="string">""</span> || src == delimiter) &#123;</span><br><span class="line"><span class="keyword">return</span> vetStr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2.分隔符为空返回单个元素为原字符串的 vector</span></span><br><span class="line"><span class="keyword">if</span> (delimiter == <span class="string">""</span>) &#123;</span><br><span class="line">vetStr.push_back(src);</span><br><span class="line"><span class="keyword">return</span> vetStr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span>::size_type startPos = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> index = src.find(delimiter);</span><br><span class="line"><span class="keyword">while</span> (index != <span class="built_in">string</span>::npos) &#123;</span><br><span class="line"><span class="keyword">auto</span> str = src.substr(startPos, index - startPos);</span><br><span class="line"><span class="keyword">if</span> (str != <span class="string">""</span>) &#123;</span><br><span class="line">vetStr.push_back(str);</span><br><span class="line">&#125;</span><br><span class="line">startPos = index + delimiter.length();</span><br><span class="line">index = src.find(delimiter, startPos);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 取最后一个子串</span></span><br><span class="line"><span class="keyword">auto</span> str = src.substr(startPos);</span><br><span class="line"><span class="keyword">if</span> (str != <span class="string">""</span>) &#123;</span><br><span class="line">vetStr.push_back(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> vetStr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//char字符处理</span></span><br><span class="line"><span class="built_in">isalpha</span>(ch);<span class="comment">//字母（不区分大小写）</span></span><br><span class="line"><span class="built_in">isupper</span>(ch);<span class="comment">//大写字母</span></span><br><span class="line"><span class="built_in">islower</span>();<span class="comment">//小写字母</span></span><br><span class="line"><span class="built_in">isdigit</span>();<span class="comment">//数字</span></span><br><span class="line"><span class="built_in">isalnum</span>();<span class="comment">//字母或数字</span></span><br><span class="line"><span class="built_in">toupper</span>();<span class="comment">//转大写</span></span><br><span class="line"><span class="built_in">tolower</span>();<span class="comment">//转小写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//string转int等类型</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stoi</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;  str, <span class="keyword">size_t</span>* idx = <span class="number">0</span>, <span class="keyword">int</span> base = <span class="number">10</span>)</span></span>;<span class="comment">//*idx是指向size_t类型对象的指针，其值由函数设置为数值后str中下一个字符的位置；base是指str的基数，默认十进制</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">stol</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;  str, <span class="keyword">size_t</span>* idx = <span class="number">0</span>, <span class="keyword">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">stoul</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;  str, <span class="keyword">size_t</span>* idx = <span class="number">0</span>, <span class="keyword">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">stoll</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;  str, <span class="keyword">size_t</span>* idx = <span class="number">0</span>, <span class="keyword">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">stoull</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;  str, <span class="keyword">size_t</span>* idx = <span class="number">0</span>, <span class="keyword">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">stof</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;  str, <span class="keyword">size_t</span>* idx = <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">stod</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;  str, <span class="keyword">size_t</span>* idx = <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">double</span> <span class="title">stold</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;  str, <span class="keyword">size_t</span>* idx = <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//int等类型转string</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span> <span class="params">(T)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//find函数</span></span><br><span class="line">str.find(tmp_str);<span class="comment">//返回下标位置，没有则返回str.npos</span></span><br><span class="line">str.find_first_of(tmp_str);<span class="comment">//第一次出现的位置</span></span><br><span class="line">str.find_last_of(tmp_str);<span class="comment">//最后一次出现的位置</span></span><br><span class="line">str.find(tmp_str, pos);<span class="comment">//从下标pos开始查找</span></span><br><span class="line">str.rfind(tmp_str);<span class="comment">//反向查找，与正向查找结合确定子串的唯一性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//取子串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">substr</span> <span class="params">(<span class="keyword">size_t</span> pos = <span class="number">0</span>, <span class="keyword">size_t</span> len = npos)</span> <span class="keyword">const</span></span>;<span class="comment">//在字符位置pos开始，跨越len个字符（或直到字符串的结尾，以先到者为准）对象的部分</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串大小写转化</span></span><br><span class="line">transform(s.begin(),s.end(),s.begin(),::<span class="built_in">tolower</span>);</span><br><span class="line">transform(s.begin(),s.end(),s.begin(),::<span class="built_in">toupper</span>);</span><br></pre></td></tr></table></figure><h1 id="5-list-列表"><a href="#5-list-列表" class="headerlink" title="5 list(列表)"></a>5 list(列表)</h1><p>list是由双向链表实现的，因此内存空间是不连续的。只能通过指针访问数据，所以list的随机存取非常没有效率，时间复杂度为$O(n)$；但由于链表的特点，能高效地进行插入和删除。</p><p>使用：</p><ul><li>需要高效的随机存取，而不在乎插入和删除的效率，使用vector;</li><li>如果需要大量的插入和删除，而不关心随机存取，则应使用list</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; l;<span class="comment">//声明一个空列表</span></span><br><span class="line"><span class="function"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">l</span><span class="params">(n)</span></span>;<span class="comment">//声明一个有n个元素的列表，每个元素都是由其默认构造函数T()构造出来的</span></span><br><span class="line"><span class="function"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">l</span><span class="params">(n,val)</span></span>;<span class="comment">//声明一个由n个元素的列表，每个元素都是由其复制构造函数T(val)得来的</span></span><br><span class="line"><span class="function"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">l</span><span class="params">()</span></span>;<span class="comment">//声明一个空列表</span></span><br><span class="line"><span class="function"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">l</span><span class="params">(first,last)</span></span>;<span class="comment">//声明一个列表，其元素的初始值由区间所指定的序列中的元素;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本操作</span></span><br><span class="line">l.begin() <span class="comment">// 得到一个指向容器起始位置的iterator</span></span><br><span class="line">l.end() <span class="comment">//返回list末端下一位置，如a[n]中的第n+1个位置a[n]，实际是不存在，经常作为循环结束判断条件使用</span></span><br><span class="line">l.push_back(x) <span class="comment">//list的末端插入x</span></span><br><span class="line">l.push_front(x) <span class="comment">// 从list的头部插入x</span></span><br><span class="line">l.empty() <span class="comment">// 利用empty() 判断list是否为空，空返回true</span></span><br><span class="line">l.resize(n) <span class="comment">//将l的长度改为n，超出的元素将被删除，如果需要扩展那么调用默认构造函数T()将元素加到list末端</span></span><br><span class="line">l.resize(n, val)<span class="comment">//扩展元素要调用构造函数T(val)函数进行元素构造，其余部分与resize相同</span></span><br><span class="line">l.clear() <span class="comment">//清空list中的所有元素</span></span><br><span class="line">l.front() <span class="comment">//获得list容器中的头部元素</span></span><br><span class="line">l.back() <span class="comment">//可以获得list容器的最后一个元素</span></span><br><span class="line">l.pop_back <span class="comment">// 删除最后一个元素</span></span><br><span class="line">l.pop_front() <span class="comment">// 删除第一个元素；序列必须不为空，当list为空时调用pop_back和pop_front会使程序崩掉</span></span><br><span class="line">l.assign() <span class="comment">//具体和vector中的操作类似</span></span><br><span class="line">l.swap(ll) <span class="comment">//交换两个链表，swap(l ,ll)也可</span></span><br><span class="line">merge() <span class="comment">//合并两个链表并使之默认升序(也可改)，l1.merge(l2，greater&lt;int&gt;()); 调用结束后l2变为空，l1中元素包含原来l1 和 l2中的元素，并且排好序，升序。其实默认是升序，greater&lt;int&gt;()可以省略，另外greater&lt;int&gt;()是可以变的，也可以不按升序排列。</span></span><br></pre></td></tr></table></figure><h1 id="6-stack-栈"><a href="#6-stack-栈" class="headerlink" title="6 stack(栈)"></a>6 stack(栈)</h1><p>stack模版类的定义在\<stack\>头文件中，stack模版类需要两个模版参数，一个是元素类型，另一个是容器类型，但是只有元素类型是必要的，在不指定容器类型时，默认容器的类型为deque。</stack\></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本操作</span></span><br><span class="line">s.push(x); <span class="comment">// ⼊栈</span></span><br><span class="line">s.pop(); <span class="comment">// 出栈，不返回值</span></span><br><span class="line">x = s.top(); <span class="comment">// 访问栈顶，</span></span><br><span class="line">s.empty(); <span class="comment">// 当栈空时，返回true</span></span><br><span class="line">s.size(); <span class="comment">// 访问栈中元素个数</span></span><br></pre></td></tr></table></figure><h1 id="7-queue-队列"><a href="#7-queue-队列" class="headerlink" title="7 queue(队列)"></a>7 queue(队列)</h1><p>queue模版类的定义在头文件\<queue\>中。queue与stack相似， queue模版类也需要两个模版参数，一个元素类型，一个容器类型，元素类型是必须的，容器类型是可选的。  </queue\></p><p>标准库提供queue分为：</p><ol><li>queue(队列)：queue从队首弹出，先入先出，并且queue只能从队首删除元素，但是两端都能访问。</li><li>deque(双向队列)：可以访问两端并且可以在队首和队尾删除和插入元素</li><li>priority_queue(优先队列)：优先队列与队列的差别在于优先队列不是按照入队的顺序出队，而是按照队列中元素的优先权出队列（默认为大者优先，也可以通过指定算子来指定自己的优先顺序）；priority_queue模版类有三个模版参数，第一个是元素类型，第二个是容器类型，第三个是比较算子。其中后两者都可以忽略，默认容器为vector，默认算子为less，即小的往前排，大的往后排（出队列时列尾元素先出队）。  </li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 队列定义</span></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列基本操作</span></span><br><span class="line">q.push(x); <span class="comment">// 从队尾⼊队列</span></span><br><span class="line">q.pop(); <span class="comment">// 从队首出队列</span></span><br><span class="line">q.front(); <span class="comment">// 访问队首元素</span></span><br><span class="line">q.back(); <span class="comment">// 访问队尾元素</span></span><br><span class="line">q.empty(); <span class="comment">// 如果队列为空，则返回true，否则返回false</span></span><br><span class="line">q.size(); <span class="comment">// 访问队列中的元素个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向队列定义</span></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; dq; <span class="comment">//创建一个int双端队列dq</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向队列基本操作</span></span><br><span class="line">dq.empty(); <span class="comment">//判断队列是否为空，为空返回true</span></span><br><span class="line">dq.push_front(s); <span class="comment">//将s从队头入队</span></span><br><span class="line">dq.push_back(s); <span class="comment">//将s从队尾入队，和普通队列方式一样</span></span><br><span class="line">dq.front(); <span class="comment">//只返回队头元素</span></span><br><span class="line">dq.back(); <span class="comment">//只返回队尾元素</span></span><br><span class="line">dq.pop_front(); <span class="comment">//将队头元素弹出</span></span><br><span class="line">dq.pop_back(); <span class="comment">//将队尾元素弹出</span></span><br><span class="line">dq.clear(); <span class="comment">//将队列清空</span></span><br><span class="line"><span class="comment">//组合操作</span></span><br><span class="line"><span class="comment">//C++中的queue自身是不支持clear操作的，但是双端队列deque是支持clear操作的。</span></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; empty;</span><br><span class="line">swap(empty, q);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优先队列定义</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; qq; <span class="comment">// 注意在两个尖括号之间⼀定要留空格，防止误判</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; qqq; <span class="comment">// 定义小的先出队列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 优先队列基本操作</span></span><br><span class="line">q.empty() <span class="comment">// 如果队列为空，则返回true，否则返回false</span></span><br><span class="line">q.size() <span class="comment">// 返回队列中元素的个数</span></span><br><span class="line">q.pop() <span class="comment">// 删除队首元素，但不返回其值</span></span><br><span class="line">q.top() <span class="comment">// 返回具有最高优先级的元素值，但不删除该元素</span></span><br><span class="line">q.push(x) <span class="comment">// 在基于优先级的适当位置插⼊新元素x</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 算子实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> x, y, z;</span><br><span class="line">T(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c) : x(a), y(b), z(c) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> T &amp;tOne, <span class="keyword">const</span> T &amp;tTwo)&#123;</span><br><span class="line"><span class="keyword">return</span> tOne.z &lt; tTwo.z; <span class="comment">// 按照z的顺序来决定tOne和tTwo的顺序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">priority_queue&lt;T&gt; q;</span><br><span class="line">q.push(T(<span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>));</span><br><span class="line">q.push(T(<span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>));</span><br><span class="line">q.push(T(<span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>));</span><br><span class="line">q.push(T(<span class="number">3</span>, <span class="number">3</span>, <span class="number">6</span>));</span><br><span class="line"><span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">T t = q.top();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; t.x &lt;&lt; <span class="string">" "</span> &lt;&lt; t.y &lt;&lt; <span class="string">" "</span> &lt;&lt; t.z &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8-map-字典"><a href="#8-map-字典" class="headerlink" title="8 map(字典)"></a>8 map(字典)</h1><p>map是与字典相关的关联式容器，map模版类的定义在头文件$<map>$中，用有序二叉树表存储类型为pair<const key, t>的元素对序列。  序列中的元素以const Key部分作为标识， map中所有元素的Key值必须是唯一的，multimap则允许有重复的Key值。unordered_map是无序 map 容器。</const></map></p><p>将map可以通过一个Key值来快速决定一个元素，因此非常适合于需要按照Key值查找元素的容器。map模版类需要四个模版参数，第一个是键值类型，第二个是元素类型，第三个是比较算子，第四个是分配器类型。其中键值类型和元素类型是必要的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字典定义</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字典基本操作</span></span><br><span class="line"><span class="comment">/* 向map中插⼊元素 */</span></span><br><span class="line">m[key] = value; <span class="comment">// [key]操作是map很有特色的操作,如果在map中存在键值为key的元素对, 则返回该元素对的值域部分,否则将会创建⼀个键值为key的元素对,值域为默认值。所以可以⽤该操作向map中插⼊元素对或修改已经存在的元素对的值域部分。</span></span><br><span class="line">m.insert(make_pair(key, value)); <span class="comment">// 也可以直接调用insert方法插⼊元素对,insert操作会返回⼀个pair,当map中没有与key相匹配的键值时,其first是指向插⼊元素对的迭代器,其second为true;若map中已经存在与key相等的键值时,其first是指向该元素对的迭代器,second为false，并且不会更新value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查找元素 */</span></span><br><span class="line"><span class="keyword">int</span> i = m[key]; <span class="comment">// key不存在时,会创建键值为key(当另⼀个元素是整型时m[key]=0)的元素对</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator it = m.find(key); <span class="comment">// 如果map中存在与key相匹配的键值时,find操作将返</span></span><br><span class="line"><span class="comment">//回指向该元素对的迭代器,否则,返回的迭代器等于map的end()(参见vector中提到的begin()和end()操作)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 删除元素 */</span></span><br><span class="line">m.erase(key); <span class="comment">// 删除与指定key键值相匹配的元素对,并返回被删除的元素的个数</span></span><br><span class="line">m.erase(it); <span class="comment">// 删除由迭代器it所指定的元素对,并返回指向下⼀个元素对的迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 其他操作 */</span></span><br><span class="line">m.size(); <span class="comment">// 返回元素个数</span></span><br><span class="line">m.empty(); <span class="comment">// 判断是否为空，空返回true</span></span><br><span class="line">m.clear(); <span class="comment">// 清空所有元素</span></span><br><span class="line"><span class="function">size_type <span class="title">count</span> <span class="params">(<span class="keyword">const</span> key_type&amp; k)</span> <span class="keyword">const</span></span>;<span class="comment">//按key搜索</span></span><br></pre></td></tr></table></figure><h1 id="9-bitset"><a href="#9-bitset" class="headerlink" title="9 bitset()"></a>9 bitset()</h1><p>bitset模版类的定义在\<bitset\>头文件中，用来方便地管理一系列的bit位类。 bitset除了可以访问指定下标的bit位以外，还可以把它们作为一个整数来进行某些统计。bitset模板类需要一个模版参数，用来明确指定含有多少位。  </bitset\></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">32</span>;</span><br><span class="line"><span class="built_in">bitset</span>&lt;MAXN&gt; bt; <span class="comment">// bt 包括 MAXN 位，下标 0 ~ MAXN - 1，默认初始化为 0</span></span><br><span class="line"><span class="function"><span class="built_in">bitset</span>&lt;MAXN&gt; <span class="title">bt1</span><span class="params">(<span class="number">0xf</span>)</span></span>; <span class="comment">// 0xf 表示十六进制数 f，对应二进制 1111，将 bt1 低 4 位初始化为 1</span></span><br><span class="line"><span class="function"><span class="built_in">bitset</span>&lt;MAXN&gt; <span class="title">bt2</span><span class="params">(<span class="number">012</span>)</span></span>; <span class="comment">// 012 表示八进制数 12，对应二进制 1010，即将 bt2 低 4 位初始化为 1010</span></span><br><span class="line"><span class="function"><span class="built_in">bitset</span>&lt;MAXN&gt; <span class="title">bt3</span><span class="params">(<span class="string">"1010"</span>)</span></span>; <span class="comment">// 将 bt3 低 4 位初始化为 1010</span></span><br><span class="line"><span class="function"><span class="built_in">bitset</span>&lt;MAXN&gt; <span class="title">bt4</span><span class="params">(s, pos, n)</span></span>; <span class="comment">// 将 01 字符串 s 的 pos 位开始的 n 位初始化 bt4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本操作</span></span><br><span class="line">bt.any() <span class="comment">// bt 中是否存在置为 1 的二进制位</span></span><br><span class="line">bt.none() <span class="comment">// bt 中不存在置为 1 的二进制位</span></span><br><span class="line">bt.count() <span class="comment">// bt 中置为 1 的二进制位的个数</span></span><br><span class="line">bt.size() <span class="comment">// bt 中二进制位的个数</span></span><br><span class="line">bt[pos] <span class="comment">// 访问 bt 中在 pos 处的二进制位</span></span><br><span class="line">bt.test(pos) <span class="comment">// bt 中在 pos 处的二进制位是否为 1</span></span><br><span class="line">bt.<span class="built_in">set</span>() <span class="comment">// 把 bt 中所有二进制位都置为 1</span></span><br><span class="line">bt.<span class="built_in">set</span>(pos) <span class="comment">// 把 bt 中在 pos 处的二进制位置为 1</span></span><br><span class="line">bt.reset() <span class="comment">// 把 bt 中所有二进制位都置为 0</span></span><br><span class="line">bt.reset(pos) <span class="comment">// 把 bt 中在pos处的二进制位置为0</span></span><br><span class="line">bt.flip() <span class="comment">// 把 bt 中所有二进制位逐位取反</span></span><br><span class="line">bt.flip(pos) <span class="comment">// 把 bt 中在 pos 处的二进制位取反</span></span><br><span class="line">bt[pos].flip() <span class="comment">// 同上</span></span><br><span class="line">bt.to_ulong() <span class="comment">// ⽤用 bt 中同样的二进制位返回⼀个 unsigned long 值</span></span><br><span class="line">bt.to_string()<span class="comment">//转字符串</span></span><br><span class="line">os &lt;&lt; bt <span class="comment">// 把 bt 中的位集输出到 os 流</span></span><br></pre></td></tr></table></figure><h1 id="10-iterator-迭代器"><a href="#10-iterator-迭代器" class="headerlink" title="10 iterator(迭代器)"></a>10 iterator(迭代器)</h1><p>iterator（迭代器）是用于访问容器中元素的指示器，从这个意义上说， iterator（迭代器）相当于数据结构中所说的“遍历指针”，也可以把iterator（迭代器）看作是一种泛化的指针。每种STL容器都有自己的iterator（迭代器）子类。</p><h1 id="11-algorithm"><a href="#11-algorithm" class="headerlink" title="11 algorithm"></a>11 algorithm</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">max_element(v.begin(),v.end()); <span class="comment">//返回容器最大值的迭代器</span></span><br><span class="line">min_element(v.begin(),v.end()); <span class="comment">//返回容器最小值的迭代器</span></span><br><span class="line">sort(v.begin(), v.end(), cmp); <span class="comment">//cmp可以自定义，默认升序排序</span></span><br><span class="line">reverse(v.begin(), v.end()); <span class="comment">//反转容器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">memset</span> <span class="params">( <span class="keyword">void</span> * ptr, <span class="keyword">int</span> value, <span class="keyword">size_t</span> num )</span></span>;<span class="comment">//将ptr所指向的某一块内存中的前num个字节的内容全部设置为ch指定的ASCII值， 第一个值为指定的内存地址，块的大小由第三个参数指定，这个函数通常为新申请的内存做初始化工作， 其返回值为指向s的指针，它是对较大的结构体或数组进行清零操作的一种最快方法。</span></span><br><span class="line">fill(begin, last, val);<span class="comment">//将[begin, last)赋值为val</span></span><br><span class="line"><span class="built_in">memcpy</span>(target, source, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*k);<span class="comment">//复制source数组的前k个到target</span></span><br><span class="line"><span class="built_in">memcpy</span>(target, source, <span class="keyword">sizeof</span>(source));<span class="comment">//复制source数组到target</span></span><br><span class="line">lower_bound(a, a+n, x);<span class="comment">//查找&gt;=x的第一个位置</span></span><br><span class="line">__gcd(<span class="keyword">int</span> x, <span class="keyword">int</span> y)<span class="comment">//求x与y的最大公约数</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>哈希表</title>
      <link href="/2021/07/22/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
      <url>/2021/07/22/%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p>散列表（Hash Table），又称哈希表。是一种数据结构，特点是：数据元素的关键字与其存储地址直接相关，通过“散列函数（哈希函数）”：$Addr=H(key)$。</p><p>若不同的关键字通过散列函数映射到同一个值，则称它们为“同义词”</p><p>通过散列函数确定的位置已经存放了其他元素，则称这种情况为“冲突”</p><h1 id="常见的散列函数"><a href="#常见的散列函数" class="headerlink" title="常见的散列函数"></a>常见的散列函数</h1><ol><li>除留余数法——$H(key)=key\%p$，散列表表长为$m$，取一个不大于$m$但最接近或等于$m$的质数$p$</li><li>直接定址法——$H(key)=key$ 或$H(key)=a*key +b$，其中，a和b是常数。这种方法计算最简单，且不会产生冲突。它适合关键字的分布基本连续的情况，若关键字分布不连续，空位较多，则会造成存储空间的浪费。</li><li>数字分析法——选取数码分布较为均匀的若干位作为散列地址，如手机号码。</li><li>平方取中法——取关键字的平方值的中间几位作为散列地址。具体取多少位要视实际情况而定。这种方法得到的散列地址与关键字的每位都有关系，因此使得散列地址分布比较均匀，适用于关键字的每位取值都不够均匀或均小于散列地址所需的位数。如身份证号。</li></ol><h1 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h1><ol><li>拉链法：把所有“同义词”存储在一个链表中，Java中的HashMap、HashSet</li><li>开放定址法：可存放新表项的空闲地址既向它的同义词表项开放，又向它的非同义词表项开放。其数学递推公式为：$H<em>{i}=\left(H(k e y)+d</em>{i}\right) \% m$，$i=0,1,2, \ldots, k \quad(k \leqslant m-1)$，其中$m$表示散列表表长；$d_i$为增量序列；$i$可理解为“第$i$次发生冲突”<ul><li>线性探测法：$d_{i}=0,1,2,3, \ldots, m-1$; 即发生冲突时，每次往后探测相邻的下一个单元是否为空<ul><li>线性探测法很容易造成同义词、非同义词的“聚集（堆积）”现象，严重影响查找效率</li><li>产生原因——冲突后再探测一定是放在某个连续的位置</li></ul></li><li>平方探测法：当 $\mathrm{d}_{\mathrm{i}}=\mathbf{0}^{2}, \mathbf{1}^{2},-\mathbf{1}^{2}, \mathbf{2}^{2},-\mathbf{2}^{2}, \ldots, \mathbf{k}^{2},-\mathbf{k}^{2}$ 时，称为平方探测法，又称二次探测法其中 $\mathbf{k} \leq \mathbf{m} / \mathbf{2}$<ul><li>比起线性探测法更不易产生“聚集（堆积）”问题</li><li>散列表长度m必须是一个可以表示成$4j+3$的素数，才能探测到所有位置</li></ul></li><li>伪随机序列法：$\mathbf{d}<em>{\mathrm{i}}$ 是一个伪随机序列，如 $\mathrm{d}</em>{\mathrm{i}}=\mathbf{0 , 5 , 2 4 , 1 1 , \ldots}$</li></ul></li><li>再散列法：除了原始的散列函数$H(key)$之外，多准备几个散列函数，当散列函数冲突时，用下一个散列函数计算一个新地址，直到不冲突为止：$\mathrm{H}<em>{\mathrm{i}}=\mathrm{RH}</em>{\mathrm{i}}(\mathrm{Key}) \quad \mathrm{i}=1,2,3 \ldots ., \mathrm{k}$</li></ol><h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><ul><li>无序集合：unordered_set</li><li>无序字典：unordered_map</li></ul><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><ol><li><a href="https://www.luogu.com.cn/problem/P4305" target="_blank" rel="noopener">洛谷——P4305 [JLOI2011]不重复数字</a>：需要加快读</li><li><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">leetcode-1 两数之和 (简单)</a></li><li></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KMP算法</title>
      <link href="/2021/04/10/KMP%E7%AE%97%E6%B3%95/"/>
      <url>/2021/04/10/KMP%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-算法思想"><a href="#1-算法思想" class="headerlink" title="1 算法思想"></a>1 算法思想</h1><h2 id="1-1-思路"><a href="#1-1-思路" class="headerlink" title="1.1 思路"></a>1.1 思路</h2><p><strong>解决问题</strong>：当主串中第 i 个字符与模式中第 j 个字符失配（即比较不相等）时，主串中第 i 个字符（i 指针不回溯）应与模式中哪个字符再比较。</p><ol><li><p>$next[j]$：模式中第 j 个字符失配时，在模式中重新与主串比较的字符位置（最长公共前后缀长度+1，下标从 1 开始）</p><p>$\text { next }[j]=\left{\begin{array}{ll}<br>0 &amp; \text { 当 } j=1 \text { 时 } \<br>\operatorname{Max}\left{k \mid 1&lt;k&lt;j \text { 且 }^{\prime} p<em>{1} \cdots p</em>{k-1}^{\prime}={ }^{\prime} p<em>{j-k+1} \cdots p</em>{j-1}{ }^{\prime}\right} &amp;<br>\text { 当此集合不空时 } \<br>1 &amp; \text { 其他情况 }<br>\end{array}\right.$</p></li><li><p>计算next数组：仅取决于模式串本身而和相匹配的主串无关</p><ul><li>仿照kmp算法，如果$p[j] != p[next[j]]$，那么$next[j+1]$的可能次大值为$next[next[j]] + 1$，依次类推即可高效求出$next[j+1]$</li></ul></li><li><p>若在匹配过程中$s_i=p_j$，则 i 与 j 分别增 1；</p></li><li><p>否则，i 不变，j 退至 next[j] 的位置再比较；若 j 退到值为 0（即模式串的第一个字符失配），则从主串的下一个字符$s_{i+1}$起与模式串重新开始匹配；</p></li><li><p>重复执行step3、step4，直至结束。</p></li></ol><h2 id="1-2-优化"><a href="#1-2-优化" class="headerlink" title="1.2 优化"></a>1.2 优化</h2><p>修正next数组，$next[j]=k$，若模式中$p[j]=p[k]$，则$next[j] = next[k]$</p><h2 id="1-3-算法分析"><a href="#1-3-算法分析" class="headerlink" title="1.3 算法分析"></a>1.3 算法分析</h2><ul><li><strong>时间复杂度</strong>：$O(m+n)$</li><li><strong>空间复杂度</strong>：next数组，$O(m)$</li></ul><h1 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2 代码实现"></a>2 代码实现</h1><h2 id="2-1-C"><a href="#2-1-C" class="headerlink" title="2.1 C++"></a>2.1 C++</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">// string、next数组下标从1开始</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span>;</span><br><span class="line"><span class="keyword">int</span> next2[maxn];</span><br><span class="line"><span class="keyword">int</span> nextval[maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算next数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_next</span><span class="params">(<span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">    next2[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; p.size()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || p[i] == p[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            next2[i] = j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = next2[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算nextval数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_nextval</span><span class="params">(<span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">    nextval[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; p.size()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || p[i] == p[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">if</span> (p[i] != p[j])</span><br><span class="line">                nextval[i] = j;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                nextval[i] = nextval[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            j = nextval[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// KMP算法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//get_next(p);//计算next数组</span></span><br><span class="line">    get_nextval(p);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>;<span class="comment">//主串从第i个字符之后匹配</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; s.size() &amp;&amp; j &lt; p.size()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || s[i] == p[j]) &#123;<span class="comment">//模式串首字符失配或相同继续匹配</span></span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//失配</span></span><br><span class="line">            j = nextval[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &gt;= p.size())<span class="comment">//找到</span></span><br><span class="line">        <span class="keyword">return</span> i - p.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">string</span> s = <span class="string">" acabaabaabcacaabc"</span>, t = <span class="string">" abaabcac"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; kmp(s, t);</span><br><span class="line">    <span class="comment">/*for (int i = 1; i &lt; t.size(); i++) &#123;</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; next2[i] &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-Java"><a href="#2-2-Java" class="headerlink" title="2.2 Java"></a>2.2 Java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KMP</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxn = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[maxn];</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] nextval = <span class="keyword">new</span> <span class="keyword">int</span>[maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">KMP</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算next数组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get_next</span><span class="params">(String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">        next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; p.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span> || p.charAt(i) == p.charAt(j)) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">                next[i] = j;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算nextval数组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">get_nextval</span><span class="params">(String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">        nextval[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; p.length() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span> || p.charAt(i) == p.charAt(j)) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">                <span class="keyword">if</span> (p.charAt(i) != p.charAt(j))</span><br><span class="line">                    nextval[i] = j;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    nextval[i] = nextval[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                j = nextval[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// KMP算法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kmp</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//get_next(p);//计算next数组</span></span><br><span class="line">        get_nextval(p);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>;<span class="comment">//主串从第i个字符之后匹配</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; s.length() &amp;&amp; j &lt; p.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span> || s.charAt(i) == p.charAt(j)) &#123;<span class="comment">//模式串首字符失配或相同继续匹配</span></span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//失配</span></span><br><span class="line">                j = nextval[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= p.length())<span class="comment">//找到</span></span><br><span class="line">            <span class="keyword">return</span> i - p.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO自动生成的方法存根</span></span><br><span class="line">    KMP test = <span class="keyword">new</span> KMP();</span><br><span class="line">        String s = <span class="string">" acabaabaabcacaabc"</span>, t = <span class="string">" abaabcac"</span>;</span><br><span class="line">        System.out.println(test.kmp(s, t));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-参考"><a href="#3-参考" class="headerlink" title="3 参考"></a>3 参考</h1><ul><li><a href="https://www.bilibili.com/video/BV16X4y137qw?from=search&amp;seid=428213560995313343" target="_blank" rel="noopener">KMP算法之求next数组代码讲解</a></li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搜索</title>
      <link href="/2021/04/10/%E6%90%9C%E7%B4%A2/"/>
      <url>/2021/04/10/%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-DFS"><a href="#1-DFS" class="headerlink" title="1 DFS"></a>1 DFS</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(参数)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(满足条件)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> step)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        判断边界</span><br><span class="line">        &#123;</span><br><span class="line">            相应操作</span><br><span class="line">        &#125;</span><br><span class="line">        尝试每一种可能</span><br><span class="line">        &#123;</span><br><span class="line">               满足check条件</span><br><span class="line">               标记</span><br><span class="line">               继续下一步dfs(step+<span class="number">1</span>)</span><br><span class="line">               恢复初始状态（回溯的时候要用到）</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-BFS"><a href="#2-BFS" class="headerlink" title="2 BFS"></a>2 BFS</h1><p>BFS使用队列，把每个还没有搜索到的点一次放入队列，然后再弹出队列的头部元素当做当前遍历点。当不需要确定当前遍历层数时：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>.push(s)<span class="comment">//压入起点，初始队列可能有多个起点</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">queue</span> 不空：</span><br><span class="line">    cur = <span class="built_in">queue</span>.pop()</span><br><span class="line">    <span class="keyword">for</span> 节点 in cur的所有相邻节点：</span><br><span class="line">        <span class="keyword">if</span> 该节点有效且未访问过：</span><br><span class="line">            <span class="built_in">queue</span>.push(该节点)</span><br></pre></td></tr></table></figure><p>当需要确定遍历层数时，这里增加了level表示当前遍历到二叉树中的哪一层了，也可以理解为在一个图中，现在已经走了多少步了。size表示在开始遍历新的一层时，队列中有多少个元素，即有多少个点需要向前走一步。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>.push(s)<span class="comment">//压入起点</span></span><br><span class="line">level = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">queue</span> 不空：</span><br><span class="line">    size = <span class="built_in">queue</span>.size()</span><br><span class="line">    <span class="keyword">while</span> (size --) &#123;</span><br><span class="line">        cur = <span class="built_in">queue</span>.pop()</span><br><span class="line">        <span class="keyword">for</span> 节点 in cur的所有相邻节点：</span><br><span class="line">            <span class="keyword">if</span> 该节点有效且未被访问过：</span><br><span class="line">                <span class="built_in">queue</span>.push(该节点)</span><br><span class="line">    &#125;</span><br><span class="line">    level ++</span><br></pre></td></tr></table></figure><h1 id="3-二分"><a href="#3-二分" class="headerlink" title="3 二分"></a>3 二分</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在[l, h)范围内查找值v(l&gt;=0),返回下标,假设a数组已经按从⼩到⼤排序,失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bs</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> l, <span class="keyword">int</span> h, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="keyword">while</span> (l &lt; h)&#123;</span><br><span class="line">m = (l + h) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (a[m] == v)&#123;</span><br><span class="line"><span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a[m] &lt; v)&#123;</span><br><span class="line">l = m + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">h = m;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-双向搜索"><a href="#4-双向搜索" class="headerlink" title="4 双向搜索"></a>4 双向搜索</h1><p>起点是给出的，终点也是已知的，需要确定能否从起点到达终点，如果可以，需要多少步。</p><p>如果我们用常规的搜索方法，从起点开始往下搜，那得到的解答树可能非常庞大，这样漫无目的的搜索就像<strong>大海捞针</strong>。让我们切换一下思路，既然终点是已知的，我们何必让它闲着呢？我们完全可以<strong>分别</strong>从起点和终点出发，看它们能否<strong>相遇</strong>。</p><p>如果原本的解答树规模是 <img alt="[公式]" data-src="https://www.zhihu.com/equation?tex=a%5En" class="lozad"> ，使用双向搜索后，规模立刻缩小到了约 <img alt="[公式]" data-src="https://www.zhihu.com/equation?tex=2a%5E%7Bn%2F2%7D" class="lozad"> ，当 <img alt="[公式]" data-src="https://www.zhihu.com/equation?tex=n" class="lozad"> 较大时优化非常可观。</p><p>双向搜索主要有两种，双向BFS和双向迭代加深。</p><h2 id="4-1-双向BFS"><a href="#4-1-双向BFS" class="headerlink" title="4.1 双向BFS"></a>4.1 双向BFS</h2><p>与普通的BFS不同，双向BFS维护两个而不是一个队列，然后<strong>轮流</strong>拓展两个队列。同时，用<strong>数组</strong>（如果状态可以被表示为较小的整数）或<strong>哈希表</strong>记录当前的搜索情况，给从两个方向拓展的节点以不同的标记。当某点被两种标记同时标记时，搜索结束。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;T&gt; Q[<span class="number">3</span>]; <span class="comment">// T要替换为用来表示状态的类型，可能为int，string还有bitset等</span></span><br><span class="line"><span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">Q[<span class="number">1</span>].push(st); <span class="comment">// st为起始状态</span></span><br><span class="line">Q[<span class="number">2</span>].push(ed); <span class="comment">// ed为终止状态</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; D + <span class="number">2</span>; ++d) <span class="comment">// D为最大深度，最后答案为d-1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> dir = (d &amp; <span class="number">1</span>) + <span class="number">1</span>, sz = Q[dir].size(); <span class="comment">// 记录一下当前的搜索方向，1为正向，2为反向</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> x = Q[dir].front();</span><br><span class="line">        Q[dir].pop();</span><br><span class="line">        <span class="keyword">if</span> (H[x] + dir == <span class="number">3</span>) <span class="comment">// H是数组或哈希表，若H[x]+dir==3说明两个方向都搜到过这个点</span></span><br><span class="line">            found = <span class="literal">true</span>;</span><br><span class="line">        H[x] = dir;</span><br><span class="line">        <span class="comment">// 这里需要把当前状态能够转移到的新状态压入队列</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (found)</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-双向迭代加深"><a href="#4-2-双向迭代加深" class="headerlink" title="4.2 双向迭代加深"></a>4.2 双向迭代加深</h2><p>迭代加深算法是那种，听名字非常高端，思想和实现却都很简单的算法。就是控制dfs的最大深度，如果深度超过最大深度就返回。某个深度搜完后没有得到答案便令最大深度+1，然后重新开始搜索。</p><p>这听起来好像效果跟广搜差不多啊？还重复搜索了很多次。但是，由于搜索的时间复杂度几乎完全由解答树的最后一层确定（看上面第一张图就能感悟到），所以它与BFS在时间上只有常数级别的差距，以此换来的优势是：空间占用很小，有时候方便剪枝、方便传参等。</p><p>双向迭代加深就是相应地，从两个方向迭代加深搜索。先从起点开始搜0层，再从终点开始搜0层，然后从起点开始搜1层……</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> D;</span><br><span class="line"><span class="keyword">bool</span> found;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">dfs</span>(<span class="title">T</span> <span class="title">x</span>, <span class="title">int</span> <span class="title">d</span>, <span class="title">int</span> <span class="title">dir</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">if</span> (H[x] + dir == <span class="number">3</span>)</span><br><span class="line">        found = <span class="literal">true</span>;</span><br><span class="line">    H[x] = dir;</span><br><span class="line">    <span class="keyword">if</span> (d == D)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 这里需要递归搜索当前状态能够转移到的新状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在main函数中...</span></span><br><span class="line"><span class="keyword">while</span> (D &lt;= MAXD / <span class="number">2</span>) <span class="comment">// MAXD为题中要求的最大深度</span></span><br><span class="line">&#123;</span><br><span class="line">    dfs(st, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">// st为起始状态</span></span><br><span class="line">    <span class="keyword">if</span> (found)</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 题中所给最大深度为奇数时这里要判断一下</span></span><br><span class="line">    dfs(ed, <span class="number">0</span>, <span class="number">2</span>); <span class="comment">// ed为终止状态</span></span><br><span class="line">    <span class="keyword">if</span> (found)</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    D++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://zhuanlan.zhihu.com/p/119349440" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/119349440</a></p><h1 id="5-极大极小值搜索算法"><a href="#5-极大极小值搜索算法" class="headerlink" title="5 极大极小值搜索算法"></a>5 极大极小值搜索算法</h1><p>简单的对抗搜索</p><p>评估函数的返回值直接设定成题目中的评估得分即可</p><p>在博弈树搜索时，先手返回能向下递归所得的最大值，后手反之返回最小值</p><p>如果某种状态已经分出胜负或者平手，就说明该种状态就是博弈树中的叶子节点，需要计算评估得分进行返回</p><p>数据很小可以不用alpha-beta剪枝</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(x,a,b) for(int x=(a);x&lt;=(b);x++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn][maxn];<span class="comment">//棋盘 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//计算评估分数，-2000代表还能继续进行棋局</span></span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">    rep(i,<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">        rep(j,<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">            x+=(a[i][j]==<span class="number">0</span>);</span><br><span class="line">    rep(i,<span class="number">0</span>,<span class="number">2</span>)&#123;<span class="comment">//A或B获胜 </span></span><br><span class="line">        <span class="keyword">if</span>(a[i][<span class="number">0</span>]==<span class="number">1</span>&amp;&amp;a[i][<span class="number">1</span>]==<span class="number">1</span>&amp;&amp;a[i][<span class="number">2</span>]==<span class="number">1</span>) <span class="keyword">return</span> x+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[i][<span class="number">0</span>]==<span class="number">2</span>&amp;&amp;a[i][<span class="number">1</span>]==<span class="number">2</span>&amp;&amp;a[i][<span class="number">2</span>]==<span class="number">2</span>) <span class="keyword">return</span> -x<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">0</span>][i]==<span class="number">1</span>&amp;&amp;a[<span class="number">1</span>][i]==<span class="number">1</span>&amp;&amp;a[<span class="number">2</span>][i]==<span class="number">1</span>) <span class="keyword">return</span> x+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">0</span>][i]==<span class="number">2</span>&amp;&amp;a[<span class="number">1</span>][i]==<span class="number">2</span>&amp;&amp;a[<span class="number">2</span>][i]==<span class="number">2</span>) <span class="keyword">return</span> -x<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//A或B获胜 </span></span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">0</span>][<span class="number">0</span>]==<span class="number">1</span>&amp;&amp;a[<span class="number">1</span>][<span class="number">1</span>]==<span class="number">1</span>&amp;&amp;a[<span class="number">2</span>][<span class="number">2</span>]==<span class="number">1</span>) <span class="keyword">return</span> x+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">0</span>][<span class="number">2</span>]==<span class="number">1</span>&amp;&amp;a[<span class="number">1</span>][<span class="number">1</span>]==<span class="number">1</span>&amp;&amp;a[<span class="number">2</span>][<span class="number">0</span>]==<span class="number">1</span>) <span class="keyword">return</span> x+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">0</span>][<span class="number">0</span>]==<span class="number">2</span>&amp;&amp;a[<span class="number">1</span>][<span class="number">1</span>]==<span class="number">2</span>&amp;&amp;a[<span class="number">2</span>][<span class="number">2</span>]==<span class="number">2</span>) <span class="keyword">return</span> -x<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">0</span>][<span class="number">2</span>]==<span class="number">2</span>&amp;&amp;a[<span class="number">1</span>][<span class="number">1</span>]==<span class="number">2</span>&amp;&amp;a[<span class="number">2</span>][<span class="number">0</span>]==<span class="number">2</span>) <span class="keyword">return</span> -x<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//平局 </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-2000</span>;<span class="comment">//棋局未结束 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> dep)</span></span>&#123;</span><br><span class="line">    <span class="comment">//dep=0代表先手，1代表后手</span></span><br><span class="line">    <span class="keyword">int</span> res=check();</span><br><span class="line">    <span class="keyword">if</span>(res!=<span class="number">-2000</span>)<span class="comment">//棋局结束 </span></span><br><span class="line"><span class="keyword">return</span> res;<span class="comment">//叶子节点返回</span></span><br><span class="line">    <span class="keyword">int</span> Res = dep==<span class="number">0</span> ? <span class="number">-1000</span>:<span class="number">1000</span>;</span><br><span class="line">    rep(i,<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">        rep(j,<span class="number">0</span>,<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!a[i][j])&#123;</span><br><span class="line">                a[i][j] = dep==<span class="number">0</span> ? <span class="number">1</span>:<span class="number">2</span>;<span class="comment">//打标签 </span></span><br><span class="line">                <span class="keyword">if</span>( dep==<span class="number">0</span> )<span class="comment">//先手找最大</span></span><br><span class="line">Res = max(Res, dfs(dep^<span class="number">1</span>));<span class="comment">//按位异或实现01轮流下棋</span></span><br><span class="line">                <span class="keyword">else</span><span class="comment">//后手找最小</span></span><br><span class="line">Res = min(Res, dfs(dep^<span class="number">1</span>));</span><br><span class="line">                a[i][j] = <span class="number">0</span>;<span class="comment">//去标签 </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> Res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> T;<span class="comment">//测试组数 </span></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        rep(i,<span class="number">0</span>,<span class="number">2</span>)<span class="comment">//输入当前棋盘 </span></span><br><span class="line">            rep(j,<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">                <span class="built_in">cin</span>&gt;&gt; a[i][j];</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; dfs(<span class="number">0</span>)&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用用alpha-beta剪枝：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(x,a,b) for(int x=(a);x&lt;=(b);x++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn][maxn];<span class="comment">//棋盘 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//计算评估分数，-2000代表还能继续进行棋局</span></span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">    rep(i,<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">        rep(j,<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">            x+=(a[i][j]==<span class="number">0</span>);</span><br><span class="line">    rep(i,<span class="number">0</span>,<span class="number">2</span>)&#123;<span class="comment">//A或B获胜 </span></span><br><span class="line">        <span class="keyword">if</span>(a[i][<span class="number">0</span>]==<span class="number">1</span>&amp;&amp;a[i][<span class="number">1</span>]==<span class="number">1</span>&amp;&amp;a[i][<span class="number">2</span>]==<span class="number">1</span>) <span class="keyword">return</span> x+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[i][<span class="number">0</span>]==<span class="number">2</span>&amp;&amp;a[i][<span class="number">1</span>]==<span class="number">2</span>&amp;&amp;a[i][<span class="number">2</span>]==<span class="number">2</span>) <span class="keyword">return</span> -x<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">0</span>][i]==<span class="number">1</span>&amp;&amp;a[<span class="number">1</span>][i]==<span class="number">1</span>&amp;&amp;a[<span class="number">2</span>][i]==<span class="number">1</span>) <span class="keyword">return</span> x+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">0</span>][i]==<span class="number">2</span>&amp;&amp;a[<span class="number">1</span>][i]==<span class="number">2</span>&amp;&amp;a[<span class="number">2</span>][i]==<span class="number">2</span>) <span class="keyword">return</span> -x<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//A或B获胜 </span></span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">0</span>][<span class="number">0</span>]==<span class="number">1</span>&amp;&amp;a[<span class="number">1</span>][<span class="number">1</span>]==<span class="number">1</span>&amp;&amp;a[<span class="number">2</span>][<span class="number">2</span>]==<span class="number">1</span>) <span class="keyword">return</span> x+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">0</span>][<span class="number">2</span>]==<span class="number">1</span>&amp;&amp;a[<span class="number">1</span>][<span class="number">1</span>]==<span class="number">1</span>&amp;&amp;a[<span class="number">2</span>][<span class="number">0</span>]==<span class="number">1</span>) <span class="keyword">return</span> x+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">0</span>][<span class="number">0</span>]==<span class="number">2</span>&amp;&amp;a[<span class="number">1</span>][<span class="number">1</span>]==<span class="number">2</span>&amp;&amp;a[<span class="number">2</span>][<span class="number">2</span>]==<span class="number">2</span>) <span class="keyword">return</span> -x<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">0</span>][<span class="number">2</span>]==<span class="number">2</span>&amp;&amp;a[<span class="number">1</span>][<span class="number">1</span>]==<span class="number">2</span>&amp;&amp;a[<span class="number">2</span>][<span class="number">0</span>]==<span class="number">2</span>) <span class="keyword">return</span> -x<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//平局 </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-2000</span>;<span class="comment">//棋局未结束 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> dep, <span class="keyword">int</span> lval)</span></span>&#123;</span><br><span class="line"><span class="comment">//dep=0代表先手，1代表后手</span></span><br><span class="line">    <span class="comment">//lval表示如果父亲是先手就是父亲的alpha，否则是父亲的beta</span></span><br><span class="line">    <span class="keyword">int</span> res=check();</span><br><span class="line">    <span class="keyword">if</span>(res!=<span class="number">-2000</span>)<span class="comment">//棋局结束  </span></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">if</span>(dep==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> alpha=<span class="number">-1e9</span>;<span class="comment">//alpha表示先手能找到的最大值</span></span><br><span class="line">        rep(i,<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">            rep(j,<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">                <span class="keyword">if</span>(!a[i][j])&#123;</span><br><span class="line">                    a[i][j]=<span class="number">1</span>;</span><br><span class="line">                    alpha=max(alpha,dfs(dep^<span class="number">1</span>,alpha));</span><br><span class="line">                    a[i][j]=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span>(alpha&gt;lval) <span class="keyword">return</span> alpha;</span><br><span class="line">                    <span class="comment">//如果先手能找到的最大值比后手父亲能找到的最小值还大，后手父亲就肯定不选当前的子树，直接返回进行剪枝</span></span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">return</span> alpha;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> beta=<span class="number">1e9</span>;<span class="comment">//beta表示后手能找到的最小值</span></span><br><span class="line">        rep(i,<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">            rep(j,<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">                <span class="keyword">if</span>(!a[i][j])&#123;</span><br><span class="line">                    a[i][j]=<span class="number">2</span>;</span><br><span class="line">                    beta=min(beta,dfs(dep^<span class="number">1</span>,beta));</span><br><span class="line">                    a[i][j]=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span>(beta&lt;lval) <span class="keyword">return</span> beta;</span><br><span class="line">                    <span class="comment">//反之同理</span></span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">return</span> beta;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> T;<span class="comment">//测试组数 </span></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        rep(i,<span class="number">0</span>,<span class="number">2</span>)<span class="comment">//输入当前棋盘 </span></span><br><span class="line">            rep(j,<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">                <span class="built_in">cin</span>&gt;&gt; a[i][j];</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; dfs(<span class="number">0</span>, <span class="number">1e9</span>)&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p>1. </p>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DFS </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/2021/04/10/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2021/04/10/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="table-container"><table><thead><tr><th style="text-align:center">排序算法</th><th style="text-align:center">最好时间复杂度</th><th style="text-align:center">平均时间复杂度</th><th style="text-align:center">最坏时间复杂度</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">直接插入排序</td><td style="text-align:center">有序：$O(n)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">逆序：$O(n^2)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">希尔排序</td><td style="text-align:center">复杂度未得到证明</td><td style="text-align:center">$O(n^{1.3-2})$</td><td style="text-align:center">d=1：$O(n^2)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">冒泡排序</td><td style="text-align:center">有序：$O(n)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">逆序：$O(n^2)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">快速排序</td><td style="text-align:center">划分均匀：$O(nlog_2n)$</td><td style="text-align:center">$O(nlog_2n)$</td><td style="text-align:center">有序：$O(n^2)$</td><td style="text-align:center">$O(log_2n\sim n)$</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">简单选择排序</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">堆排序</td><td style="text-align:center">$O(nlog_2n)$</td><td style="text-align:center">$O(nlog_2n)$</td><td style="text-align:center">$O(nlog_2n)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">归并排序</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">$O(nlog_2n)$</td><td style="text-align:center">$O(n)$</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">基数排序</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">$O(d(r+n))$</td><td style="text-align:center">$O(r)$</td><td style="text-align:center">稳定</td></tr></tbody></table></div><h1 id="1-直接插入排序（Insertion-Sort）"><a href="#1-直接插入排序（Insertion-Sort）" class="headerlink" title="1 直接插入排序（Insertion Sort）"></a>1 直接插入排序（Insertion Sort）</h1><p>插入排序的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><p>优化：先用折半查找找到应该插入的位置，再移动元素。</p><h1 id="2-希尔排序（Shell-Sort）"><a href="#2-希尔排序（Shell-Sort）" class="headerlink" title="2 希尔排序（Shell Sort）"></a>2 希尔排序（Shell Sort）</h1><p>先将待排序表分割成若干形如$L[i,i+d,i+2d,…,i+kd]$的特殊子表，对各个子表分别进行直接插入排序。缩小增量d，重复上述过程，直到d=1为止。（希尔本人建议：d初始值为n，然后每次将增量缩小一半）</p><p>适用性：仅适用于顺序表，不适用于链表</p><h1 id="3-冒泡排序（Bubble-Sort）"><a href="#3-冒泡排序（Bubble-Sort）" class="headerlink" title="3 冒泡排序（Bubble Sort）"></a>3 冒泡排序（Bubble Sort）</h1><p><strong>冒泡排序</strong>是一种交换排序，它的思路就是在待排序的数据中，两两比较相邻元素的大小，看是否满足大小顺序的要求，如果满足则不动，如果不满足则让它们互换。然后继续与下一个相邻元素的比较，一直到一次遍历完成。一次遍历的过程就被成为一次冒泡，一次冒泡的结束至少会让一个元素移动到了正确的位置。所以要想让所有元素都排序好，一次冒泡还不行，我们得重复N次去冒泡，这样最终就完成了N个数据的排序过程。</p><p>对一个长度为 $n$ 的排列 $p[i]$ 进行一轮冒泡排序的伪代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i = <span class="number">1</span> to n<span class="number">-1</span>:</span><br><span class="line"><span class="keyword">if</span> p[i] &gt; p[i + <span class="number">1</span>]:</span><br><span class="line">swap(p[i], p[i + <span class="number">1</span>])</span><br></pre></td></tr></table></figure><h1 id="4-快速排序（Quck-Sort）"><a href="#4-快速排序（Quck-Sort）" class="headerlink" title="4 快速排序（Quck Sort）"></a>4 快速排序（Quck Sort）</h1><p>快速排序是一种交换排序，它的思路：在待排序表$L[1…n]$中任取一个元素 pivot 作为枢轴（或基准，通常取首元素），通过一趟排序表划分为独立的两部分$L[1…k-1]$和$L[k+1…n]$，使得$L[1…k-1]$中的所有元素小于 pivot，$L[k+1…n]$中的所有元素大于等于 pivot，则 pivot放在了其最终位置$L[k]$上，这个过程称为一次“划分”。然后分别递归地对两个子表重复上述过程，直至每部分内只有一个元素或空为止，即所有元素放在了其最终位置上。</p><p>若每一次选中的“枢轴”将待排序序列划分为均匀的两个部分，则递归深度最小，算法效率最高。</p><p>优化：</p><ol><li>选头、中、尾、三个位置的元素，取中间值作为枢轴元素；</li><li>随机选一个元素作为枢轴元素。</li></ol><h1 id="5-简单选择排序（Selection-Sort）"><a href="#5-简单选择排序（Selection-Sort）" class="headerlink" title="5 简单选择排序（Selection Sort）"></a>5 简单选择排序（Selection Sort）</h1><p>选择排序：每一趟在待排序元素中选取关键字最小（或最大）的元素加入有序子序列。</p><p>适用性：既可以用于顺序表，也可用于链表</p><h1 id="6-堆排序（Heap-Sort）"><a href="#6-堆排序（Heap-Sort）" class="headerlink" title="6 堆排序（Heap Sort）"></a>6 堆排序（Heap Sort）</h1><p>堆排序是选择排序的一种，思路：每一趟将堆顶元素加入到有序子序列（与待排序序列中的最后一个元素交换），并将待排序元素序列再次调整为大根堆（小元素不断下坠）</p><p><strong>什么是堆？</strong></p><p>若$n$个关键字序列$L[1..n]$满足下面某一条性质，则称为堆（Heap）：</p><ol><li>若满足：$L(i)≥L(2i)$且$L(i)≥L(2i+1)$，$(1 \leq i \leq n / 2)$——大根堆（大顶堆）</li><li>若满足：$L(i)≤L(2i)$且$L(i)≤L(2i+1)$，$(1 \leq i \leq n / 2)$——小根堆（小顶堆）</li></ol><p><strong>建立大根堆</strong>：</p><ol><li>把所有非终端结点都检查一遍，是否满足大根堆的要求，如果不满足则进行调整</li><li>检查当前结点是否满足<code>根节点&gt;=左、右</code>，若不满足，将当前结点与更大的一个孩子互换</li><li>若元素互换破坏了下一级的堆，则采用相同的方法继续往下调整（小元素不断“下坠”）</li></ol><p>建堆$O(n)$，排序$O(nlogn)$</p><p><strong>在堆中插入新元素</strong>：</p><ol><li>对于大根堆，新元素放到表尾，与父结点相比，若新元素比父节点更大，则将二者互换。新元素就这样一路上升，直到无法继续上升。</li></ol><p><strong>在堆中删除元素</strong>：</p><ol><li>被删除元素用堆底元素代替，然后让该元素不断下坠，直到无法下坠为止。</li></ol><h1 id="7-归并排序（Merge-Sort）"><a href="#7-归并排序（Merge-Sort）" class="headerlink" title="7 归并排序（Merge Sort）"></a>7 归并排序（Merge Sort）</h1><p>把两个或多个已经有序的序列合并成一个。</p><p>核心操作：把数组内的两个有序序列归并为一个。</p><h1 id="8-基数排序（Radix-Sort）"><a href="#8-基数排序（Radix-Sort）" class="headerlink" title="8 基数排序（Radix Sort）"></a>8 基数排序（Radix Sort）</h1><p>假设长度为$n$的线性表中每个结点$a$的关键字由$d$元组$\left(k<em>{j}^{d-1}, k</em>{j}^{d-2}, k<em>{j}^{d-3}, \ldots, k</em>{j}^{1}, k<em>{j}^{0}\right)$组成，其中，$0 \leq k</em>{j}^{i} \leq r-1 \quad(0 \leq j&lt;n, 0 \leq i \leq d-1)$，$r$称为基数。</p><p><strong>基数排序得到递减序列的过程如下</strong>：</p><ol><li>初始化：设置$r$个空队列，$Q<em>{r-1}，Q</em>{r-2}…Q_0$</li><li>按照各个关键字位权重递增的次序（个、十、百），对$d$个关键字位分别做“分配”和“收集”</li><li>分配：顺序扫描各个元素，若当前处理的关键字位=x，则将元素插入$Q_x$队尾</li><li>收集：把$Q<em>{r-1}，Q</em>{r-2}…Q_0$各个队列中的结点依次出队并链接</li></ol><p><strong>注意</strong>：</p><ol><li>基数排序不是基于比较的排序算法；基数排序通常基于链式存储实现。</li><li>需要$r$个辅助队列，空间复杂度为$O(r)$，其中$r$为基数；</li><li>一趟分配$O(n)$，一趟收集$O(r)$，总共$d$趟分配、收集，总的时间复杂度=$O(d(n+r))$</li></ol><p><strong>基数排序擅长解决的问题</strong>：</p><ol><li>数据元素的关键字可以方便地拆分成$d$组，且$d$较小；</li><li>每组的关键字的取值范围不大，即$r$较小</li><li>数据元素个数$n$较大</li></ol><h1 id="9-外部排序"><a href="#9-外部排序" class="headerlink" title="9 外部排序"></a>9 外部排序</h1><p><strong>外部排序原理</strong>：</p><p>外部排序：数据元素太多，无法一次全部读入内存进行排序。</p><p>使用归并排序的方法，最少只需在内存中分配3块大小的缓冲区即可对任意一个大文件进行排序。</p><p><strong>步骤</strong>：</p><ol><li>构造初始归并段：归并排序要求各个子序列有序，每次读入两个块的内容，进行内部排序后写回磁盘；</li><li>第一趟归并：将两个归并段归并为一个，缓冲区1/2空了就要立即用归并段1/2的下一块补上</li><li>第二趟归并：与第一趟类似…</li></ol><p><strong>时间开销分析</strong>：</p><ol><li>外部排序时间开销=读写外存时间+内部排序所需时间+内部归并所需时间</li></ol><p><strong>优化</strong>：</p><ol><li>多路归并：采用多路归并可以减少归并趟数，从而减少磁盘I/O(读写)次数</li><li>减少初始归并段数量：生成初始归并段的“内存工作区”越大，初始归并段越长，则可减少初始归并段数量r</li></ol><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> arr[maxn] = &#123;<span class="number">0</span>, <span class="number">53</span>, <span class="number">17</span>, <span class="number">78</span>, <span class="number">9</span>, <span class="number">45</span>, <span class="number">65</span>, <span class="number">87</span>, <span class="number">32</span>&#125;;<span class="comment">//下标从1开始 </span></span><br><span class="line"><span class="keyword">int</span> n;<span class="comment">//数组长度 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//直接插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j, tmp;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">tmp = arr[i];</span><br><span class="line"><span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j] &gt; tmp) &#123;</span><br><span class="line">arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">arr[j + <span class="number">1</span>] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//希尔排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j, tmp, d;</span><br><span class="line"><span class="keyword">for</span> (d = n / <span class="number">2</span>; d &gt;= <span class="number">1</span>; d /= <span class="number">2</span>) &#123;<span class="comment">//增量 </span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> + d; i &lt;= n; i++) &#123;</span><br><span class="line">tmp = arr[i];</span><br><span class="line"><span class="keyword">for</span> (j = i - d; j &gt;= d; j -= d) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j] &gt; tmp) &#123;</span><br><span class="line">arr[j + d] = arr[j];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">arr[j + d] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//冒泡排序 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n - i; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">swap(arr[j], arr[j + <span class="number">1</span>]);</span><br><span class="line">flag = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag == <span class="literal">false</span>) &#123;<span class="comment">//无交换，表已经有序 </span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//快速排序——用arr[low]将子表划分</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> pivot = arr[low];<span class="comment">//第一个元素作为枢轴元素 </span></span><br><span class="line"><span class="keyword">while</span> (low &lt; high) &#123;<span class="comment">//用low、high搜索枢轴的最终位置 </span></span><br><span class="line"><span class="keyword">while</span> (low &lt; high &amp;&amp; arr[high] &gt;= pivot) &#123;</span><br><span class="line">high--;</span><br><span class="line">&#125; </span><br><span class="line">arr[low] = arr[high];<span class="comment">//比枢轴小的元素移动到左边 </span></span><br><span class="line"><span class="keyword">while</span> (low &lt; high &amp;&amp; arr[low] &lt;= pivot) &#123;</span><br><span class="line">low++;</span><br><span class="line">&#125; </span><br><span class="line">arr[high] = arr[low];<span class="comment">//比枢轴大的元素移动到左边 </span></span><br><span class="line">&#125;</span><br><span class="line">arr[low] = pivot;<span class="comment">//枢轴元素存放的最终位置</span></span><br><span class="line"><span class="keyword">return</span> low;<span class="comment">//返回存放枢轴的最终位置 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quck_sort</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line"><span class="keyword">int</span> pivot_pos = partition(low, high);</span><br><span class="line">quck_sort(low, pivot_pos - <span class="number">1</span>);</span><br><span class="line">quck_sort(pivot_pos + <span class="number">1</span>, high);</span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//简单选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">select_sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;<span class="comment">//进行n-1趟 </span></span><br><span class="line"><span class="keyword">int</span> mini = i;<span class="comment">//记录最小元素位置 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++) &#123;<span class="comment">//在arr[i+1...n]中选择最小元素 </span></span><br><span class="line"><span class="keyword">if</span> (arr[j] &lt; arr[mini]) &#123;</span><br><span class="line">mini = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mini != i) &#123;</span><br><span class="line">swap(arr[i], arr[mini]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//堆排序——将以 k 为根的子树调整为大根堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_adjust</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">arr[<span class="number">0</span>] = arr[k];<span class="comment">//arr[0]暂存子树的根节点 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> * k; i &lt;= len; i *= <span class="number">2</span>) &#123;<span class="comment">//沿key较大的子节点向下筛选 </span></span><br><span class="line"><span class="keyword">if</span> (i &lt; len &amp;&amp; arr[i] &lt; arr[i + <span class="number">1</span>]) &#123;<span class="comment">//比较左右孩子结点大小 </span></span><br><span class="line">i++;<span class="comment">//取key较大的子节点下标 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (arr[<span class="number">0</span>] &gt;= arr[i]) &#123;<span class="comment">//筛选结束 </span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">arr[k] = arr[i];<span class="comment">//将arr[i]调整到双亲结点上 </span></span><br><span class="line">k = i;<span class="comment">//修改k，以便继续向下筛选 </span></span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">arr[k] = arr[<span class="number">0</span>];<span class="comment">//被筛选节点的值放入最终位置 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//堆排序——建立大根堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_max_heap</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = len / <span class="number">2</span>; i &gt; <span class="number">0</span>; i--) &#123;<span class="comment">//从后往前调整非终端结点 </span></span><br><span class="line">heap_adjust(i, len);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">build_max_heap(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt; <span class="number">1</span>; i--) &#123;</span><br><span class="line">swap(arr[i], arr[<span class="number">1</span>]);</span><br><span class="line">heap_adjust(<span class="number">1</span>, i - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *b = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));<span class="comment">//辅助数组 </span></span><br><span class="line"><span class="comment">//归并排序——arr[low...mid]与arr[mid+1...high]各自有序，将两者合并</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j, k;</span><br><span class="line"><span class="keyword">for</span> (k = low; k &lt;= high; k++) &#123;<span class="comment">//将arr中所有元素复制到b </span></span><br><span class="line">b[k] = arr[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//合并 </span></span><br><span class="line"><span class="keyword">for</span> (i = low, j = mid + <span class="number">1</span>, k = low; i &lt;= mid &amp;&amp; j &lt;= high; k++) &#123;</span><br><span class="line"><span class="keyword">if</span> (b[i] &lt; b[j]) &#123;</span><br><span class="line">arr[k] = b[i++];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">arr[k] = b[j++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//没有归并完的部分复制到尾部 </span></span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid) arr[k++] = b[i++];</span><br><span class="line"><span class="keyword">while</span> (j &lt;= high) arr[k++] = b[j++]; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;<span class="comment">//从中间拆开 </span></span><br><span class="line">merge_sort(low, mid);<span class="comment">//对左半部分归并排序 </span></span><br><span class="line">merge_sort(mid + <span class="number">1</span>, high);<span class="comment">//对右半部分归并排序 </span></span><br><span class="line">merge(low, mid, high);<span class="comment">//归并 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//cin&gt;&gt; n;</span></span><br><span class="line">n = <span class="number">8</span>;</span><br><span class="line">merge_sort(<span class="number">1</span>, n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; arr[i]&lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><ol><li></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>欧拉路</title>
      <link href="/2021/04/10/%E6%AC%A7%E6%8B%89%E8%B7%AF/"/>
      <url>/2021/04/10/%E6%AC%A7%E6%8B%89%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><ul><li><strong>欧拉回路</strong>：每条边只经过一次，而且回到起点</li><li><strong>欧拉路径</strong>：每条边只经过一次，不要求回到起点  </li><li><strong>欧拉回路判断</strong>：<ul><li><strong>无向图</strong>：连通(不考虑度为 0 的点)，没有奇度顶点</li><li><strong>有向图</strong>：强连通，每个顶点出度等于入度</li><li><strong>混合图(有无向边和有向边)</strong>：首先是基图连通(不考虑度为 0 的点)，然后需要借助网络流判定。<ol><li>首先给原图中的每条无向边随便指定一个方向（称为初始定向），将原图改为有向图 G’，然后的任务就是改变 G’ 中某些边的方向（当然是无向边转化来的，原混合图中的有向边不能动）使其满足每个点的入度等于出度。</li><li>设 $D[i]$ 为 $G’$ 中 (点 $i$ 的出度 - 点 $i $的入度）。可以发现，在改变 $G’$ 中边的方向的过程中，任何点的 $D$ 值的奇偶性都不会发生改变（设将边 $<i, j>$ 改为 $<j, i>$，则 $i $入度加 1 出度减 1，$j$ 入度减 1 出度加 1，两者之差加 2 或减 2，奇偶性不变）！而最终要求的是每个点的入度等于出度，即每个点的 $D$ 值都为 0，是偶数，故可得：若初始定向得到的 $G’$ 中任意一个点的$D$值是奇数，那么原图中一定不存在欧拉环！</j,></i,></li><li>若初始 $D$ 值都是偶数，则将 $G’$ 改装成网络：设立源点 $S$ 和汇点 $T$，对于每个 $D[i]&gt;0$ 的点$i$，连边 $<s, i>$，容量为 $D[i]/2$；对于每个 $D[j]<0$ 的点 $j$，连边 $<j, t>$，容量为 $-D[j]/2$； $G’$中的每条边在网络中仍保留，容量为 1（表示该边最多只能被改变方向一次）。求这个网络的最大流，若 $S$ 引出的所有边均满流，则原混合图是欧拉图，将网络中所有流量为 1 的中间边（就是不与 $S$ 或 $T$关联的边）在 $G’$ 中改变方向，形成的新图 $G”$ 一定是有向欧拉图；若 $S$ 引出的边中有的没有满流，则原混合图不是欧拉图。</0$></s,></li></ol></li></ul></li><li><strong>欧拉路径的判断</strong>：<ul><li><strong>无向图</strong>：连通(不考虑度为 0 的点)，没有奇度顶点或恰有两个奇度顶点</li><li><strong>有向图</strong>：基图连通(把边当成无向边，同样不考虑度为 0 的点)，每个顶点出度等于入度或<br>者有且仅有一个点的出度比入度多 1，有且仅有一个点的出度比入度少 1，其余出度等于入<br>度。</li><li><strong>混合图</strong>：如果存在欧拉回路，一定存在欧拉路径了。否则如果有且仅有两个点的（出度 -入<br>度）是奇数，那么给这个两个点加边，判断是否存在欧拉回路。  </li></ul></li></ul><p><a href="https://blog.csdn.net/richenyunqi/article/details/80382450/" target="_blank" rel="noopener">https://blog.csdn.net/richenyunqi/article/details/80382450/</a></p><h1 id="欧拉路径模板"><a href="#欧拉路径模板" class="headerlink" title="欧拉路径模板"></a>欧拉路径模板</h1><h2 id="1-递归"><a href="#1-递归" class="headerlink" title="1 递归"></a>1 递归</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无向图的欧拉路径</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;graph[maxn],path;<span class="comment">//图、欧拉路径的倒序</span></span><br><span class="line"><span class="keyword">int</span> N, M;<span class="comment">//顶点数、边数</span></span><br><span class="line"><span class="keyword">bool</span> visit[maxn][maxn];<span class="comment">//表示边是否已被访问</span></span><br><span class="line"><span class="comment">//顶点v的度数是否为奇数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">f</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v.size()%<span class="number">2</span>==<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//深度优先遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;graph[v].size();++i)&#123;<span class="comment">//遍历该点能到达的结点</span></span><br><span class="line">        <span class="keyword">int</span> w=graph[v][i];</span><br><span class="line">        <span class="keyword">if</span>(!visit[v][w])&#123;<span class="comment">//该边没有被访问过</span></span><br><span class="line">            visit[v][w]=visit[w][v]=<span class="literal">true</span>;<span class="comment">//该边已被访问</span></span><br><span class="line">            DFS(w);<span class="comment">//递归遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    path.push_back(v);<span class="comment">//加入欧拉路径中</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;M);<span class="comment">//输入点数、边数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;++i)&#123;<span class="comment">//输入边，无向图</span></span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">        graph[a].push_back(b);</span><br><span class="line">        graph[b].push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;++i)<span class="comment">//排序、题目要求输出字典序最小的一种方案</span></span><br><span class="line">        sort(graph[i].begin(),graph[i].end());</span><br><span class="line">    DFS(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> k=count_if(graph+<span class="number">1</span>,graph+N+<span class="number">1</span>,f);<span class="comment">//度数为奇数的顶点个数</span></span><br><span class="line">    <span class="comment">//连通、没有奇度顶点或恰有两个奇度顶点且起点为奇度顶点</span></span><br><span class="line">    <span class="keyword">if</span>(path.size()==M+<span class="number">1</span>&amp;&amp;(k==<span class="number">0</span>||(k==<span class="number">2</span>&amp;&amp;f(graph[<span class="number">1</span>]))))</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=path.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)<span class="comment">//反向输出路径</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,path[i]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-1"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-非递归"><a href="#2-非递归" class="headerlink" title="2 非递归"></a>2 非递归</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无向图的欧拉路径</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;graph[maxn],path;<span class="comment">//图、欧拉路径的倒序</span></span><br><span class="line"><span class="keyword">int</span> N, M;<span class="comment">//顶点数、边数</span></span><br><span class="line"><span class="keyword">bool</span> visit[maxn][maxn];<span class="comment">//表示边是否已被访问</span></span><br><span class="line"><span class="comment">//顶点v的度数是否为奇数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">f</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v.size()%<span class="number">2</span>==<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;M);<span class="comment">//输入点数、边数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;++i)&#123;<span class="comment">//输入边，无向图</span></span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">        graph[a].push_back(b);</span><br><span class="line">        graph[b].push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;++i)<span class="comment">//排序、题目要求输出字典序最小的一种方案</span></span><br><span class="line">        sort(graph[i].begin(),graph[i].end());</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;s;</span><br><span class="line">    s.push(<span class="number">1</span>);<span class="comment">//1号顶点(起点)入栈</span></span><br><span class="line">    <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> v=s.top(),i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;graph[v].size();++i)&#123;<span class="comment">//遍历该点能到达的结点</span></span><br><span class="line">            <span class="keyword">int</span> w=graph[v][i];</span><br><span class="line">            <span class="keyword">if</span>(!visit[v][w])&#123;<span class="comment">//该边没有被访问过</span></span><br><span class="line">                s.push(w);<span class="comment">//顶点w入栈</span></span><br><span class="line">                visit[v][w]=visit[w][v]=<span class="literal">true</span>;<span class="comment">//该边已被访问</span></span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//跳出循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i==graph[v].size())&#123;<span class="comment">//没有还未访问的边</span></span><br><span class="line">            path.push_back(v);<span class="comment">//顶点v加入欧拉序列</span></span><br><span class="line">            s.pop();<span class="comment">//出栈</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k=count_if(graph+<span class="number">1</span>,graph+N+<span class="number">1</span>,f);<span class="comment">//度数为奇数的顶点个数</span></span><br><span class="line">    <span class="comment">//连通、没有奇度顶点或恰有两个奇度顶点且起点为奇度顶点</span></span><br><span class="line">    <span class="keyword">if</span>(path.size()==M+<span class="number">1</span>&amp;&amp;(k==<span class="number">0</span>||(k==<span class="number">2</span>&amp;&amp;f(graph[<span class="number">1</span>]))))</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i=path.rbegin();i!=path.rend();++i)<span class="comment">//倒序输出</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,*i);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-1"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>背包dp</title>
      <link href="/2021/04/10/%E8%83%8C%E5%8C%85dp/"/>
      <url>/2021/04/10/%E8%83%8C%E5%8C%85dp/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>转载：<a href="https://www.cnblogs.com/jbelial/articles/2116074.html" target="_blank" rel="noopener">dd大牛的《背包九讲》</a>、<a href="https://www.kancloud.cn/kancloud/pack/70124" target="_blank" rel="noopener">背包问题九讲</a>、<a href="https://zhuanlan.zhihu.com/p/139368825" target="_blank" rel="noopener">知乎转载</a></p></blockquote><h1 id="P01-01背包"><a href="#P01-01背包" class="headerlink" title="P01: 01背包"></a>P01: 01背包</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>有N件物品和一个容量为V的背包。第i件物品的费用/体积是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的体积总和不超过背包容量，且价值总和最大。</p><h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>这是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放。</p><p>用子问题定义状态：即$f[i][v]$表示前i件物品恰放入一个容量为v的背包可以获得的最大价值。则其状态转移方程便是：$f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]}$。</p><p>这个方程非常重要，基本上所有跟背包相关的问题的方程都是由它衍生出来的。所以有必要将它详细解释一下：“将前i件物品放入容量为v的背包中”这个子问题，若只考虑第i件物品的策略（放或不放），那么就可以转化为一个只牵扯前i-1件物品的问题。如果不放第i件物品，那么问题就转化为“前i-1件物品放入容量为v的背包中”；如果放第i件物品，那么问题就转化为“前i-1件物品放入剩下的容量为v-c[i]的背包中”，此时能获得的最大价值就是$f [i-1][v-c[i]]$再加上通过放入第i件物品获得的价值$w[i]$。</p><p>注意$f[i][v]$有意义当且仅当存在一个前i件物品的子集，其费用总和为v。所以按照这个方程递推完毕后，最终的答案并不一定是$f[N] [V]$，而是$f[N][0…V]$的最大值。如果将状态的定义中的“恰”字去掉，在转移方程中就要再加入一项$f[i][v-1]$，这样就可以保证$f[N] [V]$就是最后的答案。</p><h2 id="优化——空间复杂度"><a href="#优化——空间复杂度" class="headerlink" title="优化——空间复杂度"></a>优化——空间复杂度</h2><p>以上方法的时间和空间复杂度均为$O(N*V)$，其中时间复杂度基本已经不能再优化了，但空间复杂度却可以优化到$O(V)$。</p><p>先考虑上面讲的基本思路如何实现，肯定是有一个主循环$i=1…N$，每次算出来二维数组$f[i][0..V]$的所有值。那么，如果只用一个数组$f [0..V]$，能不能保证第$i$次循环结束后$f[v]$中表示的就是我们定义的状态$f[i][v]$呢？$f[i][v]$是由$f[i-1][v]$和$f[i-1] [v-c[i]]$两个子问题递推而来，能否保证在推$f[i][v]$时（也即在第$i$次主循环中推$f[v]$时）能够得到$f[i-1][v]$和$f[i-1][v -c[i]]$的值呢？事实上，这要求在每次主循环中我们以$v=V..0$的顺序推$f[v]$，这样才能保证推$f[v]$时$f[v-c[i]]$保存的是状态$f[i -1][v-c[i]]$的值。伪代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i=<span class="number">1.</span>.N</span><br><span class="line"><span class="keyword">for</span> v=V.<span class="number">.0</span></span><br><span class="line">f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;;</span><br></pre></td></tr></table></figure><p>其中的$f[v]=max{f[v],f[v-c[i]]+w[i]}$一句恰就相当于我们的转移方程$f[i][v]=max{f[i-1][v],f[i- 1][v-c[i]]+w[i]}$，因为现在的$f[v-c[i]]$就相当于原来的$f[i-1][v-c[i]]$。如果将v的循环顺序从上面的逆序改成顺序的话，那么则成了$f[i][v]$由$f[i][v-c[i]]$推知，与本题意不符，但它却是另一个重要的背包问题P02最简捷的解决方案，故学习只用一维数组解01背包问题是十分必要的。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">5</span>;<span class="comment">//物品最大数量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv = <span class="number">1e3</span> + <span class="number">5</span>;<span class="comment">//背包最大体积</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[maxv];<span class="comment">//背包</span></span><br><span class="line"><span class="keyword">int</span> volume[maxn], value[maxn];<span class="comment">//每个物品的体积和价值</span></span><br><span class="line"><span class="keyword">int</span> n, v;<span class="comment">//总物品数、背包体积</span></span><br><span class="line"><span class="comment">//01背包 每种物品仅有一件，可以选择放或不放</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zero_one_park</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> vol)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = v; j &gt;= vol; j--) &#123;</span><br><span class="line">        dp[j] = max(dp[j], dp[j - vol] + val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt; n&gt;&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt; volume[i]&gt;&gt; value[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        zero_one_park(value[i], volume[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; dp[v]&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>01背包问题是最基本的背包问题，它包含了背包问题中设计状态、方程的最基本思想，另外，别的类型的背包问题往往也可以转换成01背包问题求解。故一定要仔细体会上面基本思路的得出方法，状态转移方程的意义，以及最后怎样优化的空间复杂度。</p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol><li><a href="https://www.acwing.com/problem/content/2/" target="_blank" rel="noopener">acwing模板题——01背包问题</a></li></ol><h1 id="P02-完全背包问题"><a href="#P02-完全背包问题" class="headerlink" title="P02: 完全背包问题"></a>P02: 完全背包问题</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</p><h2 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a>基本思路</h2><p>这个问题非常类似于01背包问题，所不同的是每种物品有无限件。也就是从每种物品的角度考虑，与它相关的策略已并非取或不取两种，而是有取0件、取1件、取2件……等很多种。如果仍然按照解01背包时的思路，令$f[i][v]$表示前$i$种物品恰放入一个容量为$v$的背包的最大权值。仍然可以按照每种物品不同的策略写出状态转移方程，像这样：$f[i][v]=max{f[i-1][v-k<em>c[i]]+k</em>w[i]|0&lt;=k<em>c[i]&lt;= v}$。这跟01背包问题一样有$O(N</em>V)$个状态需要求解，但求解每个状态的时间则不是常数了，求解状态$f[i][v]$的时间是$O(v/c[i])$，总的复杂度是超过$O(VN)$的。</p><p>将01背包问题的基本思路加以改进，得到了这样一个清晰的方法。这说明01背包问题的方程的确是很重要，可以推及其它类型的背包问题。但我们还是试图改进这个复杂度。</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="一个简单有效的优化"><a href="#一个简单有效的优化" class="headerlink" title="一个简单有效的优化"></a>一个简单有效的优化</h3><p>完全背包问题有一个很简单有效的优化，是这样的：若两件物品$i、j$满足$c[i]&lt;=c[j]$且$w[i]&gt;=w[j]$，则将物品$j$去掉，不用考虑。这个优化的正确性显然：任何情况下都可将价值小费用高的$j$换成物美价廉的$i$，得到至少不会更差的方案。对于随机生成的数据，这个方法往往会大大减少物品的件数，从而加快速度。然而这个并不能改善最坏情况的复杂度，因为有可能特别设计的数据可以一件物品也去不掉。</p><h3 id="转化为01背包问题求解"><a href="#转化为01背包问题求解" class="headerlink" title="转化为01背包问题求解"></a>转化为01背包问题求解</h3><p>既然01背包问题是最基本的背包问题，那么我们可以考虑把完全背包问题转化为01背包问题来解。最简单的想法是，考虑到第i种物品最多选$V/c [i]$件，于是可以把第$i$种物品转化为$V/c[i]$件费用及价值均不变的物品，然后求解这个01背包问题。这样完全没有改进基本思路的时间复杂度，但这毕竟给了我们将完全背包问题转化为01背包问题的思路：将一种物品拆成多件物品。</p><p>更高效的转化方法是：把第i种物品拆成费用为$c[i]<em>2^k$、价值为$w[i]</em>2^k$的若干件物品，其中$k$满足$c[i]*2^k&lt;V$。这是二进制的思想，因为不管最优策略选几件第$i$种物品，总可以表示成若干个$2^k$件物品的和。这样把每种物品拆成$O(log(V/c[i]))$件物品，是一个很大的改进。但我们有更优的$O(VN)$的算法。 </p><h3 id="O-VN-的算法"><a href="#O-VN-的算法" class="headerlink" title="$O(VN)$的算法"></a>$O(VN)$的算法</h3><p>这个算法使用一维数组，先看伪代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i=<span class="number">1.</span>.N </span><br><span class="line">    <span class="keyword">for</span> v=<span class="number">0.</span>.V </span><br><span class="line">        f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;;</span><br></pre></td></tr></table></figure><p>你会发现，这个伪代码与P01的伪代码只有v的循环次序不同而已。为什么这样一改就可行呢？首先想想为什么P01中要按照$v=V..0$的逆序来循环。这是因为要保证第$i$次循环中的状态$f[i][v]$是由状态$f[i-1][v-c[i]]$递推而来。换句话说，这正是为了保证每件物品只选一次，保证在考虑“选入第$i$件物品”这件策略时，依据的是一个绝无已经选入第$i$件物品的子结果$f[i-1][v-c[i]]$。而现在完全背包的特点恰是每种物品可选无限件，所以在考虑“加选一件第$i$种物品”这种策略时，却正需要一个可能已选入第$i$种物品的子结果$f[i][v-c[i]]$，所以就可以并且必须采用$v= 0..V$的顺序循环。这就是这个简单的程序为何成立的道理。</p><p>这个算法也可以以另外的思路得出。例如，基本思路中的状态转移方程可以等价地变形成这种形式：$f[i][v]=max{f[i-1][v],f[i][v-c[i]]+w[i]}$，将这个方程用一维数组实现，便得到了上面的伪代码。</p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">5</span>;<span class="comment">//物品最大数量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv = <span class="number">1e3</span> + <span class="number">5</span>;<span class="comment">//背包最大体积</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[maxv];<span class="comment">//背包</span></span><br><span class="line"><span class="keyword">int</span> volume[maxn], value[maxn];<span class="comment">//每个物品的体积和价值</span></span><br><span class="line"><span class="keyword">int</span> n, v;<span class="comment">//总物品数、背包体积</span></span><br><span class="line"><span class="comment">//完全背包 每种物品都有无限件可用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">complete_park</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> vol)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = vol; j &lt;= v; j++) &#123;</span><br><span class="line">        dp[j] = max(dp[j], dp[j - vol] + val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt; n&gt;&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt; volume[i]&gt;&gt; value[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        complete_park(value[i], volume[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; dp[v]&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>完全背包问题也是一个相当基础的背包问题，它有两个状态转移方程，分别在“基本思路”以及“O(VN)的算法“的小节中给出。希望你能够对这两个状态转移方程都仔细地体会，不仅记住，也要弄明白它们是怎么得出来的，最好能够自己想一种得到这些方程的方法。事实上，对每一道动态规划题目都思考其方程的意义以及如何得来，是加深对动态规划的理解、提高动态规划功力的好方法。</p><h2 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h2><ol><li><a href="https://www.acwing.com/problem/content/3/" target="_blank" rel="noopener">acwing模板题——完全背包问题</a></li></ol><h1 id="P03-多重背包问题"><a href="#P03-多重背包问题" class="headerlink" title="P03: 多重背包问题"></a>P03: 多重背包问题</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>有N种物品和一个容量为V的背包。第i种物品最多有n[i]件可用，每件费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</p><h2 id="基本思路-2"><a href="#基本思路-2" class="headerlink" title="基本思路"></a>基本思路</h2><p>这题目和完全背包问题很类似。基本的方程只需将完全背包问题的方程略微一改即可，因为对于第$i$种物品有$n[i]+1$种策略：取0件，取1件……取 $n[i]$件。令$f[i][v]$表示前$i$种物品恰放入一个容量为$v$的背包的最大权值，则：$f[i][v]=max{f[i-1][v-k<em>c[i]]+ k</em>w[i]|0&lt;=k&lt;=n[i]}$。复杂度是$O(V*∑n[i])$。</p><h2 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h2><h3 id="转化为01背包问题"><a href="#转化为01背包问题" class="headerlink" title="转化为01背包问题"></a>转化为01背包问题</h3><p>另一种好想好写的基本方法是转化为01背包求解：把第$i$种物品换成$n[i]$件01背包中的物品，则得到了物品数为$∑n[i]$的01背包问题，直接求解，复杂度仍然是$O(V*∑n[i])$。</p><p>但是我们期望将它转化为01背包问题之后能够像完全背包一样降低复杂度。仍然考虑二进制的思想，我们考虑把第$i$种物品换成若干件物品，使得原问题中第i种物品可取的每种策略——取$0..n[i]$件——均能等价于取若干件代换以后的物品。另外，取超过$n[i]$件的策略必不能出现。</p><p>方法是：将第$i$种物品分成若干件物品，其中每件物品有一个系数，这件物品的费用和价值均是原来的费用和价值乘以这个系数。使这些系数分别为 $1,2,4,…,2^{k-1},n[i]-2^k+1$，且$k$是满足$n[i]-2^k+1&gt;0$的最大整数。例如，如果$n[i]$为$13$，就将这种物品分成系数分别为$1,2,4,6$的四件物品。</p><p>分成的这几件物品的系数和为$n[i]$，表明不可能取多于$n[i]$件的第i种物品。另外这种方法也能保证对于$0..n[i]$间的每一个整数，均可以用若干个系数的和表示，这个证明可以分$0..2^{k-1}$和$2^k..n[i]$两段来分别讨论得出，并不难，希望你自己思考尝试一下。</p><p>这样就将第$i$种物品分成了$O(log n[i])$种物品，将原问题转化为了复杂度为$O(V*∑log n[i])$的01背包问题，是很大的改进。</p><h3 id="O-VN-的算法-1"><a href="#O-VN-的算法-1" class="headerlink" title="* $O(VN)$的算法"></a>* $O(VN)$的算法</h3><p>多重背包问题同样有$O(VN)$的算法。这个算法基于基本算法的状态转移方程，但应用单调队列的方法使每个状态的值可以以均摊$O(1)$的时间求解。由于用单调队列优化的DP已超出了NOIP的范围，故本文不再展开讲解。我最初了解到这个方法是在楼天成的“男人八题”幻灯片上。</p><h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">5</span>;<span class="comment">//物品最大数量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv = <span class="number">1e3</span> + <span class="number">5</span>;<span class="comment">//背包最大体积</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[maxv];<span class="comment">//背包</span></span><br><span class="line"><span class="keyword">int</span> volume[maxn], value[maxn], c[maxn];<span class="comment">//每个物品的体积和价值、数量</span></span><br><span class="line"><span class="keyword">int</span> n, v;<span class="comment">//总物品数、背包体积</span></span><br><span class="line"><span class="comment">//01背包 每种物品仅有一件，可以选择放或不放</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zero_one_park</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> vol)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = v; j &gt;= vol; j--) &#123;</span><br><span class="line">        dp[j] = max(dp[j], dp[j - vol] + val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//完全背包 每种物品都有无限件可用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">complete_park</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> vol)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = vol; j &lt;= v; j++) &#123;</span><br><span class="line">        dp[j] = max(dp[j], dp[j - vol] + val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//多重背包 每种物品都有限件可用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multiple_park</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> vol, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vol * amount &gt;= v) &#123;<span class="comment">//该种物品足以装满背包，转化为完全背包</span></span><br><span class="line">        complete_park(val, vol);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//转化为01背包，将第i种物品分成若干件物品</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; amount) &#123;</span><br><span class="line">            zero_one_park(k * val, k * vol);</span><br><span class="line">            amount -= k;</span><br><span class="line">            k &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (amount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            zero_one_park(amount * val, amount * vol);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt; n&gt;&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt; volume[i]&gt;&gt; value[i]&gt;&gt; c[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        multiple_park(value[i], volume[i], c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; dp[v]&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><p>这里我们看到了将一个算法的复杂度由$O(V<em>∑n[i])$改进到$O(V</em>∑log n[i])$的过程，还知道了存在应用超出NOIP范围的知识的O(VN)算法。希望你特别注意“拆分物品”的思想和方法，自己证明一下它的正确性，并用尽量简洁的程序来实现。</p><h2 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h2><ol><li><a href="https://www.acwing.com/problem/content/4/" target="_blank" rel="noopener">acwing模板题——多重背包问题 I</a></li><li><a href="https://www.acwing.com/problem/content/5/" target="_blank" rel="noopener">acwing模板题——多重背包问题 II</a>：本题考查多重背包的二进制优化方法。</li></ol><h1 id="P04-混合三种背包问题"><a href="#P04-混合三种背包问题" class="headerlink" title="P04: 混合三种背包问题"></a>P04: 混合三种背包问题</h1><h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h2><p>如果将P01、P02、P03混合起来。也就是说，有的物品只可以取一次（01背包），有的物品可以取无限次（完全背包），有的物品可以取的次数有一个上限（多重背包）。应该怎么求解呢？</p><h2 id="01背包与完全背包的混合"><a href="#01背包与完全背包的混合" class="headerlink" title="01背包与完全背包的混合"></a>01背包与完全背包的混合</h2><p>考虑到在P01和P02中最后给出的伪代码只有一处不同，故如果只有两类物品：一类物品只能取一次，另一类物品可以取无限次，那么只需在对每个物品应用转移方程时，根据物品的类别选用顺序或逆序的循环即可，复杂度是$O(VN)$。伪代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i=<span class="number">1.</span>.N</span><br><span class="line"><span class="keyword">if</span> 第i件物品是<span class="number">01</span>背包</span><br><span class="line"><span class="keyword">for</span> v=V.<span class="number">.0</span></span><br><span class="line">f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> 第i件物品是完全背包</span><br><span class="line"><span class="keyword">for</span> v=<span class="number">0.</span>.V</span><br><span class="line">f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;;</span><br></pre></td></tr></table></figure><h2 id="再加上多重背包"><a href="#再加上多重背包" class="headerlink" title="再加上多重背包"></a>再加上多重背包</h2><p>如果再加上有的物品最多可以取有限次，那么原则上也可以给出$O(VN)$的解法：遇到多重背包类型的物品用单调队列解即可。但如果不考虑超过NOIP范围的算法的话，用P03中将每个这类物品分成$O(log n[i])$个01背包的物品的方法也已经很优了。</p><h2 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h2><p>有人说，困难的题目都是由简单的题目叠加而来的。这句话是否公理暂且存之不论，但它在本讲中已经得到了充分的体现。本来01背包、完全背包、多重背包都不是什么难题，但将它们简单地组合起来以后就得到了这样一道一定能吓倒不少人的题目。但只要基础扎实，领会三种基本背包问题的思想，就可以做到把困难的题目拆分成简单的题目来解决。</p><h2 id="练习-3"><a href="#练习-3" class="headerlink" title="练习"></a>练习</h2><ol><li><a href="acwing.com/problem/content/7/">acwing模板题——混合背包问题</a></li></ol><h1 id="P05-二维费用的背包问题"><a href="#P05-二维费用的背包问题" class="headerlink" title="P05: 二维费用的背包问题"></a>P05: 二维费用的背包问题</h1><h2 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h2><p>二维费用的背包问题是指：对于每件物品，具有两种不同的费用；选择这件物品必须同时付出这两种代价；对于每种代价都有一个可付出的最大值（背包容量）。问怎样选择物品可以得到最大的价值。设这两种代价分别为代价1和代价2，第i件物品所需的两种代价分别为$a[i]$和$b[i]$。两种代价可付出的最大值（两种背包容量）分别为$V$和$U$。物品的价值为$w[i]$。</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>费用加了一维，只需状态也加一维即可。设$f[i][v][u]$表示前$i$件物品付出两种代价分别为$v$和$u$时可获得的最大价值。状态转移方程就是：$f [i][v][u]=max{f[i-1][v][u],f[i-1][v-a[i]][u-b[i]]+w[i]}$。如前述方法，可以只使用二维的数组：当每件物品只可以取一次时变量$v$和$u$采用逆序的循环，当物品有如完全背包问题时采用顺序的循环。当物品有如多重背包问题时拆分物品。</p><h2 id="物品总个数的限制"><a href="#物品总个数的限制" class="headerlink" title="物品总个数的限制"></a>物品总个数的限制</h2><p>有时，“二维费用”的条件是以这样一种隐含的方式给出的：最多只能取$M$件物品。这事实上相当于每件物品多了一种“件数”的费用，每个物品的件数费用均为$1$，可以付出的最大件数费用为$M$。换句话说，设$f[v][m]$表示付出费用$v$、最多选$m$件时可得到的最大价值，则根据物品的类型（01、完全、多重）用不同的方法循环更新，最后在$f[0..V][0..M]$范围内寻找答案。</p><p>另外，如果要求“恰取M件物品”，则在$f[0..V][M]$范围内寻找答案。</p><h2 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">5</span>;<span class="comment">//物品最大数量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv = <span class="number">1e2</span> + <span class="number">5</span>;<span class="comment">//背包最大体积</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxw = <span class="number">1e2</span> + <span class="number">5</span>;<span class="comment">//背包最大承受重量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[maxv][maxw];<span class="comment">//背包</span></span><br><span class="line"><span class="keyword">int</span> volume[maxn], value[maxn], weight[maxn];<span class="comment">//每个物品的体积和价值、重量</span></span><br><span class="line"><span class="keyword">int</span> n, v, w;<span class="comment">//总物品数、背包体积、背包承受重量</span></span><br><span class="line"><span class="comment">//二维01背包</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">two_dimension_park</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> wei, <span class="keyword">int</span> vol)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = v; j &gt;= vol; j--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = w; k &gt;= wei; k--) &#123;</span><br><span class="line">            dp[j][k] = max(dp[j][k], dp[j - vol][k - wei] + val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt; n&gt;&gt; v&gt;&gt; w;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt; volume[i]&gt;&gt; weight[i]&gt;&gt; value[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        two_dimension_park(value[i], weight[i],volume[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; dp[v][w]&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h2><p>事实上，当发现由熟悉的动态规划题目变形得来的题目时，在原来的状态中加一维以满足新的限制是一种比较通用的方法。希望你能从本讲中初步体会到这种方法。</p><h2 id="练习-4"><a href="#练习-4" class="headerlink" title="练习"></a>练习</h2><ol><li><a href="https://www.acwing.com/problem/content/8/" target="_blank" rel="noopener">acwing模板题——二维费用的背包问题</a></li></ol><h1 id="P06-分组背包问题"><a href="#P06-分组背包问题" class="headerlink" title="P06: 分组背包问题"></a>P06: 分组背包问题</h1><h2 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h2><p>有$N$件物品和一个容量为$V$的背包。第$i$件物品的费用是$c[i]$，价值是$w[i]$。这些物品被划分为若干组，每组中的物品互相冲突，最多选一件。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</p><h2 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h2><p>这个问题变成了每组物品有若干种策略：是选择本组的某一件，还是一件都不选。也就是说设$f[k][v]$表示前$k$组物品花费费用$v$能取得的最大权值，则有$f[k][v]=max{f[k-1][v],f[k-1][v-c[i]]+w[i]|物品i属于第k组}$。</p><p>使用一维数组的伪代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 所有的组k</span><br><span class="line">    <span class="keyword">for</span> v=V.<span class="number">.0</span></span><br><span class="line">        <span class="keyword">for</span> 所有的i属于组k</span><br><span class="line">            f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;</span><br></pre></td></tr></table></figure><p>注意这里的三层循环的顺序，“for v=V..0”这一层循环必须在“for 所有的i属于组k”之外。这样才能保证每一组内的物品最多只有一个会被添加到背包中。</p><p>另外，显然可以对每组中的物品应用P02中“一个简单有效的优化”。</p><h2 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e2</span> + <span class="number">5</span>;<span class="comment">//物品最大数量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv = <span class="number">1e2</span> + <span class="number">5</span>;<span class="comment">//背包最大体积</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[maxv];<span class="comment">//背包</span></span><br><span class="line"><span class="keyword">int</span> volume[maxn], value[maxn];<span class="comment">//每个物品的体积和价值</span></span><br><span class="line"><span class="keyword">int</span> n, v;<span class="comment">//物品组数、背包体积</span></span><br><span class="line"><span class="comment">//分组背包 物品被划分为若干组，每组最多选一件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">group_park</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> vol)</span> </span>&#123;<span class="comment">//物品组数、背包最大容量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t;<span class="comment">//每组的个数</span></span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt; t;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; i++) &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt; volume[i]&gt;&gt; value[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从前k组中选</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = vol; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= t; l++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (volume[l] &lt;= j) &#123;</span><br><span class="line">                    dp[j] = max(dp[j], dp[j - volume[l]] + value[l]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt; n&gt;&gt; v;</span><br><span class="line">    group_park(n, v);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; dp[v]&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h2><p>分组的背包问题将彼此互斥的若干物品称为一个组，这建立了一个很好的模型。不少背包问题的变形都可以转化为分组的背包问题（例如P07），由分组的背包问题进一步可定义“泛化物品”的概念，十分有利于解题。</p><h2 id="练习-5"><a href="#练习-5" class="headerlink" title="练习"></a>练习</h2><ol><li><a href="acwing.com/problem/content/9/">acwing模板题——分组背包问题</a></li><li><a href="https://ac.nowcoder.com/acm/problem/14602" target="_blank" rel="noopener">牛客——xinjun与阴阳师</a></li></ol><h1 id="P07-有依赖的背包问题"><a href="#P07-有依赖的背包问题" class="headerlink" title="* P07: 有依赖的背包问题"></a>* P07: 有依赖的背包问题</h1><h2 id="简化的问题"><a href="#简化的问题" class="headerlink" title="简化的问题"></a>简化的问题</h2><p>这种背包问题的物品间存在某种“依赖”的关系。也就是说，$i$依赖于$j$，表示若选物品$i$，则必须选物品$j$。为了简化起见，我们先设没有某个物品既依赖于别的物品，又被别的物品所依赖；另外，没有某件物品同时依赖多件物品。</p><h2 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h2><p>这个问题由NOIP2006金明的预算方案一题扩展而来。遵从该题的提法，将不依赖于别的物品的物品称为“主件”，依赖于某主件的物品称为“附件”。由这个问题的简化条件可知所有的物品由若干主件和依赖于每个主件的一个附件集合组成。</p><p>按照背包问题的一般思路，仅考虑一个主件和它的附件集合。可是，可用的策略非常多，包括：一个也不选，仅选择主件，选择主件后再选择一个附件，选择主件后再选择两个附件……无法用状态转移方程来表示如此多的策略。（事实上，设有$n$个附件，则策略有$2^n+1$个，为指数级）</p><p>考虑到所有这些策略都是互斥的（也就是说，你只能选择一种策略），所以一个主件和它的附件集合实际上对应于 P06 中的一个物品组，每个选择了主件又选择了若干个附件的策略对应于这个物品组中的一个物品，其费用和价值都是这个策略中的物品的值的和。但仅仅是这一步转化并不能给出一个好的算法，因为物品组中的物品还是像原问题的策略一样多。</p><p>再考虑P06中的一句话： <em>可以对每组中的物品应用P02中“一个简单有效的优化”</em>。 这提示我们，对于一个物品组中的物品，所有费用相同的物品只留一个价值最大的，不影响结果。所以，我们可以对主件$i$的“附件集合”先进行一次01背包，得到费用依次为$0..V-c[i]$所有这些值时相应的最大价值$f’[0..V-c[i]]$。那么这个主件及它的附件集合相当于$V-c[i]+1$个物品的物品组，其中费用为$c[i]+k$的物品的价值为$f’[k]+w[i]$。也就是说原来指数级的策略中有很多策略都是冗余的，通过一次01背包后，将主件$i$转化为$V-c[i]+1$个物品的物品组，就可以直接应用P06的算法解决问题了。</p><h2 id="较一般的问题"><a href="#较一般的问题" class="headerlink" title="较一般的问题"></a>较一般的问题</h2><p>更一般的问题是：依赖关系以图论中“森林”的形式给出（森林即多叉树的集合），也就是说，主件的附件仍然可以具有自己的附件集合，限制只是每个物品最多只依赖于一个物品（只有一个主件）且不出现循环依赖。</p><p>解决这个问题仍然可以用将每个主件及其附件集合转化为物品组的方式。唯一不同的是，由于附件可能还有附件，就不能将每个附件都看作一个一般的01背包中的物品了。若这个附件也有附件集合，则它必定要被先转化为物品组，然后用分组的背包问题解出主件及其附件集合所对应的附件组中各个费用的附件所对应的价值。</p><p>事实上，这是一种树形DP，其特点是每个父节点都需要对它的各个儿子的属性进行一次DP以求得自己的相关属性。这已经触及到了“泛化物品”的思想。看完P08后，你会发现这个“依赖关系树”每一个子树都等价于一件泛化物品，求某节点为根的子树对应的泛化物品相当于求其所有儿子的对应的泛化物品之和。</p><h2 id="具体思路"><a href="#具体思路" class="headerlink" title="具体思路"></a>具体思路</h2><p>dfs在遍历到 $x$ 结点时，先考虑一定选上根节点 $x$ ，因此初始化 $f[x][v[x]…m] = w[x]$<br>在分组背包部分：<br>$j$ 的范围 $[ m , v[x] ] $小于$v[x]$则没有意义因为连根结点都放不下；<br>$k$的范围$ [ 0 , j-v[x] ]$，当大于$j-v[x]$时分给该子树的容量过多，剩余的容量连根节点的物品都放不下了；</p><h2 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">5</span>;<span class="comment">//物品最大数量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv = <span class="number">1e2</span> + <span class="number">5</span>;<span class="comment">//背包最大体积</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxv];<span class="comment">//dp[x][v]表达选择以x为子树的物品，在容量不超过v时所获得的最大价值</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tree[maxn];<span class="comment">//树，存放依赖关系</span></span><br><span class="line"><span class="keyword">int</span> volume[maxn], value[maxn];<span class="comment">//每个物品的体积和价值</span></span><br><span class="line"><span class="keyword">int</span> n, v, root;<span class="comment">//总物品数、背包容量、树根结点</span></span><br><span class="line"><span class="comment">//有依赖的背包</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = volume[x]; i &lt;= v; i++) dp[x][i] = value[x];<span class="comment">//点x必须选，所以初始化dp[x][value[x] ~ v]= value[x]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tree[x].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> son = tree[x][i];</span><br><span class="line">        dfs(son);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = v; j &gt;= volume[x]; j--) &#123;<span class="comment">//j的范围为value[x]~v, 小于value[x]无法选择以x为子树的物品</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= j - volume[x]; k++) &#123;<span class="comment">//分给子树son的空间不能大于j-value[x],不然都无法选根物品x</span></span><br><span class="line">                dp[x][j] = max(dp[x][j], dp[x][j - k] + dp[son][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt; n&gt;&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> fa;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt; volume[i]&gt;&gt; value[i]&gt;&gt; fa;</span><br><span class="line">        <span class="keyword">if</span> (fa == <span class="number">-1</span>)</span><br><span class="line">            root = i;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tree[fa].push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; dp[root][v];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h2><p>NOIP2006的那道背包问题我做得很失败，写了上百行的代码，却一分未得。后来我通过思考发现通过引入“物品组”和“依赖”的概念可以加深对这题的理解，还可以解决它的推广问题。用物品组的思想考虑那题中极其特殊的依赖关系：物品不能既作主件又作附件，每个主件最多有两个附件，可以发现一个主件和它的两个附件等价于一个由四个物品组成的物品组，这便揭示了问题的某种本质。</p><p>我想说：失败不是什么丢人的事情，从失败中全无收获才是。</p><h2 id="练习-6"><a href="#练习-6" class="headerlink" title="练习"></a>练习</h2><ol><li><a href="https://www.acwing.com/problem/content/10/" target="_blank" rel="noopener">acwing模板题——有依赖的背包问题</a></li></ol><h1 id="P08-泛化物品"><a href="#P08-泛化物品" class="headerlink" title="* P08: 泛化物品"></a>* P08: 泛化物品</h1><h2 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h2><h2 id="算法-3"><a href="#算法-3" class="headerlink" title="算法"></a>算法</h2><h2 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h2><h2 id="练习-7"><a href="#练习-7" class="headerlink" title="练习"></a>练习</h2><h1 id="P09-背包问题问法的变化"><a href="#P09-背包问题问法的变化" class="headerlink" title="P09: 背包问题问法的变化"></a>P09: 背包问题问法的变化</h1><h2 id="输出方案"><a href="#输出方案" class="headerlink" title="输出方案"></a>输出方案</h2><h2 id="输出字典序最小的最优方案"><a href="#输出字典序最小的最优方案" class="headerlink" title="输出字典序最小的最优方案"></a>输出字典序最小的最优方案</h2><p>这里“字典序最小”的意思是$1…N$号物品的选择方案排列出来以后字典序最小。以输出01背包最小字典序的方案为例。</p><p>题目要求输出字典序最小的解，假设存在一个包含第1个物品的最优解，为了确保字典序最小那么我们必然要选第一个。那么问题就转化成从$2～N$这些物品中找到最优解。之前的$f(i,j)$记录的都是前$i$个物品总容量为$j$的最优解，那么我们现在将$f(i,j)$定义为从第$i$个元素到最后一个元素总容量为$j$的最优解。接下来考虑状态转移：</p><p>$f(i,j)=max{f(i+1,j),f(i+1,j−v[i])+w[i]}$<br>两种情况，第一种是不选第$i$个物品，那么最优解等同于从第$i+1$个物品到最后一个元素总容量为$j$的最优解；第二种是选了第$i$个物品，那么最优解等于当前物品的价值$w[i]$加上从第$i+1$个物品到最后一个元素总容量为$j−v[i]$的最优解。</p><p>计算完状态表示后，考虑如何的到最小字典序的解。首先$f(1,m)$肯定是最大价值，那么我们便开始考虑能否选取第1个物品呢。</p><p>如果$f(1,m)=f(2,m−v[1])+w[1]$，说明选取了第1个物品可以得到最优解。</p><p>如果$f(1,m)=f(2,m)$，说明不选取第一个物品才能得到最优解。</p><p>如果$f(1,m)=f(2,m)=f(2,m−v[1])+w[1]$，说明选不选都可以得到最优解，但是为了考虑字典序最小，我们也需要选取该物品。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">5</span>;<span class="comment">//物品最大数量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv = <span class="number">1e3</span> + <span class="number">5</span>;<span class="comment">//背包最大体积</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxv];<span class="comment">//从第i个元素到最后一个元素总容量为j的最优解</span></span><br><span class="line"><span class="keyword">int</span> volume[maxn], value[maxn];<span class="comment">//每个物品的体积和价值</span></span><br><span class="line"><span class="keyword">int</span> n, v;<span class="comment">//总物品数、背包体积</span></span><br><span class="line"><span class="comment">//01背包 每种物品仅有一件，可以选择放或不放</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">optimal_park</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> vol, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= v; j++) &#123;</span><br><span class="line">        dp[i][j] = dp[i + <span class="number">1</span>][j];</span><br><span class="line">        <span class="keyword">if</span>(j &gt;= vol)</span><br><span class="line">            dp[i][j] = max(dp[i][j], dp[i + <span class="number">1</span>][j - vol] + val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt; n&gt;&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt; volume[i]&gt;&gt; value[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        optimal_park(value[i], volume[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出</span></span><br><span class="line">    <span class="keyword">int</span> cur_v = v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++) &#123;   </span><br><span class="line">        <span class="keyword">if</span> (i == n &amp;&amp; cur_v &gt;= volume[i]) &#123;<span class="comment">//如果是最后一个元素，特判一下，防止越界即可</span></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt; i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur_v &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//判断下标是否越界</span></span><br><span class="line">        <span class="keyword">if</span> (cur_v - volume[i]&gt;=<span class="number">0</span> &amp;&amp; dp[i][cur_v] == dp[i + <span class="number">1</span>][cur_v - volume[i]] + value[i]) &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt; i&lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            cur_v = cur_v - volume[i];<span class="comment">//选了第i个物品，剩余容量就要减小。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求方案总数"><a href="#求方案总数" class="headerlink" title="求方案总数"></a>求方案总数</h2><h2 id="最优方案的总数"><a href="#最优方案的总数" class="headerlink" title="最优方案的总数"></a>最优方案的总数</h2><p>这里的最优方案是指物品总价值最大的方案。以01背包为例。</p><p>时间复杂度 $O(nm)$<br>定义两个数组：$f[maxv]$，$cnt[maxv]$：$f[i]$ 用来存储背包容积为 $i$ 时的最佳方案的总价值，$cnt[i]$为背包容积为 $i$ 时总价值为最佳的方案数。</p><p>先初始化所有的 $cnt[i]$ 为 1，因为背包里什么也不装也是一种方案。</p><p>外层循环 $n$ 次，每次读入新物品的 $v,w$</p><p>求出装新物品时的总价值，与不装新物品时作对比</p><p>如果装新物品的方案总价值更大，那么用 $f[j−v]+w$ 来更新 $f[j]$，用 $cnt[j−v]$ 更新 $cnt[j]$<br>如果总价值相等，那么最大价值的方案数就多了 $cnt[j−v]$ 种。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">5</span>;<span class="comment">//物品最大数量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv = <span class="number">1e3</span> + <span class="number">5</span>;<span class="comment">//背包最大体积</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod  = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[maxv], cnt[maxv];<span class="comment">//背包，最优方案总数</span></span><br><span class="line"><span class="keyword">int</span> volume[maxn], value[maxn];<span class="comment">//每个物品的体积和价值</span></span><br><span class="line"><span class="keyword">int</span> n, v;<span class="comment">//总物品数、背包体积</span></span><br><span class="line"><span class="comment">//01背包 求解最优方案总数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">optimal_sum_park</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> vol)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = v; j &gt;= vol; j--) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = dp[j - vol] + val;</span><br><span class="line">        <span class="keyword">if</span> (tmp &gt; dp[j]) &#123;</span><br><span class="line">            dp[j] = tmp;</span><br><span class="line">            cnt[j] = cnt[j - vol];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tmp == dp[j]) &#123;</span><br><span class="line">            cnt[j] = (cnt[j] + cnt[j - vol]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt; n&gt;&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt; volume[i]&gt;&gt; value[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= v; i++) &#123;</span><br><span class="line">        cnt[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        optimal_sum_park(value[i], volume[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; cnt[v]&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结-8"><a href="#小结-8" class="headerlink" title="小结"></a>小结</h2><p>显然，这里不可能穷尽背包类动态规划问题所有的问法。甚至还存在一类将背包类动态规划问题与其它领域（例如数论、图论）结合起来的问题，在这篇论背包问题的专文中也不会论及。但只要深刻领会前述所有类别的背包问题的思路和状态转移方程，遇到其它的变形问法，只要题目难度还属于NOIP，应该也不难想出算法。</p><p>触类旁通、举一反三，应该也是一个OIer应有的品质吧。</p><h2 id="练习-8"><a href="#练习-8" class="headerlink" title="练习"></a>练习</h2><ol><li><a href="https://www.acwing.com/problem/content/11/" target="_blank" rel="noopener">acwing模板题——背包问题求方案数</a></li><li><a href></a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最短路</title>
      <link href="/2021/04/09/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
      <url>/2021/04/09/%E6%9C%80%E7%9F%AD%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>　　最短路问题分为两类：<strong>单源最短路</strong>和<strong>多源最短路</strong>。前者只需要求一个<strong>固定的起点</strong>到各个顶点的最短路径，后者则要求得出<strong>任意两个顶点</strong>之间的最短路径。</p><ul><li><strong>单源 Dijkstra算法</strong>：<ul><li><strong>优点</strong>：时间复杂度稳定$O(n^2)$，堆优化能达到$O(ElogE)$；也可解决多源最短路，总的时间复杂度也是$O(n^3)$</li><li><strong>缺点</strong>：不能处理负边</li></ul></li><li><strong>单源 Bellman-Ford算法</strong>：<ul><li><strong>优点</strong>：其优于Dijkstra算法的方面是边的权值可以为负数、实现简单</li><li><strong>缺点</strong>：时间复杂度过高，高达$O(V*E)$；但算法可以进行若干种优化，提高了效率。</li></ul></li><li><strong>单源 SPFA算法</strong>：<ul><li><strong>优点</strong>：快于Bellman-Ford，据说随机数据下期望时间复杂度是$O(m+nlogn)$</li><li><strong>缺点</strong>：时间复杂度<strong>不稳定</strong>，最坏情况可以被卡成Bellman-Ford，也就是$O(V*E)$</li></ul></li><li><strong>全源 Floyd算法</strong>：<ul><li><strong>优点</strong>：算法简洁，可以解决负权图</li><li><strong>缺点</strong>：时间复杂度为$O(n^3)$，空间复杂度为$O(n^2)$，都比较高，所以只适用于数据规模较小的情形；不能解决负环图</li></ul></li><li><strong>全源 Johnson算法</strong>：<ul><li><strong>优点</strong>：相对于Floyd算法时间复杂度低，$O(nmlogm)$；</li><li><strong>缺点</strong>：无负环图、算法较繁琐</li></ul></li><li><strong>BFS算法</strong>：<ul><li><strong>优点</strong>：</li><li><strong>缺点</strong>：只能解决无权图</li></ul></li></ul><h1 id="1-单源-Dijkstra算法"><a href="#1-单源-Dijkstra算法" class="headerlink" title="1 单源 Dijkstra算法"></a>1 单源 Dijkstra算法</h1><p><strong>贪心</strong>的思想，不断取出<strong>离顶点最近</strong>而<strong>没有被访问过</strong>的点，松弛它和它能到达的所有点。</p><blockquote><p>对于每个顶点v∈V，都设置一个属性d[v]，用来描述从源点s到v的最短路径上权值的上界，称为最短路径估计（shortest-pathestimate）。</p><p>π[v]代表S到v的当前最短路径中v点之前的一个点的编号,我们用下面的Θ(V)时间的过程来对最短路径估计和前趋进行初始化。</p><p>在松弛一条边(u,v)的过程中，要测试是否可以通过u，对迄今找到的v的最短路径进行改进；如果可以改进的话，则更新d[v]和π[v]。一次松弛操作可以减小最短路径估计的值d[v]，并更新v的前趋域$π[v]$(S到v的当前最短路径中v点之前的一个点的编号)。</p></blockquote><p><strong>打印路径</strong>：只需要用一个pre[]数组存储每个点的<strong>父节点</strong>即可。（单源最短路的起点是固定的，所以每条路有且仅有一个祖先节点，一步步溯源上去的路径是唯一的。相反，这里不能存<strong>子节点</strong>，因为从源点下去，有很多条最短路径）</p><p>参考：<a href="https://zhuanlan.zhihu.com/p/96621396" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/96621396</a></p><p><strong>朴素Dijkstra</strong>：时间复杂度是 $O(n^2+m)$, $n$ 表示点数，$m$ 表示边数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e2</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g[maxn][maxn];  <span class="comment">// 存储每条边</span></span><br><span class="line"><span class="keyword">int</span> dist[maxn];  <span class="comment">// 存储1号点到每个点的最短距离</span></span><br><span class="line"><span class="keyword">bool</span> st[maxn];   <span class="comment">// 存储每个点的最短路是否已经确定</span></span><br><span class="line"><span class="keyword">int</span> n;<span class="comment">//点数</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 求1号点到n号点的最短路，如果不存在则返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ ) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">-1</span>;     <span class="comment">// 在还未确定最短路的点中，寻找距离最小的点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用t更新其他点的距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            dist[j] = min(dist[j], dist[t] + g[t][j]);</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>堆优化Dijkstra</strong>：时间复杂度 $O(mlogn)$, $n$ 表示点数，$m$ 表示边数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1.5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;      <span class="comment">// 点的数量</span></span><br><span class="line"><span class="keyword">int</span> h[maxn], w[maxn], e[maxn], ne[maxn], idx;  <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="keyword">int</span> dist[maxn];        <span class="comment">// 存储所有点到1号点的距离</span></span><br><span class="line"><span class="keyword">bool</span> st[maxn];     <span class="comment">// 存储每个点的最短距离是否已确定</span></span><br><span class="line"><span class="comment">//加边</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    w[idx] = c; <span class="comment">// 有重边也不要紧，假设1-&gt;2有权重为2和3的边，再遍历到点1的时候2号点的距离会更新两次放入堆中</span></span><br><span class="line">    e[idx] = y; <span class="comment">// 这样堆中会有很多冗余的点，但是在弹出的时候还是会弹出最小值2+x（x为之前确定的最短路径），并</span></span><br><span class="line">    ne[idx] = h[x]; <span class="comment">// 标记st为true，所以下一次弹出3+x会continue不会向下执行。</span></span><br><span class="line">    h[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 求1号点到n号点的最短距离，如果不存在，则返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;PII, <span class="built_in">vector</span>&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;</span><br><span class="line">    heap.push(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;);      <span class="comment">// first存储距离，second存储节点编号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (heap.size()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.top();</span><br><span class="line">        heap.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ver = t.second, distance = t.first;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[ver]; i != <span class="number">-1</span>; i = ne[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; distance + w[i]) &#123;</span><br><span class="line">                dist[j] = distance + w[i];</span><br><span class="line">                heap.push(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-单源-Bellman-Ford算法"><a href="#2-单源-Bellman-Ford算法" class="headerlink" title="2 单源 Bellman-Ford算法"></a>2 单源 Bellman-Ford算法</h1><p>一维数组dist[]来存储每个点到起点的距离，初始化dist[S]  = 0，其他初始化为INF。</p><p>找到从起点到某个点的最短路，设起点为S，终点为D，那这条最短路一定是$S-&gt;P_1-&gt;P_2-&gt;…-&gt;D$的形式，假设<strong>没有负权环</strong>，那这条路径上的点的总个数一定<strong>不大于n</strong>。</p><p>定义对点x, y的松弛操作是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dist[y] = min(dist[y], dist[x] + e[x][y]);<span class="comment">//这里的e[x][y]表示x、y之间的距离，具体形式可能根据存图方法不同而改变</span></span><br></pre></td></tr></table></figure><p>松弛操作就相当于考察能否<strong>经由x点</strong>使<strong>起点到y点</strong>的距离变短。</p><p>所以要找到最短路，只需要进行以下步骤：</p><ol><li>先松弛$S$, $P_1$，此时$dist[P_1]$必然等于$e[S][P_1]$</li><li>再松弛$P_1, P_2$，因为$S-&gt;P_1-&gt;P_2$是最短路的一部分，<strong>最短路的子路也是最短路</strong>（这是显然的），所以$dist[P_2]$不可能小于$dist[P_1]+e[P_1][P_2]$，因此它会被更新为$dist[P1]+e[P1][P2]$，即$e[S][P1]+e[P1][P2]$。</li><li>再松弛$P2, P3$，……以此类推，最终$dist[D]$必然等于$e[S][P1]+e[P1][P2]+…$，这恰好就是最短路径。</li></ol><p><strong>把所有边松弛n-1遍！</strong></p><p><a href="https://zhuanlan.zhihu.com/p/96621396" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/96621396</a></p><p><a href="https://blog.csdn.net/luomingjun12315/article/details/50377525" target="_blank" rel="noopener">https://blog.csdn.net/luomingjun12315/article/details/50377525</a></p><h1 id="3-单源-SPFA算法"><a href="#3-单源-SPFA算法" class="headerlink" title="3 单源 SPFA算法"></a>3 单源 SPFA算法</h1><p><strong>SPFA算法</strong>，也就是<strong>队列优化</strong>的Bellman-Ford算法，维护一个队列。</p><h1 id="4-全源-Floyd算法"><a href="#4-全源-Floyd算法" class="headerlink" title="4 全源 Floyd算法"></a>4 全源 Floyd算法</h1><p>求出每一对顶点之间的最短路径。Floyd本质上是一个<strong>动态规划</strong>的思想，每一次循环更新<strong>经由k点，i到j的最短路径</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算法结束后，d[a][b]表示a到b的最短距离，path存放路径信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//初始化：</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (i == j) d[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> d[i][j] = inf;</span><br><span class="line">    <span class="comment">//memset(path, -1, sizeof path);</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//dp </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k ++ ) &#123;<span class="comment">//考虑以k为中转点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ ) &#123;</span><br><span class="line">                <span class="keyword">if</span> (d[i][j] &gt; d[i][k] + d[k][j]) &#123;<span class="comment">//以k为中转点的路径更短</span></span><br><span class="line">                d[i][j] = d[i][k] + d[k][j];<span class="comment">//更新最短路径长度</span></span><br><span class="line">                    <span class="comment">//path[i][j] = k;//中转点</span></span><br><span class="line">                &#125;     </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-全源-Johnson算法"><a href="#5-全源-Johnson算法" class="headerlink" title="5 全源 Johnson算法"></a>5 全源 Johnson算法</h1><h1 id="6-BFS算法"><a href="#6-BFS算法" class="headerlink" title="6 BFS算法"></a>6 BFS算法</h1><p>该算法求单源最短路径只适用于无权图，或所有边的权值都相同的图。</p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><ol><li><a href="https://www.acwing.com/problem/content/851/" target="_blank" rel="noopener">acwing模板题目——Dijkstra求最短路 I</a></li><li><a href="https://www.acwing.com/problem/content/852/" target="_blank" rel="noopener">Dijkstra求最短路 II</a></li><li></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集</title>
      <link href="/2021/04/09/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
      <url>/2021/04/09/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="简介"><a href="#简介" class="headerlink" title="简介　　"></a>简介　　</h1><p>英文：Disjoint Set，即“不相交集合”。将编号分别为$1…N$的$N$个对象划分为不相交集合，在每个集合中，选择其中某个元素代表所在集合。常见两种操作：</p><ol><li>合<strong>并</strong>两个集合；</li><li><strong>查</strong>找某元素属于哪个集合。</li></ol><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="1-无优化"><a href="#1-无优化" class="headerlink" title="1 无优化"></a>1 无优化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>;</span><br><span class="line"><span class="keyword">int</span> node[maxn];<span class="comment">//每个节点的父节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n; i++ )&#123;</span><br><span class="line">        node[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找当前元素所在树的根节点(代表元素)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == node[x])</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> find(node[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//合并x和y所在的集合</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> root_x = find(x);<span class="comment">//找到根节点</span></span><br><span class="line">    <span class="keyword">int</span> root_y = find(y);</span><br><span class="line">    <span class="keyword">if</span> (root_x == root_y)<span class="comment">//两者根节点相同</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    node[root_x] = root_y;<span class="comment">//将x的根节点与y的根节点相连</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断xy是否属于一个集合</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">same</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> find(x) == find(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-优化-路径压缩-按秩合并"><a href="#2-优化-路径压缩-按秩合并" class="headerlink" title="2 优化(路径压缩+按秩合并)"></a>2 优化(路径压缩+按秩合并)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>;</span><br><span class="line"><span class="keyword">int</span> node[maxn];<span class="comment">//每个节点的父节点</span></span><br><span class="line"><span class="keyword">int</span> Rank[maxn];<span class="comment">//树的高度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        node[i] = i;</span><br><span class="line">        Rank[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//路径压缩</span></span><br><span class="line"><span class="comment">//查找当前元素所在树的根节点(代表元素)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == node[x])</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> node[x] = find(node[x]);<span class="comment">//在第一次查找时，将节点直连到根节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按秩合并</span></span><br><span class="line"><span class="comment">//合并x和y所在的集合</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> root_x = find(x);<span class="comment">//找到根节点</span></span><br><span class="line">    <span class="keyword">int</span> root_y = find(y);</span><br><span class="line">    <span class="keyword">if</span> (root_x == root_y)<span class="comment">//两者根节点相同</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="comment">//判断两棵树的高度，然后在决定谁为子树</span></span><br><span class="line">    <span class="keyword">if</span> (Rank[root_x] &lt; Rank[root_y])</span><br><span class="line">        node[root_x] = root_y;<span class="comment">//将x的根节点接到y的根节点下</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        node[root_y] = root_x;<span class="comment">//将y的根节点与x的根节点下</span></span><br><span class="line">        <span class="keyword">if</span> (Rank[root_x] == Rank[root_y])<span class="comment">//树的高度相同</span></span><br><span class="line">            Rank[root_x]++;<span class="comment">//root_x树高度+1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断xy是否属于一个集合</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">same</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> find(x) == find(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>直接实现的话，时间复杂度最坏可以到$O(n)$。<br>两个常见优化，启发式合并，路径压缩。</p><ul><li>启发式合并：把大小较小的集合挂在较大的集合上。（有的写法是考虑深度而不是大小）</li><li>路径压缩：询问过的点到根节点的路径，都直接挂在根节点上。</li></ul><p>实现其中任意一个时间复杂度变为$O(\log n)$。<br>实现其中两个，时间复杂度变为$O(\alpha(n))$，其中$\alpha(n)$是阿克曼函数的反函数，可以认为非常小。</p><p>多数情况下为了简单，都实现路径压缩（只需要一句赋值）而不实现启发式合并（需要记录大小）</p><p>在某些题目中由于会爆栈，需要使用非递归的find函数。</p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><ol><li><a href="https://www.luogu.com.cn/problem/P3367" target="_blank" rel="noopener">洛谷——P3367 【模板】并查集</a></li><li></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关键路径</title>
      <link href="/2021/04/09/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/"/>
      <url>/2021/04/09/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><strong>概念</strong>：</p><ol><li>AOE网（Activity On Edge Network，用顶点表示活动的网）：在带权有向图中，以顶点表示事件，以有向边表示活动，以边上的权值表示完成该活动的开销（如完成活动所需的时间），称之为用边表示活动的网络。</li><li>在AOE网中仅有一个入度为0的顶点，称为开始顶点（源点），它表示整个工程的开始；也仅有一个出度为0的顶点，称为结束顶点（汇点），它表示整个工程的结束。</li><li>从源点到汇点的有向路径可能有多条，所有路径中，具有最大路径长度的路径称为关键路径，而把关键路径上的活动称为关键活动。</li><li>完成整个工程的最短时间就是关键路径的长度，若关键活动不能按时完成，则整个工程的完成时间就会延长。</li></ol><p><strong>性质</strong>：</p><ol><li>只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始；</li><li>只有在进入某顶点的各有向边所代表的活动都已结束时，该顶点所代表的事件才能发生。另外，有些活动是可以并行进行的。</li></ol><p><strong>求解关键路径的一些定义</strong>：</p><ul><li>事件$v_k$的最早发生时间$ve{(k)}$——决定了所有以$v_k$开始的活动能够开工的最早时间</li><li>活动$a_i$的最早开始时间$e(i)$——指该活动弧的起点所表示的事件的最早发生时间</li><li>事件$v_k$的最迟发生时间$vl(k)$——它是指在不推迟整个工程完成的前提下，该事件最迟必须发生的时间。</li><li>活动$a_i$的最迟开始时间$l(i)$——它是指该活动弧的终点所表示事件的最迟发生时间与该活动所需时间之差。</li><li>活动$a_i$的时间余量$d(i)=l(i)-e(i)$，表示在不增加完成整个工程所需总时间的情况下，活动$a_i$可以拖延的时间</li><li>若一个活动的时间余量为零，则说明该活动必须要如期完成，$d(i)=0$的活动$a_i$是关键活动；由关键活动组成的路径就是关键路径。</li></ul><p><strong>求解关键路径的步骤</strong>：</p><ol><li><p>求所有事件的最早发生时间$ve()$</p><ul><li>按拓扑排序序列，依次求各个顶点的 $v e(k)$ :<br>$v e($ 源点 $)=0$<br>$v e(k)=\operatorname{Max}\left{v \mathrm{e}(j)+\operatorname{Weight}\left(v<em>{j}, v</em>{k}\right)\right}, \quad v<em>{j}$ 为 $v</em>{k}$ 的任意前驱</li></ul></li><li><p>求所有事件的最迟发生时间$vl()$</p><ul><li><p>按逆拓扑排序序列，依次求各个顶点的 $v l(\boldsymbol{k})$ :<br>$v l($ 汇点 $)=v e( 汇点)$ </p><p>$v l(k)=\operatorname{Min}\left{v l(j)-\operatorname{Weight}\left(v<em>{k}, v</em>{j}\right)\right}, v<em>{j}$ 为 $v</em>{k}$ 的任意后继</p></li></ul></li><li><p>求所有活动的最早发生时间$e()$</p><ul><li>若边 $<v_{k}, v_{j}>$ 表示活动 $a_{i}$, 则有 $e(i)=v e(k)$</v_{k},></li></ul></li><li><p>求所有活动的最迟发生时间$l()$</p><ul><li>若边 $<v_{k}, v_{j}>$ 表示活动 $a<em>{i}$, 则有 $l(i)=v l(j)-$ Weight $\left(v</em>{k}, v_{j}\right)$</v_{k},></li></ul></li><li><p>求所有活动的时间余量$d()$</p><ul><li>$d(i)=l(i)-e(i)$</li></ul></li></ol><p><strong>关键活动、关键路径的特性</strong>：</p><ol><li>若关键活动耗时增加，则整个工程的工期将增长</li><li>缩短关键活动的时间，可以缩短整个工程的工期</li><li>当缩短到一定程度时，关键活动可能会变成非关键活动</li><li>可能有多条关键路径，只提高一条关键路径上的关键活动速度并不能缩短整个工程的工期，只有加快那些包括在所有关键路径上的关键活动才能达到缩短工期的目的。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拓扑排序</title>
      <link href="/2021/04/09/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
      <url>/2021/04/09/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>有向无环图：若一个有向图中不存在环，则称为有向无环图，简称DAG图（Directed Acyclic Graph）</p><p>AOV网（Activity On Vertex Network，用顶点表示活动的网）：用DAG表示一个工程，顶点表示活动，有向边$<v_i,v_j>$表示活动$V_i$必须先于$V_j$进行。</v_i,v_j></p><p>拓扑排序是一个有向无环图(DAG)的所有顶点的线性序列，且该序列必须满足下面两个条件：</p><ol><li>每个顶点出现且只出现一次。</li><li>若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。</li></ol><p><strong>实现</strong>：</p><ol><li>从AOV网中选择一个没有前驱（入度为0）的顶点并输出；</li><li>从网中删除该顶点和所有以它为起点的有向边；</li><li>重复1和2直到当前的AOV网为空或当前网中不存在无前驱的顶点为止（说明有回路）。</li></ol><p><strong>逆拓扑序</strong>：</p><ol><li>从AOV网中选择一个没有后继（出度为0）的顶点并输出；</li><li>从网中删除该顶点和所有以它为终点的有向边；</li><li>重复1和2直到当前的AOV网为空。</li></ol><p><strong>思路</strong>：</p><ol><li>用一种容器（比如栈，队列，集合）维护当前所有入度为0的点。</li><li>每次从容器中取出一个点，删掉他和他的出边，这可能导致一些点入度为0，将新的入度为0的点加入容器。</li></ol><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>邻接表：时间复杂度 $O(n+m)$, $n$ 表示点数，$m$ 表示边数</p><p>邻接矩阵：时间复杂度 $O(n^2)$</p><p>也可以使用dfs实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxe = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;      <span class="comment">// 点的数量</span></span><br><span class="line"><span class="keyword">int</span> h[maxn], e[maxe], ne[maxe], idx;  <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="keyword">int</span> d[maxn];<span class="comment">//每个点的入度 </span></span><br><span class="line"><span class="keyword">int</span> print[maxn];<span class="comment">//拓扑序列 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//加边</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    e[idx] = y; <span class="comment">// 这样堆中会有很多冗余的点，但是在弹出的时候还是会弹出最小值2+x（x为之前确定的最短路径），并</span></span><br><span class="line">    ne[idx] = h[x]; <span class="comment">// 标记st为true，所以下一次弹出3+x会continue不会向下执行。</span></span><br><span class="line">    h[x] = idx++;</span><br><span class="line">    d[y]++;<span class="comment">//入度 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拓扑排序 </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">topsort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;<span class="comment">//存储入度为0的点 </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// d[i] 存储点i的入度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!d[i])<span class="comment">//将所有入度为0的点入栈 </span></span><br><span class="line">            s.push(i);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;<span class="comment">//记录当前已经输出的顶点数 </span></span><br><span class="line">    <span class="keyword">while</span> (!s.empty()) &#123;<span class="comment">//栈不空，存在入度为0的顶点 </span></span><br><span class="line">        <span class="keyword">int</span> t = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        print[cnt++] = t; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (-- d[j] == <span class="number">0</span>)</span><br><span class="line">                s.push(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。</span></span><br><span class="line">    <span class="keyword">return</span> cnt == n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><ol><li></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小生成树</title>
      <link href="/2021/04/09/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
      <url>/2021/04/09/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>　　 给定一个无向图，如果它任意两个顶点都联通并且是一棵树，那么我们就称之为生成树(Spanning Tree)。如果是带权值的无向图，那么权值之和最小的生成树，我们就称之为最小生成树(MST, Minimum Spanning Tree)。</p><p>　　常见求解最小生成树的算法有Kruskal算法和Prim算法，两者都是运用贪心的思路。两者区别：Prim在稠密图中比Kruskal优，在稀疏图(一般我们认为满足$E &lt; V*(V-1)/4$)中比Kruskal劣；Prim是以更新过的节点的连边找最小值，Kruskal是直接将边排序。</p><p><strong>注意</strong>：</p><ol><li>最小生成树可能有多个，但边的权值之和总是唯一且最小的</li><li>最小生成树的<code>边数=顶点数-1</code>。砍掉一条则不连通，增加一条边则会出现回路</li><li>如果一个连通图本身就是一棵树，则其最小生成树就是它本身</li><li>只有连通图才有生成树，非连通图只有生成森林</li></ol><h1 id="1-Kruskal算法"><a href="#1-Kruskal算法" class="headerlink" title="1 Kruskal算法"></a>1 Kruskal算法</h1><p>　　Kruskal算法是基于贪心的思想得到的。首先我们把所有的边按照权值先从小到大排列，接着按照顺序选取每条边，如果这条边的两个端点不属于同一集合（两点是否连通），那么就将它们合并，直到所有的点都属于同一个集合为止（所有结点连通）。</p><p>　　<strong>时间复杂度</strong>：Kruskal算法每次要从都要从剩余的边中选取一个最小的边。通常我们要先对边按权值从小到大排序，这一步的时间复杂度为$O(ElogE)$。Kruskal算法的实现通常使用并查集，来快速判断两个顶点是否属于同一个集合。最坏的情况可能要枚举完所有的边，此时要循环$E$次，所以这一步的时间复杂度为$O(E*α(V))$，其中$α$为Ackermann函数，其增长非常慢，我们可以视为常数。所以Kruskal算法的时间复杂度为$O(ElogE)$。</p><ul><li>参考：<a href="https://blog.csdn.net/luomingjun12315/article/details/47700237/" target="_blank" rel="noopener">https://blog.csdn.net/luomingjun12315/article/details/47700237/</a></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">int</span> n, v;       <span class="comment">// n是点数，v是边数</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span><span class="comment">// 存储边</span></span><br><span class="line">    <span class="keyword">int</span> a, b, w;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> Edge &amp;W)<span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; W.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edges[maxv];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> node[maxn];<span class="comment">//并查集的父节点数组</span></span><br><span class="line"><span class="keyword">int</span> Rank[maxn];<span class="comment">//树的高度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        node[i] = i;</span><br><span class="line">        Rank[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//路径压缩</span></span><br><span class="line"><span class="comment">//查找当前元素所在树的根节点(代表元素)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == node[x])</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> node[x] = find(node[x]);<span class="comment">//在第一次查找时，将节点直连到根节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按秩合并</span></span><br><span class="line"><span class="comment">//合并x和y所在的集合</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> root_x = find(x);<span class="comment">//找到根节点</span></span><br><span class="line">    <span class="keyword">int</span> root_y = find(y);</span><br><span class="line">    <span class="keyword">if</span> (root_x == root_y)<span class="comment">//两者根节点相同</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="comment">//判断两棵树的高度，然后在决定谁为子树</span></span><br><span class="line">    <span class="keyword">if</span> (Rank[root_x] &lt; Rank[root_y])</span><br><span class="line">        node[root_x] = root_y;<span class="comment">//将x的根节点接到y的根节点下</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        node[root_y] = root_x;<span class="comment">//将y的根节点与x的根节点下</span></span><br><span class="line">        <span class="keyword">if</span> (Rank[root_x] == Rank[root_y])<span class="comment">//树的高度相同</span></span><br><span class="line">            Rank[root_x]++;<span class="comment">//root_x树高度+1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断xy是否属于一个集合</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">same</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> find(x) == find(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sort(edges, edges + v);</span><br><span class="line"></span><br><span class="line">    init(n);  <span class="comment">// 初始化并查集</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; i ++ ) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;</span><br><span class="line"></span><br><span class="line">        a = find(a), b = find(b);</span><br><span class="line">        <span class="keyword">if</span> (a != b) &#123;<span class="comment">// 如果两个连通块不连通，</span></span><br><span class="line">            merge(a, b);<span class="comment">//则将这两个连通块合并</span></span><br><span class="line">            res += w;</span><br><span class="line">            cnt ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>) <span class="keyword">return</span> inf;<span class="comment">//原图不连通 </span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-Prim算法"><a href="#2-Prim算法" class="headerlink" title="2 Prim算法"></a>2 Prim算法</h1><p><strong>思想</strong>：</p><p>从某一个顶点开始构建生成树；每次将代价最小的新顶点纳入生成树，直到所有顶点都纳入为止。</p><p><strong>时间复杂度</strong>：</p><div class="table-container"><table><thead><tr><th style="text-align:center">最小边、权的数据结构</th><th style="text-align:center">时间复杂度（总计）</th></tr></thead><tbody><tr><td style="text-align:center">邻接矩阵、搜索</td><td style="text-align:center">$O(V^2)$</td></tr><tr><td style="text-align:center">二叉堆、邻接表</td><td style="text-align:center">$O((V + E) log(V)) = O(E log(V))$</td></tr><tr><td style="text-align:center">斐波那契堆、邻接表</td><td style="text-align:center">$O(E + V log(V))$</td></tr></tbody></table></div><p><strong>流程</strong>：</p><p>输入：一个加权连通图，其中顶点集合为$V$，边集合为$E$<br>输出：使用集合$Vnew$和$Enew$来描述所得到的最小生成树</p><p>从单一顶点开始，Prim算法按照以下步骤逐步扩大树中所含顶点的数目，直到遍及连通图的所有顶点。</p><ol><li>初始化：$Vnew = {x}$，其中$x$为集合$V$中的任一节点(起始点)，$Enew = {}$；</li><li>重复下列操作，直到$Vnew = V$:<ol><li>在集合$E$中选取权值最小的边$(u, v)$，其中$u$为集合$Vnew$中的元素，而$v$则是$V$中没有加入$Vnew$的顶点（如果存在有多条满足前述条件即具有相同权值的边，则可任意选取其中之一）；</li><li>将$v$加入集合$Vnew$中，将$(u, v)$加入集合$Enew$中。</li></ol></li></ol><ul><li>参考：<a href="https://blog.csdn.net/luomingjun12315/article/details/47859993" target="_blank" rel="noopener">https://blog.csdn.net/luomingjun12315/article/details/47859993</a></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;      <span class="comment">// n表示点数</span></span><br><span class="line"><span class="keyword">int</span> g[maxn][maxn]; <span class="comment">// 邻接矩阵，存储所有边，编号从1开始 </span></span><br><span class="line"><span class="keyword">int</span> dist[maxn];    <span class="comment">// 存储其他点到当前最小生成树的距离</span></span><br><span class="line"><span class="keyword">bool</span> st[maxn];     <span class="comment">// 存储每个点是否已经在生成树中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) &#123;</span><br><span class="line">    <span class="comment">//寻找代价最小的新顶点 </span></span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line"><span class="comment">//原图不连通 </span></span><br><span class="line">        <span class="keyword">if</span> (i &amp;&amp; dist[t] == inf) <span class="keyword">return</span> inf;</span><br><span class="line"><span class="comment">//加点 </span></span><br><span class="line">        <span class="keyword">if</span> (i) res += dist[t];</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//更新dist </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ ) dist[j] = min(dist[j], g[t][j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><ol><li><a href="https://ac.nowcoder.com/acm/problem/15108" target="_blank" rel="noopener">牛客——道路建设</a></li><li><a href="https://ac.nowcoder.com/acm/problem/17509" target="_blank" rel="noopener">牛客——挖沟</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>202104华为招聘面试流程</title>
      <link href="/2021/04/07/202104%E5%8D%8E%E4%B8%BA%E5%AE%9E%E4%B9%A0%E6%B5%81%E7%A8%8B/"/>
      <url>/2021/04/07/202104%E5%8D%8E%E4%B8%BA%E5%AE%9E%E4%B9%A0%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误！请检查后重试~" data-whm="解密出现了一点问题，你仍可以看一看。">  <script id="hbeData" type="hbeData" data-hmacdigest="12c0d60781b1b22badb4bd17704d5b688aa3714361c29f2dee328273c43a8f5a">fb82b35931811eccec5218a1e0a6c69cdf52456ba616b4a099f400e13646b7eb1fa751f1a81931be1917117835adcdb2aa299c5cbac9ac5e10c58bc33dc312a27e3a62a287d3e12c8e505f42d268c3da452267a1c4f158663a29c91e905ce86d9eeb41ce28daef3cb7a0617db8cff5497950d75378fddc503598f82a7a44bdae7cec19e9320f1ed9941e440f96960ad9afbc58bd4652a51523ab2b8553cce3a9397c449152ad17cfbb0191daae1fa57ac2dfe9d814e924e13643d696332be883b60a31e18a9bb1067334b60d35a60d9126315bbf36b47049913fe041d5595dc258b31f1667ca9cb075aac3a3d5561f6c2e0eb6fbd4c68e645ffb6ed24803c8f2aa8fbe2cfbb180ff6e3ad5d60a44569f50b517e45eaee538a8066f747b95a44375feff7585808e5aa4310b18ea93b5b3e71d67428313181c7e629fb9d0f470e329819e5f9ba7ea8684f945786eaee96a0c08e4931d88a02187d8f38b1dc7eef7a1c63c7558a740ad425207b1b3df3005a51517ff23caf78b57735f537fa3b6f4367b8a73eea861341828d7e943fec6d48d64d1d7dde96803232338fe698e496e19a4403ac1f58619419ee34e35473cb24f0043206740f20125b9fe94a0684bcdbb179c633304a8e3b7831c9a2fa1aaf100e86d9865b987c9cbed4617a0f098436ab4e551c7ca931e827b1cf0099e18b0db64c4ca9c3ae829ec115320d98cc05beb365fce940b100a43dfb129a53787a69879748c3608071f712856f4a03fd95fefac71ce1f4c6df088f477fb92c3e7afd1ee0912d79589bdc2bf61f2cea1f1d648d15e9e7306a0720bc2210d6cf48825ff186b2f4a6a76ee498d62f9514bd1a32bf55f8747af8018c3e49b2ad694aaa3470e6ab854c501fc087726ba3e4c83283829eb53951db734b7ff183fcd5980ee3528146ff556878c53268149a0ed903ddff1b3c464c4c6bcdc9c22effd31d5b1556802f6b380afd5e93a9210eea50492a73c47d07880a4257b07289952ca76a84a78e9d5a6a7e757f90db5f3ae6e46ac348c501eec0ea71d2a5e587916bf039dba7e1a3b26b0d1ac945fec05f68123e3139bcf08880abfbbeab6e47e7c08c7009c6c7fad7e54c80def0003fea2a7b4a365200b474ad97f6b87d1cb6a70a1e8422698ee8b4a98111ce569a90ca08b2af6d7ff5d83dd9f2915f61d38980f671e0edbfea7a55a0672414cabca3d45ed763318fd6a2e5722001e7058e164c3d07fee17799699fd9a002d581bc9155eb431773fd7176e39dfe1eb3192084826d9277ab778cc01993146f05539c41c2e03aeb7f78de69d7c746ccb77f9d2a2ffe4867d75ff713aae84892301178a3428b5a7d943dca824c4a41c725f5b5273e7a3ffe0909b13c12f72c72f57218d4d2d4f95bdf77d5b0d458a9d2824cb501923004f59432db80201154cb3b86a2c1ee30fa5ced29b352d78f986f67a46ff24cd585157f5a2b891cb6db463a865878edf19bfb4d72fcf7df2081419af5919857247f8f5fa7d0449d28e0877a66235334bbd33dcaed4fe926bf74d1817116f7d7c9f183bc3a4a52fe6e6bf7002c8b1af0c49217a1f991a74138e00014225d5feacbcb41f65774bbf612053658962c6c6afd7a5d42905c3337abb26a9c6453fd466da1df4f26acc28e264df00fe3f32c3b4f6f3a8ca78cb61f53fe0e886b3cdc4ef7306b1a4b4e4845314e27413095e953273a83e1176e6e20a9a9b4f8f7f40468c8b7d6a38b223d81fc4e7a85829caa0d2dc907f9e5f4bcc3d833b794cae6f3e498d0695cf6f563829494f566d7305c819334e24152a87d0aa15662da13e0387c0d11c7ebcfa23be57e6d4fe104c6a5a7ac7693bd1555ef1a8570503c7d841278de76cdedf3008665080a165bc3134af383e202fe8032a2d6e7c79298f74b003c6f515871695c2a68e4772740fce014e4fa9eaec0fef4838020e1ee5b1ebe5fb0ab48487003f5ca324b1a9b5478ffa2638bff15cbb0e37cd1824cd84adc519b102f9784ff277cbcd5bdec12a762f9aeef0143d5c4bdc5540b997fe525e9ae632a1fe3ba2c6377ca19ab026b61ff84feaa4ae25a6b1402199cffadf8b2fac20693b8b052f2ff6020d388e7031d8bfe39167658906a106a12b76d288532fd0689641f03255b35670e33c5ce721352e25d3a77fe3c237599b2595888b35c3f3a62eb1137781e6577ffbb1273f026a7551e253c570ff8f288a229663f4e866cf4b7e929573c65ed29e98aac95b75e5abf8f69dbf97e1fef727f7ad8d1b340734adc7f2774860d7d1a8c761792dcc9ce812e50e6bdf9ffdce2e6b489720a139bf4071256f5e5064d3fc0f7ad409272cd4bd51cf9b8ec62fa5e95c4842c3e0c6da1a9fc676075e3f912fb2172c9999b6595625e991291d1302e6308e469e5ff97ce11530d91b7c654894d89c955229b9f04da7ae861f4660abff625d61af77970177adff7265a72d9d98f6018f1f8d3e3ee85251398bba7fb71477419677cade5af5e13fe9c0432124d2a7c98979d55ebb543eda96f63202f17ca2a9cd0bf1c188ef6f29885c99c211afca6b5a446c22d6d2688aded2975ac5d734787e9e2a281b119859595e3a01605a48c7932d36e62ab136f4064607f085eba05e0818e54b0cc96ab326bafebaa9402e55f16c9b72a1c003aac7c84158913192cb1372e376785849f0da9ec5d7ab62d17bfbbe80259b71a043cfe68ca2e0acfde96f257c55d2262e581b484e94d4689cd8e39100209764863766d0734fcce7bf87e99e36644be755f6325aab355a420c0fe5e727f94823303f6dd6a55e19eddfec825ffc92d054f871b9f0f3f5e96c898873057bf852a5f855f859dd32b4b136257ea1ed99bdefd316145bcccbed27546b4eb4332ce8ffbbd20cc812d1ec6b2efea4878826816df40d45d58683a08ef289591fe434808f05dda7b3890de6068d85dc06791647d59366daf7caf6582a26fbe2d7912a4c4f4043d4ca6e43b47b1a20836915c875ba3735f79eba07879de8c20e6d9c31ac550421f4eaa10a01898e4d7619e4dac51743734b1d8bba0df7465bc5ab33544c0e6eb083e9ce518a67920e82814d0783355f9d41aa48976f4db9f929542f5ea9868cbba390632168659662f412ada8c570c09ad1d56794c59fc18614888cb39f0a5d4122f14225e1b36a54c4128d2075faf51115528aecf8f8b82ba11fd8dded88350ff2f89730a49a9972d1ab11501b346e81b807cf6be91fc1af16cd9bb20aeac4f085ed4cc85899f0fcc6744507007f5fd373ea05b7e98f1b1af11ad55a591237675e80a5fd379ebc47fa16a6087c8d33a4710cb470109bd9f2dc4984f8bad694a26af100ad8f1107b919cedd923340ab37bffabf80ac6f9d7f00643a4de0b5b252c3081a14e8a1804a3878ea3f33ab4a0d6984c186545947bd9222d269f49301bcd9147b616cdb0660d4c36e32d4d93b4909fd61ed851b647855196f2b3311f0ef3c4898b7581d17694ee102e882504d3588688471d352ef6efd4a321e23e68182ff56bac5c6adf73cee03d702672e94bf6230160a7b3b0be0b7a007c7c45d8d08fdad1e1c7ff3e9843cd0a6ffae68ce739c2446053f2086670da63812cc7f7042df8a311ebb3ca5132a368975fa7d03321ba7f7068a7fd3790919218cdb19b18248a904d85e0949afd34eaa4927ba868fe943711e7aedfc9b61752449938155c8df6a6763043fc3fbb8367a13aa06ba93258617a7f48b9244cd511596cc9e4c7d34998f7abcf42f616a6932285a17a4fcc448c499fd712b40ada1515602770d93ef57313e4a8b26c4db77ba8966e7bc139934f3310e55be60e2e9b7ce45ddb4200b6b4b0ddc0798748d0bf987bde63c540603a667d4b54f853caeb4d9e20bee21c476125efce47f83e60041b6abccd2629fb6eed158f0153b6580a2bd677655378487473aa83d98351610fa6e8fa7df1387aeb5163902fabb380b396bd089f7d63f29cc4cd1e790d65bd3346e6e731b5ca5d4fce44cc2dc4b0b138d2f1445c0ca5e6d2ad929388b9e6ffe594ea84d62a657d6100198f407ee5e80270bb52d77f81a1c930d96457464626b10bf2aa4bcf2a09b9a58e8f83c5df0f64a5060631eab13cffc76c0e573e459ed39fbd120280c961a6e27432a49b60af98b0d12531df0894db29f7293ea66294f5dad7a18a86eb5acae5e48f93928564ec1b53da94bfa623f79a7e0e16f44c5e9d89f4a29b73a78a2d7a01fff1c2f54ddd2f20a7fd252eab152cb6018deb11c97bb01858ddaf8bd2bd25858a30f44f9d820a7a8408a23bf7e553a3b789bb1ae1674028b2b8a580411ddcb7a62ccdf1c68889d0f7f62600b1f9630747a4b5b62548db973d28a8dedd4292fd7a3a3b7e3c178460fe1a79d168e275b5b1a491caa7f79dd8d22d635f61956603f95ef63b045ce9f2fde76e2f9ab950d2670cc407fd84e6220f7278598cc82606d2049dc4c3757a52017ad3b77d83e242bd21fe689a8b7d047bc48cabea088a46d66116d46cf9d3dd06b88d7ac846964a5d7929a08b03d6ce4a1059bd10132c194b87e44fdd06a6115e4253b14b30df8064e0e9c9dfdea829a6269274541c10eab4d2d3cf5ec411453c9f88161b84c02fb48411ee5697641413a24e214654f895415c7e34a120c7dff4e5652d4c89af61e9697ecc193e2e3f24fda6f85338b9444abd2bcdb211c95a5ce611b4bb802c4ae79aa5f9df34dff8d8f623f0cf3fde0c339de8b419639954f15bf60d092694fda2c429c5d07947852463792ece9976a9a172f0110fea1b739c2c5f239bf3ab34d8778b43c44b00d7ea2daad49c5110ffbaab4c6380005ee2930fa788936da1e9c4301a7de17ac72e590a5e5f774d560f75891d3dc313f5369ebdd652a0ea7c9c0918f15b03136abda84fad804d1fd54c67c26193f759da03732bf17236993219bb26e10e2719a11c84182ff7f91fd80eeed307354c7403ece61ea4ad70702b77cf349024e4076059f6b54491ace5f97fafd227fc3be4005b9fa386670a2bf61b21a41bb1c4144c1378ca0a39e3a94e8cca77ed6b9b0ccf9bcdf882af083e3cc4e57ebcc77e5b8e77b51498f3c319544ccac69b9cb6b677da36639bce5ed79ebb8cf2816dfc9f66890d4c3c86544ab8a8f44d0dd441f7f2745b2e3ff005aa741719849448bf2824de096c9d47ba4c1a942beaf366bfb94ee478dfd8050755796951076758d391b4f8c058319014b8b73e801d57ef8ff437a6cf9c759dbb0525f46e410f27d9816266a66207fca0d2b03b6e2e2a4abed1a760992a2d3bad8ef90e7e655ad94baf381218d0c21d8f8f1948a6ba90329a6901dfbe276a6307baabcdd455d4a718ae14000d8597fffc8902bfac6e06c1004fd33aaecfe027eeaab201d0efc5b30273c7bb26c527919c83a0dcb8c3ba1fe0aef929a0f4ddd79b40544f460bf75158b6fab6d85438b2356f249fd2c5d2329f5e778131bf75730d51d111a1324831cba8dcbf48e93722b4a8db0687bb0aa31ba15bb59858f9b11cbf461b8db00cddb4c49411648e59dade83cfa0bc50834cf9762f3ae1fb3af19265fec87e715caf55baf015c8c9f4d947f90c3cb381eebb9de440518c63b76dd5b15dd24a48922587f91c3320e1eca6a07837e7a945b82e3d115087d2a254a38b1cf90ef92cce6ebab81ddb8e020a645938e556bfbf212976dd34eacda4994e9b8b72023eb88faa1c5ef405a81435786fc2018703e05a3d205c112e34da1310af353f1622e0ab3216ca6bd16f76df7d5182fa5594578ca1b1ff5c88d16d09a6e0b9b040c7c899fc1d5aa0319616eef64bcb398098a1acdd9f984e36b8de6a3d80d90fe1d5d67ed9115556f926061c63047a73cdd7b215bc9a257d872565519c8b711d762497194cf633247a2c6d07e25658d137759a727251dcb6106496f8fe7c1445b822f3282dacdb26b9a8ee41f128cf852a53c15190393227a7f9eeffb1f2fc3b05ca06778142526c7c1b56f82d986c18c3f36ad34f3067a0d0292eddf42f8658f19ef5a412c2aef2fe698c558f17e17ade73afb8824dc7e158df100dfe7e4b545d7b4f41bc759d251e8e00cd2269322d56a2139a1d02ddcf99cd397779dd38ecf07039d0b3e5680da57bd403bd134c388c9931fc03b3bc27f7b82dab2c142e434bcd92353107e4de0c98e9ce9a6afc6a18452e19316277d61e0565bb35655cf964a9ebb3988c6571ce320f8ce82331f25ab91d5daae82bfebc3586675061dd7c890bb3470ce9566c7f045b050a317f05345fde2e8a478be7448ab062d421dc37c59a480b29f43ba526e8237b433c5fe52542700240c5050ae92f205dc65aed25001796ea8528ed628599e93afb7d5b2117bb6485e76c61e78a2addd6cd5b9799e9280857ffbac829dc2461fcd87642ec9bf38db867fb13477040350875e9ec343b6e88b3b3970cd2d6bc6c0eb9fb26b72decb0b30e99926c9f54c84a832c1b47fb9a3aacce054755bee65e3abc5ef39dedf9975c3181bdbb4a42200b8436a69c7ec80c1a1757a4f6a8361d4632d9be700d49591411315f098118d0a0e009ef1eb706c94443e575b6f735315a7a729ad911b0dd7430da67bba2138ac9823e03cecf39691499d7e74eb8aea3f13400d8302c95cb8753243a904898ff004da4e63f8a90cf25258d9dc713c8573e521bcb3d56909cb0b73a83cec309980a9492b576e37130abcf0c28e0cfd0860dd208dc825820415264b1e6e85257aeb0efb3a95030876f5d65b086ab3582b80cbcfcbdf72de2ab6af4fba270def3af63571fd424883c271314116e7a1f31c2f9e448d74d3b9be4f6218a282d9572f1b79d95ed9c25e54b2f04bf699a3afe1104dc22074bba4c86ae1c3144860ea2c054db28997c212039ed7edab49747ef18bbbdf5299e50e9e3aadb1c89ec3fb2864720fdf9b98b15192ee003db5e0d7753177be0a022e3e2e0b92e2244fa66c0cf4a4139c85b3155d40d850cac5160c060cc2581d6dea3d71e6c61c160c49066b89e9569a313286415cde6e3fc869a537afcf13fd0523604bc84295f51faa99b0c9768e708241aeab7b0dbba8a171c088259e3596e0006eec51d02385068ea35557ed501c9e2ed5b9f60c590166be70203cbcadec383dbcc103ade3e6d48aabc3c519c18e443038351f9a103b78b27a4232a2293cb762b1ea532bfdfdf1006b0669255b497584c71bbe458b48e2dd9614e9e93a0bbd4aaf079237e9ccb8f7de6bb80d7ec916ae52aed7abc41b5c4523db082212c6b738c86b5eb32ac9faed9cd63d8c962efe975aa47aabb35fe109e94a83924dbc6b42761eb309dd4a4ecf92fc533f66e3728c0de9f1a967e3e936cde671640347d5fea9f3a122a498b03b812aa35cfa4b4a0895169dffac35f1c28f3de458b98c31c6806eb9d538c848e76fb173ef4ef7c2bcaaddaa33b1bd45e979906361ebbc98824ddab5b406d9a3af6ff103ff34c3c4d1c4bbba227dd8ab84d3642feee62c37defb577f4a4a2eccb23efc0083a1993c8e54765c14aa7c42187e2ddb439f2be1eb248a3737c8c06c5fa4dff4d342b6d47334db1bab0bfe6a643dfb19340774c2ee167429896490e06d6666197bae6b83c237da26f9d68b70bbca911c753beb922b1999b6299b6315de0890a6218b33c58e441dc19508d41999280e781fee0abd94344ec9fbab7f76bb6d05fe6af5061514bddbf5e549380a6313a4ff405092be4aa33e867eca1996d608b0180f5280eeeb8362f9a65bb3a659c62217e50fff064c49947161fdb4192209450c6b8a1f5c7dd0704643a4a787a62304df225a3c3a042755eea80bd5d6f2eb7311dd55d73e99f921323c1db65ac6138da3fefd9f68596defe987060f0bb50c399a9ee7b3377718925114a32003ba83939c7a6a4c736f521b8f3a770abbe0f7c55989dd98e3a3f4659a7c91a84111b79a7504e2fb3248d0c0f9c6ec100ce07d8d5d1db8b1ea0e036077c50ceb49e6584fd15e59ed961af2bfa008bc98b0c27a72f3df78e7085d828cda2f72633cc5095c8c18cdf5e4ddc3e783ff68e99d271f41256e02c5f88e90130436ac49d206be4aa248ce81e28759d0eb10911f0b2d1a204474b739088fe4d80115a2d95122872fc1f8d567ada91ee00e950063e6880b8d1b7209ee983e44760bbb0eb525a54b9d903be0538553766f26e1e2aeb41909ae369187275cc223b892d97ac6aae156adf5665a9ff4c2d4e916854382242d39e686ca4cdff00429573a67eb6a4c6cebb5174aec48897eafa1edf4e93932637b2c420d8fe5ce9fa3f7446686c059595c9bde344b1f46659093a8051d4b79116d465990ef8a522c7194ea95347b4a2bca39a7c4ec979d87e5f62b86b5165210c15e6bf1ba1d447349271e77c7d84fbd82999e2e090665fadfaf01f6300328b4e9aad2e0184f72caf9cf674eec9ca0fa5241de186c80e89ca157946d5323ff02477bdd89e0e9d405a821e2d09dee9eb5d601cb1c3162c733faa16fe8989e6d5269712a84e9a172c6cb7a11b149516ce47e83b33e43779d058354b9c9fe0e6ac9d467d1a01450516db0921ab81f4bed12da321ad6182a3fe0810c1e4d196a1c055cc6207ac0a64c5eb80cf485e6d1c37f4a92e941be1434f68726edf9840630715e64f8ab086ce6fe995766da59ab1cca92042febc7143900d68138d6ec02a6695ba480da886eb22f914bfb7d8a84914d1a3548c6bac8ef58b4c74f32ccfb7400cd4fc6052ad9c44bbd56c36bf28fdf289ef4da6deaaeb93645bdd422e4d5426d453751ea8b0ba662947bb95c5bd8da547016a6cf4eb40567fbb282248623c94ef2e820855dea7f6a4e5d801d7247eefe6caa3b2acd220226aeb0441c4ae3aad1f6bc0d6abef3ea800b5690399f184fd39ee09b04b20af7845dd1e515d22ffddd98fd441e1260ecf6dcad02d3978100899b13e221e91fc29fc6b4efc8d897bfce6dc231a66e73e76a6e690a728e13d598c15e2ba72034a7c6897e2ab162310528e513e6b00874770550af2e378863c1c59e073b24df327c04e9f75db5cc9ae9817a1839dcfbd9c26c67d5d5e4b093e6c910919746ef6d0303fc635c30accea081451e1427d8023c6e479aff12a18a501e38a6883ee2acf835fbb6cc405da5deaca4fa8b55e9a7bed14b015c5d5397f207598a87404fbba0c774af7491fe0171ca9ed2e29cdfef373f21ff9cfe8288911383251870a38e6b6d454900107004fb1826effe31e920b26a48efaa133df1d38941fe14a26ebf71ed8383c332d44bcc4866df7ab442aa6eeec88d33428eec4bec54590aeaf6d48bf0ea5d7760b646d17b1db24eab4e7b170f455b13415cba3ab6e77a03d5e088c0b1ddfd56e1456487d6cd24167fa95099fa89de60b5ff259bd4097f68cd23b23ec836d7483ebe2646b73db9b0e22d72b588e2bca7d4d9e4edd6999a08b841d60e32842b91b29b0fa643c8f0c3c6930d89f9aa4e015ecdb0adef1b78949852c87e180570286a6e68c087f1ed04108ef003aa2626f3d402465c96918a82943e90d9d44b7bb6069b416ec3cb44aef549666c0f00a42f60c09104255008b95085071c5f79897175ae9673336d3e40dd678102dd800c9512c0e26a09fb8553ed22e64027c418862fe9c792eaeedf1a3ab83fcb09dadb0112fbc51c6aefa6109a3f51c3d6ad13b0a9c3af7f4d6c8756aa65e48f49d4b0f3c193f02bef1e8d95b22acd9b7219a1fe493b7218b7014d0e52e1edd95ac6478d91e9002d14de2033bd7e064c37bfd5dd76dedde99381dbb66d189ac61baeaa8b03e57e5e35b5dc605991930b61613d8520b3826ce5a524f93d3eb0733385c28a23ecd1ef11dc2acccde92376c6c58310ee982c89f5dad2d1224719bef8be8d2a9acf8eab2fb998f4543ddc0872704a74db5a036bfe63be425ca84fc9d76644a18f87b21246fd559139adc0cfd0f2575f40b16e0c74277cec389a88a04936b512ad1aa895ebbc8f9b32b94c062371ed3e1c1c1139a90c11ad379f8911702f85d9c4f27fc557a84ad71050654540deae3b559c6a261640bbdbca741cd51bcc82bc03e25481e7d8af58b6f4a19e60b7e2a2870cb9c4891fb9d97c37a2001687ff2a06b1ebdd4ae688bb64607c35a733b576c07deec80999096fad7c23c0a6ab642cf711050e8f16fa701897e216caff77a7951645f845721c8016aa05b2b3c4375f491ae34c4dc5650dda0435c1f192a1214707b551513ae8539f7ab362a4b015cbe46c20c22f818aae1b61f2b001acbf71ca2ae4b07d8e3ad4cc564a58b7547d6354f22444168f08b3db18ce52c1190a6ede5fca9534007c91fa6abb7e547839590fa34ba88ba5b93de840cb02ee8b275910a579865b4717cbbe40250bea05edcb5bb31bada8210f5f6fb223eedc20995ad0d9ac7f1bb4b8007ee358b95b052ca92d32900743ac4c6d03b46765efdc3d44f5c66ed1faaa18fd706ab0ef5d7ef7f339f70b683060c15d2c02c3ce8eec211a781192b9501ebd0d8cbd3b0b545cb097a27cc6b8d4fc6666012bad9565ee839233674996d7fae941bb567330b10d9ac29729cafa297afa3f61417aba8f376e05ebbe401cac13662c30b542a056c062005327ff16fa353e54fbcb3fa54b64afd5d3bfcdc891048313f96fe4ba7106a289b755f9bfc57c195f1389dd8a9c7c45d1dafdd35259b8277fe9782e2ab61174c13f9f504b654cecf4930b045a51d1dac31efa9edc7268b42f9eeecfdc200ea83d8210673d78f07f9db4c5c026042499f2f42ad79026bb2beae3f81dfa7c947f43280f4111ea728ea3f1abb8342b80c12c44ca263ef6bd6da3cd39ecb96744e4e93b43ca0b8d27a1b43f200f1cccd0267498036006b3321c06e890cb6b0152bd8715e2d25d75a411c100df4b2960c41ad79492974fc7af008e4786d57e5d5211ea1db2ebfc6c973e79ef9590deadaeaa106a614dda69ed28ac4d2bd3474472bcb0224298fc639913dc676a93714753734c76bfee1434df3bd652fdb895726ac732fdaed3cfe341749b811e10961dad2c20aaced73ffe2099f7feb75420c57981a654c99a7481486ddea1bdcfcdc8dbf6bb073cce879f2ce575db98145fe820be92217054d8b378c01f8d2acf0a7fd100848ce7a93b19022e7549eb8368728328fda258e97cd768ea1723b6ad2aa0f2de52a1b534bbf12aee8c22be41e2cc4fcfa411a0bd5da9ebdcaa897d7005a7114265d028f4fdfa17455fb0165a8136d0613a11222f06b0d30f7e0d49631336f75eb8c8fac97ee752921611001a30c7cf73d3479abfd7de667a3aa961257515520f2882deb6482e35c4608fdad6d935f7ed069e09da6d557eb2bc67e81cb300896c163906692964892bc91a5dcc286e3b1c4bcc810069989737854708791333db638c4e50cfd7cd6504950f263194b032d798cfb421b711c56820c9cccfabddd83efb92ca95f4c3eaafdddd42e3740b69f58f6bf0fe21355fb13ab107d91b95821382b265019954e6ac1c8b82fc065e6188f9c8982a9e8162b1fe01c24d47b05a852a3551ab78bc189ca26f11621bfbefae0f2091f21600e48e93e97f651ed0113c7a7302eaa422b8d01e7597343d329acf1684df6dff3b5c53a006c9692a723944428f63c635a1c1ae5ddca3c7c99a015b12079fe1b6365c71f6865c0344b79a1e7a91a0b0ca359106c13353eece7490e5d75e2752530ee173f308b78e9549e8576376f1556639020b5e7095de64126200f04389c6f6485df495f72ceeaa530e703156d90a7c1e6035b6a43c9bcbc33bab481c089db40d2224e4c23e5ea46f35ca5e83c38d303d93ee2ac42e362f20bc4251959ff2e9ba7793acef726404d4c43aa9a3e8f461920047b2d6a2f1d92652e420875015251a593a6f2bbd2a6226a965dd750888a993aa7cffb4dbebd62a6a9eceabead5ecbdc987b35109b5b228213385b5db1f93062467c3435ae1b5b0a29b1251383a41dde9002326fba4522649c7bd1ba2ff8df488ff2eaf597274e49c11a4630afea93ae9c2aa8521a332793a177d28df4e5bce3a85323973a836762f21ea36521d3dc76eae5c11bc7525e6c2ef61568bde3ff14acde40bdb26c3280a9fa09e77d8c42638f241c99c16c4e2ffd11206715d1b591dc35fe3bc555a98cc312697473732531db817329bc8ec151218241dbb2e750aa5e002bec2d588775a4fdb9a989069902444a95284b42bb03a7fce79089b33b342326135ef5e4a3b0dd532b3b7f668df38efb9fafe6608c2ce3eee115847337487d425995b3b9f8265bb789a2f4fb24d7ccbe0f25ac13ea5f8e482713ab00cc47e413a1ec8d6efc5e32293f7030c4f6f6e9f7577877ce463716af33732b74a8281ee36f9c98835df31fb54c66aa0f31eac2428537e17289cd23b2593fb9c87bcbe749e692289b6b31b64ea939f243be91d0a0d7d3ea0a8f6686303f7e207c450d0a6a4eddeaad631ffab08091f6cb9c3573981940f05001b04a0f06ca42939a941245e1278dc18d282cb78d22dd522a5252c9da87a08647b2d1255e0e3f1bf130d57694c7519bfc245c21cf6f8bb989409f773b4d3b02d94e2c19492ea1c1a58f28cf5f319ad145c7a9be10d929d011d1928559c86b1f56ac22a10449c00b6a0ace712726b07bff4bac36b890c8ff1f8ef19d56e2539318fc583e31711e1d507e65442390818f1ccbfb22f9e5fa0a79a73f7b7fc234b22dee81e784131a5ea8814e44698d9b8815f3be7c6bd3cdf3ed8714e5759413084124c4bdcba338c5b8995ac80365894bb91357421fd7b35585a4ba769edd42643953fea2c5b4c3b2acdbbf2d33df5396b45a11cd3689d7d6b0a5c22c524e5a96f823ede14c41a193bb2bd61306747139bfa98caa9203b16858bfcf4091ec7363093284a32ee4d0fc080cbaacb187eddbe77e5ec76cc999ad3e8f8ff8476ba814bb89d25564bef55339f6d2250670309175e1b15b20cc3e1e651c8b6a996000fc76e42e6d187c3787bc1ed9e3bbb09ea4f050488a707db0c46f3651000dadc16301938a64a1008b8e1dafea243cc5b4117c871e300664a5aa3e19428ef7a28489b1f85ad7e16d2554840ffc13ad79f5e68ff3ef309a8587f02b50b14b06ca51f9f1e192a6350e3878795b5cd4e275f9f4c9afbb8ae4432892a8e05b17e5d33819b6fc496d732add7aff3817602d099db0adb5695bc836679264943da9973c54fe9ece290553f70d737dbc4ede36a279e40c61ca38eb47b6d6a1059230bd42c39009948eb353a100c3a2f73457b6da6b96b</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码以阅读这篇私密文章。</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 面试篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 华为 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MAC地址泛洪与欺骗</title>
      <link href="/2021/03/04/MAC%E5%9C%B0%E5%9D%80%E6%AC%BA%E9%AA%97/"/>
      <url>/2021/03/04/MAC%E5%9C%B0%E5%9D%80%E6%AC%BA%E9%AA%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-理论"><a href="#1-理论" class="headerlink" title="1 理论"></a>1 理论</h1><h2 id="1-1-原理"><a href="#1-1-原理" class="headerlink" title="1.1 原理"></a>1.1 原理</h2><p>　　MAC地址欺骗是数据链路层攻击，它是利用<strong>交换机端口学习的漏洞</strong>，通过客户端向交换机发送欺骗报文、攻击交换机的CAM表的方式，使交换机CAM表的记录与真实的主机对应MAC地址不一致，从而使交换机将报文错误转发给攻击者。</p><p>　　MAC地址泛洪攻击，每台交换机的CAM表都有最大记录条数，当交换机端口学习得到的记录大于交换机CAM表条数上限时，交换机收到一个网络帧，只要其目标主机的MAC地址不存在于该交换机CAM表中，那么该帧会以广播的方式发向交换机的每一个端口，此时的交换机就相当于一个集线器HUB，我们就可以监听网络中的所有通讯报文。</p><p>　　与ARP攻击不同：MAC地址欺骗改变的是端口/MAC地址映射关系，ARP攻击改变的是IP/MAC地址映射关系。</p><p>　　MAC地址泛洪攻击针对路由器不行，原因是路由器仅仅转发特定地址的数据包，不传送不支持路由协议的数据包传送和未知目标网络数据包的传送，从而可以防止广播风暴。参考：<a href="https://www.cnblogs.com/Lynn-Zhang/articles/5754336.html" target="_blank" rel="noopener">交换机和路由器的区别在哪里 一针见血通俗解答</a></p><p>　　实验网络拓扑如下：</p><p><img data-src="https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/Snipaste_2021-03-05_11-19-37.jpg" class="lozad"></p><h2 id="1-2-知识储备"><a href="#1-2-知识储备" class="headerlink" title="1.2 知识储备"></a>1.2 知识储备</h2><ul><li><strong>MAC地址</strong>：它是一个用来确认网络设备位置的位址。在<a href="https://baike.baidu.com/item/OSI模型" target="_blank" rel="noopener">OSI模型</a>中，第三层网络层负责<a href="https://baike.baidu.com/item/IP地址" target="_blank" rel="noopener">IP地址</a>，第二层数据链路层则负责MAC位址。MAC地址用于在网络中唯一标示一个<a href="https://baike.baidu.com/item/网卡" target="_blank" rel="noopener">网卡</a>，一台设备若有一或多个网卡，则每个网卡都需要并会有一个唯一的MAC地址。由网络设备制造商生产时烧录在网卡(Network lnterface Card)的<a href="https://baike.baidu.com/item/EPROM/1690813" target="_blank" rel="noopener">EPROM</a>(一种闪存芯片，通常可以通过程序擦写)。<a href="https://baike.baidu.com/item/IP地址/150859" target="_blank" rel="noopener">IP地址</a>与MAC地址在计算机里都是以<a href="https://baike.baidu.com/item/二进制/361457" target="_blank" rel="noopener">二进制</a>表示的，IP地址是32位的，而MAC地址则是48位的，通常表示为12个16进制数，如：00-16-EA-AE-3C-40就是一个MAC地址。</li><li><strong>交换机</strong>：主要功能是在局域网内的主机之间转发数据帧，工作核心是<strong>端口/MAC地址映射表</strong>，这张表里记录了交换机每个端口同与之相连的主机MAC地址之间的对应关系。交换机接收从主机上传来的比特流之后，要先将其缓存成数据帧，然后通过分析帧头中的MAC地址，交换机就可以判断出数据的发送方和接收方，在映射表里查找与数据帧的目的MAC地址相对应的端口。若找到则发给目的主机；若找不到则以广播的方式将这个数据帧向除了源端口以外的其它所有端口转发，从而将数据发送给了目的主机，并记录端口与MAC地址的对应关系。</li></ul><h1 id="2-实战"><a href="#2-实战" class="headerlink" title="2 实战"></a>2 实战</h1><h2 id="2-1-MAC地址欺骗"><a href="#2-1-MAC地址欺骗" class="headerlink" title="2.1 MAC地址欺骗"></a>2.1 MAC地址欺骗</h2><ol><li><strong>准备</strong>：没有交换机物理设备，vmware中桥接模式中有虚拟交换机(但是无法登陆后台)，所以只能利用路由器测试(也无法进入后台)，只能查看现象了。</li><li>此处未进行实践，可参考：<a href="https://blog.csdn.net/redwand/article/details/105388491?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-0&amp;spm=1001.2101.3001.4242" target="_blank" rel="noopener">MAC地址欺骗与MAC地址泛洪攻击（eNSP环境演示）</a></li></ol><h2 id="2-2-MAC地址泛洪攻击"><a href="#2-2-MAC地址泛洪攻击" class="headerlink" title="2.2 MAC地址泛洪攻击"></a>2.2 MAC地址泛洪攻击</h2><ol><li>以<code>kali</code>为攻击机，使用<code>macof</code>命令向网络中发送大量网络不存在的源mac地址，堵塞交换机(路由器)的CAM表；</li><li>攻击前，<code>Win物理机</code>可以ping通kali、node01、node02、node03；</li><li>攻击后，按道理此时的路由器中的CAM表中存在大量陌生MAC地址记录，但是目前无法查看；现象为：请求超时或间断ping通，但可以ping通外网及局域网内其它主机。</li></ol><h1 id="3-存在问题"><a href="#3-存在问题" class="headerlink" title="3 存在问题"></a>3 存在问题</h1><ul><li>没有物理交换机，虚拟交换机无法登陆后台</li><li>用路由器测试，但是无法登录后台查看CAM表，可参考：<a href="https://cloud.tencent.com/developer/article/1482014" target="_blank" rel="noopener">小米路由器开启SSH</a></li></ul><h1 id="4-参考"><a href="#4-参考" class="headerlink" title="4 参考"></a>4 参考</h1><ul><li><a href="https://baike.baidu.com/item/MAC%E5%9C%B0%E5%9D%80/1254181?fr=aladdin" target="_blank" rel="noopener">百度百科-MAC地址</a></li><li><a href="https://blog.csdn.net/weixin_34234829/article/details/85088965?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.baidujs&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.baidujs" target="_blank" rel="noopener">MAC泛洪<em>*</em>的实施与防御</a></li><li><a href="https://blog.csdn.net/redwand/article/details/105388491?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-0&amp;spm=1001.2101.3001.4242" target="_blank" rel="noopener">MAC地址欺骗与MAC地址泛洪攻击（eNSP环境演示）</a></li><li><a href="https://www.youtube.com/watch?v=FiDq8g0gBsI" target="_blank" rel="noopener">亁颐堂现任明教教主CCNA Security 2019 7 第三天 2 MAC泛洪MAC欺骗</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MAC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARP攻击</title>
      <link href="/2021/02/17/ARP%E6%AC%BA%E9%AA%97-%E6%96%AD%E7%BD%91%E6%94%BB%E5%87%BB/"/>
      <url>/2021/02/17/ARP%E6%AC%BA%E9%AA%97-%E6%96%AD%E7%BD%91%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-理论"><a href="#1-理论" class="headerlink" title="1 理论"></a>1 理论</h1><h2 id="1-1-原理"><a href="#1-1-原理" class="headerlink" title="1.1 原理"></a>1.1 原理</h2><p><img data-src="https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/Snipaste_2021-02-18_14-20-42.jpg" class="lozad"></p><p>　　ARP攻击主要是通过伪造IP地址和MAC地址进行欺骗。假设A、B、C位于<code>同一局域网</code>内，A是PC主机，B是攻击主机，C是路由器。攻击过程如下：</p><ol><li>A将包含目标IP地址(10.0.1.1)信息的ARP Request，广播到网络中的所有主机，源主机A的IP地址和MAC地址都包括在ARP请求中；</li><li>C确定ARP请求中的IP地址与自己的IP地址匹配，则将主机A的IP地址和MAC地址<a href="https://baike.baidu.com/item/映射" target="_blank" rel="noopener">映射</a>添加到本地ARP缓存中；并将包含其MAC地址的ARP回复消息直接发送回主机A；</li><li>当主机A收到从C发来的ARP回复消息时，会用C的IP和MAC地址映射更新ARP缓存；</li><li>攻击主机B向A发送伪造的ARP应答包，在这个伪造的应答包中，IP地址为C的IP地址，而MAC地址为B的MAC地址；</li><li>A在接收到这个应答包后，会刷新它的ARP缓存，这样在A的ARP缓存表中就出现了IP-C与MAC-B的映射；</li><li>攻击主机B向C发送伪造的ARP应答包，在这个伪造的应答包中，IP地址为A的IP地址，而MAC地址为B的MAC地址；</li><li>C在接收到这个应答包后，会刷新它的ARP缓存，这样在C的ARP缓存表中就出现了IP-A与MAC-B的映射。</li></ol><p>　　这样一来，A与C之间的流量交换都会经过B，可以进行<code>监听、篡改信息、断网攻击</code>。</p><h2 id="1-2-知识储备"><a href="#1-2-知识储备" class="headerlink" title="1.2 知识储备"></a>1.2 知识储备</h2><ul><li><p><strong>网关</strong>：网关(Gateway)在网络层以上实现网络互连。由于历史的原因，许多有关TCP/IP的文献曾经把网络层使用的路由器称为网关，在今天很多局域网采用路由来接入网络，因此通常指的网关就是路由器的IP！</p></li><li><p><strong>Bridged(桥接模式)</strong>：将主机网卡与虚拟机虚拟的网卡利用虚拟网桥进行通信。其网络结构如下图所示：</p><p><img data-src="https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/v2-0e29e8f13495c269f3fdc723aa2255c2_r.jpg" class="lozad"></p></li></ul><h1 id="2-实战"><a href="#2-实战" class="headerlink" title="2 实战"></a>2 实战</h1><h2 id="2-1-断网攻击"><a href="#2-1-断网攻击" class="headerlink" title="2.1 断网攻击"></a>2.1 断网攻击</h2><ol><li><p><strong>准备</strong>：<code>kali</code>虚拟机，设置桥接模式，否则断网无效；</p></li><li><p><strong>查看自己的网卡信息</strong></p><p><img height="300" width="600" data-src="https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/Snipaste_2021-02-17_22-40-47.jpg" class="lozad"></p></li><li><p><strong>找到目标IP</strong>：<code>nmap</code>扫描内网(命令<code>nmap -sP 192.168.1.*</code>)或使用安卓端的<code>Net Analyzer</code>进行<code>LAN Scan</code>；</p><p><img height="300" width="600" data-src="https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/Snipaste_2021-02-17_22-04-15.jpg" class="lozad"></p></li><li><p><strong>arpspoof进行攻击</strong>：执行下面命令后目的主机无法上网；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arpspoof -i 自己网卡信息 -t 目标IP -r 网关</span><br><span class="line">例：arpspoof -i eth0  -t  192.168.1.7 -r 192.168.1.1</span><br></pre></td></tr></table></figure></li></ol><h2 id="2-2-窃听"><a href="#2-2-窃听" class="headerlink" title="2.2 窃听"></a>2.2 窃听</h2><ol><li><strong>开启IP转发</strong>：<code>echo 1 &gt;/proc/sys/net/ipv4/ip_forward</code></li><li><strong>arp攻击</strong>：<code>arpspoof -i eth0 -t targetIP -r gateway（具体参考上面）</code></li><li><strong>窃听</strong>：<code>driftnet -i eth0（你的网卡）</code>或<code>wireshark</code></li></ol><h1 id="3-存在问题"><a href="#3-存在问题" class="headerlink" title="3 存在问题"></a>3 存在问题</h1><ul><li>攻击局域网其他系统时，kali虚拟机可以上网，但是其宿主机(物理机win10)无法上网；<font color="#008000">开启IP转发可以解决</font></li><li>窃听时目标主机虽然可以ping通，当时网速太慢且不稳定；driftnet无法正确抓取图片；</li></ul><h1 id="4-参考"><a href="#4-参考" class="headerlink" title="4 参考"></a>4 参考</h1><ul><li><a href="https://baike.baidu.com/item/ARP/609343" target="_blank" rel="noopener">百度百科-ARP</a></li><li><p><a href="https://baike.baidu.com/item/ARP%E6%94%BB%E5%87%BB#:~:text=ARP%20%E7%97%85%E6%AF%92%E6%94%BB%E5%87%BB%E6%98%AF%E5%B1%80%E5%9F%9F%E7%BD%91,%E6%AD%A3%E5%B8%B8%E4%B8%8A%E7%BD%91%E5%92%8C%E9%80%9A%E4%BF%A1%E5%AE%89%E5%85%A8%E3%80%82" target="_blank" rel="noopener">百度百科-ARP攻击</a></p></li><li><p><a href="https://baike.baidu.com/item/ARP%E6%AC%BA%E9%AA%97" target="_blank" rel="noopener">百度百科-ARP欺骗</a></p></li><li><a href="https://baike.baidu.com/item/%E7%BD%91%E5%85%B3" target="_blank" rel="noopener">百度百科-网关</a></li><li><p><a href="https://zhuanlan.zhihu.com/p/56658358#:~:text=%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E5%B0%B1%E6%98%AF%E5%B0%86%E4%B8%BB%E6%9C%BA,%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AE%E8%80%8C%E4%B8%8D%E5%B9%B2%E6%89%B0%E3%80%82" target="_blank" rel="noopener">vmware 虚拟机三种网络模式—“桥接、NAT 、仅主机”区别？</a></p></li><li><p><a href="https://blog.csdn.net/weixin_43343144/article/details/102679135" target="_blank" rel="noopener">Kali Linux使用arpspoof命令进行断网攻击（ARP欺骗）【VMware一定要设置桥接模式，否则断网会无效】</a></p></li><li><p><a href="https://blog.csdn.net/weixin_44839457/article/details/108333653?utm_source=app&amp;app_version=4.5.2" target="_blank" rel="noopener">使用kali进行ARP攻击与欺骗</a></p></li><li><a href="https://blog.csdn.net/qq_42039946/article/details/112968942?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control" target="_blank" rel="noopener">使用kali进行局域网ARP欺骗攻击与监听</a></li><li><a href="https://www.youtube.com/watch?v=ko4VvZuO4rs" target="_blank" rel="noopener">秦柯-ARP攻击</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020年终总结</title>
      <link href="/2021/02/11/2020%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
      <url>/2021/02/11/2020%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误！请检查后重试~" data-whm="解密出现了一点问题，你仍可以看一看。">  <script id="hbeData" type="hbeData" data-hmacdigest="6e100be63972fc508ad2ca1eee4b73c10c79f6869f561f7e8f629d89f73cbc59">a1edaa97922bb2ec7906d4ab82b474d6d8aa50d47dfcc79a7863314b6f8ebdcc5e963f9cf1da89f851d21298076f8fe899a407018269516a7430d6ea6f1e8a44acda1ade9a52a21f69cc2493bdc26a1a61ed126fdfe3ac93069c32f21a9d42a673cb1a47536d70574a33cf548b7c4557460f4517927dd21c1f458a4df0ec6fdf29ccd7d25ed9ff5a2ad2bc167a591f81ac2520bccedbdc5d60bd836898acb50181db84a82b23ce2b9915638fd14ec799badb2fa956341e0efac431e18a52df03806976124d19670aecda4dd6f1d7c1f07a4ae6ee789a25fd553e851c8e63d0725381a17958f0ece7a16ba348044d896b379651f29fbe17957736401d2ae0a4b419157ffb4a61cf9886938f524925a8d6adc9ee74d1116216986591807d5bc5017cd29ce69b882e43e4b945fec8a4608f2a3c5c6d28aee151fdf11221ad7166890ca2838d780b541bd17f2b6de41fe72cc5c6976c67e2d77e2167f3b6671261a12ffe094f28a546f821c0bb32fb3af488c07381022602c00ecb12461804f84863128a1563c345f060bab3483adc75df60335967cfc66ec00e6ef2cc9c6e4c5485258942ac1cd3cb7abd3d6c018b1e29f2ed592f2579350f2a039a002388532371619ae995a922a8f0643222e818caf521c1a5e03ed7f31022e9da0a4e471aac558566cb117831f2fb9bee4588b41b6799eaac2b4f31f661033742187746cd2a85c074ca7a36feb6f744f31164fff600430c942def243a96b44743da8fa488cba80dc5feff3f2e9721fb0ef8661da764dd935eb3460f27c5829669d8f5a2db5f086a899a07c2457154f59aaab8612f48201cc726c2c4810c8822d265a423b6b33fff2b5260f766a4164375855ccb2ff5981a5d1ae17097a92f4ab82ad5ef8dfbde38c9236b031ebd45d437d5ccd68967e01bfe5b419d0186e053a26ecbbb3483c4cbe49f5ab28319ba57a25ac0175a107ecd5dc7b622690f86f6019de33097be5d4c47562eeb45f1e90b4d1a512993d4b90cc771e9c8bf20582142d12c3230326475d704b2ea05e2a43ac413cf87639fa2dad97e21bc69ce2d116aaa2f67a4ee1e1084ee3b0910bda21578eee53b3a8c63be6ee2abf1a6820cc57b6443684ce1665a6521b9ec9bb89b255571c58c71d9561a1ee9afd4a87055c844aa227f6fa0c90d6ead8aacfedc1eae12823d212981dfa10213db53547324bc471ace20d416095f77748436f77658f3e00bff7c6681193c5838f6b782f11291a9beeed00b114c421534230e3bf6ccd4c145f91ff8b4db66c383f3691648e9edd261c11094ca9572b23fe5a2cc93363cad806aac3761a5207bea7c437ba5bbb4da8a0f4816a25948021c28eab29014b81cdcd76f72a5890b18d36cc079faa4989862fc55640ad704d4673c7ced237287723c83e5564c4f563e03e35130d27e80a944538c57773b234ee915dc89ada781562bbbf8437b01f32fe5ca2a5c3358faf7df63cf14fc189674d63996106f76edc5aa8b4e5071fc4f32727ec487f464a0527521ccca8b5e7401b17161543dabce931c4733b7236a7035cea464d95f082de0ef62bfa624a2c731eb138556c26dc333fb9be5715ddeea40f7d59247d5f347f6da861090b059fe43cfa3555670c732b9048c0c2f8047724135f38a8546e08e24f4e7681ddf9da56a70629babd76b56e8efc52999ec96774d06b5e770f2a0511800811a3d2f469e2fb29201c27d7bd6ad609474ab8ab8780da7f439bb742533eb05eb0f00eed79dcc620b898803625f0f4aa7b48928ff09fedde449747ab1d413150dbabdf6f8f86e4f2bd8d148cd1a3e650617af980aa6810918686f3c37e0a314f7b18ff9a1ab6a066959172037f9a55049ed22edfea5cc2791d4bc11473c839564ee8b85a869a5439acd8b3bd15871efc0661494b0d9f4049c0fe68d976e020ad1cd8a0825ab2c6cc9cbb888375f99875e06a0458635e15ea84233202fa7ae2657e0eb68728b5948881ec1bfc1d51a3e18a0d6852f8ae7a087c3c9807892acfe3dc8344471327a67eca8c8a0f3002b6b19f8318fa776cdf85ed067d9f1dc96a573b9fa528ce5c707ac64064786f9cec4a96113b755a63368044357e1084d5f13d7d35e97ef8da99fc0d265938a1c150830977c7ba7fcdc72509ac86c313c1a5633e5ce87a1b489f657b90065219ab921685eacd545b00e5008317ce2568440906e9bbad4df8e92b7ddc7d98e0d6997ec40f0cf39c7d1a098873241f09ee5f6e7221a0f268ef26522079f668469677fb80c9c924b8b92c5f3692bddb7e9a5a7ac91d178619867229baf33bae458e0fc6ea98c430090f3ba4e733ed674006b3da6f30e496f63156f2f8eb506b2eee6994e5703c9dcd4b51677d709a7798d77f34d8c98830dcf764281ae7adc89318d6813c0206f62757a3566cf81c14b6e8a21777cdaf76fc5ef73c36c2a55930f1ce2f723a990dc7a75dcd9f1e10c17ea08a7b23c5a54deb75a26e4401cc8b574656681dee28fb1e8e86167dd485a0a4387b2302b02bb6f3268419800c2e50b6658700343a954a39d9eb1bdf2d124875b2e0b23f9ecb6a3c814d67e49163c0d26f7da8535675d889ca536de80f1432c95b486b85dd933d52c79bf75faa6c0d3548d73a691a1bbe93004cd73a3e9174ac2de3114d42f75a71c885bb0c714678a25bc8632fb4ac3042d3071db466286f46b07d83d1ddf7847456bc6c48055eb7472c4732d61d57247f9ab296f7ff2aad0f0a158496fa9fe35cd704fc7dfd92497c298cbd6f4924413815968553e8a63b53d6ec12ddbff27d6e3b30cd6aab677e166fe5766a67cbf72e679f92be7dcf3f7a5decbc6fd55ca48941dac32fa2c57d11e6bb1e010a0685a25a7ef0027dbbdf66918f3f7f3ab8de19037632e9ef6f0418cccbd894a3e536fdedfcebd8ab45a7983caa88738ddb3fc50fd2967d20c8a78f9819cf5c82ab2ceb66089b567eee17ce4d3945116638f9d6ddbc5c3855a48541a5a3bac92e809af789f571fdb7d7b0deb1186857b1506ef7a904686d8d0ed67c5946dd0bcc504edf05c8d664434f05b4874b900d9019443a68a332e450f474308c96d94969b674c43805d61fb4a083cc27092a76106e90a408fb0cffe708516cec5b0d187db3f3b042ad25ddecf53bcdd8cdf424be95cfe8589dfb5476a9a872314436699b0fb0a5c25cf6f0ae58ed4f4ad47614e7f3d95fb99c13a906d5750cd23160602a1944c61ff2ccb412ccea43344b5e077fee1e45181b4a21e9c7f23c27ae396e19c305c643c8c96ea2b700348c86860190904401bd313cba21849eab6dcd429664b4400e4fb705d741b53f8f71e1b50fb3d1f2369092a73729c83d70909e3fbaa2428d1f06a102482c23af2bdd4df75fdd0aec16de1f1d39afa0e3dab14756e4000c60772f39efd0bc9177cdee2a79211c3730fb094bb4333bf95d9edd16eb96494b19ea112eee86cae6ecebdd1b26eae9d815392b41289ab9872e2f55952e06b71978bf6f9a8f0bee53dcaf437720f6911394bc7b14b6da54fdafdb0b57986025f6d39b3e4c0dd2e433e5251bb314781697c32efc69d60df44044fc0bc51aedf27f0b29e3d5de01eb4e9eed0e5227e4e4f5eed46d21dd3d128285a7333acdd73f8c951fd5a4abd09b3c7a0a39ddf61bb17f3a084d8687deff13af9df79b527ffa8b876be66d25d08d22738c17d0368eda398df01c2446f11dc3f1088cb678a51e9c452bd93820344a686c275341fa1b29cc6040f7e037dad33ab7b8b370a810de7ecbfe801cedcf5aecbbe75874006ab9b5ed21b21f6c51842b7fce794143999a1aaea7693f6e8e42604b7bd1c89c5b28cb9dda2c76712cc847642da0db9b1e9621a17327b02b6fa003501df85869c935bfba12ac18eb2e36a48cb5c0d35143012e5e756c466888f823f71854400e2b686fdf8525fc5712b87d2e553b58a7c9fafcf64027e50432435f6b588a0ef18bfc8fb81e0724a91fb85a28ca9dc9edc86900e0ceb68b8197bf1d746e2677a2d473f37c67d31f0460a345babaa8ba62dcdb47e29a09c2ea657bbe2eb7fe0d8d55bf10714df225ba0395ddbad01ad5a056a11a5567ea3b60e05ce3a68fc59f05091a057c2c5a9de52f99e3fa6733aee3de1d17119f93c0d2f6277569cd58980a8a972d1912a5a584a140756554a6cb548108e0492f7f2b6eff5a89cd603c32d75d94811f8ea6d2f0c74934f9adca70badbabc1d234e06e3875911ac1b3db5268064c87e4dd02fe2ae841ad4db35025de007173ffbc19757f68955f7e2ed83a049eef5a84550f704905b390d26e8b438b8e3d898dd861e10eb620723a47dd195cd1e27106c0e76222b112e66ad8f66da6e524ff4e849faaa5817d66231f78bbeb7a8bdb214dc39124cbcfcb60dc4d1b8feccef74db798097057f26fa77c638b40deb9810a10badb8fa302756b3a81f2332d368008d4dbff833177f0d60fcd3ae7f55e956f0c885ec7e8a33ccf816283834338f9c5e937572f2da7cd48a489ee2571174fe99c475ef8bb0ad56d55f6b626dca6a7bea444d020d090eb3709c67688a5602bd914dc22c93ca016a1e980d3bc50648ed7be840a57410af4a2e0770ae19dd3b0e0175158eddbf075005c3981ef3c5769519b6717cf673fc7b5d3d150697ce3465454a52cf15833c14a7ce67c50c98372b93ccb0e3cf77793c4e7d212d9d79b75c834097d4dd70be1c9a4715a344d7c397a594a71d3c8fc766491b607b7b2dd473ccd58dbcb0ef82aa0983c2b2927c5d454da208d6ee06eaf26996107a8b765fea0addbc5fcf877c8c2ea37127a3a0d706d4831441e64abc38b0d5de74a125bfed1203d44bd5c9d16a7e60e7eb547b34f94a3fc4e7f7e995c57061a010339316a8ae6a9397b29f0fcbf59be1ab58fe1f1754b08bdcaa6a2f669686f2cad52a71f8e1d3f64cd5ed630abcf1c350c4b829ad63149b5d6f5bb64c6e9d2b8e3e7ecda93d8049ed92183d4f2ce7b059b78e20d90335b607d03b85e81ab9b6405a430b402830e2e5611711c2a6739ce5145b35206c921bf3a390b68afd1a26c24bd9eef45014e1a1d71635ba911b04d0a21ce70bbd99b2f01377093ba577af702222f9ac2849ce86306b6dc7757b907c43fc77a8aa5a3ff9fb6c3da0f4402ca7a888aa7b34b4ebd6d5412d3df1635062342774ce7a2e00cbb76834ac00c8033646d2d0bbb7d5e242ed686a1d7a3d1a4714996a944ee5ae81ce90ee41f357d54324b51378ac94799105a3ca8dbb684e4991895189483c0a7237dbc4a8cd91005ee027111ae1b4327624dcd65db154618bb02219a6c0ecb19307f48136514e7d2c176d5249c4b145ededd72c6a28a48b6a9ba6639159ff85f38e13ac7916b4496fc9258986f6f505e0bce1a4cf58b49eee29dda9ef800f0c38ee2fa5ee04fa89e77629c61625fdf5f0751ee8f45bfb0efea9ed0785ad0d8fdd48f9e76600c60bc86cd67783acfaa0849bed12659a88bc9330dd1ab027efaf42edd60d2605a6db1371fb64d7935942ecb899b0dbd943a514765db390afa0eed74588e7e151c1ac3c899bd3a48a62c9dbdf61ca3f6644dcef8704110b366153446332343d3ba2eb2e1d304bcb060f5241bd0a60808fac1773b95cc5364d5fafe4b5e8471ed283704eb4b8bada2d80115839be4aaddf7087e5e80d4033bd39e243454d02a290d0723a47b6e97b7ae8c8963267bfd42873086178fb5bc9e1398e0b4728d4a90f69023519ade4ce9b38c762e1a17c6447807afdc3c96f565e27e9342815a24a144c20101ec4c94ff8a7c47e72a0d00c09396185e524bcda9d9ef9ed9550eb6663696af8465db6d6a78a1e0003ec3e4495fe5fccc4c8a6ee961fb47cf695b8a6f3aecf1062ad2b29a9aa5b53310f86b868a715f5a6893ab925532fbb124f8a9a7e32c94ca2f39abcf7a622199279f1985c114ec2eb5583cb3172bd43411851f28181f7ecaf15149dcaec8a36889b9e390f7cd14e87bc1b28e0210de319e974b0080604e5e2e7f79f51a34cb90b061031e265a63bce0b89adfd78988de4cf66547f0863f689563f5f3536cc32d4dbe9e2aaaf643aecd7419db33f20ed323caeabc28e6bb582998d1eda5d7a2f4e21d73a0027bf238bb2d95015e3017f1412d83b4eb4e52a056356ee1dcc0cfcd796ac3e4e6b43c02975fae698bde11b350c8ab2f2d53486613b8b48c12afe68fb134ac19dc55a62209add59b5e47f39adb85935fbc9ca0c74d5788cde109e9f5996cc7c793c9a58fe53e4b6a0547966420179e436b21347fdb7330d0c2d2171d58a03caeed0f294c41eaf12f6983b0880b8fa72ea964fa3978ecb4af8dba9e0211ff14f078b73a60738035eb264436029e5c09d0d3fe0770f1643310be88513e8e2874e8eb6b36ea0ddbb32c30cf3ba68853106de1d1042756bc0617348f275e42c4673c907faf60bdea2c36faeb64b687a866b1b08f934ae20a48b802959c6d0c609c7d04eee6ba729ae4b45c28fab9e86a2687f63174e07c9d1eb7fe53450299a56ad8409f8a0fd5c3e949044fa97d031b69af010332c10235a114641fbc266d4ab51c9692ece318b0969cd550933095dfc4ae3da64106ec16c563322a1f381ada80325e9cd10a80f2176da15907c82dfcae961af31b291e2db23b84deefd158174c524c31ce32a43bee04875fbd8d40b528105a2a2985f9288c5d814c754b8823b442d0a91e7056923dc99dc476ce7685b2d7f96aab9c5e8d1f92132b9b0aaa1686808a341f06240fd6fcde6b8b603795f12c1e7625ca74e9e676b0256f8547e266997ce89c2835208ffa7b964c8476c841c62bddf75c0095e9498f6fb54cb56fa1281e5f2fee7adc576e3718315a409b5bd5e4046daf029683885f4f48210cfcb3ff36cf1b63104b2ba04732188e102b57906204a27802db235ad5b014317b425f299e871ccec10c89930f8339a8e2746d88e889ac4abf4b4ca6829c59230f4edd8e3d40341118f3edc86349f9278a39bcd0e555f90322a8a91539e25a16990533ea681d6e94497f4a806f5a909bc2937d67202c7a7c4e04f24d4550e12bb2b40f77eff57754d6adb7f1d9e412dcb50b40699e51c1d4a8335fd8ee50dc0519746d7037ff30232dd6d4b6444c9176d044d05b21f33ebc2fb51a656796a93f41b5fc2b7f8a532c86e15f4358d66ea0b6de564923bd64d3c5d61f447f829d92c26aac5aa9dc5a36f23787324854e4361a7c1b1fecabbc3087186aceebe4fe824fd1011655f0ada4f55206bca6fa63a13bce85ee209663e93540efd5a51446f4883247599bd9d561446d988bb4a392d8f74f2b37f93632b2a0170d674cae7eb34897065a4cf70177ff5a3a7dceabd0b8192d258e0e465b230146e7d24ef5d76cf64904927094ec760410a76c1aa084a52f4c8a97ec272cadb96441d2ec9e1b867546367cc8bd526781558a1bca5a5fdf97b2325a1d93bc17c8c403825eb4ceca712da8c7ce0d1e69c03baff72040262ff69976a85a666c3337c305eacc4a67ddc17d859e4f7356c8169b9b3b5d7d4df394913cc9210a5376718813efba01cc0133b040fc4e56e2571e42a288f7bbddef060ea2c3678e63dcda41e229a267812e3a4c8e4f6debc0418a043e3f0e8933ce8e976ddfc196d3782cf14cea430b17f02badf8634a81bc7cdd7b32c2a317f6e6728af08a86d072634907f0e5cfccc1ec4b21f0532ff8361e4bf8f3dc2aa6f5cb40bd060385bf31259a328c1479066cbaf5b2ecf1f48a425d7a9f060521b085f93e8843b9f023b55e53752c2f13422e7a03c1ccd5bedd82dc718b38cfa1583574723d16198378c3cc482552ecb0b2b801c224e60a58e055c5c8b4d04192d4abef9f45753af5db60fe2db4ed6b281243a0da0f13a71d417182cd0b9027b722f8cf1e985036305a54af4a03fb438e1acf06331cd3b78acc4e0369adad2f00afa6de8b41698c522a00f244e3cb2a44755a082407d2726459c6368b97c57bbbf3637d30297163a4308ae2b86e4bcc09f089702e45ee655d53331682ad08f93c699b372de1715c7c7ceca8fb7dc8541c7bfa2fc42838b59868bd0058f3e90bc0ca43dca019ca61ea591a0b368e33546116b5ab7269e849e888414cac0d922c7abf31df8658be9b753c472ab692b5c566f9bba2a52a20fb23c91c4a78b7de546319cb8a3c93cef0253ea5814921c5c77d4674e251e1ed215c28bdc2bebb5c1fc5e28d67f016fe1b38bdaad6cf89844d9a3e8195f96b991d6c9a258d215c0fb1b51c76dfc21fe30912dcce6f5c0f6f4db1f5ffbdba078e02cad24c17d985cd8bbe71ba9d1995436bb72c40f90de545bf3b1c5006df6b2fa620108d729f96486bdabcff172646a3ae2dd79e2f39652187672e627c7cb0bd0a09587952fffed56bed0963f6443d02397bff9420fa0b879e97f36c4757874ae0480da5a123d2deb481cd7885ad4278c285543759138bbc328f09d25bd9f71ce333866713415eaae4a7292998ccd7279e56abd783456176dce6fd13d8fbfb28d3ea0fc63a16a604271fb55eb7134947c70c1bb2c7ebd32611043d8870e9effc29b67d5af61827a8889f7a5b4156fcbea0d81df83e7b76193621764e35e93bd25114eff1c8750babfbb3ebb7ab2f50bc91c8a27ea8a2ed814e5373caa3dcc29ea64032e981a52837a31c51f78c6f58d1c68f3461945495523f870988fcb86afd00f0bc81a568ed54dc16820ef730ebbd9b94502b52e78b3ca9943d009d0691abf2108c3050f066dceadc5894204b61c849f6422f4be1b2630a2fb0c68574c6c2b4c8a86a4c234eb642a77751991fb4f85b50a842bc96a43f358acc4fbafbd19bed60e54ed506e64fddf116e5a05278195dd4c74000fa7f262f153f0628512450d12cba44ce104f55da6e549421b26c3c336cc92baa6b87913814fd2a1869e4d9fdd900fcdf2273f323a51864d91a19c5d3742202671e875060c5160ef8725566eb53b7a95412ea2a93a086dc96eb64de383599b34f6d3f6562e9d15ac92d0800843096fdbc6bead67bd308b5eeb03fd4c2383c77f38f306081f4d93cd41aaed302a942b16bc0178e2f66aebfb9ca5b86d066f8bd1d79b1c81fd74093125908f433f975be9326ab4c9144917eae8261536063a0b21116e710bb26510b1312334b6a0f69391e278b553a1a0514ad8997895f6b59e7f594a8734d8955ad9b98d506c71477c004c9f9493b81f4e71fc22677a38b913d202063f178d83c8e2792204708926c87c39a9a2df43e8f19aba9336ea064cfaddac1b3e219e2692f17aeff5cfc1af49caab23eb4e912d4f23fad0b7b9c48481d865eb974cf87c80eb4d474835755f50ef50d1def312a3bad67ebbcc45e80eaf06349490c98123ed59c18a268a1fce4676568d6155f4a2e266a7c9b9700558a3afd06a8f44d4111c003f019c1a2ddf4577ca03fc8c0112c9f9a79de31c9be93cf10482b2aa3240cd6d91fe6f90362bdf66c8dc9a75b8a7bba0be6ff1d742f4423bf0e80d2cf34d4c5a7653fa3e6ad5fb05589cfc8dd85532eb48c1d1a5741c81ff43bf9642a3d7ef82dc4c89988ef47ad5701127bafff8688bb132b61b3557e27f2149ac5be19a7bb95cda146d568e3a45e27171a162226545baf309fd05d781e5fc54be81abc47d6ed73381fb04f90a63b52511a631f94810cac3e5247564a4ef3fef1fa7073addd68890b1201130f04f3a6d043f2da895098a1e3cda4121e363cea2915a45b353734246320f6ed1c04c9d74f87ceaa6be5548baede649627dc9f06cd0f1ab3505a645a9c09bcd2eefb524a8ba529aadcfed8ebf8c4c3ae6d265b52f86559373706073ec989b7ebd1164137a16f4a756d51e1c250d0151b01647f871fcb6291a089a29fe62ab15a9cacfe1db74d7ab06795c2813b62344fd5096fba61d67383968476e4d5e3747c12946eacb567ff11c4a71593e8305a6b685e227bee7c81668cba9cd163bc3efe31fbc751002a476dfd5eb8f1ae9135059048c9a855b06f78a4e82e6b7a22acc646fe520c51e9cfac277663e069703c05cfdf85ba07291eea0a64f3490668facf899b4993cba7ab67868419cfdf2e5d930ac41f2a5a956f1f5f8ec90bb42ce6d35a156a647e1761ec8c5707ad7c89c47d9bf81e2e732e5abdb255bf788b20f0249683193f2eb51910fcf0c39a58e74aeb35bb2636dc9abf99967247bdf6dd1b7ca6ec7a756fa072d9112230b2e8eafb229553a916c0315aa4a3e3de90489bc239a95bcc0084ceb861e067ea72efc6dbca7e4ccaf085cf2b76bb478d6c7a65e21fff17d4181a9c5f69db11fb9def0b6edfe62288288be539d69aee193491644625675f3753a547d557f1bfdf7dccbc4d86fe2aff7f727c0f2c5f14e1e7b8797f63f5cb8799471d5c781f82dee84429b3cb5618206edabef8cec7134a1f813edcfefe4bc4fc1f930eb19b9800046d18e4e24bb44425b6afc8b0cad2c64a6cfd6434fcec9367d68e579db0798a6e77614ec5dc3f885a6636a0d4e27d310b3371138f0976f826132782998f3a1017e2fbb78427c64c0e53485a6e3eddf0e9f7276a500acc070f8bab7166597c27126260f10d796aadb9107e9d608fe820b1e9fce41214f4390c45d709028782b0aeee2a186b214f6791fe72a5d0e1b49536ae06eadd040b4650afcf94042018ba864a043b7a3db989dcc64d716b9e334fa7ffb54370e876db16901c1d12904b49fe10d25236bd487c2a95db16a0c608ee2a7e886b58895c76372cd3e071e59eda6fefa7fef42fa9ed355fb90f566d2b434b8efb44c21e215f52d6bb06005c9e0dd144976a9172de907849fe4884d530e53b073906996db66901eda1e79a6999579140b9cf9e094501599b19f196180008f5a9576499a10b66657c2e11e9b48bfcbea2803607de5f95e1cd1078a0e1346fdb1e913fddcb82b7d264bb03bcbb8d0b352bb00cb723c8d6a636cbb51dd980440ab7022e2e62d2e48e8a0662b147522339560fa45338ddc945f04aa6648a2250ef541b8b9f15090459d0bbddc46581b4fb05d58e78d42e890e590f0b098e739df73c9b242a96102bb1005a9cfe98ff769aecb47a54e7f3051adc0c3063a5d5a5224ba7e87549d4fbdd791c4ae528b554473fa12cea0740a8f01be742f98298f7b3a052be5d4d76c07a461ff0e5622c106844ffabec15dd8a201f089da060ff79d1b8c76b760582309b0854d7548f317dc12022138a345cfdc7c9e462bafcc276356fa0a348cae1c57a9d1fbe57dcf42c2a237ef5c7b60b6c7c19321147fa6c8a5d4b9d23b29f05237bbe1e2cdcbe020370315d54098c0ddda414c4610f12f3e3c2bc1b5a916843d1189c695006c9dd2a873c6bd089d7e2d044aa508ee5485f7a482107da159bbc6dd9b3b5ac1aa74a0469e5478ef4e01ef73538e4b2044ac50fb5e1863ac43738ddab7801b3d7382504b2d2f03d3c19b456626b5e9f2dbbd0ce6329a82b3e00544f2477270e18a5a436f32e5fc89977369a6cde0607cb2aff1b636c6556d91e126c283b49a47786dfe595478d44f31666d0d74eb6a799f0713ecbbc749edd46e9a4325c61483a1a825c5fbba9e0201858c7a6a6b3e096f28c22a76c41d3420feefb12aca05e3af1d7b7865b62cdaec9df9a6b53a0bccdb40f47301decb947d287c698728d77f45695321fa434f63955fef7b2b1f5e27f385cfcaf15fa3eeb7487478c48963337b674d6b4223c19f195ab42642818146ca776b071de492ea4e8c0c59b0fad31c4d154e37f76840df1820275462fbe97adc7eabbec6ef0146042e4cf81548b2d5c95eb915cf2015b005a69e19b232bb0b4fe0a0080dfbb4b07b502685271a0fb0c61e5657b882063ab1a9dc8ad0d97941a9b13afe9e719c1abaa071edc04015022593604cb7dfa1be93e38c4f25d404f7289b1c92c873f703c47d81fc8d3dea15c9640b0771256c41ef2f5754db50e835bacf31d0df98732acef1c7596a2fd42226c1a4deff6600de866327e6c979183c25cfb3c4c7243ee81636546acae45bd993068709ccfdfd8767ec5d4df61da36900bb140581982181562c1f9a42dfca4c20927e918d2e6fb66f32de6fe20e8010094243377afabf7bf66f66d1dd60c43860ec98303e7e715cca955a076934166b1dc3fbc8fe181984dfd8245402fb6908688c394cc75544ee89e3af84a0abc2b1803e12e450f2a2200fc4da0ae415bd9337e3d62a82b6549debff63d9fe343b268b4014d4d223aec41e621e4e93802d4cb6dc1928f1b11d3921fed20fc3953f52ffcd365cbd9bf3a58b72e94dd4d4b0e9ace9f31b0f2bc718e8bddd98f7d414f37045df1e765184fa8254e0f4bf354abf5ccd2b82d6c8cbaead2a3caa564401cfc681feb4888b9a6cc711927c3037a725463e5c4bb01d10a719130d8034a8aeef8b207fbcfae97ca8e468f32992bbf15ef830adf48cf6ff6fde981725ba5a77f226e2059f631827699a67df207cfc2f873a3971bd66f5a95143d13ad0678287b2141561949ce2685fa30783c2062e3362e8f16577f482caa95320727db3a90f7af60d86c81525b2eb92779897e9984c560ba1e1bab9c9376c98b86b65c58e8906672a79cf90cca7a8f0fc22744ef74f2aeeb28bb6d7dbebebc15e1175ca1291491789513d350ea7e3708e80e1766beadbf53e6c1e9438aa696355b0a5e3b55f7313d5e417308915eb7acf3e3406fbcb40a98cf4866308c464d7e95b8f5c7318f0c2ae434638d4bb81b559faa8af7944a31ade9878b68d870016d561a57db01bed160c5dfaee0e8d772206cad0bf5408a0b2b508286d727a58cc612bdfaeb3971c1f49c117e0baab1a53968b00ed43d068f812a06e666edf155ed9f7b8d902d7de3469295696a83d22f8cc9df51de3676b3001a7cf2316c239361a65bc9b5d890fb042ebd5dc108f80a24c2fb40cf6ac181c22b79e7327b2d5b7b7fe6d3c6bb470ed7baf4e95c8719d7adc64cbc754ed85cef79a30075d94fc02ea1cd3508adc967526d8abce008311c3c2f78212041e4372876edbbaf755809581f093f7ea56336a1ca9b9958c2096aeef7a7e7e20e8d0f6ca397d58b5f62cdc2675c1a509b15de05b5aa4e0b15f8d45429ecd3ba2f7723d9491310f494e4dfae5bd5f72868066e8edfb2a1d6befe43b5cb3c92ab158693db70319e4236ab5f5ed297ffc548d290c241d66ebd9e37ccc634c9a5b9a8dfffe1e14a05abb98422fafcdda9dbdab188c5fc9d73e588159de39ce533393e4aae3b6de65c5edde1e6156c0592001b6f33f02d12088bf1584e2e0fa3d4ccaf05a147ddb04dd1b5812d4c7863114a6feefe813b48364dee90cbd66f862ed03f2a7b0c98bff5282714c13aa5642d4591c7cfb6f6f8775c6b841ec7f34fa91dc5694ed6b3b4d0c7c8777840976a17018801327f75f2775c83d93546629ae32cfa6d3b66cb548e20dc3ecb8875954854d5bdbaeb00e2ab8077a88cc3185333fc300b8c2380855d829a4606fce93a505ed3f606d7d1ac396b7bad6ab494dd070a5c57d1c4038bd5e7444dd26680e13698fbcb88b0db01ff64c5c3005ea7d42357c9aa5d097c38586bfc4837f7da755b6e93b9340e81e7c442379e67b0942de2041c58dace742b85dcd4eb1a5911d7c0efc63ec4e4e9ed768a0baa3b00cd1b805df9a810099e3e0e3d47d28ebdb491f93acac28b4be396c1c2c4ccac1ea67654af63f8f393753c736a1c1ce970d686d984bc1a262e096129fe38bf18dbd673e23e8681663e06e768800e61b10dbfc464ad119e0a2b9768045e9ac72b6a33ba5fe7575dde544db8766ff96770f02fd25aca5b83bf44c346cd16a5cd4f6bd2924080d8255eba6e154191ee24a9665ef883204013791f0f9b8c0e1a8c3248ba974d21b4e77bdeeec59668fa386c0e4f64aa4d71084ff27bebb3d2a6a82b6f78a92dfa67cc1dc4dd52c297dd0cb5c993f5135a39756c3b57eb0ade974bf6eef7b7d830e41658771ba278cb859fc388578297815b9b1e322367d78ded62ab7a915bfc14bda73485d37b23ba7d2b6c55c4ff41244c0f18af06df7e22aef89a0c70909f34f3c276529f21fe90dcf75d62695e956482fb0060f89953c07cda628d02bac4f516368a67fa9d87354edc83c5e2ae2242a9671d091cf9bf223657e0e1a0e4c3d8055c944cf9ece97db8bee9e65a3328baa336949f853ce27d69b65f90f799a953383ba18a0dd49272f23ebc1b205136e8d98107b8722aee13656e5b6965b57f7139c5a4058858ced1a78cfb9aded41de11d3d408d045e2ceb9b3d6946890846ec2cb520b5c2764aef5f7dfe309f63bc463f23789bc11273e6225086b39ca38d7494d39ea9861687f0ed5e9c76c8a343fa20fb5e256e8ef871f35252fa07c25be7f30b76e4fd667d7e0d76f2ddc3d3ad00b224fb3a06f5b69749bfb4b3a93cd2bba42d4be5ccd9fc8bf20061f69a411d57acd7ccc161d1516b4617afb504b5845a0dd30b428ebee7e22d83f8c594b930131967ae5cc02cf531bfc195fd80e51633dd9f9b98ed261cbc72ff8e3b93efcdd6349b9b776bd1f9d14d2914ebead0749f9750a71daef945cc32d129e7be24d9c7a15a7e4e4d9912171da6c9067d95b54cd6133cf46e01f76251568774ea0ce8f110100be7061b004a8b0e435052c1a9d8a2dd61e0374ed750ca53a1d0d2762fb43dd8e2cf41ccd67026aa5f7757acd73be6452fef3789b366f51ac894056bcb0b0dee90b6465c120187efc29f9238a38307116e0dc877cfcba5b55178ce6cf4653d546559c46273a0d802f6edf14b9538ac00c712948e51cd40b45e1fac860bb73601b6b2d3482d1addd9ff0a606ead649b96e8b84277cb57ade44d4b56db8d9995a68fe291b0c0f05a6aaf386e760fdac8e0b8d789f653407e1b91aa74679d3b1e89581eba99f5b0fd404c9e0b8bff7a9b5980c584e1d0ef08b1faa2808a30b732cdc180c2da22b34e31e6fc5f8ba614d623051d50c52844d23d15b60759ec355d042b83e75bfddfd71095d1e264c056fa7b15df5df35fbd091b4f70137fa26eb3213c23116e7ca3051bce6cc874008f1acf15265d284de09677bc2e7b0405bcba347fb876de0a8eda421b6b83128da5a9aa4bce8508fb971e09b8d5b1058cfb57c9e860e6a18e6dde15257a8d9dcf8db3193f6e564de698f2777e5b518a44de3d3e173abcb92bc94567594d9d81e89bceff0ff36a22e2f067bf3809e8b00321c7fbb3f20973f14f109303c1d1ca1ffa27ebdd99cf9f990f1f7e56a862aa5da014f53115cb8a012ca22d5077e725698ae8507ef127499adacf20f84da657125884e21158b0e70baa5e17dfd07ab3da69f5b81841d41db2afec88bcea7e44a077ce0e8525984a74d2e9e45a486a1088bd7e34f04a80bf37bdc1085ceb0736fd52917139be204cce5aa9131be977ae58637b6880a95178427cd1634847c49710005721d677674175d2e45cfc35d1bd11f8e786ef6a378f266f7a9f5f2ff22a2d25ed895bb85cbde36e4e889f3825cc328e1c65a93f3fb59bcd3cbcd6c083c6f47e1005fa9de09cee65e084f44c7410bf0c359b89fc18993bda2cc775e8db9a77bfa33184fe9c2ab99d3f21d8284a7f47189886ed705856cc8adedba8775a4dfe664719ffe9c47e08bca9ea6937cc3631db3bce64916f762546835d2686d21efc8a817bd06869d01010acf257bf77aadfab6fa86ade6b3506bb0ad9151defb10c0c2be7ee90c873ea605b8c25df490bae03d241b8a378ba5143909ebe99a09dc109480fa9c5fed728f0c1d8f4f01b7ea440d2a8a833770b4fd299b6b114f186e9ace8b558c7df9f88fa3a6e8715e3ef9c8320d511269bf2f752808e58e442694b7d7b173471b143861462d08ca5575ed140a9795d772046c9f8bdf703bbb5f393e4977de5d6db9912abebbe9d1743eac0e9730f1f9f210d55849f96e64136c0af6ed360319f80b3f44fca6ec731454a7db27da2f71083a728aeeca3a52d684bcba4ad1b26668e6c15af67ff39e3a59dbc235f9bb7f2465e70bb788e945fdd72d3397a884251d9704c337903be69e2887a7d56297360b3252c578b224a14b52b8e3b0cac3537e47177c797585c7f641ab54984d5475dfb43b6cffa1632382ce9b834871255c</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码以阅读这篇私密文章。</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 未定义 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>图像滤波整理</title>
      <link href="/2020/11/08/%E5%9B%BE%E5%83%8F%E6%BB%A4%E6%B3%A2%E6%95%B4%E7%90%86/"/>
      <url>/2020/11/08/%E5%9B%BE%E5%83%8F%E6%BB%A4%E6%B3%A2%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="图像滤波"><a href="#图像滤波" class="headerlink" title="图像滤波"></a>图像滤波</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ol><li><strong>定义</strong>：图像滤波，即在尽量保留图像细节特征的条件下对目标图像的噪声进行抑制，是图像预处理中不可缺少的操作，其处理效果的好坏将直接影响到后续图像处理和分析的有效性和可靠性。</li><li><strong>比喻：</strong>我们可以把滤波器想象成一个包含加权系数的窗口，当使用这个滤波器平滑处理图像时，就把这个窗口放到图像之上，透过这个窗口来看我们得到的图像。</li><li><strong>公式：</strong> <script type="math/tex">O(i, j) = \sum_{m,n}I(i+m,j+n)K(m,n)</script> 其中O(i, j)是像素输出值，I(i+m, j+n)是像素输入值，K为滤波器（核：二维矩阵，核的不同值表示不同的算法。）</li><li><strong>种类</strong>：低通滤波器可以消除噪声、模糊化，高通滤波器可以提取边缘。<a href="https://blog.csdn.net/u013631121/article/details/80444602?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">白话文讲计算机视觉-第三讲-滤波器</a></li><li><strong>作用</strong>：图像滤波可以更改或者增强图像。通过滤波，可以强调一些特征或者去除图像中一些不需要的部分。滤波是一个邻域操作算子，利用给定像素周围的像素的值决定此像素的最终的输出值。常见的应用包括去噪、图像增强、检测边缘、检测角点、模板匹配等。</li></ol><h2 id="非学习类型算法"><a href="#非学习类型算法" class="headerlink" title="非学习类型算法"></a>非学习类型算法</h2><h3 id="0x01-均值滤波"><a href="#0x01-均值滤波" class="headerlink" title="0x01 均值滤波"></a>0x01 均值滤波</h3><ol><li><strong>定义</strong>：用其像素点周围像素的平均值代替元像素值，在滤除噪声的同时也会滤掉图像的边缘信息。</li><li><strong>代码：</strong>Python调用OpenCV实现均值滤波的核心函数：<strong>result = cv2.blur(原始图像,  核大小)</strong>   其中，核大小是以（宽度，高度）表示的元组形式，常见的形式包括：核大小（3，3）和（5，5）。<strong>boxFilter</strong>也可实现。</li></ol><h3 id="0x02-方框滤波"><a href="#0x02-方框滤波" class="headerlink" title="0x02 方框滤波"></a>0x02 方框滤波</h3><ol><li><strong>定义</strong>：方框滤波和均值滤波核基本一致，区别是需不需要均一化处理。</li><li><strong>代码</strong>： OpenCV调用boxFilter()函数实现方框滤波。函数：<strong>result = cv2.boxFilter(原始图像, 目标图像深度, 核大小, normalize属性)</strong>  其中，目标图像深度是int类型，通常用“-1”表示与原始图像一致；核大小主要包括（3，3）和（5，5）；normalize属性表示是否对目标图像进行归一化处理，当normalize为true时需要执行均值化处理，当normalize为false时，不进行均值化处理，实际上为求周围各像素的和，很容易发生溢出，溢出时均为白色，对应像素值为255。</li></ol><h3 id="0x03-中值滤波"><a href="#0x03-中值滤波" class="headerlink" title="0x03 中值滤波"></a><strong>0x03 中值滤波</strong></h3><ol><li><strong>定义：</strong>中值滤波用测试像素周围邻域像素集中的中值代替原像素。中值滤波去除椒盐噪声和斑块噪声时，效果非常明显。在OpenCV中，可以使用函数medianBlur进行操作。</li><li><strong>代码</strong>： OpenCV主要调用medianBlur()函数实现中值滤波。图像平滑里中值滤波的效果最好。<strong>dst = cv2.medianBlur(src, ksize)</strong>   其中，src表示源文件，ksize表示核大小。核必须是大于1的奇数，如3、5、7等。</li></ol><h3 id="0x04-高斯滤波"><a href="#0x04-高斯滤波" class="headerlink" title="0x04 高斯滤波"></a>0x04 高斯滤波</h3><ol><li><strong>定义</strong>：加权平均，距离越近的点权重越大，距离越远的点权重越小。由于图像是二维矩阵，则采用二维高斯函数(正态分布)<script type="math/tex">f(x,y)= \frac{1}{2πσ^2} e^{\frac{-(x^2+y^2)}{2σ^2}}</script> 。如果原图是彩色图片，可以对RGB三个通道分别做高斯模糊。参考：<a href="https://blog.csdn.net/nima1994/article/details/79776802" target="_blank" rel="noopener">高斯模糊（高斯滤波）的原理与算法</a></li><li><strong>边界处理</strong>：把已有的点拷贝到另一面的对应位置，模拟出完整的矩阵。</li><li><strong>公式</strong>：以 q为中心的窗口中，某一点 p在高斯滤波过程中。 权重(空间)： <script type="math/tex">G(p) = \frac{1}{2πσ^2} e^{\frac{-||p-q||^2}{2σ^2}}</script> </li><li><strong>代码</strong>：Python中OpenCV主要调用GaussianBlur函数：<strong>dst = cv2.GaussianBlur(src, ksize, sigmaX)</strong>   其中，src表示原始图像；ksize表示核大小，核大小（N, N）必须是奇数；sigmaX表示X方向方差，主要控制权重，sigmaX小，表现在高斯曲线上就是曲线越高越尖，表现在滤波效果上就是模糊程度小（sigmaX大，表现在高斯曲线上就是曲线越矮越平缓，表现在滤波效果上就是模糊程度大）。 </li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">@author: Dragon Liu</span></span><br><span class="line"><span class="string">Operating environment: Python 3.7.1</span></span><br><span class="line"><span class="string">lib:  opencv-python</span></span><br><span class="line"><span class="string">Date: 2020/3/16</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment">#导入库</span></span><br><span class="line"><span class="keyword">import</span> cv2  </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"> </span><br><span class="line"><span class="comment">#读取图片</span></span><br><span class="line">img = cv2.imread(<span class="string">'02.png'</span>)</span><br><span class="line">source = cv2.cvtColor(img,cv2.COLOR_BGR2RGB)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#方框滤波</span></span><br><span class="line">img_box = cv2.boxFilter(source, <span class="number">-1</span>, (<span class="number">5</span>,<span class="number">5</span>), normalize=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 均值滤波</span></span><br><span class="line">img_blur = cv2.blur(source, (<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#中值滤波</span></span><br><span class="line">img_median = cv2.medianBlur(source, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 高斯滤波</span></span><br><span class="line">img_Guassian = cv2.GaussianBlur(source, (<span class="number">5</span>,<span class="number">5</span>), <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#显示图形</span></span><br><span class="line">titles = [<span class="string">'Source Image'</span>, <span class="string">'BoxFilter Image'</span>, <span class="string">'Blur Image'</span>, </span><br><span class="line">         <span class="string">'Median Image'</span>, <span class="string">'Guassian Image'</span>]  </span><br><span class="line">images = [source, img_box, img_blur, img_Guassian, img_median]  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):  </span><br><span class="line">   plt.subplot(<span class="number">2</span>, <span class="number">3</span>, i+<span class="number">1</span>), plt.imshow(images[i], <span class="string">'gray'</span>)  </span><br><span class="line">   plt.title(titles[i])  </span><br><span class="line">   plt.xticks([]),plt.yticks([])  </span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>参考：<a href="https://blog.csdn.net/Eastmount/article/details/82216380?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">我跳</a></p><h3 id="0x05-双边滤波-—-边缘保护滤波"><a href="#0x05-双边滤波-—-边缘保护滤波" class="headerlink" title="0x05 双边滤波 —  边缘保护滤波"></a>0x05 双边滤波 —  <strong>边缘保护滤波</strong></h3><ol><li><strong>定义</strong>：高斯滤波只考虑了周边点与中心点的空间距离来计算得到权重，会模糊掉边缘。在高斯滤波的基础上加入了像素值(灰度)权重项，也就是说既要考虑距离因素，也要考虑像素值差异的影响，像素值越相近，权重越大。参考：<a href="http://www.360doc.com/content/17/0306/14/28838452_634420847.shtml" target="_blank" rel="noopener">双边滤波详解</a>、<a href="https://blog.csdn.net/u013921430/article/details/84532068" target="_blank" rel="noopener">【图像处理】——双边滤波</a></li><li><strong>公式：</strong> 像素值权重     <script type="math/tex">G_r= exp(-{\frac{||I_p-I_q||^2}{2σ^2_r}})</script>  空间距离权重  <script type="math/tex">G_s= exp(-{\frac{||p-q||^2}{2σ^2_s}})</script>  滤波窗口内每个像素值的权重和 <script type="math/tex">W(q) = \sum_{p\in S} G_s(p)G_r(p)</script> —-用于权重的归一化 滤波结果： <script type="math/tex">BF = \frac {1}{W_q}\sum_{p\in S} G_s(p)G_r(p)*I_p</script> </li><li><strong>代码</strong>：OpenCV在Python中双边滤波函数是<strong>cv2.bilateralFilter(src, d, sigmaColor, sigmaSpace）</strong>时间复杂度 <script type="math/tex">O(Nr^2)</script>  <strong>① s</strong>rc是输入图像； ② d是在过滤期间使用的每个像素邻域的直径，如果输入d非0，则sigmaSpace由d计算得出，如果sigmaColor没输入，则sigmaColor由sigmaSpace计算得出； ③ sigmaColor是灰度值相似性高斯函数标准差，色彩空间的标准方差，一般尽可能大， 较大的参数值意味着像素邻域内较远的颜色会混合在一起， 从而产生更大面积的半相等颜色； ④ sigmaSpace是空间高斯函数标准差，坐标空间的标准方差(像素单位)，一般尽可能小。 参数值越大意味着只要它们的颜色足够接近，越远的像素都会相互影响。 当d &gt; 0时，它指定邻域大小而不考虑sigmaSpace。 否则，d与sigmaSpace成正比。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">@author: Dragon Liu</span></span><br><span class="line"><span class="string">Operating environment: Python 3.7.1</span></span><br><span class="line"><span class="string">lib:  opencv-python</span></span><br><span class="line"><span class="string">Date: 2020/3/16</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment">#导入库</span></span><br><span class="line"><span class="keyword">import</span> cv2  </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"> </span><br><span class="line"><span class="comment">#读取图片</span></span><br><span class="line">img = cv2.imread(<span class="string">'02.png'</span>)</span><br><span class="line">source = cv2.cvtColor(img,cv2.COLOR_BGR2RGB)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#双边滤波</span></span><br><span class="line">img_bilateral = cv2.bilateralFilter(source, <span class="number">7</span>, <span class="number">50</span>, <span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#显示图形</span></span><br><span class="line">titles = [<span class="string">'Source Image'</span>, <span class="string">'bilateralFilter Image'</span>]  </span><br><span class="line">images = [source, img_bilateral]  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):  </span><br><span class="line">   plt.subplot(<span class="number">1</span>, <span class="number">2</span>, i+<span class="number">1</span>), plt.imshow(images[i], <span class="string">'gray'</span>)  </span><br><span class="line">   plt.title(titles[i])  </span><br><span class="line">   plt.xticks([]),plt.yticks([]) <span class="comment">#禁止输出坐标轴 </span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h3 id="0x06-引导滤波-—-边缘保护滤波"><a href="#0x06-引导滤波-—-边缘保护滤波" class="headerlink" title="0x06  引导滤波 — 边缘保护滤波"></a>0x06  引导滤波 — <strong>边缘保护滤波</strong></h3><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a><strong>1. 定义</strong></h4><p>　　引导滤波的思想用一张引导图像产生权重，从而对输入图像进行处理。引导滤波除了可以用于图像平滑，还可以用于HDR压缩、细节增强、图像去雾、联合上采样等图像处理任务。引导滤波中空间域的贡献自然取决于窗口的大小，即由参数 r 决定。而标准差则是评判颜色差异性的参数，窗口中标准差越大，说明局部的像素相似性越差。</p><h4 id="2-公式：【图像处理】引导滤波"><a href="#2-公式：【图像处理】引导滤波" class="headerlink" title="2. 公式：【图像处理】引导滤波"></a><strong>2. 公式：</strong><a href="https://blog.csdn.net/u013921430/article/details/99695647" target="_blank" rel="noopener">【图像处理】引导滤波</a></h4><ol><li><strong>权重</strong> <script type="math/tex">W_{ij}(i,j) = \frac{1}{|ω|^2} \sum_{k:(i,j)\in ω_k} (1+ \frac{(I_i-μ_k)(I_j-μ_k)}{σ_k^2+ϵ})</script>   (局部窗口 <script type="math/tex">ω_k</script> ；ϵ是 <script type="math/tex">L_2</script> 范数正则化系数，防止<script type="math/tex">a_k</script> 过大； <script type="math/tex">μ_k</script>与 <script type="math/tex">σ_k</script> 表示 <script type="math/tex">I_i</script> 在窗口内的均值、标准差； <script type="math/tex">∣w∣</script> 表示窗口内像素块的总数 )</li><li><strong>结果</strong> <script type="math/tex">q_i = \sum_{j}{W_{ij}(I)*p_j}</script>   (q、I、p分表表示输出图像、引导图像和输入图像 ，i、j 分别表示图像中像素点的索引。权重 W 仅与引导图像 I 有关，而在双边滤波中权重 W 由输入图像自身决定。)</li></ol><h4 id="3-代码1-引导滤波-："><a href="#3-代码1-引导滤波-：" class="headerlink" title="3. 代码1(引导滤波)："></a><strong>3. 代码1(引导滤波)</strong>：</h4><p>　　第一个代码块是手写实现引导滤波。时间复杂度O(N)，当 r 与 ϵ 越大，图像被平滑的程度越大。伪代码中：r是窗口半径， <script type="math/tex">f_{mean}(I,r)</script> 表示在(r, r)窗口对图像做均值滤波。大佬博客：<a href="https://blog.csdn.net/u013921430/article/details/99695647" target="_blank" rel="noopener">我跳</a><br>　　第二个代码块是使用的现有库。参考：<a href="https://jinzhangyu.github.io/2018/09/06/2018-09-06-OpenCV-Python%E6%95%99%E7%A8%8B-16-%E5%B9%B3%E6%BB%91%E5%9B%BE%E5%83%8F-3/" target="_blank" rel="noopener">我跳</a></p><p><img alt="&#x56FE;1 GF&#x7B97;&#x6CD5;&#x6846;&#x67B6;" data-src="https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/GF.png" class="lozad"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">@First_author: 不用先生</span></span><br><span class="line"><span class="string">@Second_author: Dragon Liu</span></span><br><span class="line"><span class="string">Operating environment: Python 3.7.1</span></span><br><span class="line"><span class="string">lib:  opencv-python</span></span><br><span class="line"><span class="string">Date: 2020/3/16</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">input_fn = <span class="string">'03.png'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数名：my_guidedFilter_oneChannel</span></span><br><span class="line"><span class="comment"># 函数功能：用于单通道图像（灰度图）的引导滤波函数；</span></span><br><span class="line"><span class="comment"># 参数：srcImg：输入图像，为单通道图像；</span></span><br><span class="line"><span class="comment"># 参数：guideImg：引导图像，为单通道图像，尺寸与输入图像一致；</span></span><br><span class="line"><span class="comment"># 参数：rad：滤波器大小r，应该保证为奇数，默认值为9；</span></span><br><span class="line"><span class="comment"># 参数：eps：防止a过大的正则化参数ϵ，</span></span><br><span class="line"><span class="comment"># 返回：dstImg：输出图像，尺寸、通道数与输入图像吻合；</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_guidedFilter_oneChannel</span><span class="params">(srcImg, guidedImg, rad=<span class="number">13</span>, eps=<span class="number">0.1</span>)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 转换数值类型，并归一化</span></span><br><span class="line">    srcImg = srcImg/<span class="number">255.0</span></span><br><span class="line">    guidedImg = guidedImg/<span class="number">255.0</span></span><br><span class="line">    img_shape = np.shape(srcImg)<span class="comment">#查看矩阵或者数组的维数。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 在(rad, rad)窗口的内对图像做均值滤波。</span></span><br><span class="line">    P_mean = cv2.boxFilter(srcImg, <span class="number">-1</span>, (rad, rad), normalize=<span class="literal">True</span>) <span class="comment"># p的均值平滑</span></span><br><span class="line">    I_mean = cv2.boxFilter(guidedImg,<span class="number">-1</span>, (rad, rad), normalize=<span class="literal">True</span>) <span class="comment"># I的均值平滑</span></span><br><span class="line"></span><br><span class="line">    I_square_mean = cv2.boxFilter(np.multiply(guidedImg, guidedImg), <span class="number">-1</span>, (rad, rad), normalize=<span class="literal">True</span>) <span class="comment">#I*I的均值平滑</span></span><br><span class="line">    I_mul_P_mean = cv2.boxFilter(np.multiply(srcImg, guidedImg), <span class="number">-1</span>, (rad, rad), normalize=<span class="literal">True</span>)<span class="comment"># I*p的均值平滑</span></span><br><span class="line">    </span><br><span class="line">    var_I = I_square_mean-np.multiply(I_mean,I_mean)<span class="comment"># 方差</span></span><br><span class="line">    cov_I_P = I_mul_P_mean-np.multiply(I_mean,P_mean)<span class="comment"># 协方差</span></span><br><span class="line">    </span><br><span class="line">    a = cov_I_P/(var_I+eps)<span class="comment"># 相关因子a</span></span><br><span class="line">    b = P_mean-np.multiply(a,I_mean)<span class="comment"># 相关因子b</span></span><br><span class="line">    </span><br><span class="line">    a_mean = cv2.boxFilter(a, <span class="number">-1</span>, (rad, rad), normalize=<span class="literal">True</span>) <span class="comment"># 对a进行均值平滑</span></span><br><span class="line">    b_mean = cv2.boxFilter(b, <span class="number">-1</span>, (rad, rad), normalize=<span class="literal">True</span>)  <span class="comment"># 对b进行均值平滑</span></span><br><span class="line">    </span><br><span class="line">    dstImg = np.multiply(a_mean,guidedImg)+b_mean</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dstImg*<span class="number">255.0</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 函数名：my_guidedFilter_threeChannel</span></span><br><span class="line"><span class="comment"># 函数功能：用于三通道图像（RGB彩色图）的引导滤波函数；</span></span><br><span class="line"><span class="comment"># 参数：srcImg：输入图像，为三通道图像；</span></span><br><span class="line"><span class="comment"># 参数：guideImg：引导图像，为三通道图像，尺寸与输入图像一致；</span></span><br><span class="line"><span class="comment"># 参数：rad：滤波器大小r，应该保证为奇数，默认值为9；</span></span><br><span class="line"><span class="comment"># 参数：eps：防止a过大的正则化参数ϵ，</span></span><br><span class="line"><span class="comment"># 返回：dstImg：输出图像，尺寸、通道数与输入图像吻合；</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_guidedFilter_threeChannel</span><span class="params">(srcImg, guidedImg, rad=<span class="number">9</span>, eps=<span class="number">0.01</span>)</span>:</span></span><br><span class="line">    </span><br><span class="line">    img_shape = np.shape(srcImg)</span><br><span class="line"></span><br><span class="line">    dstImg = np.zeros(img_shape, dtype=float)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ind <span class="keyword">in</span> range(<span class="number">0</span>,img_shape[<span class="number">2</span>]):</span><br><span class="line">        dstImg[:,:,ind] = my_guidedFilter_oneChannel(srcImg[:,:,ind],</span><br><span class="line">              guidedImg[:,:,ind], rad, eps)</span><br><span class="line">    </span><br><span class="line">    dstImg = dstImg.astype(np.uint8)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dstImg</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    img = cv2.imread(input_fn)<span class="comment">#读入图像</span></span><br><span class="line">    print( np.shape(img) )</span><br><span class="line"></span><br><span class="line">    dstimg = my_guidedFilter_threeChannel(img, img, <span class="number">9</span> , <span class="number">0.01</span>)<span class="comment">#输入图像作为自身的引导图</span></span><br><span class="line">    print( np.shape(dstimg) )</span><br><span class="line">    <span class="comment"># cv2.imwrite('output.jpg',dstimg)</span></span><br><span class="line">    cv2.imshow(<span class="string">'output'</span>, dstimg)</span><br><span class="line">    cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">@First_author: Jin ZhangYu</span></span><br><span class="line"><span class="string">@Second_author: Dragon Liu</span></span><br><span class="line"><span class="string">Operating environment: Python 3.7.1</span></span><br><span class="line"><span class="string">lib:  opencv-contrib-python</span></span><br><span class="line"><span class="string">Date: 2020/3/16</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 导入库</span></span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> skimage</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造参数解析器</span></span><br><span class="line"><span class="comment"># ap = argparse.ArgumentParser()</span></span><br><span class="line"><span class="comment"># ap.add_argument("-H:\project_work\Machine_Vision_Lab\thesis\Gaussian\code", "--02.png", required=True, help = "Path to the image")</span></span><br><span class="line"><span class="comment"># args = vars(ap.parse_args())</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载图像并显示</span></span><br><span class="line">input_fn = <span class="string">'02.png'</span></span><br><span class="line"><span class="comment"># img = cv2.imread(args["image"],1)</span></span><br><span class="line">img = cv2.imread(input_fn)</span><br><span class="line">img = img[:,:,::<span class="number">-1</span>]</span><br><span class="line">guide = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行导向滤波</span></span><br><span class="line">dst1 = cv2.ximgproc.guidedFilter(</span><br><span class="line">            guide=guide, src=img, radius=<span class="number">16</span>, eps=<span class="number">50</span>, dDepth=<span class="number">-1</span>)</span><br><span class="line">dst2 = cv2.ximgproc.guidedFilter(</span><br><span class="line">            guide=guide, src=img, radius=<span class="number">16</span>, eps=<span class="number">200</span>, dDepth=<span class="number">-1</span>)</span><br><span class="line">dst3 = cv2.ximgproc.guidedFilter(</span><br><span class="line">            guide=guide, src=img, radius=<span class="number">16</span>, eps=<span class="number">1000</span>, dDepth=<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制图片</span></span><br><span class="line">images = [img,[dst1,dst2,dst3]]</span><br><span class="line">titles =    [</span><br><span class="line">                <span class="string">'Original'</span>,</span><br><span class="line">                [<span class="string">'Guided Filter eps=50'</span>,<span class="string">'Guided Filter eps=200'</span>,<span class="string">'Guided Filter eps=1000'</span>]</span><br><span class="line">            ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制原图</span></span><br><span class="line">plt.figure(figsize=(<span class="number">9</span>,<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>),plt.imshow(images[<span class="number">0</span>])</span><br><span class="line">plt.title(titles[<span class="number">0</span>], fontsize=<span class="number">10</span>),plt.xticks([]), plt.yticks([])</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>),plt.imshow(images[<span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line">plt.title(titles[<span class="number">1</span>][<span class="number">0</span>], fontsize=<span class="number">10</span>),plt.xticks([]), plt.yticks([])</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>),plt.imshow(images[<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">plt.title(titles[<span class="number">1</span>][<span class="number">1</span>], fontsize=<span class="number">10</span>),plt.xticks([]), plt.yticks([])</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>),plt.imshow(images[<span class="number">1</span>][<span class="number">2</span>])</span><br><span class="line">plt.title(titles[<span class="number">1</span>][<span class="number">2</span>], fontsize=<span class="number">10</span>),plt.xticks([]), plt.yticks([])</span><br><span class="line"></span><br><span class="line"><span class="comment"># plt.savefig('1_out.png', transparent=True, dpi=300, pad_inches = 0)</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h4 id="4-代码2-快速导向滤波"><a href="#4-代码2-快速导向滤波" class="headerlink" title="4. 代码2(快速导向滤波)"></a>4. 代码2(快速导向滤波)</h4><p>　　通过下采样减少像素点，计算mean_a &amp; mean_b后进行上采样恢复到原有的尺寸大小。假设缩放比例为s,那么缩小后像素点的个数为 <script type="math/tex">\frac {N}{s^2}</script> ，那么时间复杂度变为 <script type="math/tex">O(\frac {N}{s^2})</script> 。伪代码中：fmean代表均值平滑，fsubsample代表图像下采样即缩小图像，fupsample代表图片上采样即放大图像，s为缩小系数。参考：<a href="https://blog.csdn.net/wsp_1138886114/article/details/84228939?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">我跳</a></p><p><img alt="&#x56FE;2 FGF&#x7B97;&#x6CD5;&#x6846;&#x67B6;" data-src="https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/FGF.png" class="lozad"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">@First_author: SongpingWangSongpingWangs</span></span><br><span class="line"><span class="string">@Second_author: Dragon Liu</span></span><br><span class="line"><span class="string">Operating environment: Python 3.7.1</span></span><br><span class="line"><span class="string">lib:  opencv-python</span></span><br><span class="line"><span class="string">Date: 2020/3/16</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">guideFilter</span><span class="params">(I, p, winSize, eps, s)</span>:</span></span><br><span class="line">    <span class="comment"># 输入图像的高、宽</span></span><br><span class="line">    h, w = I.shape[:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 缩小图像</span></span><br><span class="line">    size = (int(round(w * s)), int(round(h * s)))</span><br><span class="line">    small_I = cv2.resize(I, size, interpolation=cv2.INTER_CUBIC)</span><br><span class="line">    small_p = cv2.resize(I, size, interpolation=cv2.INTER_CUBIC)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 缩小滑动窗口</span></span><br><span class="line">    X = winSize[<span class="number">0</span>]</span><br><span class="line">    small_winSize = (int(round(X * s)), int(round(X * s)))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># I的均值平滑 p的均值平滑</span></span><br><span class="line">    mean_small_I = cv2.blur(small_I, small_winSize)</span><br><span class="line">    mean_small_p = cv2.blur(small_p, small_winSize)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># I*I和I*p的均值平滑</span></span><br><span class="line">    mean_small_II = cv2.blur(small_I * small_I, small_winSize)</span><br><span class="line">    mean_small_Ip = cv2.blur(small_I * small_p, small_winSize)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 方差、协方差</span></span><br><span class="line">    var_small_I = mean_small_II - mean_small_I * mean_small_I</span><br><span class="line">    cov_small_Ip = mean_small_Ip - mean_small_I * mean_small_p</span><br><span class="line"></span><br><span class="line">    small_a = cov_small_Ip / (var_small_I + eps)</span><br><span class="line">    small_b = mean_small_p - small_a * mean_small_I</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对a、b进行均值平滑</span></span><br><span class="line">    mean_small_a = cv2.blur(small_a, small_winSize)</span><br><span class="line">    mean_small_b = cv2.blur(small_b, small_winSize)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 放大</span></span><br><span class="line">    size1 = (w, h)</span><br><span class="line">    mean_a = cv2.resize(mean_small_a, size1, interpolation=cv2.INTER_LINEAR)</span><br><span class="line">    mean_b = cv2.resize(mean_small_b, size1, interpolation=cv2.INTER_LINEAR)</span><br><span class="line"></span><br><span class="line">    q = mean_a * I + mean_b</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> q</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    eps = <span class="number">0.01</span></span><br><span class="line">    winSize = (<span class="number">16</span>,<span class="number">16</span>)       <span class="comment">#类似卷积核（数字越大，磨皮效果越好）</span></span><br><span class="line">    image = cv2.imread(<span class="string">r'02.png'</span>, cv2.IMREAD_ANYCOLOR)</span><br><span class="line">    image = cv2.resize(image,<span class="literal">None</span>,fx=<span class="number">0.8</span>,fy=<span class="number">0.8</span>,interpolation=cv2.INTER_CUBIC)</span><br><span class="line">    I = image/<span class="number">255.0</span>       <span class="comment">#将图像归一化</span></span><br><span class="line">    p =I</span><br><span class="line">    s = <span class="number">3</span> <span class="comment">#步长</span></span><br><span class="line">    guideFilter_img = guideFilter(I, p, winSize, eps,s)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存导向滤波结果</span></span><br><span class="line">    guideFilter_img = guideFilter_img  * <span class="number">255</span>         <span class="comment">#(0,1)-&gt;(0,255)</span></span><br><span class="line">    guideFilter_img[guideFilter_img  &gt; <span class="number">255</span>] = <span class="number">255</span>    <span class="comment">#防止像素溢出</span></span><br><span class="line">    guideFilter_img = np.round(guideFilter_img )</span><br><span class="line">    guideFilter_img = guideFilter_img.astype(np.uint8)</span><br><span class="line">    cv2.imshow(<span class="string">"image"</span>,image)</span><br><span class="line">    cv2.imshow(<span class="string">"winSize_16"</span>, guideFilter_img )</span><br><span class="line">    cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">    cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><h3 id="0x07-高通滤波-—-边缘检测-高反差保留"><a href="#0x07-高通滤波-—-边缘检测-高反差保留" class="headerlink" title="0x07 高通滤波 — 边缘检测/高反差保留"></a>0x07 高通滤波 — 边缘检测/高反差保留</h3><ol><li><strong>定义</strong>：</li><li><strong>代码</strong>：使用的函数有：<code>cv2.Sobel()</code> , <code>cv2.Schar()</code> , <code>cv2.Laplacian()</code> Sobel, scharr其实是求一阶或者二阶导数。scharr是对Sobel的优化。 Laplacian是求二阶导数。cv2.Sobel() 是一种带有方向过滤器。参考：<a href="https://blog.csdn.net/wsp_1138886114/article/details/82872838?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">我跳</a></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">@First_author: SongpingWang</span></span><br><span class="line"><span class="string">@Second_author: Dragon Liu</span></span><br><span class="line"><span class="string">Operating environment: Python 3.7.1</span></span><br><span class="line"><span class="string">lib:  opencv-python</span></span><br><span class="line"><span class="string">Date: 2020/3/16</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">dst = cv2.Sobel(src, ddepth, dx, dy[, dst[, ksize[, scale[, delta[, borderType]]]]])</span></span><br><span class="line"><span class="string">src:    需要处理的图像；</span></span><br><span class="line"><span class="string">ddepth: 图像的深度，-1表示采用的是与原图像相同的深度。 </span></span><br><span class="line"><span class="string">        目标图像的深度必须大于等于原图像的深度；</span></span><br><span class="line"><span class="string">dx和dy: 求导的阶数，0表示这个方向上没有求导，一般为0、1、2。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">dst     不用解释了；</span></span><br><span class="line"><span class="string">ksize： Sobel算子的大小，必须为1、3、5、7。  ksize=-1时，会用3x3的Scharr滤波器，</span></span><br><span class="line"><span class="string">        它的效果要比3x3的Sobel滤波器要好 </span></span><br><span class="line"><span class="string">scale： 是缩放导数的比例常数，默认没有伸缩系数；</span></span><br><span class="line"><span class="string">delta： 是一个可选的增量，将会加到最终的dst中， 默认情况下没有额外的值加到dst中</span></span><br><span class="line"><span class="string">borderType： 是判断图像边界的模式。这个参数默认值为cv2.BORDER_DEFAULT。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">img=cv2.imread(<span class="string">'02.png'</span>,cv2.IMREAD_COLOR)</span><br><span class="line">x=cv2.Sobel(img,cv2.CV_16S,<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line">y=cv2.Sobel(img,cv2.CV_16S,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">absx=cv2.convertScaleAbs(x)</span><br><span class="line">absy=cv2.convertScaleAbs(y)</span><br><span class="line">dist=cv2.addWeighted(absx,<span class="number">0.5</span>,absy,<span class="number">0.5</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">'original_img'</span>,img)</span><br><span class="line">cv2.imshow(<span class="string">'y'</span>,absy)</span><br><span class="line">cv2.imshow(<span class="string">'x'</span>,absx)</span><br><span class="line">cv2.imshow(<span class="string">'dsit'</span>,dist)</span><br><span class="line"></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><h3 id="0x08-窗口感知的高斯引导滤波"><a href="#0x08-窗口感知的高斯引导滤波" class="headerlink" title="0x08 窗口感知的高斯引导滤波"></a>0x08 窗口感知的高斯引导滤波</h3><ul><li><strong>gr.m</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function result = gr(px, py, qx, qy, dr)</span><br><span class="line">% 高斯空间核函数</span><br><span class="line">    result = exp( - ( (qx - px)^<span class="number">2</span> + (qy - py)^<span class="number">2</span> ) / (<span class="number">2</span> * dr^<span class="number">2</span>) );</span><br><span class="line">end</span><br></pre></td></tr></table></figure><ul><li><strong>gzeta.m</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function result = gzeta(guide_img, div, px, py, qx, qy, dzeta)</span><br><span class="line">% 高斯频域核函数</span><br><span class="line">    result = exp( - ( ( guide_img(px, py, div) - guide_img(qx, qy, div) )^<span class="number">2</span> )  / (<span class="number">2</span> * dzeta^<span class="number">2</span>) );</span><br><span class="line">end</span><br></pre></td></tr></table></figure><ul><li><strong>GS.m</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function output = GS(image, r, dr, px, py, div)</span><br><span class="line">% 求解高斯空间域滤波，返回指定像素点(p)的输出</span><br><span class="line">    Upsilon = <span class="number">0</span>;%τ，归一化系数</span><br><span class="line">    output = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i = -r : r % 以p为中心的窗口半径为<span class="number">2</span>r+<span class="number">1</span>的区域</span><br><span class="line">        <span class="keyword">for</span> j = -r : r</span><br><span class="line">            Upsilon = Upsilon + gr(px, py, px + i, py + j, dr);</span><br><span class="line">            output = output + gr(px, py, px + i, py + j, dr) * image(px + i,py + j,div);</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    output = output / Upsilon ;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><ul><li><strong>WGGF.m</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function output = WGGF(guide_img, source, r, dzeta, px, py, div, <span class="keyword">lambda</span>)</span><br><span class="line">% 窗口感知的高斯引导滤波</span><br><span class="line">%求解WGGF在每个像素点p的输出并返回</span><br><span class="line">    Upsilon = <span class="number">0</span>;%τ，归一化系数</span><br><span class="line">    output = <span class="number">0</span>;</span><br><span class="line">    flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i = -r : r</span><br><span class="line">        <span class="keyword">for</span> j = -r : r</span><br><span class="line">            temp = abs( guide_img(px + i, py + <span class="number">1</span>, div) - guide_img(px, py, div) );</span><br><span class="line">            <span class="keyword">if</span> temp &lt;= <span class="keyword">lambda</span> </span><br><span class="line">                flag = flag + <span class="number">1</span>;</span><br><span class="line">                Upsilon = Upsilon + gzeta(guide_img, div, px, py, px+i, py+j, dzeta);</span><br><span class="line">                output = output + guide_img(px + i,py + j,div) * gzeta(guide_img, div, px, py, px+i, py+j, dzeta);</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> flag == <span class="number">1</span> %不满足窗口感知的要求，返回<span class="number">3</span>*<span class="number">3</span>窗口中的像素点中值</span><br><span class="line">        output = medfilt2( source( (px - <span class="number">1</span>):(px + <span class="number">1</span>), (py - <span class="number">1</span>):(py + <span class="number">1</span>), j), [<span class="number">3</span>,<span class="number">3</span>] );</span><br><span class="line">    <span class="keyword">else</span> %满足条件</span><br><span class="line">        output = output / Upsilon ;</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><ul><li><strong>Main.m</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">%% 读取图片</span><br><span class="line">source = im2double( imread(<span class="string">'01.jpg'</span>) );</span><br><span class="line">guide_img = source;</span><br><span class="line"></span><br><span class="line">%% 求解高斯引导滤波</span><br><span class="line">[m ,n, div] = size(source);</span><br><span class="line">r = <span class="number">5</span>; %窗口半径</span><br><span class="line">dr = <span class="number">0.5</span>; %空域带宽</span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span> : div</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span> : m</span><br><span class="line">        <span class="keyword">for</span> j = <span class="number">1</span> : n</span><br><span class="line">            <span class="keyword">if</span> i &lt;= r || i &gt;= m - r || j &lt;= r || j &gt;= n - r %图片四周处理(原像素)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                guide_img(i,j,k) = GS(source, r, dr, i, j, k); %空间域滤波</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">%% 求解WGGF</span><br><span class="line">target = guide_img;</span><br><span class="line">r = <span class="number">5</span>; %窗口半径</span><br><span class="line">dzeta = <span class="number">0.1</span>; %频域带宽</span><br><span class="line"><span class="keyword">lambda</span> = <span class="number">0.12</span>; % λ为一选定的阈值 </span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span> : div</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span> : m</span><br><span class="line">        <span class="keyword">for</span> j = <span class="number">1</span> : n</span><br><span class="line">            <span class="keyword">if</span> i &lt;= r || i &gt;= m - r || j &lt;= r || j &gt;= n - r%图片四周处理(引导像素)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                target(i, j, k) = WGGF(guide_img, source, r, dzeta, i, j, k, <span class="keyword">lambda</span>); </span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">%% 显示图形</span><br><span class="line">figure;</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>), imshow(source), title(<span class="string">'Source image'</span>);</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>), imshow(target), title(<span class="string">'WGGF image'</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>WGGF.py(Bug)</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">@author: Dragon Liu</span></span><br><span class="line"><span class="string">Operating environment: Python 3.7.1</span></span><br><span class="line"><span class="string">lib:  opencv-python</span></span><br><span class="line"><span class="string">Date: 2020/3/22</span></span><br><span class="line"><span class="string">BUG: 时间复杂度O(m*n*div*r*r)，不可行，另外存在img[]访问问题</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment">#导入库</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> cv2  </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 高斯空间核函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gr</span><span class="params">(px, py, qx, qy, dr)</span>:</span></span><br><span class="line"></span><br><span class="line">   nut = math.exp( - ( pow((qx - px), <span class="number">2</span>) + pow((qy - py), <span class="number">2</span>) ) ) <span class="comment">#分子</span></span><br><span class="line">   det = <span class="number">2</span> * pow(dr, <span class="number">2</span>) <span class="comment">#分母</span></span><br><span class="line">   result =  nut / det  </span><br><span class="line">   <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment"># 高斯频域核函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gzeta</span><span class="params">(guide_img, div, px, py, qx, qy, dzeta)</span>:</span></span><br><span class="line"></span><br><span class="line">   guide_img = guide_img </span><br><span class="line">   nut = math.exp( - ( pow( ( guide_img[px, py, div] - guide_img[qx, qy, div] ), <span class="number">2</span> ) ) ) <span class="comment">#分子</span></span><br><span class="line">   det = <span class="number">2</span> * pow(dzeta, <span class="number">2</span>)</span><br><span class="line">   result =  nut / det</span><br><span class="line">   <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment"># 求解高斯空间域滤波，返回指定像素点(p)的输出</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GS</span><span class="params">(image, r, dr, px, py, div)</span>:</span></span><br><span class="line"></span><br><span class="line">   Upsilon = <span class="number">0</span> <span class="comment">#τ，归一化系数</span></span><br><span class="line">   output = <span class="number">0</span></span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> range(r, -(r+<span class="number">1</span>), <span class="number">-1</span>):<span class="comment"># 以p为中心的窗口半径为2r+1的区域</span></span><br><span class="line">      <span class="keyword">for</span> j <span class="keyword">in</span> range(r, -(r+<span class="number">1</span>), <span class="number">-1</span>):</span><br><span class="line">         Upsilon = Upsilon + gr(px, py, px + i, py + j, dr)</span><br><span class="line">         output = output + gr(px, py, px + i, py + j, dr) * image[px + i,py + j,div]</span><br><span class="line">   </span><br><span class="line">   output = output / Upsilon </span><br><span class="line">   <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"><span class="comment">#求解指定窗口(3*3)的中值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">medbox</span><span class="params">(img, x, y, div, length, width)</span>:</span></span><br><span class="line">   </span><br><span class="line">   nums = []</span><br><span class="line">   length = width = <span class="number">3</span></span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> range(math.floor(length/<span class="number">2</span>), -math.floor(length/<span class="number">2</span>)<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">      <span class="keyword">for</span> j <span class="keyword">in</span> range(math.floor(width/<span class="number">2</span>), -math.floor(width/<span class="number">2</span>)<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">         nums.append( img[x+i, y+j, div])</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> np.median(nums)</span><br><span class="line"></span><br><span class="line"><span class="comment">#窗口感知的高斯引导滤波</span></span><br><span class="line"><span class="comment">#求解WGGF在每个像素点p的输出并返回</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">WGGF</span><span class="params">(guide_img,source,r,dzeta,px,py,div, lam)</span>:</span></span><br><span class="line">   </span><br><span class="line">   guide_img = guide_img </span><br><span class="line">   source = source  </span><br><span class="line">   Upsilon = <span class="number">0</span> <span class="comment">#τ，归一化系数</span></span><br><span class="line">   output = <span class="number">0</span></span><br><span class="line">   flag = <span class="number">0</span></span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> range(r, -(r+<span class="number">1</span>), <span class="number">-1</span>):<span class="comment"># 以p为中心的窗口半径为2r+1的区域</span></span><br><span class="line">      <span class="keyword">for</span> j <span class="keyword">in</span> range(r, -(r+<span class="number">1</span>), <span class="number">-1</span>):</span><br><span class="line">         temp = abs( guide_img[px + i, py + <span class="number">1</span>, div] - guide_img[px, py, div] )</span><br><span class="line">         <span class="keyword">if</span> temp &lt;= lam:</span><br><span class="line">               flag = flag + <span class="number">1</span></span><br><span class="line">               Upsilon = Upsilon + gzeta(guide_img, div, px, py, px+i, py+j, dzeta)</span><br><span class="line">               output = output + guide_img[px + i,py + j,div] * gzeta(guide_img, div, px, py, px+i, py+j, dzeta)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> flag == <span class="number">1</span> <span class="keyword">or</span> Upsilon == <span class="number">0</span>: <span class="comment">#不满足窗口感知的要求，返回3*3窗口中的像素点中值</span></span><br><span class="line">      output = medbox( source, px, py, j, <span class="number">3</span>, <span class="number">3</span> )</span><br><span class="line">   <span class="keyword">else</span>: <span class="comment">#满足条件</span></span><br><span class="line">      output = output / Upsilon </span><br><span class="line">   <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主函数，测试</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">   <span class="comment">#读取图片</span></span><br><span class="line">   img = cv2.imread(<span class="string">'02.png'</span>, <span class="number">1</span>)</span><br><span class="line">   source = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)</span><br><span class="line">   source = source / <span class="number">255.0</span></span><br><span class="line">   guide_img = source</span><br><span class="line">   </span><br><span class="line">   print(<span class="number">1.666</span>)</span><br><span class="line">   <span class="comment">#求解高斯引导滤波</span></span><br><span class="line">   [m ,n, div] = np.shape(source)<span class="comment">#查看矩阵或者数组的维数。</span></span><br><span class="line">   r = <span class="number">5</span> <span class="comment">#窗口半径</span></span><br><span class="line">   dr = <span class="number">0.5</span> <span class="comment">#空域带宽</span></span><br><span class="line">   <span class="comment"># 高斯滤波</span></span><br><span class="line">   guide_img = cv2.GaussianBlur(source, (r,r), dr)</span><br><span class="line">               </span><br><span class="line">   </span><br><span class="line">   print(<span class="number">2.666</span>)</span><br><span class="line">   <span class="comment">#求解WGGF</span></span><br><span class="line">   target = guide_img</span><br><span class="line">   r = <span class="number">5</span> <span class="comment">#窗口半径</span></span><br><span class="line">   dzeta = <span class="number">0.1</span> <span class="comment">#频域带宽</span></span><br><span class="line">   lam = <span class="number">0.12</span> <span class="comment">#λ为一选定的阈值 </span></span><br><span class="line">   num = <span class="number">0</span></span><br><span class="line">   <span class="keyword">for</span> k <span class="keyword">in</span> range(div):</span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">         <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">               <span class="keyword">if</span> i &lt;= r <span class="keyword">or</span> i &gt;= m - r <span class="keyword">or</span> j &lt;= r <span class="keyword">or</span> j &gt;= n - r: <span class="comment">#图片边界处理(引导像素)</span></span><br><span class="line">                  <span class="keyword">continue</span></span><br><span class="line">               <span class="keyword">else</span>:</span><br><span class="line">                  target[i, j, k] = WGGF(guide_img, source, r, dzeta, i, j, k, lam)</span><br><span class="line">               num = num + <span class="number">1</span></span><br><span class="line">               print(num)</span><br><span class="line">   print(<span class="number">3.666</span>)</span><br><span class="line">   <span class="comment">#显示图形</span></span><br><span class="line">   titles = [<span class="string">'Source Image'</span>, <span class="string">'WGGF Image'</span>]  </span><br><span class="line">   images = [source*<span class="number">255.0</span>, target*<span class="number">255.0</span>]  </span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):  </span><br><span class="line">      plt.subplot(<span class="number">1</span>, <span class="number">2</span>, i+<span class="number">1</span>), plt.imshow(images[i], <span class="string">'gray'</span>)  </span><br><span class="line">      plt.title(titles[i])  </span><br><span class="line">      plt.xticks([]),plt.yticks([]) <span class="comment">#禁止输出坐标轴 </span></span><br><span class="line">   plt.show()  </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 未定义 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像光顺 </tag>
            
            <tag> CV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF编码加密整理</title>
      <link href="/2020/07/13/CTF%E7%BC%96%E7%A0%81%E5%8A%A0%E5%AF%86%E6%95%B4%E7%90%86/"/>
      <url>/2020/07/13/CTF%E7%BC%96%E7%A0%81%E5%8A%A0%E5%AF%86%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="01-常见编码"><a href="#01-常见编码" class="headerlink" title="01 常见编码"></a>01 常见编码</h1><h2 id="0x01-莫尔斯电码-Morse-Code"><a href="#0x01-莫尔斯电码-Morse-Code" class="headerlink" title="0x01 莫尔斯电码(Morse Code)"></a>0x01 莫尔斯电码(Morse Code)</h2><h3 id="01-原理"><a href="#01-原理" class="headerlink" title="01 原理"></a>01 原理</h3><p>　　摩尔斯电码也被称作摩斯密码，是一种时通时断的<a href="https://baike.baidu.com/item/信号/32683" target="_blank" rel="noopener">信号</a>代码，通过不同的排列顺序来表达不同的英文字母、数字和标点符号。</p><h3 id="02-特征"><a href="#02-特征" class="headerlink" title="02 特征"></a>02 特征</h3><ol><li>由<code>. -</code>组成的字符串；</li><li>由<code>0 1</code>组成的字符串，且为空格间隔得一组一组的。</li></ol><h3 id="03-解题"><a href="#03-解题" class="headerlink" title="03 解题"></a>03 解题</h3><ul><li><a href="http://ctf.ssleye.com/morse.html" target="_blank" rel="noopener">通道1(英文字母小写)</a></li><li><a href="http://www.zhongguosou.com/zonghe/moErSiCodeConverter.aspx" target="_blank" rel="noopener">通道2(英文字母大写)</a></li><li><a href="http://moersima.00cha.net/" target="_blank" rel="noopener">通道3(英文字母小写)</a></li><li>01破解脚本</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">string = <span class="string">'...'</span></span><br><span class="line">dic= &#123;    <span class="string">'01'</span>: <span class="string">'A'</span>,</span><br><span class="line">        <span class="string">'1000'</span>: <span class="string">'B'</span>,</span><br><span class="line">        <span class="string">'1010'</span>: <span class="string">'C'</span>,</span><br><span class="line">         <span class="string">'100'</span>: <span class="string">'D'</span>,</span><br><span class="line">           <span class="string">'0'</span>: <span class="string">'E'</span>,</span><br><span class="line">        <span class="string">'0010'</span>: <span class="string">'F'</span>,</span><br><span class="line">         <span class="string">'110'</span>: <span class="string">'G'</span>,</span><br><span class="line">        <span class="string">'0000'</span>: <span class="string">'H'</span>,</span><br><span class="line">          <span class="string">'00'</span>: <span class="string">'I'</span>,</span><br><span class="line">        <span class="string">'0111'</span>: <span class="string">'J'</span>,</span><br><span class="line">         <span class="string">'101'</span>: <span class="string">'K'</span>,</span><br><span class="line">        <span class="string">'0100'</span>: <span class="string">'L'</span>,</span><br><span class="line">          <span class="string">'11'</span>: <span class="string">'M'</span>,</span><br><span class="line">          <span class="string">'10'</span>: <span class="string">'N'</span>,</span><br><span class="line">        <span class="string">'111'</span>: <span class="string">'O'</span>,</span><br><span class="line">        <span class="string">'0110'</span>: <span class="string">'P'</span>,</span><br><span class="line">        <span class="string">'1101'</span>: <span class="string">'Q'</span>,</span><br><span class="line">        <span class="string">'010'</span>: <span class="string">'R'</span>,</span><br><span class="line">        <span class="string">'000'</span>: <span class="string">'S'</span>,</span><br><span class="line">        <span class="string">'1'</span>: <span class="string">'T'</span>,</span><br><span class="line">        <span class="string">'001'</span>: <span class="string">'U'</span>,</span><br><span class="line">        <span class="string">'0001'</span>: <span class="string">'V'</span>,</span><br><span class="line">        <span class="string">'011'</span>: <span class="string">'W'</span>,</span><br><span class="line">        <span class="string">'1001'</span>: <span class="string">'X'</span>,</span><br><span class="line">        <span class="string">'1011'</span>: <span class="string">'Y'</span>,</span><br><span class="line">        <span class="string">'1100'</span>: <span class="string">'Z'</span>,</span><br><span class="line">        <span class="string">'01111'</span>: <span class="string">'1'</span>,</span><br><span class="line">        <span class="string">'00111'</span>: <span class="string">'2'</span>,</span><br><span class="line">        <span class="string">'00011'</span>: <span class="string">'3'</span>,</span><br><span class="line">        <span class="string">'00001'</span>: <span class="string">'4'</span>,</span><br><span class="line">        <span class="string">'00000'</span>: <span class="string">'5'</span>,</span><br><span class="line">        <span class="string">'10000'</span>: <span class="string">'6'</span>,</span><br><span class="line">        <span class="string">'11000'</span>: <span class="string">'7'</span>,</span><br><span class="line">        <span class="string">'11100'</span>: <span class="string">'8'</span>,</span><br><span class="line">        <span class="string">'11110'</span>: <span class="string">'9'</span>,</span><br><span class="line">        <span class="string">'11111'</span>: <span class="string">'0'</span>,</span><br><span class="line">        <span class="string">'001100'</span>: <span class="string">'?'</span>,</span><br><span class="line">        <span class="string">'10010'</span>: <span class="string">'/'</span>,</span><br><span class="line">        <span class="string">'101101'</span>: <span class="string">'()'</span>,</span><br><span class="line">        <span class="string">'100001'</span>: <span class="string">'-'</span>,</span><br><span class="line">        <span class="string">'010101'</span>: <span class="string">'.'</span>,</span><br><span class="line">        <span class="string">'110011'</span>:<span class="string">','</span>,</span><br><span class="line">        <span class="string">'011010'</span>:<span class="string">'@'</span>,</span><br><span class="line">        <span class="string">'111000'</span>:<span class="string">':'</span>,</span><br><span class="line">        <span class="string">'101010'</span>:<span class="string">':'</span>,</span><br><span class="line">        <span class="string">'10001'</span>:<span class="string">'='</span>,</span><br><span class="line">        <span class="string">'011110'</span>:<span class="string">"'"</span>,</span><br><span class="line">        <span class="string">'101011'</span>:<span class="string">'!'</span>,</span><br><span class="line">        <span class="string">'001101'</span>:<span class="string">'_'</span>,</span><br><span class="line">        <span class="string">'010010'</span>:<span class="string">'"'</span>,</span><br><span class="line">        <span class="string">'10110'</span>:<span class="string">'('</span>,</span><br><span class="line">        <span class="string">'1111011'</span>:<span class="string">'&#123;'</span>,</span><br><span class="line">        <span class="string">'1111101'</span>:<span class="string">'&#125;'</span></span><br><span class="line">        &#125;; </span><br><span class="line"></span><br><span class="line">flag = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> key:</span><br><span class="line">    flag += dic[item]</span><br><span class="line">print( flag )</span><br><span class="line">print( flag.lower() )</span><br></pre></td></tr></table></figure><hr><h2 id="0x02-Base64-32-16编码"><a href="#0x02-Base64-32-16编码" class="headerlink" title="0x02 Base64/32/16编码"></a>0x02 Base64/32/16编码</h2><h3 id="01-原理-1"><a href="#01-原理-1" class="headerlink" title="01 原理"></a>01 原理</h3><p>　　base64、base32、base16可以分别编码转化8位字节为6位、5位、4位，16、32、64分别表示用多少个字符来编码。以base64为例：Base64编码要求把3个8位字节转化为4个6位的字节，之后在6位的前面补两个0，形成8位一个字节的形式，6位2进制能表示的最大数是2的6次方是64，这也是为什么是64个字符(A-Z,a-z，0-9，+，/这64个编码字符，=号不属于编码字符，而是填充字符)的原因。</p><h3 id="02-特征-1"><a href="#02-特征-1" class="headerlink" title="02 特征"></a>02 特征</h3><p>　　有大写、小写、数字，密文末尾一般为<code>==</code>。</p><h3 id="03-解题-1"><a href="#03-解题-1" class="headerlink" title="03 解题"></a>03 解题</h3><ul><li><a href="http://ctf.ssleye.com/base64.html" target="_blank" rel="noopener">通道1</a></li><li><a href="https://tool.bugku.com/safe/base64.php" target="_blank" rel="noopener">通道2</a></li></ul><hr><h2 id="0x03-Escape-Unescape编码"><a href="#0x03-Escape-Unescape编码" class="headerlink" title="0x03 Escape/Unescape编码"></a>0x03 Escape/Unescape编码</h2><h3 id="01-原理-2"><a href="#01-原理-2" class="headerlink" title="01 原理"></a>01 原理</h3><p>　　Escape/Unescape加密解码/编码解码,又叫%u编码，采用UTF-16BE模式， Escape编码/加密,就是字符对应UTF-16 16进制表示方式前面加%u。Unescape解码/解密，就是去掉”%u”后，将16进制字符还原后，由utf-16转码到自己目标字符。如：字符“中”，UTF-16BE是：“6d93”，因此Escape是“%u6d93”。</p><h3 id="02-特征-2"><a href="#02-特征-2" class="headerlink" title="02 特征"></a>02 特征</h3><p>　　密文中含有<code>%u</code>。</p><h3 id="03-解题-2"><a href="#03-解题-2" class="headerlink" title="03 解题"></a>03 解题</h3><ul><li><a href="http://ctf.ssleye.com/escape.html" target="_blank" rel="noopener">通道1</a></li><li>工具Converter：Unescape</li></ul><hr><h2 id="0x04-HTML编码"><a href="#0x04-HTML编码" class="headerlink" title="0x04 HTML编码"></a>0x04 HTML编码</h2><h3 id="01-原理-3"><a href="#01-原理-3" class="headerlink" title="01 原理"></a>01 原理</h3><p>完整编码手册：<a href="http://www.w3school.com.cn/tags/html_ref_entities.html" target="_blank" rel="noopener">我跳</a></p><h3 id="02-特征-3"><a href="#02-特征-3" class="headerlink" title="02 特征"></a>02 特征</h3><p>由元素<code>&amp;#x26;</code>构成，26可为别的数字。</p><h3 id="03-解题-3"><a href="#03-解题-3" class="headerlink" title="03 解题"></a>03 解题</h3><ul><li><a href="http://ctf.ssleye.com/html_en.html" target="_blank" rel="noopener">通道1</a></li><li><a href="https://tool.chinaz.com/tools/htmlencode.aspx" target="_blank" rel="noopener">通道2</a></li><li>工具Converter：Decode HTML</li></ul><hr><h2 id="0x05-Unicode编码"><a href="#0x05-Unicode编码" class="headerlink" title="0x05 Unicode编码"></a>0x05 Unicode编码</h2><h3 id="01-原理-4"><a href="#01-原理-4" class="headerlink" title="01 原理"></a>01 原理</h3><p>Unicode编码有以下四种编码方式：</p><ul><li>源文本： <code>The</code></li><li>&amp;#x [Hex]： <code>&amp;#x0054;&amp;#x0068;&amp;#x0065;</code></li><li>&amp;# [Decimal]： <code>&amp;#00084;&amp;#00104;&amp;#00101;</code></li><li>\U [Hex]： <code>\U0054\U0068\U0065</code></li><li>\U+ [Hex]： <code>\U+0054\U+0068\U+0065</code>　　</li></ul><h3 id="02-解题"><a href="#02-解题" class="headerlink" title="02 解题"></a>02 解题</h3><ul><li><a href="https://tool.chinaz.com/tools/unicode.aspx" target="_blank" rel="noopener">通道1</a></li><li><a href="http://www.mxcz.net/tools/Unicode.aspx" target="_blank" rel="noopener">通道2</a></li></ul><hr><h2 id="0x06-URL编码"><a href="#0x06-URL编码" class="headerlink" title="0x06 URL编码"></a>0x06 URL编码</h2><h3 id="01-原理-5"><a href="#01-原理-5" class="headerlink" title="01 原理"></a>01 原理</h3><p>　　url编码又叫百分号编码，是统一资源定位(URL)编码方式。URL地址（常说网址）规定了常用地数字，字母可以直接使用，另外一批作为特殊用户字符也可以直接用（/,:@等），剩下的其它所有字符必须通过%xx编码处理。 现在已经成为一种规范了，基本所有程序语言都有这种编码，如js：有encodeURI、encodeURIComponent，PHP有 urlencode、urldecode等。编码方法很简单，在该字节ascii码的的16进制字符前面加%. 如 空格字符，ascii码是32，对应16进制是’20’，那么urlencode编码结果是:%20。</p><h3 id="02-解题-1"><a href="#02-解题-1" class="headerlink" title="02 解题"></a>02 解题</h3><ul><li><a href="https://tool.chinaz.com/tools/urlencode.aspx" target="_blank" rel="noopener">通道1</a></li><li><a href="http://web.chacuo.net/charseturlencode" target="_blank" rel="noopener">通道2</a></li></ul><hr><h1 id="02-代换密码"><a href="#02-代换密码" class="headerlink" title="02 代换密码"></a>02 代换密码</h1><h2 id="0x01-凯撒密码-Caesar-Cipher"><a href="#0x01-凯撒密码-Caesar-Cipher" class="headerlink" title="0x01 凯撒密码(Caesar Cipher)"></a>0x01 凯撒密码(Caesar Cipher)</h2><h3 id="01-原理-6"><a href="#01-原理-6" class="headerlink" title="01 原理"></a>01 原理</h3><p>　　凯撒密码(Caesar Cipher或称恺撒加密、恺撒变换、变换加密、位移加密)是一种替换加密，明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。例，当偏移量是3的时候，所有的字母A将被替换成D，B变成E，以此类推。</p><ul><li><strong>加密</strong>：$c=E_3(m)=m+3(\bmod 26)　0\leq m\leq 25$</li><li><strong>解密</strong>：$m=D_3(c)=c-3(\bmod 26)　0\leq c\leq 25$</li></ul><p>凯撒有两种编码脚本，一种是字母26内循环移位，一种是127次非字母内的循环移位。</p><h3 id="02-样例"><a href="#02-样例" class="headerlink" title="02 样例"></a>02 样例</h3><ul><li>c =  xyz</li><li>m = abc</li></ul><h3 id="03-解题-4"><a href="#03-解题-4" class="headerlink" title="03 解题"></a>03 解题</h3><ul><li>CTFcrackTools工具(所有结果罗列)</li><li><a href="http://ctf.ssleye.com/caesar.html" target="_blank" rel="noopener">通道2(单个情况)</a></li><li>127次非字母内的循环移位脚本</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">c = <span class="string">"""..."""</span> <span class="comment">#密文</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> range(<span class="number">127</span>):</span><br><span class="line">    m = <span class="string">''</span> <span class="comment">#明文</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> c:</span><br><span class="line">        temp = chr( (ord(i) + p) % <span class="number">127</span> )</span><br><span class="line">        <span class="keyword">if</span> <span class="number">32</span> &lt; ord(temp) &lt; <span class="number">127</span>:</span><br><span class="line">            m += temp</span><br><span class="line">            flag = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            flag = <span class="number">0</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> flag == <span class="number">1</span>:</span><br><span class="line">        print(<span class="string">'****%d****:'</span>%p, m)</span><br></pre></td></tr></table></figure><hr><h2 id="0x02-Brainfuck加密"><a href="#0x02-Brainfuck加密" class="headerlink" title="0x02 Brainfuck加密"></a>0x02 Brainfuck加密</h2><h3 id="01-原理-7"><a href="#01-原理-7" class="headerlink" title="01 原理"></a>01 原理</h3><p>　　Brainfuck是一种极小化的计算机语言，它是由Urban Müller在1993年创建的。由于fuck在英语中是脏话，这种语言有时被称为brainf＊ck或brainf＊＊k，甚至被简称为BF。brainfuck语言用<code>&gt; &lt; + - . , [ ]</code>八种符号来替换C语言的各种语法和命令。</p><h3 id="02-解题-2"><a href="#02-解题-2" class="headerlink" title="02 解题"></a>02 解题</h3><ul><li><a href="https://tool.bugku.com/brainfuck/" target="_blank" rel="noopener">通道1</a></li><li><a href="https://www.splitbrain.org/services/ook" target="_blank" rel="noopener">通道2</a></li></ul><hr><h2 id="0x03-Ook加密"><a href="#0x03-Ook加密" class="headerlink" title="0x03 Ook加密"></a>0x03 Ook加密</h2><h3 id="01-原理-8"><a href="#01-原理-8" class="headerlink" title="01 原理"></a>01 原理</h3><p>　　Ook密码中只含<code>Ook. Ook? Ook!</code>三个不同的语法元素。</p><h3 id="02-解题-3"><a href="#02-解题-3" class="headerlink" title="02 解题"></a>02 解题</h3><ul><li><a href="https://tool.bugku.com/brainfuck/" target="_blank" rel="noopener">通道1</a></li><li><a href="https://www.splitbrain.org/services/ook" target="_blank" rel="noopener">通道2</a></li></ul><hr><h2 id="0x04-加密"><a href="#0x04-加密" class="headerlink" title="0x04 .!?加密"></a>0x04 .!?加密</h2><h3 id="01-原理-9"><a href="#01-原理-9" class="headerlink" title="01 原理"></a>01 原理</h3><p>　　.!?密码中只含<code>. ? !</code>三个不同的语法元素，使用Ook解密即可。</p><h3 id="02-解题-4"><a href="#02-解题-4" class="headerlink" title="02 解题"></a>02 解题</h3><ul><li><a href="https://tool.bugku.com/brainfuck/" target="_blank" rel="noopener">通道1</a></li><li><a href="https://www.splitbrain.org/services/ook" target="_blank" rel="noopener">通道2</a></li></ul><hr><h2 id="0x05-社会主义核心价值观"><a href="#0x05-社会主义核心价值观" class="headerlink" title="0x05 社会主义核心价值观"></a>0x05 社会主义核心价值观</h2><h3 id="01-原理-10"><a href="#01-原理-10" class="headerlink" title="01 原理"></a>01 原理</h3><p>　　富强、民主、文明、和谐，自由、平等、公正、法治，爱国、敬业、诚信、友善。</p><h3 id="02-解题-5"><a href="#02-解题-5" class="headerlink" title="02 解题"></a>02 解题</h3><ul><li><a href="http://ctf.ssleye.com/cvencode.html" target="_blank" rel="noopener">通道1</a></li><li><a href="http://www.atoolbox.net/Tool.php?Id=850" target="_blank" rel="noopener">通道2</a></li></ul><hr><h2 id="0x06-标准银河字母"><a href="#0x06-标准银河字母" class="headerlink" title="0x06 标准银河字母"></a>0x06 标准银河字母</h2><h3 id="01-原理-11"><a href="#01-原理-11" class="headerlink" title="01 原理"></a>01 原理</h3><p>　　标准银河字母（Standard Galactic Alphabet）出自游戏《<a href="https://baike.baidu.com/item/指挥官基恩/10345602" target="_blank" rel="noopener">指挥官基恩</a>》系列。是系列中使用的书写系统。字母对应如下：</p><p><img alt data-src="https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/eac4b74543a98226aab284e78a82b9014b90ebfb.png" class="lozad"></p><hr><h2 id="0x07-仿射加密"><a href="#0x07-仿射加密" class="headerlink" title="0x07 仿射加密"></a>0x07 仿射加密</h2><h3 id="01-原理-12"><a href="#01-原理-12" class="headerlink" title="01 原理"></a>01 原理</h3><p>　　仿射密码是一种表单代换密码，字母表的每个字母相应的值使用一个简单的数学函数对应一个数值，再把对应数值转换成字母。</p><ul><li><strong>加密</strong>：$c = E_{a,b}(m) \equiv am+b(\bmod 26)$</li><li><strong>解密</strong>：$m = D_{a,b} \equiv a^{-1}(c-d)(\bmod 26)$</li></ul><p>　　其中，a、b是密钥，为满足$0\leq a,b\leq 25$和$gcd(a,26) = 1$的整数。其中$gcd(a,26) = 1$表示a和26的最大公因子，$a<em>{-1}$表示a的逆元，即$a</em>{-1}*a \equiv 1(\mod26)$。</p><h3 id="02-解题-6"><a href="#02-解题-6" class="headerlink" title="02 解题"></a>02 解题</h3><ul><li><strong>常规解法</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">a = ... <span class="comment">#密钥</span></span><br><span class="line">b = ... <span class="comment">#密钥</span></span><br><span class="line">text = <span class="string">"..."</span> <span class="comment">#密文</span></span><br><span class="line">flag = <span class="string">""</span>    <span class="comment">#明文</span></span><br><span class="line"> </span><br><span class="line">text_list = []</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> text:</span><br><span class="line">    text_list.append( ord(i) - <span class="number">97</span> )</span><br><span class="line"></span><br><span class="line">aa = gmpy2.invert(a, <span class="number">26</span>) <span class="comment">#求解模逆元</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> text_list:</span><br><span class="line">    tmp = (aa * (i - b)) % <span class="number">26</span></span><br><span class="line">    flag += chr(tmp + <span class="number">97</span>)</span><br><span class="line"></span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure><ul><li><strong>暴力破解</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">text = <span class="string">"..."</span></span><br><span class="line"> </span><br><span class="line">text_list = []</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> text:</span><br><span class="line">    text_list.append( ord(i) - <span class="number">97</span> )</span><br><span class="line"> </span><br><span class="line">flag = <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> text_list:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">26</span>):</span><br><span class="line">        c = (<span class="number">17</span> * j - <span class="number">8</span>) % <span class="number">26</span></span><br><span class="line">        <span class="keyword">if</span>(c == i):</span><br><span class="line">            flag += chr(j + <span class="number">97</span>)</span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure><hr><h2 id="0x08"><a href="#0x08" class="headerlink" title="0x08"></a>0x08</h2><h3 id="01-原理-13"><a href="#01-原理-13" class="headerlink" title="01 原理"></a>01 原理</h3><p>　　</p><h3 id="02-解题-7"><a href="#02-解题-7" class="headerlink" title="02 解题"></a>02 解题</h3><ul><li><a href>通道1</a></li><li><a href>通道2</a></li></ul><hr><h1 id="03-换位加密"><a href="#03-换位加密" class="headerlink" title="03 换位加密"></a>03 换位加密</h1><h2 id="0x01-栅栏密码-Rail-fence-Cipher"><a href="#0x01-栅栏密码-Rail-fence-Cipher" class="headerlink" title="0x01 栅栏密码(Rail-fence Cipher)"></a>0x01 栅栏密码(Rail-fence Cipher)</h2><h3 id="01-原理-14"><a href="#01-原理-14" class="headerlink" title="01 原理"></a>01 原理</h3><p>　　栅栏密码(Rail-fence Cipher)就是把要加密的明文分成N个一组，然后把每组的第1个字符组合，每组第2个字符组合…每组的第N(最后一个分组可能不足N个)个字符组合，最后把他们全部连接起来就是密文。</p><h3 id="02-样例-1"><a href="#02-样例-1" class="headerlink" title="02 样例"></a>02 样例</h3><ul><li>c = KYsd3js2E{a2jda}<ul><li>KYsd3js2</li><li>E{a2jda}</li></ul></li><li>m = <code>KEY{sad23jjdsa2}</code></li></ul><h3 id="03-解题-5"><a href="#03-解题-5" class="headerlink" title="03 解题"></a>03 解题</h3><ul><li>CTFcrackTools工具(所有结果罗列)</li><li><a href="http://ctf.ssleye.com/railfence.html" target="_blank" rel="noopener">通道2(不区分大小写)</a></li><li><a href="https://www.qqxiuzi.cn/bianma/zhalanmima.php" target="_blank" rel="noopener">通道3(区分大小写)</a></li></ul><hr><h2 id="0x02-转盘加密"><a href="#0x02-转盘加密" class="headerlink" title="0x02 转盘加密"></a>0x02 转盘加密</h2><h3 id="01-原理-15"><a href="#01-原理-15" class="headerlink" title="01 原理"></a>01 原理</h3><p><strong>题目</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1： &lt;ZWAXJGDLUBVIQHKYPNTCRMOSFE &lt;</span><br><span class="line">2： &lt;KPBELNACZDTRXMJQOYHGVSFUWI &lt;</span><br><span class="line">3： &lt;BDMAIZVRNSJUWFHTEQGYXPLOCK &lt;</span><br><span class="line">4： &lt;RPLNDVHGFCUKTEBSXQYIZMJWAO &lt;</span><br><span class="line">5： &lt;IHFRLABEUOTSGJVDKCPMNZQWXY &lt;</span><br><span class="line">6： &lt;AMKGHIWPNYCJBFZDRUSLOQXVET &lt;</span><br><span class="line">7： &lt;GWTHSPYBXIZULVKMRAFDCEONJQ &lt;</span><br><span class="line">8： &lt;NOZUTWDCVRJLXKISEFAPMYGHBQ &lt;</span><br><span class="line">9： &lt;QWATDSRFHENYVUBMCOIKZGJXPL &lt;</span><br><span class="line">10：&lt;WABMCXPLTDSRJQZGOIKFHENYVU &lt;</span><br><span class="line">11：&lt;XPLTDAOIKFZGHENYSRUBMCQWVJ &lt;</span><br><span class="line">12：&lt;TDSWAYXPLVUBOIKZGJRFHENMCQ &lt;</span><br><span class="line">13：&lt;BMCSRFHLTDENQWAOXPYVUIKZGJ &lt;</span><br><span class="line">14：&lt;XPHKZGJTDSENYVUBMLAOIRFCQW &lt;</span><br><span class="line"></span><br><span class="line">密钥： 2,5,1,3,6,4,9,7,8,14,10,13,11,12</span><br><span class="line">密文：HCBTSXWCRQGLES</span><br><span class="line">flag格式 flag&#123;你解密的内容&#125;</span><br></pre></td></tr></table></figure><p><strong>解答</strong></p><p>这个转盘加密，比如第一个密钥匙：2、密文匙：H</p><p>把转盘第二行单独提出来  2： &lt;KPBELNACZDTRXMJQOY<strong>HGVSFUWI</strong> &lt; ；从H的地方一直剪切，把剪切的内容放在最前面，变成   2： &lt;<strong>HGVSFUWI</strong>KPBELNACZDTRXMJQOY &lt;</p><p>依次类推把14行都按这样的方式整一遍就得到这个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">2：  &lt;HGVSFUWIKPBELNACZDTRXMJQOY &lt;</span><br><span class="line">5：  &lt;CPMNZQWXYIHFRLABEUOTSGJVDK &lt;</span><br><span class="line">1：  &lt;BVIQHKYPNTCRMOSFEZWAXJGDLU &lt;</span><br><span class="line">3：  &lt;TEQGYXPLOCKBDMAIZVRNSJUWFH &lt;</span><br><span class="line">6：  &lt;SLOQXVETAMKGHIWPNYCJBFZDRU &lt;</span><br><span class="line">4：  &lt;XQYIZMJWAORPLNDVHGFCUKTEBS &lt;</span><br><span class="line">9：  &lt;WATDSRFHENYVUBMCOIKZGJXPLQ &lt;</span><br><span class="line">7：  &lt;CEONJQGWTHSPYBXIZULVKMRAFD &lt;</span><br><span class="line">8：  &lt;RJLXKISEFAPMYGHBQNOZUTWDCV &lt;</span><br><span class="line">14：&lt;QWXPHKZGJTDSENYVUBMLAOIRFC &lt;</span><br><span class="line">10：&lt;GOIKFHENYVUWABMCXPLTDSRJQZ &lt;</span><br><span class="line">13：&lt;LTDENQWAOXPYVUIKZGJBMCSRFH &lt;</span><br><span class="line">11：&lt;ENYSRUBMCQWVJXPLTDAOIKFZGH &lt;</span><br><span class="line">12：&lt;SWAYXPLVUBOIKZGJRFHENMCQTD &lt;</span><br></pre></td></tr></table></figure><p>flag在倒数第六列。</p><p>flag{XSXSBUGKUADMIN}，可能要转化为小写。</p><hr><h1 id="04-文件加密"><a href="#04-文件加密" class="headerlink" title="04 文件加密"></a>04 文件加密</h1><h2 id="0x01-zip压缩包破解"><a href="#0x01-zip压缩包破解" class="headerlink" title="0x01 zip压缩包破解"></a>0x01 zip压缩包破解</h2><p><a href>我跳</a></p><h2 id="0x02-Linux-shadow-文件破解密码"><a href="#0x02-Linux-shadow-文件破解密码" class="headerlink" title="0x02 Linux shadow 文件破解密码"></a>0x02 Linux shadow 文件破解密码</h2><p>john爆破：<code>john filename</code></p><h1 id="05-其他加密"><a href="#05-其他加密" class="headerlink" title="05 其他加密"></a>05 其他加密</h1><h2 id="01-键盘布局加密"><a href="#01-键盘布局加密" class="headerlink" title="01 键盘布局加密"></a>01 键盘布局加密</h2><p>密文：<code>r5yG lp9I BjM tFhBT6uh y7iJ QsZ bhM</code></p><p>明文：<code>TONGYUAN</code></p><h1 id="0x-参考"><a href="#0x-参考" class="headerlink" title="0x 参考"></a>0x 参考</h1><ul><li><a href="http://blog.neargle.com/SecNewsBak/drops/CTF中那些脑洞大开的编码和加密 .html" target="_blank" rel="noopener">CTF中那些脑洞大开的编码和加密</a></li><li>具体请看：<a href="https://ctf-wiki.github.io/ctf-wiki/crypto/classical/introduction-zh/" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/crypto/classical/introduction-zh/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Fin6模拟流程</title>
      <link href="/2020/07/13/Fin6%E6%A8%A1%E6%8B%9F%E6%B5%81%E7%A8%8B/"/>
      <url>/2020/07/13/Fin6%E6%A8%A1%E6%8B%9F%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误！请检查后重试~" data-whm="解密出现了一点问题，你仍可以看一看。">  <script id="hbeData" type="hbeData" data-hmacdigest="a0e629a8514cb74763ddaef7b018f8cee41d8dfcc0dfdd0b42586ebc6d867f1f">a1edaa97922bb2ec7906d4ab82b474d6d8aa50d47dfcc79a7863314b6f8ebdcc5e963f9cf1da89f851d21298076f8fe899a407018269516a7430d6ea6f1e8a44acda1ade9a52a21f69cc2493bdc26a1a61ed126fdfe3ac93069c32f21a9d42a673cb1a47536d70574a33cf548b7c4557460f4517927dd21c1f458a4df0ec6fdf29ccd7d25ed9ff5a2ad2bc167a591f81ac2520bccedbdc5d60bd836898acb50181db84a82b23ce2b9915638fd14ec799badb2fa956341e0efac431e18a52df03806976124d19670aecda4dd6f1d7c1f07a4ae6ee789a25fd553e851c8e63d0725381a17958f0ece7a16ba348044d896b379651f29fbe17957736401d2ae0a4b419157ffb4a61cf9886938f524925a8d6adc9ee74d1116216986591807d5bc501feba8c1c9cb817113f50ae2536c9e52ed143f170ffdcdea9d90b97e38f5f0605260d22705840e411b5fef2edcd75f72221f0e1286dacf38d8942a0528c6e8b7f766dc92931200d6031d1879c5f8881f735f3a023762337a2bf67ebac28dd618314f7c2bb7ad83a3265b1c9882c0201ecc4b2025fd049bec7bbe4cd5f83dea07f3bbe2299f83a97882d98191355af7fad2504c65eba4653a7c928f8c5f80ece92914f52fb37c6550b095655d09eb81beb6eb841f871b49c2ce7a5bf6b5667e4132e2e6f72cab93ffea92be463728802c3fc3be1eee726d615d18b4c4312069dd0206fe889143cb244b1559490d8b2a8ab199165acd4eac30d1d81fd4dd96f61d9b33031dbeb26657f7b46626a4e5ca023207c0f3fbc2e4449eb7fcb4e2ebaf3a03a2e8947407cd5f540eb6ff3117677189ba7cb389ea7ecd399d0da0fbeb8543124597dc30a8c8d6c0382bf0a1be06ae0a73758e2f6eaa067635780642d76c2881e8292d98f5d514be1807d4c019cef1b0db5efc877218787480964fe022be1e684d52d1a259e827f75d6efd9c68801e603aed9d49007707c0eb92f29b2e9fa30d0049ae5eb35aceac1f1b3647b74db8b7b388f864d28fb7f61d8d6730d072350ac43cf34436b22357b562cbe493cc1e6ba7d72808aca76521698db66f52849bdf104509427d658feba8254406d8b37851146692730d689733e6bdb0b5b5f6641d252236a9b8c981e510628fc5e23e4b35951b199b12cd9ce744ebfb284368ce58250c47dca71ceeef41177dba6df9a9c243b286cfd59ae8d9e919f1ace7aa303f8ff9b53de514afef153511a061014fd582951a3e30bdfb87a64fea657ee85aca8a55d9a67b8769b3e4d89564bc16b514aa47ef0d9d6fd0f7d6219df49cf88f19e265fcad952ce65d1c302de63b545212083ae3e329acb0f8f2f1fdbda10b7ce5947ef846ab5b041be3a9ceb6369620fec89e77ddc6fe9c01625370761fa6bd72acd5a72c4f593261960a970b61df71d67c826d48f9afebcac1af29280b29ce302a62b0171cae8321a5ad4df9ef74120873a4f22338f7f31158e2d823fb8f7d1e33138b1dfe577ead38a29ba10866f4764c8d67a9c6805b0e1da9c27ab47cf5dc477a62c49c23ca4751237b3d44f228ccf3ae226e2f4bca391731475a190b1d254c014ff379224e73c0761a894442029288417164b7adc3024aecf337e701788653e6a093a8115e19b7e54246f66715f39260433933035a22dc9cda05e7558d3e129999f59893aa4a1566e0da2ae99dcca40cadda87ada753f1d7e04f90d0c389ffbd87c004f1d5f26ed5589cc0af3f9352ea42809bb8d4b2c78e2fcea612c6db656d9c59aa18efbe5ca3cc88f3e33b2dc4ee161125a5157645bccc45292e36c80a6156a20432f384745ef57495a12123faee73bf73123607c565bbc35ff376303fffee7057b36c7f9db8b6307359a7f25faa7b4f605cb4cfcc2823213743edad63b9eed4084ef979afb213cd29caee763f59ecf114cecec043701e272be6b7a259918f9c9ca837d881ca1935fe7eb52f10cb1c03ffc67e9f178b8446653f0ba81c16b565eac762cd04d4e550dd6a8f1b52bcd00d39da6ee2aebbe68462cbb5813ce70d410329c600058b2b6ab0b8e4d2fa6f1a13805fcb2f05169d0f6fbaf1a8b88990d6a5765bd52192fcb35d59243895140fedabb61035bc1932ea407ada3dfb65de3ce8a9cf8e3cd460e0ba5ef62b2d66a8839a16fa0f75189c0ebd84fc25ee4ca223ab25abc1a46362842182b180f1e122e7aaf360f12a872505dbdc5cb7dad2a64b087a56b797065dcbedd5d53e126bedc49203118ea85f76483a1163347ecc3ffcc763feb4740502c22a5009b3220190f024b0cedd4290c7acbc7971be152559b63847cfe73ade69830e92696c6e77c574b958565d835eb080e8378dab704c07e1ecbec703e0ffcfbfa615fc8366665ded6d67f7565bebb6db2a6820cfbe64ccf8864e8b60f9fedd68c008b33949b986033717bc611e92731e5dc662c4d3fb08c553afb18ba8cd52434a2be884eb5c74b4f7a1d917151da975218b65ae5aba088d11fe3a9571729389778bddfd26125a09b0b8a20e22afdaf5a9f8d20349c6d8133143954acbe40e416f6ad51be15d623a25779b884aa6b97da2789240f1e61e6c72d5dabd06ca811ab4e951a03fd3d488df9d5eaa0193b19802d7bb706ae9beacc376c56428e336bdfcfff6b00b6ea9e1965fe65b04788216d6d79f4f972736f38d5ee4e66c4a81aca9aa532a2e6fb2a75fbcebcf8469da426458c36b44a9e60d1d7ac5717df6f6b6870a3494ccbc7212b83e2fddf63482b50bdcf4e6fe732451ac902db6e2850a5906dccc8e1c064b2fe4fee9c3386e333463d9c96f19dab80fefd164f7daa0c41bf010a2ac5d73bfa8a6322301328ceb40afa280beb3b9e7f3b41b7eeb0248c52de64328eb8164b620337a50773cca530b11ef1610e351199bbcdc1e4a245a77d68dbde67a479f6900a56417cc47415647cac3e7de251b646eed329c8c167d11861fc3a424a7789b33f7ebb755069baab4caaed5513ec3eb2583e155d3d2db0f32afec917f2a990d669d0eeff76de08a82fdfc5d6452f6cbd2862185426853923731b7c119701ce666ec0b36cd2eadaa8d628c355e0f8fdd3626ac83d7c14a4bdd9c5dfde034edcaa8dd41f03fe69682f76c68ec6efa89b38bd814d2198d4e04fb88e05d4f90cd8714d9d13c2f10d930ab411f577861d59b7b484d7617b22f7ebf81f36e31c6dcf0d94b9655efd4d74ae8f562a69c797523cdb7edf1f498edb881bd5c517666f4ded05ec80835b41f00f7e0af7c72b9042a6608330427c16e924d80a782a2d6e0f3f23fb0f66e6f439f8762c8b3942ec98c88ab356e36309037b913e2ee4d5b9d371761dcd1415106e4433934f2f3add57303ca87d2c57f007bbb9ea81fa04a8e02df6c27ab0ed98543fbba2f29976f5b43a877558fcbca86444179e0eb988510da3004503d9712519897106deb426c46137cd84d1f9fdeb24ea806f1675595ac6b1b90992d0971386b6e31111566d28bb506ab0f56f84387feb58709f7efa16841abd381adb3918596e838d7c94f58d74fab3a716048e724e2e31d4456f1905871fd1bbd13bb412ab47a73e07e99fbd1755984a441147273145e115f460eef8aa41f3963556a1a3028c0ed35ad23b4f82fd44b21aef72325a61ea955e9c939d7b4f03f292ece8a8273d3cf7206f555e8095b137096fad913c79c4c6775591e8fb91387ff4b7d6c6b319598c6e059141d4c26c55735b3e6dbb24fd6ba94a91fcac32a3eb3dcf5ce33b02779f01fa8c4fbb322f9bd4256ac584aa37aae2295db1ce8df4157f8b7e0bd71b61b0e250dc268cbabb605efa75e727e0d296c79acf1e28cba11ab1a477021a54e68d0b8215b5da99cf4753f8c13b4e0c6d456e1b51c4aad382d10fb89286af6e2b72f7b65ff28a50d42c100060240a68532ca77ee902f708b102f4edb2190850b0f733f44c07ecefcd9a334a908610ab1e04d73709fed9d41085345202c6d0e9e68d6ea11d8f8066eca29f977b2624f2129ff16720fd0f1e57df9070549af737fcf3e5e94313ab22dbff73138f18eeb3d15c52a0a7451b1367f4aab8b68fa0b8f9f10ccfa14e92f3ac9dc9d016a6bafa932a945c1dd767a74dc530aac4f5ffb6efffcc7c7969e4f2e43815f47d1ea8797939b39b24c2d7e52276dbb8306f3c54fc53b6131078877732e55dbb0dc3fb0a3f933211aa754a0a5d07da4cfa64dd389ac8d9c77a73f39c5fc5bc29c59a36968a577944d8d719022a070471c11cbbcefbf50b9a0ee50840daa7bc6a58e4ba79025c4532782c7266111fa839d6f9a0dfa2665bef8fd5a4deef4883791b10ee61d4beb822d5c71b5a47c614212c63bfac7251df4b95d582ccc6363fdcaee659ee6842ab8c35323aacd816a978710272b6eb1571e6fece2f8adb19bd1f481ae69f5bf18e2b0dced281e94f8325d3bbab65c89c6b27c2cbcbe1fbe81ca2f1d6af771cf26a747bf6f84f2ecb573c96dae4a3babeb975e100012b49ad02ac8f1302884cf1bbaf215a973b51acada4d7c02ea915be1a5cb2703595a47286a6ff73c0974fcca9dcaa93061194638c98e1245a388da01b03ff472627e7133b5372242468dfbeeefd6911c8330f32718d7e663de1cd3292b1ff97da5b8784702e143dee594e40610dd05a31f16627549b01fc67d2f9199585694c9202ef9c7640e29c637eb1891a4e5184e8090129e0440f0bf2b0e60236b1859544cd04eb84d0170bdef0d6908d0a718214a3c86862c7b1facbecb66cb7092ad46e56a449e41b5df168e823a85f2f73808b7b3808d2a6a1b68ecddcd314cafc249f81e401201818138232f46a8fafe1fa69befe0f9a34fb4b23ee03eb218c41db6c08c5df889ccce82be65d847d49deb1a0739a591d05caac1460f73dff21da58dfb5cc4f83b0d3f24dababf90ac3f1811f8c769941da238de5fb458d199d72f64a5de5893c8a90be642613595af3f9932bcec4b2855b668e3d8d87964e4a251521b71b46208fde4bc6bbeda4743076fd815c1ff1ec020ceb5d46c2a426b4ae8d24b0aa576d83d1b2f78d1a4d41e588fe2de97ea834a21d1e0a8ba80b75a27f9029513462a2843d9984f471dae129ab14a278dd43f1ab4322e45a4a336d8d7d76b003676efee03fcfedaf0afe6a42e229104be4e5f61ea81a1f8dc0a03a294502cd053c82cc77e5155bc07ebfda4af707cffa7f86edb37db62be262df5660e8263fd8746b99afcc0045ad37f43aa128c2bb08f2e32852ad9dc628c40fab45c989ca4550a9c24b97ba0a9449eaff917466ca4a9beb7357a37c802cbd05d765594cb85f9c63e2fcd82d270f06d9a743a483d06284547e255b201c45a05dce24bb0869032ca27a90fbc34fdf15d8e52fb8854e318f6ba1c636d00a94e95fcccf36940506d2b9203b657dfbb63e7185a290da4d6812f7986c8308bc00359e0cc29993aa9391f3691a043535b1eb1fa04c099c1431699447d6f4f47ec53106069581577c4664aa493cae9351e303ad6392c25a586bb098acfcb5202d5531056a84cd6dea443189389e69847c5aafd99b7d777661309546229ca6f8a40ba5bfba579f28efbfeb3cfa95d8ea93c0adb0afe89e22c8b5681b3c30f9de039021f51d0404d8d1e97bd9b5fdb50eaac36b8c2fb738306089cd12be3f0ce07d6779671572443ad6c3bc190b471ccaa7fbacfc4c6eb3455d3cc12ce5f2cb382570539e350ff21f85a093d9480d90ae78f34da09d4b1a287940b46fbb380bb557374dd18d1b85f0716dda2cc826babbb0bddfe260d3d6c7915180a4174ae22f50c28e867e91d0a7cdb54cf5ff0ba1662fdf01f0566f5747a2bbc05390b73065c63db46ef7476a43075d87d2c126ce00d34831ea5edd0b2b1d130b7031c8a8388530bebbb21e479e92797705257dde0bfb0fe1fe5514688f5bcef828a61b0a3c468cc69a018a9e18bf2515bd0a69bf3e5335760a2c4ab2cb1256de44e716e30ebeb74716453021c44ae1135e7881e7a526dee072f86d0b4da364714a016018d26edef3235ee18a8fae98f20298fde187a6cf61c93147ac86bd4f3d832ea425347cc7dd486932bfe6ec4523f456e50033eb71b03090b8e77540175f0d899867f7fb37488388d0a67ee3c00cbca49366fe460cde52726a817c7909e6019352f3e9d2f5dedfe527a87e8216cd89f99ef51fe19c51897626074095e149e5ffe8b3d4de3ee65c9aef244b160b0b090a132b9a6b3179109b1cb9a5f8af9f2592462917b1ea9846a564c984168931e7b44a404e954eacdc6c99aaaccd2ef0a8ed061fb16a7ddf4d10f767344679971dcfa4ce49cbcff83d220ac35b3ae744e9e33221a1783979154019c262841849bb8be132059cf8e3b73d464d3595ea8663bd9d4e9d1a9ab2ad81152d2d1ea5f31943cbc97d13c1238a3eb9bdfa0e8ede314725d9bf7952e40d3e05a7b1b46d9ab2f0b11dfc1058b1c3c422d5f158714c3565a2309c83fd820a9d1a12b45faf38d242140a7f7c49ab605155e4484a53e7fee3949bec8cb4c8351823b399d4ff4d912a95a102e64a6c6ba0225b14daae5121e9c56dc6e72432065f0832073e049868a9554199409ca58d3eb06a78d9b16724c99a498c26b338d8f9762ed888f795c4027eea93ab571cd50efd8da7e77c812f61ac6a3d41b8378748f759f20d7cbfb8b377b1c74e9c63d1a882c089144d30c627d740e139803ac6ca75a1b940b6dcb474c65075fb78f11d3f21d965f1ffb171d4178b9f47ddb84d39b9415c317575bf22b1c17080958e4599e054fc0aa7aab5267c7f558fd2067789dd59b64a4e43cdd173f44a970ff2034704a712299e64504a329573cef05b10cf1eb27308dc8fca4bad4487df36f2df0beb1b2a400a9887aabde172e32b7227b965fcbbe4cab8e3791d21a961b2c0aed2331b60afb788d703e531734f57f6f19f79c3a4f28e1086c1588ceb82fd548aabaa49e7098974c10478e3e588f04877cf39c2ff475a40ac13d0e9a2f005b3138bfd4db540b5994fdcdaf86609c2a3b1c0ec4883088cb6df5dc396ccec2a36d40fbefd536a9a5b2df8bd1552b60f8880f42aa68041ed73f2be152923dc48dcfb3a7fad7c98f17b02f6ff1aad6bd94a402cfda34adecaf4e7a140bb50ce8da7978603579ef80fce458f8951d81f1445b76e6d56a1029cb9b3f04652418de5ccd025e3275f9fa7ccb523f069d8aeb50db4e6a9df06421c8925556b7e6be94f24bec1a567a54ed57981ae3307ebd36a85e3e65114cb76c77bdd7136562c75e6504e898415d0f30f3516517d776557c5c6ed70d6b5c6d7c99e802b78d59c2f7cfb3d4e2a62d35dff208484d6375dca277b76cc0d93ad6583f207eac6d34a8e2c5af2ac91720baa04759b220a0c802990c40a9e6c5d8b65dd8c08c229308c48847dc362bea5b8aeaf94a9276f2604e8807076cd071b88a02d47cef89e0351e2a92f8923485f0c6568b18d2282775ed4c23c37d0d8cf79f59bbf0a04d0312534038000893f25c1ae439cbe8dd409f2db26f07ad40ea4d7fa7f77c7b8fcb0f517e4665095e6625a4f2601afa80d4a712f4e13ac5e043f07445f3fed7fa914fc2af2b5cc7cf7f99a30d68ee9a50f4ed070b46221f1cd5221c8618347be80155c99fa6a74ceb57ee79e641a8f04d2edad6bf1ee68ca99043eaf18e4dcddeccf8a285bc1157b30310dcfeb2af7e72b39feab53c25e08c4b178ffa69d2152ebd26208b0b5e9ec2df64737c37fde64ac6555f5a8ea80e2411ea3244f5532956b04bafad7b5f2132cc0fff46f4ed81d698afa8cc4fa3540df8a68a3662d2b3957ef63fffdf0510f5272a440e4ea884122d6f4a665645290a192557482452a64ca04fd0c1c9914cbcde472a54f66576d73758c91692ec90935e33fc63603f44ceaaf27fd6ca89ef0cfbeaf364ca6b6f7e292f6b4a7004afcde261577ca1a8b6ea339153c9456d4ee6a9dcbab760532e15943f824ff64a116623e17d480e342be816e88993e789cb5f670504ac35f93912cee8460c6bf41c8e720f051750904e758fb38ac2375d3cce359021e68b76a4279bddd44083d714e48c9f6d5fc99a94aca685a45ff4e191f133d2c845d30f75a0cf867018dfb890cd7210d45ebfca0b64b47efca45b8a6258fc2ff95d65c62be9daf12634ea4b4ac6dce7dbc5232b4fd740aee1a1e57ee128a4cc728b60bc7f53c325dc4b344a163d99e6355cf0d03e7fd472e369b0f542ba86f40bca6aec701694d63da51a203fda521984a9d255c0f784ca1cd3e947df6928fe608afb00dea8c006cc34befcb92c97ede94962380e8843b7f057797306243d35dfd1f426025f043950ce55fb65064c9561085872a7ef29aea5c45cb645dfabcec6b2e3f5ec74779e4cb2cbc34321b358189da5644188509c6496aab08b6523f602946f81cb0a9765064a2b4ad11a19d3326351545e1f476489a59f05bc7e451e12abdea3724fd8b3a7a09c367e3626824acc20e096cf076d78a149c8f977e88a9a703b7ccc9561e4c705f2dea5314c809935a56b1d49faee19132b3452dfb52c0a90463814fddf0facf186aa9cda2cb38046b9ab2d134ad35ae51c538dc6d34fd59b837426b0deb614c340803d125862c09693e26c1ed56f78c6f97b218b1de80db11f78623f85a79a48aac09a8ef9979c2f4a0f348c35faa1a491e80d997f7bb3b95e138b25b53aa7aae6a3e59a93cb7ad785b65ebc4372cb6856e38191413fb0ada52bc12541d7f5c74d1308d0e70f16efa1eb370db94505ef3409582f39667b50a021b8c7cc6bf789278dd0436ad038ef196678bd111e4dff24985edb1339b1edeac4c536dfc63567e955457f0ab9906cb07ee281c5faf1593eead3d97c6dd1184ce555de69a6385f244fe39b3a8e2c577c6224ea4587c689b43dea9444a7d5f97ec362a3b80e5314b6748056728f1a471a9a7791c3dab12e1c512bfc8860dc16431ee7fefa508c12edca4b135ee626e76c5d294b3441e724a9d4d3aa20d8ef55794bf82b3593ef4958e2f4f035daef37e58a50d99d168614229cd0a72f3d3c22c31e81e78d72452e0c199c35138d37a0893a7b0a770329211a2f2e77e4178067dd99e3fe20fd49bf3799a58f9eedbebd8bccf8895cec4e4bfd6778c012134c7be2547ce95dc1cbfd7a4cf21080376fa8201cdf6f9f3a231a9356374bd8f7f8c94a510b42d8c72c7970850b1c8c64710a7a6e056bff8f7200569c06dcad6223ba98c8aaa535481cf5fff8e72e2bb9589f718f7ad31ab0459067cfb6eedeb55a0c0f68fea6c9881f3744a564fe57871a75f6c0f33c96d61c74432d34efc2f7809dcb59446b00caf3442b57b9132b3c6cae32924da22ded939a7ec3544ed7a6e11cd0fa6d1187da74e63c625254ddf86c1038251c4338b3dce831f212b39406b0dbe50c30ef0edefabfb55ea3849ceb49d4526cf06da0c3d578255f1b0647133cdcffd0e13d5ff07847502515499380e1ffeac00e297b95c69c4abf7a960191a785bdd4ec4d967fb7816c0b6fd89073478e8ad0e2949e4b61c35f15a614fc680b92fa13ca97d43e7c5a6ee32cf0db98609afe3098b282012addc2aba80a7bf90dc9a12a41a4e9082369cb633ebc9b015910e2bf0e755235a7d624487255eb8e0c2045667ec3e0479a5ad1b6125c05268677b76d1281dcddf23308177d86e20b7b1e41194fabeafc4c0147e6a9532f4092d5820010bd967a6f6afdd6228fb398df039da7dc54326d0a8cdcdfa25b168274a95ecba26c4786f0d2b092d461b24998870f6293f48a70a78ed16199f1fed7a5f22de34e25a94dbfc414f40c5a971b8c26ee4b156c3636ea3cafb9c721f8a436f68839acbb7a84746db9f4cda41796d86dec38d628e15b01719f39820aaca6b2e10f2518a07eb43ce19c9b683061142f3735ae6775244b1371e6d94255d294fa98316ebcc1293e11468dc7c0513fad2a8c1dbbf406ab13ea4bc7c6d995315ce1b69ff0719ac289618b51acaaf5d94afaa7b58c6b2adc2c78fe80bd3fc17d8718a60bbdea866dbf83fef4eae2aee559b41e4a660ad85a25c40a1fa53bae98600b72e60c03b1b5b3cb84f070e9908fe73be9958fb01b773e47d95434f1dcee7b200e49fba11d00f1cb82b36c1a53be9a3ec358229972bb87d082e432c88bfde94250bf456337c61732b4bfba87b137eb9c4f7aba89d8d8e1054d3515e44c852b542f26b0971d0a1523dc63e9d1f2aa6758f27950fa85884c50c2b53b1d6f32896254466361363eb2cdf7ffb110419bdb15913403f9e965917e714e0bd003e37cfb8c72d2fff9f64c4a23c7e35863f4d7d70ddc24aadd6db3fed68164f7bf6ad991d4059e05ec1846414fcbcc56963664564c69dea16420fdf0191e71a5df11ceb9b4778536a55b96a6dd32b1a2d701e47eda8f2cef11a8066baa4951286bb33b94327339af19e12b04760d8b3a9dbaac1cea7e55a4c28cfd84a15322b8f8a9dcacb7acb23305210c04ef59e2ddb3ce199be3cda5cb2629c45c6719bb6ee9448ecfe541bfd121117e8524fd7fde756987c63cc016a7e8db620825ed0571cdea7d86cba7e85ae409771c73e877df0076125e2f58f595d90bbd06d937ba2b2c42d181dc86d4966eb0acfcbeb964f1ff5896ab338929cd01a76c461eae977a288a36ee468ed2b410b6e495fb5ef8b0efc90e20b03ee0c3dd40392d3f2d480635c04518d2f47ac0c16b123c69ce73feeb8e65a53daf88ef56a77da910f5d7cbe757b9d47cb51946e9f6da5a95346f502b6c1a5cef860906c1d15c2f032da1422297caa26983d26feac4c279eefb61341a0fec5dc4873c9b884ea6a1ff93a2f3dfc65b996baf2a3ca1ac2546b23cee487949a0cb1a4abde826596d6258f1106a3ed800b483a09dc2bbadac6e4581bb0b9f4b25095422713ca880a01632314ce9fc8ac5cec36a942c1435dc1cc07d10df29d08330b55e3147c64865b3688530f43586a2d4cf987573482a2253767ccd20f262ec17f880cf171ea69405f2be9087174ac8af13f392d68a19d2916762731f8d32043c76c4b1c72072f8ce015ae49a4feb46cf4a60183019925eecf7c118190e53230406a1d9a158379c555ab44a26da879e4f6d45164eb1ba5de9b94c3f8278574d5e11bfe07494fd8283e6a64d51a9f0100075861ca905548f9cd6c773772094ded67d2118cb7d46e07526784d6353158849b1f441f0716b32e2e9254294ca77c49462e375e14262d285ec56edab083ad58a2467fb4eeb9d82954284911c1b9e44901d3462b70ce41d13222d02a8dea08380b510712474e312d2e24f47db2f00507e330fc832b6ecf331517041fd1f90476c8b69b0c51b59b98d2f1d562f08899a8f9a1cb28b6b632eddb7acffbad9e962ee0486f0c21556508070f52498e5872da4a8b2a6a4b9aaefbdd00e5e814021ee81cd016c3294de6d16d594f2ef184a64712766ed53670dd3fc6a40f5472516be2a620132b5fd6063fb9c17ce8480b0ab8f03eef48040613c0fe9f1a9a64714465e33c7b5fa0f48ae9bf7fedde82e44b34e446ddae61494668b1c8fba4541c9fc0f5333f3a984bea88c9c01034f239394aa8079121959a3684cd882e261631ba4add538f1d2312343fbc5dfd8fd81b78527d7c7495500bf1de5ed3cf2190b236f85a782ec2e55cb5b7834a04bd0614a4feb4a3bfaf9e75cd77f71c71b1028075e6010237825ea9b30b650d49245ee47709b9a68741402d942133ae29708af2e77dd944a19e91c8dcc54fb0470e286916d1ac5dba01f861da04cda2ac31bcecfa76fdbdb149f5bdaf5d0aa6a2721ec9ed7ee5bcb6d78b4f05a10de77a4c78dbb9303af6143739bb90378c1a50c459b315261b2b35086ea174ad249800b365666585636c38ba78c91ee30032e1d9d016884e3fb0740fd369ccb3b5971de04dfa6b26a4854e77b2250d9eb68d38395f9eae698d68ccc46993506dcb83e8fb1a9958afcfc5113fe40798ed7ef6403039271df5d391c3db9d6ae81db809aa4adda2593fc3b91bfccfbccaac36ffe86c62c9e819be16afd348267b32063d4ea40c2850af534d9a6bbe1d4d16fbd7eee1529a9b360bafb06f6b9aa46788d110908e233e8040652428a63d7b56860414aad4c5f512225e5bec961d7320b5e4e689e7479e943d7172c22c686539fcbf2955f85cda3d952279943cd41ce047a89d37a824269027894b6cde0cc9d6f7b2725435c5cd209467885f2cad75af87f0ea08a1e7fda6e1f47987db9922454ebf3cab4b87c5c36e1421c602ee9ae58856030903f9c322429742e469f2eb2c203ec84fe702f0d343a05ae6e2cd117ae079797e8e16b5e5fcc3a674c6ee8e3daf4a4d9a6dbdde528aaa624279f8632d04e96ef7b0bdc68682fdd1fac35a74942d9da272cafe68eca4eb16b83a1d5a08c145c74437f07c30d9e54cb96efd470b37da32abaa7abec12f014f6b66b48243a933fc3dadcd3984004f44f883b76c3814d839f367ebc8ba9e0498aa35262e42e4f01bf56ed0639afc1e4ca2aaffa65735531a6eec3e5394ab8ecc59bddef722c26d7a6a756def460fa51a7b9f68a8b9ca9cda77d09577e4e03b49df479ed0eacba552505aed13272fc9fb5c107ab76e81d331f6388d949ff103202b8c4a552a5b26aa2b6b7551310a7f27b265a4e1b96d482bb523af426b044d4a34ada982411fcd2047c9c04db40db131f6317b92faca64e192068fcb924b0324ed7bb733a4cbb8f3c28277d6a7f7af948367ab98c9938493f7414b0cee9e03a570b5d30335d1349beb15767d24e9ec560bb8f19807bd2bf6fd4dcdc79baa3aaa779325d77b9364305a23348c4f41a5a3a2f395018e6e0d05ace1b0b60dbac768859d8663bcf81d73883258fb97078e80c029d6e2f19436e272b8461275b4effb396d6c5832bf9e7a5ac19cd73cd70ae1f0fdc88f3ebd6a050b9feff56f8595a1eb7e09074a0f7b97c328c066e77dac056c123bd2d4b62395ae534ed41bb99204bd5917ba1ee84a4e23bfbd8ce248fd612f206ed84a13879a36034772459c8cbf35ad8a3fe73b239611e1b2fcbf5cac9c514768d1dc14a1795c7b3b752f4c1d65031b3c92d78d36ff768bc1903a81ef72cc4959194c3b4652fc9c78e61a50e8196de1fc245f857daa68b5a59045d256ce20b47bc399fd053d7baef6267ac31f32f8204d6637c1947c1be37d4129e801275eff88846815c766e2a22b49435c3d5ebe0e4a15edcc324f9f6ad593ea363bb20e030e8414f5533ba1804d96e51275171c697d92e89c8ead9c5ead71a190378056a804f167ea0c1bbd62f9658b3720edc5b6230a8dfa2e92a8a4918264e28d1b72f2df9bb3fa001b8a747a38f4bb60dd371ba16ad19b89e4ac0f83a5d7db5ac557dc32953173243e14d626ff432e05eb38fe2f25a1ef32ae1b881dd3980634241b3a2bd391a6f85e07c773c65b1e5ba1f2bf1833bcfb8cb199d435f12e1b051dc4f9643cdfb186513ce585eb76b5f607f03b434af8bc5f677868f62ab1a185548a778f5326dcc029a94372b532c492373838a06b781bdad99c0ccc76617765a038d3de776b3afc8a87b4f64fcc85be44c1b309c5173b7f625759ab2370fb7daf6b4e02e0f3f0713f1a7afdaa2e40d15af1f3ac509037d615519a691e4265fba802c673e7556507d5b8d2ec16a80bc1d6def13adba93f70e533853253db6106c415a9b7f1cbae23c0c96a819afb2ff7c95a39902dbcd1f8be35f7899f68db0bfacc836f6825a1874b2b844ee9a2759de235fbb6f602e250635302b66f52fe055e8fa3f58f222d0a2a5d43d79a69a19c8b4c66e8b321c0c4cb69fff9c2421cee0bdd20afed7532dc5a6cd6da7914b65e4246c56c783ced2c1c8d6880358758dd80308ff18559c616ef2bbffc5fe103fe4fb701ee30cdefb378a0deed8b63fa5446590a1ca113d8dc5d6bb37f1a2230663ed4f3df75ab711ad794e060fe4bfeb91cea2b2470ac1fd61ca04baa5917ec0d05daa51798ce3d10e265fc700aec6c8efac5553df9d4918442409edd763a331d892eb8352ba5156ed6ece612492adbf50eecafe894c14bb16da591581b6661eac44b353244cc5712bfe6c51ae55d96abe3a8ca4bcecbed7a1470fc61829802da0bd225cf0c9c5ca9360a48eebead3bbd125a6c6947b4c577ccd7b72624004d81b10819559a64d1315959fb49c412e22c6d8c41875472e3a23ebbf576d9909abac4ccadb7b7abdae84c8827681265658a0e2008dbf2951150f771a4f370c24ddcfe97e305734e2130951eaa6ce4a9b289ef818cb243d05009baf79e3b2bfc10ca02e06ef64e4ff9bc5e72930b6b607ed3797c865bbb3d461a3015746db745216ab4e9aa214268eda7f241dec2523956aa9fac1fcea3ba0852ad19570c10f1d62fc0f55a8c1f28186df934156a7a051eca5b5e4ef747ab0e0ddd2f8367eb5295b84f1f3a798fcb808843f91878dc73ec5ad185c5a0e0f80f57bbfbcd3912bd609db6c80a16fbb09c65ec9108200e42d6738b676f6c58638ee6148cdac1e165ffc33f7b9ce080fdfe1dd5f99dbaa5e9cb0271f61d3ab8817b5489344f3f7fbad713300ef51209d5606c4801a3d669c1bb18045f1394fdc242c64dad3b7c8ee725f47538ca0b050aaec7805fcb162947e29ace26c847339b9b958a907b645eae9d7878613c6aaadd5c40a81dc61026dd535ddce87820648936829542a7f20a8c5c81542e323863105fd42b5e883dad301363be2d0d04d3215a45315f052a4ebdce4aba8d320747729b1223d9d710bd9d0c773dbfa4b8531dadb90d7d5e12e006c1926f5cc71c601ad0fa00f92ff38c02edd991f2c61733d38fcf11dbdd437cc8ec15e3d3850c2683ca1487c27d5ac9d58b5f6ec3bbec318935d436370a7897f7a8be1077d3e17de43f7d439cc9dd568df3b499a80016529643e27932e01e843967efd91c7c08cbea0a49ea794868057b894718a26dae2350941f9bcebeffaeffd8b307c500ed6dced27e4b86ea47953f0514449f4fcca4458241551fa8f5f4eca873ca6242c1123c5fc3d943f73ea96ed171987bca69ac8275f48a8f120477a6067bfa1edc3461ea77b04c2af991ed35f4baa9829a0d8e3b0fdcd50713b4665b6d889990533ee7a3171c74201aaa83cafba96832619c39ff1fc56df895f509f90bc8f635c27d2aea143cd8b5d8df55177b9f523bc2e76022c4028136e1e808bc029cf4881d27482cdfef80bd4cb2fe20f1171777bbe8f355f8aed49be378ef3ab01d9401d9081dac9deec3311387352f105c782f971d17ccba979fee1999500984e4f8641838f5a5be1291f6b29ac0f99cbffb9d62d5cf5a29edf0d9370489926f16f2c65fed5b0d9384203369c56824d299aa33716187b439a2ad50efd295ea86d5334b1141baef6d792fb64e87b1ccbca905d5bb5e186032f333e4cff7214d15f13c8897feddd3dc54aebb60f58044af71846df2cf19e4fabd34eeadc243d269f5129ffd76a796651cd5373709f1b88fcbd75ba7fce93d248f77fc8462d32ad3b7875f6ad798f19a38e3d7095ff968eaa878521cc43b587c083b69f6b6929b5aa4537aad82300c29fb87cfa381f71670122ed6c1389f2221fce345be226c4b713c196c1e531536ed787e7ab83fbad98514e096f3312b4dc55228c45eabf467c831ac40006c83f0f28c9dd008d1946354abd830bd0dfaca202f3b5435dd079eb93ef02a4db00238313fb29bd7ecbf48585912b571055c36a8bd47e037ba93ff0422e1a98778a80b732bc9371e617cd89229cb0cb6173494c889ba090e4bcbaa95dfe4f6ecbfe8cabcd3dbfabb71d69ada56c6defe04b9853d4f6e494341a523d032b47aaac62bb28d2d1995b9cbec57c41a856f0ce082ecc18acc7ee511bd8db4e6ab31cf5552bf7e625c89cb72b1b1f0f5a3e41e85f6049df3238c0c833de1d1668b5be9ac6e775cfbbad3b43680de0f8e9dd5d4184f1746e182503bc4d64695b98c33b7e33f2656bb99c429106a3a4868bbbc3ede2c4180ed9ed87b21a334835288fb1f972c654c15e9b6c7e16feeb358b4ec9eae1865a302d8b93754b02c1bc4f611e9730e3ca344909de16780e28700d17c422eecae65478083fe03da2a00f18826203c45805a33a820e43d9da922764c9132f742aa29912e061c838dcc04fc1efe9de3bc2b2d4637f4df686b26ed51803db20492b98c53e2a1c0a79d1334fd191d80423b3a8111c39afdb9bb1fdcdff15506562631662eeffe4c16a99629a88b1d846a07a0abd4be36822014ddbbd575851b64be6ffbd1925f73ca493ee822bf2d840abc8d825959f3dfd1b3f69ef7819278274fc97b795f7ebce9fdf173713e2d5340defb1e9f52da2567e0f17370ea3d8459f466505d33f6b0efb1b0b46e06fdf0a672f9b3b030324184d90b366889c3db931c6eafb864a71901ed5c2d81504de72acbff8d94346d9cf2a87ff110de949d52b5bc1701d985f8d92e40582c938f56ca024dabb1fc4a67635af04b0c591b16d48782aec59866429aef1cc7c9cca84a7e6b3185b3254407f49bcf3547700a03541098252b09948ffed0004ac0cf838e725cb53f9f3cf47514fa0444b21eade476c6da9f264ad890bac45034aec29d6f86ec1179e8fd99f6605e5ce0254f9a5e437701274d1c849e1cfdde831641c4f2e1161dfbdb804f32e3f429d945fa30ebde98d3177875aa7073b371b3a62427fcfae85f5811adfff833a695dcc610b906b4ed28ecb47716cc9ad8f9cd36f804405c5c85795be3a3942ce1166c08418482cdb1d45a5d92db42b3c0683404785d7f3b8587f435b8b062a1113fd59c73bb370e65534e8a012323995aa0ae150ac882fa3f9e86b34f5ae758b1529e473b4dcb44fbf98869dac383248bc2a18435ba842d56767180ac3366d6d14ad0f2967726b802ed6990e9e43e8f49b483441bfae8f90029b5df566fe30df900f3a9ad19f50f746f396f3e910f89cc30c6583cde5658f4ce3461b94186b22119a7fdeb35e47e865a7b19b3b3908ad67c12e492f4e2e57432cd0f5b42cc5c05bbd21d1f38909237f048b29d0c36581211c2eaf79afe0fb6b4e38304e10272914a6e38603bcb6fcb36767647faffed6761bf6b96726e221491d9f0e2a4bbc568b88b5b9b87038c80bab1d6aafdb684606e099688c8b078384f42c09823ff7624e5de58efe8fc9b7b3235e67a6b6937b0da73692ea3456991b999998a189273c80af423c46123e4caa0dafcd693775a4ec9f82e354763a0f27a18e54752d0325fe46b52efb7cbcbe995b676590345714dca904cf2afccca486a505621ea7a37ffd750ed134ac2bb3f403b21c341e22ca311253c830383d1bb86b7c757bfbfac1e3b9c7c12533b7c7babfad8480355e7759e12fd14ea5aaece5c99540d8411e25a56515e2886171b33dff3ab450a41a8a8d269cb2dbe6ba8d922e2558b8f62a3f5e4f17361f8e88d387afd47f7816d277e51e5c70c421dd2972036e417ff07661c08b03e537d12db3197d218fc283cc53bb830521224845c884749417abea90c2557ac71c0ebca14ad6569e8b874f90da1719555e1de8826aad1818a1ad57e26e6dde5d454840a6d1c63ce09c876ef2f842cb9a4d9497d26882546f0817b269f15fe3aff626f53b4fc90db4a1758470cc70abeca5da34a9efcb9950c5be843982afb775826c6b23343eee1097fed58ca4c092170f494782c7fa3c1f8a4209d1fbe359ddd9d4a5f6a7d5b4bc1cdb1001baf0c7e00d6eb11346e9aea31a1d6d1021d529ceb007e453e69a3d17d6036e465210ffd69a3d7fcc5b5c398eb3fb2dc4af8f08bd13f9813d994bac22b99cbd686ad8e2db5810a87fa139269ca98752b2955f0759dd0fd34640e8539b2fbb6ac0e911f5a6af87f297ebe9f30a986929915e928d49e8db853a301f9408be04dced4b6499029a45f27ab5ccfbd8010f46c5fa54d3787218f8a66ce16cd1347999fcc2c8533dba8061b985d4c55caab3e0afcfdec710affe2e42f925f69aa209cb3d72a6662b1d99d9e0d6c280b9a1743c2f90009df3e4004d2ccc9a33baf4a1e60d799ed6c491c3b5ae11c84586679b9076a3daf9b79c9b597a69569c79698c4876591096ccaced91ed0ea818c2e8c4620cfcd60d8e843be7745a889312757b484d0a849e2bffd07d14ed1503a1e2e8751c6709f9b980f9132d8d92c0d7eceaba7bf0b011582dd6ffa5ef17f1754a056fafc3db295938e33a66ded2c8a468a9ba7688cdae1625942f8942e68c99b90cda22f4ab0e19e917dcda9b0050c9407f0b16fb67458eb3a2e26e7a01cb817dca822ebc8b282364ed3710ccca9d5a4e4ede972ca056598bae134e042abe4dd28f380be534b155fb77a31fdd8616a3ffe787c97c6b8653ff3263f9448ee3fc20f1f2340cdc9605a0a38fb2362d0a7355e470e873d397f030b07eed3d5cc40dccc4acfcbec619ab98b2e8286a9581e8631aed2b581192b30075d7d3e9901ede99f70a7e777e2ea231a594c6aaf5a331d2453feec5e136bfffb09aa5d0dcbaa1e5038661f54cf97fc012751a2e8e1c0e14ccb7a54e8255b5c971a3046be4017c78dca9b7d8e3cd3a65c320918212894c3305515c4773ae11fc3ab5f0e11614f834210bd346b6d9514f0c9d1f22887f96378b82fd27ea474b2d3a48e83534e31b0c535be05bb084154ac2495c1f7176ccf45e61bf9b917a3c282d18cf1470b644c59e7c0aee21977cd82077229dad675be6db2be0239e167002c4eacd5a5f13116878d3a14856430d978f3e5be44d053d09253f4e29631e1a88d0fde8fb1c6d52a9c36757459baf1c23ab7226d757349c5a95cd13f224efc000210178ee4fbe06c59caedcfc46bbf5d6c62a161f9acfd8e51ff7ffb4a3d118a3fa1ba771b4e699f68400de7658e496ce6cfa1d207fe434aa3da8000c33050428c7dbd406ae4f3954c127b4217c234b820e91d1f310adf1a3681053d456a62d1bf0a596095c94b45e2c4cb017f75cb3c92d7c240469b7f4f37da332fc4bca2f319dc43fe1026cecbdfa4825d5a58518d3569551fe6697221e83f7cef8945c2202902bbf1ea9d620f4c0c239524afbaa33516ff6f242e963909704d83c7182518603b82c322aafc0d17b078c9e7ecfd289fba6f7a657e4972d82f94501c1accdf9942d0228f2503eec1ce84e0c320cbe67788c0107aff90710e02120534eecf1c7754afe2f3a1a0c77cf2bf721ae88bb919ccc5ac2802f35e8a73754f6d0bf40aca1ded162d4da2a887c669586cf8a4daeef299ae68f472588f30fdb2f54e03e40e42fb31d1e8ba6c14ffdf8b928d9a34b72153c7dff5406e8334414ed94ade8492eb55bc26c0a699215b6278ece0cbbc1d25c5334af9d920788efa87e89c0e18326cc664059d2e0df1927e3e129026b3a4b40feee5157350ab12c994dc04551a4836e6bfc48d282d8ceda5c6b76e8394500a80fca149d194904f5a293af99cf8ed87c7760355d9f5088c88b1e24eb38d5cfec5a35e8077e0111f493b01274c5d23bd0119a9d08a46d39cf1a7e9085a6c8f64a480ca3c04091c6ec71fde214ddc898d105f9649e62024ef768d507b8e752982e18bc2ca05b1da99be1022ef69317a523ed70a2fab4c761ea31498212f868f0658647518237e19ef1605256a159b72e4b8566e82a6a3ab4f0880d62ceddf3f43c1ce0108a533d206f87e1a2b1aea41a2e7abef3e7acb23737d1d3a4d2012d30981c3f1e872906136ee27ce37648402ff275e1cd6620eaf1420c446c726d7f335603eb6c42338cc53a5929aeacaaff1826b08757cc39e993a5421361c6104a0549210364098b88fa513720a8909915902a7ca8194888e4e6d726420885f716244fdfb0cc9a47b0400308ff0f374a3e553c2a534aa89ddeedd623f609ec0f62a074bc178a847eb58283ba151bad724d8adc4731f68cf50dab5e86807a52c034060b7bccf9b2b34917d791ab711b684b08d3f838d8a4740fdc809ac3abafe707acee52882fa9b3ca08df5c7e4b4935b77990bd73d94331c544cf8bb99ebb57b1f0de82177be7832c0feb56504e85f85e918a5cbcc7076d6772b455a7fcbdcc91c09c61177073904e0a8bb530674d68e123585b510eb0caaf6325072a98a662e783c07cfaf81d92aee26d469c7ca9dc0cee8812febd86e50789a436d3ab8cd44afe793a11f084eb88aa0431064a450abf6cafead1e98bfc7a1c63432c2390ce51f60c85d8b00d7ffc8911e90aab6f94a639f0af2dd4f06d229822ed2f8c7dc1daf25c4d55c886a71bb52230a1c7bbb13634c4f6881af3b9a2f22655b1960555322c0796df30d8906b413c872c1b3c26fd031bb21bf3c75c670ba51283ec720d35a50b267b2ef7c965a4c73da770d5f3e0080c1d3c0c62fef0c3d9130d195d98815cbdd9e23e67740652b827d9c9014d349f49eda1fa8f612cd77cd449a1f382907beb8f7ad8681dc91f114fa2345defee59518dfa049ebfa12e45314232203ec8427ee22ed53b51cdc0c3309e2766db4ebd994544c96ba113f1ccc72a4e633457fbf9928e9480df2af9a7dec9015cda0d752098eec0c0f8b112d7242850854d8a37067d08280b511fb6ae9a98af58ffc9d5fcb24434a73675cce7fddd26fce5cda825f4cd44b59b9ca1ed4365260a07978d11f75b3e2e5d9290b6b3932b49e8a82ef13bb9d58ad886f0ec05f2bd0fc450d69720cf79f8c35baa49a84008a102898bdd5d14dc13c4d5ebb5166c905ea442f5cd79e412ae6121d96328cc0c843227192b9aa3199cfadd05280437f6333c703ed63a83493433b3dd79f2a56da2369bdcd623c0b0dc6c5ff893861754736a4c9039192f5a9675dd893242bfb201483a021cfb2c88454ae9a54868f990ba56ba09cfc1eaf9cb7f0e33bf3074df7b957d371ace6633fde69f6c2438a74f88c3787fcf9f7f2680710c0c2ccc853eecf3e0760fad43a70c7b59ee5c582abee5bdbb3131f3f26ece69585c7e67baba414ee18f3e1294171e6c2b2286f5a6c328da29625e515392eecb8302bc6346d3328469df432b6655a5eda90ee2a4b794e50871d40e1ec4ad24cf6b7587ee6f41ca3c9bca1d3b558949fef29e51bc77f14a3c33b1a3f785b6f983072c84a0578055d969fa56608a1e99f67c45119b631b7a32db317af04299c46a7a8c27a8fd8300b7d86e46793d430c3fb1769f91a0d975dcc4cf45adffb6e1e237b3f555920ddcf71e5c2970cf3754297ab431b3477f24bde1fa6e85fe5ddcee37c5def9ba48e6807d9f00ab8bc88e7f25e3b3f6883b7c5c13b35d8ecb2aecd7b2b56b6c3cfb41910f1281bbbc29c3033001856623be16615eaf7ce2b121da9847e96f71511fc3f5b872a8f341dc8eae10af8b2492e188ca9d3394acddbd09fb9ce6f5787ce94efe3a7a071b67970bd0a4a4544483820575441426e0ac1591be34f0b23d52fc95f550683d352ab6d2d8a199f54e6981e933f7fac06d5a6dc761b9639b615a70e21d99a68f8ac6602bdc8886cc8d22dd0c864e3c157dfffef82003388a111258e4528af5bcdc0b4c3cd3a69c74c26a995066dd46ea924a2be67edd8bb9f76357a74fc49cdee14642ebb44ff33b836e30f1a89653c2fb4a2a8945d26592fab1eeb476bacf88881743d49603c5af26f1111a79e917f8c0841521517a7217b2e47293d79ab51a6f64e2de1567e9cfcc79b066dd011c4e0f664aad3ba23963599fc4f794b3ecffd379393305bf005692bf240ca8f318a1915b636fdda65e755a53aded39a27883506e91c0134b5cd05bf4899770936f266930863f015a211f0c4f5a3fe5bda102c755411d6e678a847580775984af2798b208d0aac199b805807cffa256e7e81a1a3a7df8535efbcb58b7d7d6c6731f74fb47acbbcda23ae3d247546edab3bbd59e66c281018573b270a3d16dec38f3a100eb59dd5962b3d29eb470095f1950a8deb77a3ec8c7f07bffc3d88b5b3690be14b9fdf4157b670724d61011552d802df534c599cf2332bb4f49d056be298b79d5d3130dc20d4cdf45b43bf7dce91ccb0154938044e9666ae4fc153993ef89cf5aeb9eea1a9678123a3c323a5f4339b188bbaadba30ef8d0e8f9b8385875953f9e10b4c1e00283c303214da7cec8799689661e14faba5946880d8dffb14025ae5d5d31e275b0302431d4b0426fe877e17a09568f4bb0fe1b6637552753c7d6f2c3cf951f6ac755ce6473821ce610a83be6dce81ee3e0cf6ab967fa28cca08b1dabac67857fa072f59017ab8b0ecfd4b7b5d9b3864201629d119d807f18dc7567559110f259a12c857accff86650ea9ffa674e6d40a61ef7afd2ed1eebff52e7a9a00a8d68070682670fe6eabcc24a54b196f8c71c20e576a6a27b59d3d90ab299ee1e0bb021a40c9a28d367470eb29938376332865dd4953609d5dc7334d11c944e5ad70a0d0515332b8e0c49bcc3a188bf911ed36b4df92f7a8a0e1b7cccdfc7f3126dde5713acf3e920a257991457b6f5489bfe39717fc37def8c3a758aeec53d2d396f6d040efaf8696257a0f03abb0ac6d4b37d998dce8a8cb5e22aa9b9d6b37dfa1e6c3415cff549b62faea444dbf2b6d175584ffecb55d27b0fea0ccb58ec01068ea7e7c4b8e926c9155a38172600ac52386157ff29a2b05c9b450db5954f703aec93da9bf4203a6bd7ef03730b42320a9484824adbea04ad62bf7503f7db0f993b3d2c43a4b904d0b600921fbc5752d5e55b42772cdfaeee74c65ed011538362e60031624eff33b86f0e92e8303ef07cd5b385e57687bdb58d3b536ffb9750da577330ec80a0e384dbd39cb62ccbab2e855053cb4de6c27d6f5b4ee12ab847297fc80c933d84938388d1fea8c920cd451054e1f2d5293bc0366221b5854f9cd123dc4f55c5ede0ef9132f29bdcf7f989e65ba9cee3013df65787de66f15c8f0f0b2913a7246dad04c58a9d8a83bf5f9d12b12bbd9592d40e98168b70654d405e61bf05d4fbe18e11d9a84b1bc55defe3099e1bfd727fcaea6f69f145a7a69deb6b28306a7890ed3ab8917ed22a6d5718da5b7a3914ad54805e8690dba7a64a4bc27b6a662fd7d596fc144990e1110897c944ba05d53516f45e114ff76dce2c60e8fe60e1268ae96dc7e6b6df6f6ae092a11bf2e9aec73546643c0bd34101a156fb86aa9502e9376cad28a77ee6cb6a8748c89e2fef178fe9e33f18752bebd97a8707d1a6713b91befe2fbcf8d41e91fcf06a70df09227d178f777af80d25e2dd6b372b2f06ec3c2509017e6c3681018be6d1024999ea66065dfb512278b6dc98c35a078a8798e823c306a61b90cec33d707f2a8b1500792b589d6b723c77dfbf1f50aead81746b76cf20193a142fdea63435c89ad78ed9b6e696a17a853047bd95dc3e01e4bf5750719967adb94e2ffb307644034ecc83a50dfc7251b96d381632b454423c7a055a2082550db25ba3c92fa979815e49dd3c3dc9cc010538e06e4b5a59405f6ae2ea38d3ef9e5aadccdef2cc603bd95cafe4f39ff9f4c2d15a58f3772126b4076f4790eb970d399862329ad3aa0c59bc2f8c965d23838dd8cb40a62f0e415737f70105322e28dc6883abf565bea5fd3089dcc1479c5202408b12c29266218a277b01f11522a9bac1693602237d56fe5dd7f4d4b3022911c2c129a9be1b1a299e45c4231015a513c6dde3de3caf2ead997e4bec684820bc12df25c2a7c18ba25dc83a319d95646945ae622879cf32fc373c056ecd6fe6784d7bc09ae32dc21148af4109e4ff08c53fab79cb34649adfbe8a08f87b77ac9546dbe7214e1848731879136cf0d173d13090116339bc689ffa5c5b0563776db3fd5fb310631e7ae4e4c1f729ca940bf8d561f01caa331ad0b03336b3b16e06ae4db869b1b5309175dbae3d31ae656c81a4a0f4638cb8034c698c601b8251b2fbbc13d3eb981f034863617693ec5475c24032d35c32dbe8c03db599eaaae172c516660ee2005e1638f3f7ba54fb03a88542e383c886dc407e569025fbb58673d7533d387365a2a1adfa10308e6d264cf92237ca64b9acbab2e1c127776abe0e69408bb91fbedba2880a9b456c86751868c7e0e54d733e498eab75626e83203953ac0d063216b220b2e7365ea50480bdeb2e037eb3721a27abdb56b766eeb7bb3c71394b52e137b4fc167009a5be6130c336c4e765ea71a794ad4a705c6e20d2d5c93f05ab1472a3eff174f5b11a42a7a02968dd55cc4c129164d201ef504297bd168b9e6f5569ae69ae638afe7827cae9d9a175d4e38616437f7b39f062f0883a9964991876c4972649f1a9b59e197aa29e9f607722a45477181a57f5ebfc393aaa5e7507920babf967e889b784de656fbba9c524f9200e9aa5e8990f58cd09a43d43b262c61fcec7ae2eb6a9c9e20710ddf21aaa6bb820cc3ae33aa8425323c77a9a687301471c41422b46350f42915ba4698fe11c6dc1049cc0d66042510f659ae0036e8f9ba440bcce5848af8925a14226d04cd39ba32c8b3cb6f2020e506e89f9d41f58276e309be6e06e06e6fc3bd1d8e42c4f8712f4a684d4a670584f39aacf9e547141ddc98a4adcc2ea51ea093e61a30102ae11507564f360018c12a8ea504e79ff3ce7c6acccdc13413a307242122017959a5dffe3044d9f29f2546bb347a0cee7f4c25b4c495598ef93fc6c282149ce036e9e5da6a5146217e05d6075aa47c4951840fa85af3855013300dbc2eb38fd00af2764b8afbd03739c83dc07420cdea75c8d99b91485775823ce15d8a2650eafdfc79685e0727173ba10f2f30a0038157f306ccdfb7ce64314e1774c8fbdf2fcd44f62cbcd916ebae4eabb34e510bcf5ba9d170676ee998091d6033a1993848baf610677f2d10087fcf65fd351ddc00cb00eb4e1ce25445ae4165bbb19e4e344e4e2af1c7bdb7ad0fbf90dedac2ce3f60736ce40a940126e6923e7b3a8f516815e71d3eff5bc50ca999afc62739570b08de3b6cceffeba457c2f869ca78d1c17ce74e3715756d68f0dd5e6688974e02d495e6defaf0b0da82f3a9feea09d8c47eff0b90eca3985e2149762d9f87a4c32320beabef7c571e3a5a777377890e73aa054e8d520d2525b30b904d2f3f5b7344fad25d6071c236495a9fe139532bb8a8c2324dae6553022ae2f007c501e88a01bf6f5b6c74334035a30ccfabc58c1d1058dbc0398d52a4a11b43ff635b5e63b2e28ba994d4b42857bf1161c304dd33099210742aac5ae5afcb19ab465b53e420d45fa29db0cfbb4b6763d4aa5052e3d932936075efccea64286487cc2cf4b41d5b7f62c0c9549c7618877351f0e546d5770bee244afad89b6e4806b535c5e980c28853a2d5091f43ea99006056cb6ae2ec7c18d7f8c6ce4881db74299a9e26c629d6917304466dc70807a4d1d8b874b0936c01c1b3981b77238a2e9f6438c5531c8becf16d2d22e66d0cf1182fad6fda402105a9fd1ab7a574fb3f79b6d8f196027d6ce26264c8f7680f4b98d822610ce26342497ce76e429d67a2c72384b73777b00e7b5988c0c46ebad67cb0014bb324d95a9dd99c71aa97c639afc267f3adcd9bef78f15d3f4135bc4a6e38424213fb9eadae119aebdbb3b4deec6ff276ebea955cc07773bf0c3d8f4951a157bf7521e72010b21c71fd49ac0f7fd3561ff74ffcfcdf95984d65c657bc8786faa0b8320f33830bae923c1a965277bdc579619a50d180d9b06adda9a45a13fadf9932991a59f8cd44cbbea30fc0e31e0b5ce479f795cb9e5009a8db5c99d26d9d7509f590ad4b0aeeaa2e15aa6349516cb0922e8e82ca23625cbb54516263c1434b52d4338f07ce844cdde0fdf8d63d3974e318389120d99e87686e3336f1008f79c05f8a0d1881454f99ed3468d351a5a8ad485e10de833bb11088a4ecdb4d2106fadac487eb0d72d0ef01da4e6381e64ad633d373ff0dff7140de5475555689a37fd59f3eaaf358c76def637af2d9002173a2add92cf9fcd60b36a3ac88fac8ed9115f1cfa9ab817ee9861494d8c00a6b1c26116f53c59a6717a723b1c9cb51be4d143f4bf324c8995a133c1757c0c03bfce1f52528d39f41763fd48789a6eae85922179fea6df489eda991364186956186fee0df44ab8f16e3ad30de35d04685fabd36f6a4adf2835e0d0c85e791030c5dcfe1e198d124d9867ba1ad828e9d735001c4c8913b4350a2ce85ef58478e518988d5b17e0b412a8d3104cdffeefc508bf8a0add6b7efb58e9352e9272b0a24337874ad9b2b53da4689d4504138b88b4bcfbfa770c654b12f50a7bcf78eab34bf3b8b1cf7f89d2ae541a985efa274cc4261211e92ac2234257cb00e1d7d082a593418675c30acb250a54c44d11b6d5fb2b5a20d798b25b9d6161378823bc2881b5f79801045cb84425c4abb8370fec23a4a9babbcc6c17ed04c5a64f3e34a3cc282309159841a1b1ce558b170a337b6986afde4a2a91077469a6296fd4bcbb70aad3061987d6889f211dd5159352d9a2015645197438eb5eb6ef38d1fe940db295e1be82761920ffecf690bd8f513aa0b63629e807aebe6b135ad4ad95d7a7b21b077db6ae4264a27f5f8b2e730cb3e09d84228e34722653a8f4de6af759d10ad9b9c3c683fe3cf901d5f71de8776d23463fe23367d0929cf33c9c2804374a0f6cb6c97572a866d430e8ad360f39a2f52ad098423b5b4c879f8dd12acc9d1885df08efd2ddccc820097b1e554a7e68de1028f84bab00641ee01d9fdc352d519771814a6be22aa8af85f99e3893e9e9ad1eef476298a75a3807b6e6fabba26e43f6c01667001ab68c4c2d73c05180778ecddff449a0f05512924d7aa973007705599301597976e8188280cb66426a5b6cc35d95449eb7abd87097705bbe6a6cb8ac16b8f3b5867e94cc797aa0d81c12276479d0103a2b050032bd192c9284a027e349575228e12daed4aa43bcc2f1a81fc8a4f02c2140e36991e749fe1f31df28c0f516696b4687c68b5491c030ebe7f224925e6f497812a310f16b2dbf1816efd2fbd3fd5739ce87a102b708664067c716324b83dab541f439be8ac12982550cc37157fc79435c637d567bb00209a6167b1f75948a7bf7e5ea7b841ba5a95db1802f9518d3fd39cb923d785b7442ab75c34ff794326c8f11b7fc0d24be38851dbe2e1d97aa106960365e7fcc66cd9fe1602eafe0bb58e1abb0a1f077a0719b16e67586548f7ecc7d4181d80c06e3d8e76a54a927b02bf43b65a1562258338c7195fbaf2e36df1d699e5ebe24a3eb3f8f7274ba929de7c4183a216daccb3956c7c757b8f50cb5a4de7d97cc8217a7477ab61e6a3207d502988bec4c477f66a01321ef8d5b6d7b2aef9945a0dce82149ac7974500f68a38957c2085b862fbe2878ebd388dad63f1e6c1e7acd925ec97ec493da2d79264cd30a32097f7223a978b78d603fcb0cec6d2919f171c13b538129650cb4291ca5384cd2aebf1c445e7b438197a7532ea4c8d40f2a270fd08b3221e22f7bb494eaa586bc3bc96aea730116eb0aadadf38bc9eb2881c8a968625b954361c2957daff5ead7ba6eb4006539e575e514cb67047eeac505168616b789a0b7b93933e0895b9126af945075a27cef998cbe59271f6b6612737f2323582710fa49e13c9b25694982410c1b29864fac3990d789200546fae171995c18afc8623a7758d60cc743342cdbad84f7a08e2034ca9cd5143b752b4d818c363fe9760303caa280de97b86a45562a6765d45717ec952d859aa8130b5f754052dd9e4b76b21cabc3893e72e468d35fefbe9018c06a46eddadd595ca93af983b41c49e33414783a4dfab421f2531b558380f054114a3b7768b3e2dee3c4302f00679141cdabd65b6642acc6d43fb0048ef4adbbdb1024860d60a95a90481c2664f286ea92611388f62dea6c2fdfbe95777d58612acfdaa4f985554ed7473fa0d4e974c45f7d1468c2234f20327c0ba7cef9b26233a4ffd4e14a1892f831099cfe8213af1849b39606b9a4c10cb3d994b2a436acbb07e7eb87d8163c9032a51d67bf9f77a1006926e354b78fb33a38ed41ddbcedbad4a8b6350b6761f51cb43f5b4031ddc478ce05359e15087fb20d764e50d3e5a5a823fa7747e115d3727b59cbbb43fcbbe60ab7f5809318e69737439f8156993809dd18f73768cc9c4d901770c1c6f62c0d7ab60b1e1eb44265dbd8768c4748e30d738c0393a513eeba2e4e6f2891dc5083f4c7d4b4553f46eaed7ca285eb3119a270a6a73b0590209107da7ec24cc7fa88132beabeaf9633b94f822009bb810adbd470a028ae9066b6bef8b5a86291817276255c5cec9bbb79d93e3a0bc59b49fb4ff94b4f1429edb9393638c107b17aecb9404e02d75cd98bcd4a101262481ca715e5767696ee7db7ec42a29f081b2650f15422f1e3794fe857c706c9816107da3fb2524416a6d4b59cb1f739aa9fc56aa6068f64aae665974c3a752b77b33d4b359defc19e6b3991002c112d506517d6b12ae42561ad0ddade55a154ae8d5bbf41cff897bb2d57d0a9849739bb572e04f00110940fb43d89986df85c2018844c76af092806e08124bed59f9e51864cc5e613794869d72e5478fbbde66958e09e682db0cb47d6ca8d24a1d083d9401207fa09f31d374cd4d37d504bf49e3b5e99cbf9da47b25eb773fe7f95b764c1d6e1c9ef5992ef95ff4f517949f6fb625047eada637d5345cd2d97df815a947242b245659f22eb8520ac313241f9ffba88a43c08ad4e387f90b7173d5ab99cfd7aa874805a5ae59597ce2bf0419dd708fb2502d37cb95c69468ee941d5265a6312bf41c60111d47484b5166988c131544f538a2d3b9486bbca59e3184989a9245cfc8fc04f07a7328a1ae46483356c4e7205835dbae5175949c5647feb7a6ece99d96e4fed7e6ac5e39476b48f27f250b124670968b13eb49b89d520a7d4a57d0ccaccc5c17ab77df045ca454a506d4d69e54d401289eeabb55a9f2cb59db4e4a4c1255ddfbc364b29943b39a1234bfff9eb31d42ae5237f258bfa061066c3833e6a09b0f27d97493add72af10874ca10c4796d1fece482015991ca9a486720cd906748c9d41369a5514109cc8a719a831a65988b6fe5fd4b9e0557bf0df805519123b4fff48e6a28698b38bbd98e05be01153ef7bac0eb8a011566db53e2a5df52b9e95a8ad5fdae5ef62fa1d36f385997743a804ecf2ff52f59973311f1f02cf6ddbac352cc66df223f3151ed5791b35183716812f5d8e241ae7591931d46de804c9846256629287d6b9c23c9aaf2a1b6c1d10af131f4c106bcec084fe36ca5bd1f3d4ac65bb030ed577fc5273bd824cb9d4a946b20b6c80bcc79cfdec07c358e1c5013876ce2152fc707b4ac2700f6d6cd2751883e9b62b996d95f5bbfc0e9379b2971fff20ac77d992e63c40df029b64a51dcb53b8bbb120ac9285a977c49048356081b08ef6699239ff7db4d36ae244bb4a2f21c87c7b523b127398906ca78ee17a0fbf5042c4649c001be7d0c47e9261d1c525cd1e3fd250f422fc744c2766d6de73107036575ce22ef315c4d18d5e578db1e0c15ed41149de630ac44aa98bfd2cf5aa1208e0b787b1874a802fa1610f902849fe9e797f27f1647c2b1e764dc4fed0060322e74bd28240bdca064913225a3d5bafe1fda303966a1dafd080937985daa080f9f5508665d476034986e17bfba0057b3d78383df90837791888233d511f73be12a7197e4a9a15975fe2b9e53780764fb42d2ed95eb15942bc016ee24549e812de7d490c417895ca6095e835e5dfd1bbe173c4a8639b040406bb479ed763851bd6853a1f277fce94f93a0f49fd49595c7e164e0defa6554063816867935f77b46f393e9ed775174689aea5c4980ab4afc602774266880514d0888bed241dc0048af9f6b3848311b47504f11851f4b040fe228b053f89b818737fdae374103edf55dd423f1983202c81be80403990803d2fd45d82bc33f24b99f8314698334efe80b9550732975ff9f53cc9e0fc3eb822df8c23e98fbc9d70e9e90c2e0053fd61606a778f82a13d0092d6e5d7658124c02049db59db429e9e819d02cb8604e4917ad96271a5eaa950cff7ed898d2c13aef8bad2c127e583dac456b562bff82fcfe276e8a51ff376e446b5a7898f80c9d8ecb653f3ac833bc8951d9285aac7a040c8557c41df98d23132a8bb53948cfac63a162894b5759612231ec9f0dc7c8a519f3069a08dd6a3591ae47a773226bcc2f4413eea216725faa34b1ec6649064d26709d1f1b1e4debac692ce7ead3ef40cea8811f1b92999011a5b6bb4fb71fc78d2d8e7c2369542d9addcd8deab72df0300d016c3b28d14053cf4cecbdbfa4425cb61a4f538f7fb47e9a34e1ea9e52589ee6a6b113b79fdc2c7c7d9ed3df56dbd6cacc19187143f7834d955f19bb5b4cbee09143d2dddcce66f69d3135378aece604b6eed426b8b00b92a3b02cc2a99bb69b5d8b4bed44118e081af7bb19e632a45d9c3ecaca5960c3cbc21290eee0fd5edf5d13d45730464c2593e8c94f207a0cd9a3e57a59399f409bc1c4e9a106b0b8ff94fac9801f72e9c7d965393ab31b6e048dfc637729a035a961936156e97a9f400d94c9b31d52804fa290bd86f3486dd51e3ccddbff8b5e751a344365eb9e268e81380d75702c70bb6a035464e5f92782e95caa0f4f6d4432517d08f97cf96425a3f021dcb7f8ae8563a902bc1a611dfe33960dbd97a4f1811c0d6013a36ad6f62ce1c95b35de2aa9f3c9a5b027b272240e091fe9bcf00e1ccb178d48286193292a64d8622b8e0e49100e0787ee9acedf28f6b22961185052b717c619160c50f77447f680e7ae29cab2a70ca6ae01b12c1bae46ccad94527517c6362c0c246eac9da1ad312db54f674faca8294a2846148d0aa8957d23b1cb3ff391a1e10f9ba71df23fe7e4932f226d0491354f2ae9924a8321ebb9bfd4fdf5cde98e38fad1dc9c55dc81fce93539eebbeef453f43c3d01de2f475866901df9c9afe992d0801ecf100d039bed8549d88ab476911c3b0338d2f5845b4e6b078ca999d6fe5bc65ec24515d4fe7ecb00c8005d401d402dbd5f5148bde4ffc6308f78d6306b5ed81eb481ddc88c9ee63b746d1d68fc499343458d788d811a4617c84cd05adc7c439889b99b3e01b5755892a00872f3c2519e1959a4af143cc7c50c872a905e177afea5e24bcb95ef38411b1d4373d99213bb311641d9b13c8b64838e6cc01c38b87643f0e293a41f4fa9b2b11a6b145bd08935c9e1657f578d30b9afa9c2117f2984e17f1489dd2c2ea9b60756f5b46f58eefad5b74b0e5301cc2c92463961b7734baf10167a1d26ade0053b9ec8697721091593ec4433b3292e612f61ecfe7d214e865b74ccbdc2853cc5f49e8973fca7e0dc1110cec2e2fe44d6a7adeb2d7f62de30282b1a62a11bf582eae1dd7341127ba3253b54f6f3e58a196e732a2a800da11c3a3c9a8f57bcc5575895c4ce31eaf655c0d1bd71df5fecabdd5bfdbe63f44518748bc4bd93c4d3e31ac36a90dd938f8dd0a867380b01c27e1fb4e219aa94d3b4b09cc28ce37c85871be752995f0e01f5a5bd59f6ea2b627089bfc089a8820fee1436df4959664d6997c1ae73fb006301832a1ca513072ded0368ddd16aaac32fd143657fbf933e19dd4039889e972af571e993fa66cf91f5f725b7749dd947f2ca5cce73d4655d2f3979b98d3393f3d2f1c75dc8e4cfc71e574d014</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码以阅读这篇私密文章。</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RSA题型整理</title>
      <link href="/2020/07/07/RSA%E9%A2%98%E5%9E%8B%E6%95%B4%E7%90%86/"/>
      <url>/2020/07/07/RSA%E9%A2%98%E5%9E%8B%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="0x00-前期准备"><a href="#0x00-前期准备" class="headerlink" title="0x00 前期准备"></a>0x00 前期准备</h1><h2 id="01-基础知识"><a href="#01-基础知识" class="headerlink" title="01 基础知识"></a>01 基础知识</h2><p>　　<strong>RSA加密算法</strong>是一种<a href="https://zh.wikipedia.org/wiki/非对称加密演算法" target="_blank" rel="noopener">非对称加密算法</a>，在<a href="https://zh.wikipedia.org/wiki/公开密钥加密" target="_blank" rel="noopener">公开密钥加密</a>和<a href="https://zh.wikipedia.org/wiki/电子商业" target="_blank" rel="noopener">电子商业</a>中被广泛使用。RSA是由<a href="https://zh.wikipedia.org/wiki/罗纳德·李维斯特" target="_blank" rel="noopener">罗纳德·李维斯特</a>（Ron Rivest）、<a href="https://zh.wikipedia.org/wiki/阿迪·萨莫尔" target="_blank" rel="noopener">阿迪·萨莫尔</a>（Adi Shamir）和<a href="https://zh.wikipedia.org/wiki/伦纳德·阿德曼" target="_blank" rel="noopener">伦纳德·阿德曼</a>（Leonard Adleman）在1977年一起提出的。当时他们三人都在<a href="https://zh.wikipedia.org/wiki/麻省理工学院" target="_blank" rel="noopener">麻省理工学院</a>工作。RSA 就是他们三人姓氏开头字母拼在一起组成的。</p><h3 id="1-1-安全保证"><a href="#1-1-安全保证" class="headerlink" title="1.1 安全保证"></a>1.1 安全保证</h3><p>安全性依赖于大整数分解的难题：寻找两个不同的大素数是容易的，但将两个大素数的乘积分解成原来的两个素数是极其困难的。  </p><h3 id="1-2-具体内容"><a href="#1-2-具体内容" class="headerlink" title="1.2 具体内容"></a>1.2 具体内容</h3><p>假设Bob想给Alice送一个消息m：</p><ol><li>选择两个大素数 p 和 q ，计算$n=p q$；</li><li>随机选取整数e和 d ，满足$e d \equiv 1(\bmod \varphi(n))$  ，其中$\varphi(n)$ 为 $n$的欧拉函数；（$r = \varphi(n)=\varphi(p) \varphi(q)=(p-1)(q-1)$，选择一个小于 r 的整数 e，使 r 与 e 互质，并求得 e 关于 r 的<a href="https://zh.wikipedia.org/wiki/模反元素" target="_blank" rel="noopener">模逆元</a>，命名为 d 求 $ e d \equiv 1(\bmod r)$。模逆元存在，当且仅当 e 与 r 互质。）</li><li>发布e和 n 为公钥， d 为私钥；  </li><li>设明文为m，加密函数为$c \equiv E(m) \equiv m^{e}(\bmod n)$，其中$1&lt;m, c&lt;n$；</li><li>解密函数为 $m \equiv D(c) \equiv c^{d}(\bmod n)$。</li></ol><p>$(n, e)$ 是公钥, $(n, d)$ 是私钥。Alice将她的公钥$(n, e)$ 传给Bob，而将她的私钥 $(n, d)$ 藏起来。</p><h3 id="1-3-证明"><a href="#1-3-证明" class="headerlink" title="1.3 证明"></a>1.3 证明</h3><p>下面使用欧拉定理证明解密函数的正确性，即已知1-4，证明 5 成立。  </p><p><strong>证明</strong>：由于 $c \equiv m^{e}(\bmod n),$ 所以 $c^{d} \equiv m^{e d}(\bmod n),$ 即证 $m^{e d} \equiv m(\bmod n)$</p><ol><li>当 $(m, n)=1$ 时，由欧拉定理知 $, m^{\varphi(n)} \equiv 1(\bmod n),$ 而由条件2知 $e d \equiv 1(\bmod \varphi(n)),$ 即存<br>在整数 $k ，$ 使得 $e d=k \varphi(n)+1,$ 因此 $, \quad m^{e d} \equiv m^{k \varphi(n)+1} \equiv m(\bmod n)$；</li><li>当 $(m, n) \neq 1$ 时，由于 $n=p q,$ 因此 $(m, n)=p$ 或 $(m, n)=q,$ 即 $p|m$ 或 $q | m$ ，<br>若 $p| m,$ 则显然 $m^{e d} \equiv m^{k \varphi(n)+1} \equiv m \equiv 0(\bmod p)$；<br>若 $p\nmid m,$ 则由欧拉定理知 $m^{p-1} \equiv 1(\bmod p),$ 于是$m^{k \varphi(n)+1} \equiv m^{k(p-1)(q-1)+1} \equiv m(\bmod p)$；<br>因此，对任意$m$，$m^{e d} \equiv m^{k \varphi(n)+1} \equiv m(\bmod p)$ 成立，同理可证，对任意 $m, \quad m^{e d} \equiv m^{k \varphi(n)+1} \equiv m(\bmod q)$ 成立，因此 $m^{e d} \equiv m(\bmod n)$ 成立。(同余性质10-最小公倍数)</li></ol><h3 id="1-4-安全性"><a href="#1-4-安全性" class="headerlink" title="1.4 安全性"></a>1.4 安全性</h3><p>假设偷听者Eve获得了Alice的公钥 $n$ 和 e 以及Bob的加密消息 $c,$ 但她无法直接获得Alice的私钥 $d 。$ 要获得 $d,$ 最简单的方法是将 $n$ 分解为 $p$ 和 $q,$ 这样她可以得到同余方程$d e=1(\bmod (p-1)(q-1))$ 并解出 $d,$ 然后代入解密公式$m\equiv c^{d} (\bmod n)$导出$m$(破密) 。<br>但至今为止还没有人找到一个多项式时间的算法来分解一个大的整数的因子，同时也还没有人能够证明这种算法不存在 (见因数分解)<br>至今为止也没有人能够证明对$n$进行因数分解是唯一的从$c$导出$m$的方法，直到今天也还没有找到比它更简单的方法。（至少没有公开的方法）<br>因此今天一般认为只要$n$足够大，那么黑客就没有办法了。<br>假如$n$的长度小于或等于256位，那么用一台个人电脑在几个小时内就可以分解它的因子了。1999年，数百台电脑合作分解了一个512位长的$n$。一个由Shamir 和Tromer在2003年从理论上构建的硬件TWIRL，使人们开始质疑1024位长的$n$的安全性，目前推荐$n$的长度至少为2048位。<br>1994年<a href="https://zh.wikipedia.org/wiki/彼得·秀爾" target="_blank" rel="noopener">彼得·秀尔</a>（Peter Shor）证明一台<a href="https://zh.wikipedia.org/wiki/量子计算机" target="_blank" rel="noopener">量子计算机</a>可以在多项式时间内进行因数分解。假如量子计算机有朝一日可以成为一种可行的技术的话，那么秀尔的算法可以淘汰RSA和相关的派生算法。（即依赖于分解大整数困难性的加密算法）<br>假如有人能够找到一种有效的分解大整数的算法的话，或者假如量子计算机可行的话，那么在解密和制造更长的钥匙之间就会展开一场竞争。但从原理上来说RSA在这种情况下是不可靠的。</p><h3 id="1-5-参考"><a href="#1-5-参考" class="headerlink" title="1.5 参考"></a>1.5 参考</h3><ul><li>《信息安全数学基础》(主编：常相茂 周玉倩)</li><li><a href="https://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95#%E5%AE%89%E5%85%A8" target="_blank" rel="noopener">维基百科</a></li></ul><h2 id="02-Ubuntu-安装gmpy2模块"><a href="#02-Ubuntu-安装gmpy2模块" class="headerlink" title="02 Ubuntu 安装gmpy2模块"></a>02 Ubuntu 安装gmpy2模块</h2><p>PARI/GP是一个比较强大的数论库，“针对数论中的快速计算（大数分解，代数数论，椭圆曲线…）而设计”。</p><p><strong>需要的依赖库 gmp mpfr mpc</strong></p><h3 id="gmp-库安装"><a href="#gmp-库安装" class="headerlink" title="gmp 库安装"></a>gmp 库安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libgmp-dev</span><br></pre></td></tr></table></figure><h3 id="mpfr-库安装"><a href="#mpfr-库安装" class="headerlink" title="mpfr 库安装"></a>mpfr 库安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libmpfr-dev</span><br></pre></td></tr></table></figure><h3 id="mpc-库安装"><a href="#mpc-库安装" class="headerlink" title="mpc 库安装"></a>mpc 库安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libmpc-dev</span><br></pre></td></tr></table></figure><h3 id="gmpy2-安装"><a href="#gmpy2-安装" class="headerlink" title="gmpy2 安装"></a>gmpy2 安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#python3</span></span><br><span class="line">sudo pip3 install gmpy2</span><br><span class="line"><span class="comment">#python2</span></span><br><span class="line">sudo pip install gmpy2</span><br></pre></td></tr></table></figure><hr><h1 id="0x01-已知n、e、c，求m"><a href="#0x01-已知n、e、c，求m" class="headerlink" title="0x01 已知n、e、c，求m"></a>0x01 已知n、e、c，求m</h1><h2 id="01-思路"><a href="#01-思路" class="headerlink" title="01 思路"></a>01 思路</h2><ol><li>利用 <a href="http://factordb.com/" target="_blank" rel="noopener">http://factordb.com/</a> 分解n获得p和q；</li><li>计算d；</li><li>解密得明文m。</li></ol><h2 id="02-代码"><a href="#02-代码" class="headerlink" title="02 代码"></a>02 代码</h2><ul><li><strong>代码1</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes,bytes_to_long,getPrime,isPrime</span><br><span class="line"><span class="keyword">import</span> primefac</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modinv</span><span class="params">(a, n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> primefac.modinv(a, n) % n</span><br><span class="line">n = ...</span><br><span class="line">e = ...</span><br><span class="line">c = ...</span><br><span class="line">p = ...</span><br><span class="line">q = ...</span><br><span class="line"></span><br><span class="line">phi_n = (p<span class="number">-1</span>)*(q<span class="number">-1</span>)</span><br><span class="line">d = modinv(e, phi_n) % phi_n <span class="comment">#求模逆元</span></span><br><span class="line">m = pow(c, d, n) <span class="comment">#求明文</span></span><br><span class="line"><span class="keyword">print</span> long_to_bytes(m)</span><br></pre></td></tr></table></figure><ul><li><strong>代码2</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line"><span class="comment">#分解n得p,q</span></span><br><span class="line">p = gmpy2.mpz(...) <span class="comment">#填写p</span></span><br><span class="line">q = gmpy2.mpz(...) <span class="comment">#填写q</span></span><br><span class="line">e = gmpy2.mpz(...) <span class="comment">#填写e</span></span><br><span class="line">c = gmpy2.mpz(...) <span class="comment">#填写c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#计算d</span></span><br><span class="line">phi_n = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">d = gmpy2.invert(e, phi_n) <span class="comment">#求解模逆元</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"private key:"</span></span><br><span class="line"><span class="keyword">print</span> d</span><br><span class="line"></span><br><span class="line"><span class="comment">#求明文</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"plaintext:"</span></span><br><span class="line">M  =  pow(c, d, p*q)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'[10进制]: '</span> + str(M)</span><br><span class="line">flag = str( hex(M) )[<span class="number">2</span>:] <span class="comment">#[2:-1]</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'[16进制]: '</span> + flag</span><br><span class="line"><span class="keyword">print</span> <span class="string">'[ASCII码]: '</span> + flag.decode(<span class="string">'hex'</span>)</span><br></pre></td></tr></table></figure><hr><h1 id="0x02-低加密指数分解攻击-e-1"><a href="#0x02-低加密指数分解攻击-e-1" class="headerlink" title="0x02 低加密指数分解攻击(e = 1)"></a>0x02 低加密指数分解攻击(e = 1)</h1><h2 id="01-思路-1"><a href="#01-思路-1" class="headerlink" title="01 思路"></a>01 思路</h2><ol><li>加密过程：$c \equiv E(m) \equiv m^{e}(\bmod n) \equiv m(\bmod n)$，所以明文与密文模n同余；</li><li>$m = c + n*k (k=0,1,2,3…)$，暴力破解即可。</li></ol><h2 id="02-代码-1"><a href="#02-代码-1" class="headerlink" title="02 代码"></a>02 代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line"></span><br><span class="line">n = ... <span class="comment">#填写n</span></span><br><span class="line">c = ... <span class="comment">#填写c</span></span><br><span class="line"></span><br><span class="line">max_num = <span class="number">6</span> <span class="comment">#遍历上限</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> range( max_num ):</span><br><span class="line">    m = c + n*k</span><br><span class="line">    <span class="keyword">print</span> libnum.n2s(m)</span><br></pre></td></tr></table></figure><hr><h1 id="0x03-Rabin加密-e-2"><a href="#0x03-Rabin加密-e-2" class="headerlink" title="0x03 Rabin加密(e=2)"></a>0x03 Rabin加密(e=2)</h1><h2 id="01-思路-2"><a href="#01-思路-2" class="headerlink" title="01 思路"></a>01 思路</h2><p>理论知识：<a href="http://dragonliu.tk/2020/07/08/Rabin加密/" target="_blank" rel="noopener">我跳</a></p><h2 id="02-代码-2"><a href="#02-代码-2" class="headerlink" title="02 代码"></a>02 代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line"><span class="comment">#从文件中读取密文</span></span><br><span class="line">f = open(<span class="string">'flag.enc'</span>,<span class="string">'r'</span>)</span><br><span class="line">c = f.read()</span><br><span class="line">c = libnum.s2n(c)<span class="comment">#字符串转数字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#分解n</span></span><br><span class="line">p = ... <span class="comment">#填写p</span></span><br><span class="line">q = ... <span class="comment">#填写p</span></span><br><span class="line">n = p * q</span><br><span class="line"></span><br><span class="line"><span class="comment">#求解mp与mq</span></span><br><span class="line">mp = pow(c, (p+<span class="number">1</span>)/<span class="number">4</span>, p)</span><br><span class="line">mq = pow(c, (q+<span class="number">1</span>)/<span class="number">4</span>, q)</span><br><span class="line"></span><br><span class="line"><span class="comment">#求解yp与yq</span></span><br><span class="line">yp = gmpy2.invert(p, q)</span><br><span class="line">yq = gmpy2.invert(q, p)</span><br><span class="line"></span><br><span class="line"><span class="comment">#获得四个解</span></span><br><span class="line">r1 = (yp*p*mq + yq*q*mp) % n</span><br><span class="line">r2 = (-r1) % n</span><br><span class="line">r3 = (yp*p*mq - yq*q*mp) % n</span><br><span class="line">r4 = (-r3) % n</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> libnum.n2s( r1 )<span class="comment">#数字转字符串</span></span><br><span class="line"><span class="keyword">print</span> libnum.n2s( r2 )</span><br><span class="line"><span class="keyword">print</span> libnum.n2s( r3 )</span><br><span class="line"><span class="keyword">print</span> libnum.n2s( r4 )</span><br></pre></td></tr></table></figure><p>当$p = q$时，使用python命令行将16进制转十进制，然后直接求解$c$模 n 时的平方根：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n = ...;</span><br><span class="line">c = ...;</span><br><span class="line"><span class="keyword">PowerMod</span>[c, <span class="number">1</span>/<span class="number">2</span>, n]</span><br></pre></td></tr></table></figure><p>Wolfram 语言在线编辑：<a href="https://www.wolframcloud.com/" target="_blank" rel="noopener">我跳</a></p><hr><h1 id="0x04-flag-enc-pubkey-pem"><a href="#0x04-flag-enc-pubkey-pem" class="headerlink" title="0x04 flag.enc + pubkey.pem"></a>0x04 flag.enc + pubkey.pem</h1><h2 id="01-思路-3"><a href="#01-思路-3" class="headerlink" title="01 思路"></a>01 思路</h2><ol><li>解压得到两个文件【flag.enc】和【pubkey.pem】，其中【flag.enc】从文件名含有flag可以判断是加密后的密文，【pubkey.pem】是公钥文件，通过公钥文件可以得到e和n；</li><li>通过openssl对公钥文件【pubkey.pem】进行分解，使用命令【openssl rsa -pubin -text -modulus -in warmup -in pubkey.pem】，得到 e【Exponent】和 n【Modulus】；</li><li>其他根据类型判断。</li></ol><h2 id="02-代码-3"><a href="#02-代码-3" class="headerlink" title="02 代码"></a>02 代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> rsa</span><br><span class="line"></span><br><span class="line"><span class="comment">#分解n得p,q</span></span><br><span class="line">n = ... <span class="comment">#填写n</span></span><br><span class="line">p = ... <span class="comment">#填写p</span></span><br><span class="line">q = ... <span class="comment">#填写q</span></span><br><span class="line">e = ... <span class="comment">#填写e</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#计算私钥</span></span><br><span class="line">phi_n = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">d = int( gmpy2.invert(e, phi_n) ) <span class="comment">#求解模逆元</span></span><br><span class="line">privatekey = rsa.PrivateKey(n , e , d , p , q) <span class="comment">#根据已知参数，计算私钥</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"./flag.enc"</span> , <span class="string">"rb"</span>) <span class="keyword">as</span> f: <span class="comment">#填写文件</span></span><br><span class="line">    <span class="keyword">print</span> rsa.decrypt(f.read(), privatekey).decode()  <span class="comment">#使用私钥对密文进行解密，并打印</span></span><br></pre></td></tr></table></figure><hr><h1 id="0x05-共模攻击"><a href="#0x05-共模攻击" class="headerlink" title="0x05 共模攻击"></a>0x05 共模攻击</h1><h2 id="01-思路-4"><a href="#01-思路-4" class="headerlink" title="01 思路"></a>01 思路</h2><p>用相同的N，不同的e进行加密的，可以使用共模攻击。</p><h2 id="02-代码-4"><a href="#02-代码-4" class="headerlink" title="02 代码"></a>02 代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> libnum <span class="keyword">import</span> n2s, s2n</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> invert, gcdext</span><br><span class="line"></span><br><span class="line">n  = ... <span class="comment">#填写n</span></span><br><span class="line">e1 = ... <span class="comment">#填写e1</span></span><br><span class="line">e2 = ... <span class="comment">#填写e2</span></span><br><span class="line"></span><br><span class="line">s = gcdext(e1, e2)  </span><br><span class="line">s1 = s[<span class="number">1</span>]</span><br><span class="line">s2 = -s[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#读取密文</span></span><br><span class="line">file1 = open(<span class="string">'flag.enc1'</span>, <span class="string">'r'</span>)</span><br><span class="line">c1 = file1.read()</span><br><span class="line">c1 = s2n(c1)<span class="comment">#字符串转数字</span></span><br><span class="line"></span><br><span class="line">file2 = open(<span class="string">'flag.enc2'</span>, <span class="string">'r'</span>)</span><br><span class="line">c2 = file2.read()</span><br><span class="line">c2 = s2n(c2)<span class="comment">#字符串转数字</span></span><br><span class="line"></span><br><span class="line">c2 = invert(c2, n)   </span><br><span class="line">m = (pow(c1,s1,n) * pow(c2 , s2 , n)) % n</span><br><span class="line"><span class="keyword">print</span> n2s(m)</span><br></pre></td></tr></table></figure><hr><h1 id="0x06-低加密指数分解攻击-e-3"><a href="#0x06-低加密指数分解攻击-e-3" class="headerlink" title="0x06 低加密指数分解攻击(e = 3)"></a>0x06 低加密指数分解攻击(e = 3)</h1><h2 id="01-思路-5"><a href="#01-思路-5" class="headerlink" title="01 思路"></a>01 思路</h2><ol><li>公钥中，e=3，N非常大。</li><li>加密过程：$c \equiv E(m) \equiv m^{e}(\bmod n) \equiv m^3(\bmod n)$，所以明文与密文的3次方模n同余；</li><li>$m = c + n*k (k=0,1,2,3…)$，然后开三次方，暴力破解即可。</li></ol><h2 id="02-代码-5"><a href="#02-代码-5" class="headerlink" title="02 代码"></a>02 代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> libnum <span class="keyword">import</span> s2n, n2s</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> iroot</span><br><span class="line"></span><br><span class="line">n = ... <span class="comment">#填写n</span></span><br><span class="line">e = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#读取密文</span></span><br><span class="line">file = open(<span class="string">'flag.enc'</span>, <span class="string">'r'</span>)</span><br><span class="line">c = file.read()</span><br><span class="line">c = s2n(c)<span class="comment">#字符串转数字</span></span><br><span class="line">file.close()</span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span> </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    res = iroot( (c + i*n), <span class="number">3</span> )</span><br><span class="line">    <span class="keyword">if</span>( res[<span class="number">1</span>] ==  <span class="literal">True</span>):</span><br><span class="line">        <span class="keyword">print</span> res</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"i = "</span> + str(i)</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">m = ... <span class="comment">#暴力获得的m</span></span><br><span class="line"><span class="keyword">print</span> n2s(m)</span><br></pre></td></tr></table></figure><hr><h1 id="0x07-私钥修复-最优非对称加密填充-God-Like-RSA"><a href="#0x07-私钥修复-最优非对称加密填充-God-Like-RSA" class="headerlink" title="0x07 私钥修复+最优非对称加密填充(God Like RSA)"></a>0x07 私钥修复+最优非对称加密填充(God Like RSA)</h1><h2 id="01-思路-6"><a href="#01-思路-6" class="headerlink" title="01 思路"></a>01 思路</h2><p>压缩包里有一个密文，一个部分缺失的私钥，一个公钥，读公钥可知 N 是 4096 位的，分解无望，肯定要从私钥着手。</p><ol><li>【vscode】打开【private.corrupted】，将对应变量填入下列脚本；</li><li>执行脚本后得到私钥，新建文件【private.pem】并将私钥复制进去；</li><li>然后执行【最优非对称加密填充】脚本。</li></ol><h2 id="02-代码-6"><a href="#02-代码-6" class="headerlink" title="02 代码"></a>02 代码</h2><p><strong>私钥修复脚本</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#-*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> product</span><br><span class="line"><span class="keyword">from</span> libnum <span class="keyword">import</span> invmod, gcd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve_linear</span><span class="params">(a, b, mod)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> a &amp; <span class="number">1</span> == <span class="number">0</span> <span class="keyword">or</span> b &amp; <span class="number">1</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> (b * invmod(a, mod)) &amp; (mod - <span class="number">1</span>)  <span class="comment"># hack for mod = power of 2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_n</span><span class="params">(s)</span>:</span></span><br><span class="line">    s = re.sub(<span class="string">r"[^0-9a-f]"</span>, <span class="string">""</span>, s)</span><br><span class="line">    <span class="keyword">return</span> int(s, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">msk</span><span class="params">(s)</span>:</span></span><br><span class="line">    cleaned = <span class="string">""</span>.join(map(<span class="keyword">lambda</span> x: x[<span class="number">-2</span>:], s.split(<span class="string">":"</span>)))</span><br><span class="line">    <span class="keyword">return</span> msk_ranges(cleaned), msk_mask(cleaned), msk_val(cleaned)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">msk_ranges</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> [range(<span class="number">16</span>) <span class="keyword">if</span> c == <span class="string">" "</span> <span class="keyword">else</span> [int(c, <span class="number">16</span>)] <span class="keyword">for</span> c <span class="keyword">in</span> s]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">msk_mask</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> int(<span class="string">""</span>.join(<span class="string">"0"</span> <span class="keyword">if</span> c == <span class="string">" "</span> <span class="keyword">else</span> <span class="string">"f"</span> <span class="keyword">for</span> c <span class="keyword">in</span> s), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">msk_val</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> int(<span class="string">""</span>.join(<span class="string">"0"</span> <span class="keyword">if</span> c == <span class="string">" "</span> <span class="keyword">else</span> c <span class="keyword">for</span> c <span class="keyword">in</span> s), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#根据文件pubilc.pem得到</span></span><br><span class="line">E = ...</span><br><span class="line"><span class="comment">#文件pubilc.pem中第一个Modulus</span></span><br><span class="line">N = to_n(<span class="string">"""..."""</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#private.corrupted中的prime1</span></span><br><span class="line">p_ranges, pmask_msk, pmask_val = msk(<span class="string">""" ... """</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#prime2</span></span><br><span class="line">q_ranges, qmask_msk, qmask_val = msk(<span class="string">""" ... """</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#privateExponent</span></span><br><span class="line">_, dmask_msk, dmask_val = msk(<span class="string">""" ... """</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#exponent1</span></span><br><span class="line">_, dpmask_msk, dpmask_val = msk(<span class="string">""" ... """</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#exponent2</span></span><br><span class="line">_, dqmask_msk, dqmask_val = msk(<span class="string">""" ... """</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(K, Kp, Kq, check_level, break_step)</span>:</span></span><br><span class="line">    max_step = <span class="number">0</span></span><br><span class="line">    cands = [<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> step <span class="keyword">in</span> range(<span class="number">1</span>, break_step + <span class="number">1</span>):</span><br><span class="line">        <span class="comment">#print " ", step, "( max =", max_step, ")"</span></span><br><span class="line">        max_step = max(step, max_step)</span><br><span class="line"></span><br><span class="line">        mod = <span class="number">1</span> &lt;&lt; (<span class="number">4</span> * step)</span><br><span class="line">        mask = mod - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        cands_next = []</span><br><span class="line">        <span class="keyword">for</span> p, new_digit <span class="keyword">in</span> product(cands, p_ranges[-step]):</span><br><span class="line">            pval = (new_digit &lt;&lt; ((step - <span class="number">1</span>) * <span class="number">4</span>)) | p</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> check_level &gt;= <span class="number">1</span>:</span><br><span class="line">                qval = solve_linear(pval, N &amp; mask, mod)</span><br><span class="line">                <span class="keyword">if</span> qval <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="keyword">not</span> check_val(qval, mask, qmask_msk, qmask_val):</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> check_level &gt;= <span class="number">2</span>:</span><br><span class="line">                val = solve_linear(E, <span class="number">1</span> + K * (N - pval - qval + <span class="number">1</span>), mod)</span><br><span class="line">                <span class="keyword">if</span> val <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="keyword">not</span> check_val(val, mask, dmask_msk, dmask_val):</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> check_level &gt;= <span class="number">3</span>:</span><br><span class="line">                val = solve_linear(E, <span class="number">1</span> + Kp * (pval - <span class="number">1</span>), mod)</span><br><span class="line">                <span class="keyword">if</span> val <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="keyword">not</span> check_val(val, mask, dpmask_msk, dpmask_val):</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> check_level &gt;= <span class="number">4</span>:</span><br><span class="line">                val = solve_linear(E, <span class="number">1</span> + Kq * (qval - <span class="number">1</span>), mod)</span><br><span class="line">                <span class="keyword">if</span> val <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="keyword">not</span> check_val(val, mask, dqmask_msk, dqmask_val):</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> pval * qval == N:</span><br><span class="line">                    <span class="keyword">print</span> <span class="string">"Kq ="</span>, Kq</span><br><span class="line">                    <span class="keyword">print</span> <span class="string">"pwned"</span></span><br><span class="line">                    <span class="keyword">print</span> <span class="string">"p ="</span>, pval</span><br><span class="line">                    <span class="keyword">print</span> <span class="string">"q ="</span>, qval</span><br><span class="line">                    p = pval</span><br><span class="line">                    q = qval</span><br><span class="line">                    d = invmod(E, (p - <span class="number">1</span>) * (q - <span class="number">1</span>))</span><br><span class="line">                    coef = invmod(p, q)</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line">                    <span class="keyword">print</span> RSA.construct(map(long, (N, E, d, p, q, coef))).exportKey()</span><br><span class="line">                    quit()</span><br><span class="line"></span><br><span class="line">            cands_next.append(pval)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cands_next:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        cands = cands_next</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_val</span><span class="params">(val, mask, mask_msk, mask_val)</span>:</span></span><br><span class="line">    test_mask = mask_msk &amp; mask</span><br><span class="line">    test_val = mask_val &amp; mask</span><br><span class="line">    <span class="keyword">return</span> val &amp; test_mask == test_val</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> K <span class="keyword">in</span> range(<span class="number">1</span>, E):</span><br><span class="line">    <span class="keyword">if</span> K % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"checking"</span>, K</span><br><span class="line">    <span class="keyword">if</span> search(K, <span class="number">0</span>, <span class="number">0</span>, check_level=<span class="number">2</span>, break_step=<span class="number">20</span>):</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"K ="</span>, K</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> Kp <span class="keyword">in</span> range(<span class="number">1</span>, E):</span><br><span class="line">    <span class="keyword">if</span> Kp % <span class="number">1000</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"checking"</span>, Kp</span><br><span class="line">    <span class="keyword">if</span> search(K, Kp, <span class="number">0</span>, check_level=<span class="number">3</span>, break_step=<span class="number">30</span>):</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Kp ="</span>, Kp</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> Kq <span class="keyword">in</span> range(<span class="number">1</span>, E):</span><br><span class="line">    <span class="keyword">if</span> Kq % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"checking"</span>, Kq</span><br><span class="line">    <span class="keyword">if</span> search(K, Kp, Kq, check_level=<span class="number">4</span>, break_step=<span class="number">9999</span>):</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Kq ="</span>, Kq</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p><strong>解题脚本(最优非对称加密填充)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> PKCS1_OAEP</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'pubkey.pem'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    key = RSA.importKey(f)</span><br><span class="line">    N = key.n</span><br><span class="line">    e = key.e</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> N</span><br><span class="line"><span class="keyword">print</span> e</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'private.pem'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    private = RSA.importKey(f)</span><br><span class="line">    oaep = PKCS1_OAEP.new(private)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'flag.enc'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">print</span> oaep.decrypt(f.read())</span><br></pre></td></tr></table></figure><h2 id="03-参考"><a href="#03-参考" class="headerlink" title="03 参考"></a>03 参考</h2><p><a href="https://www.40huo.cn/blog/rsa-private-key-recovery-and-oaep.html" target="_blank" rel="noopener">RSA 私钥恢复和最优非对称加密填充</a></p><hr><h1 id="0x08-wiener-attack-e特别大"><a href="#0x08-wiener-attack-e特别大" class="headerlink" title="0x08 wiener attack(e特别大)"></a>0x08 wiener attack(e特别大)</h1><h2 id="01-思路-7"><a href="#01-思路-7" class="headerlink" title="01 思路"></a>01 思路</h2><ol><li>给出的n分解无望，而且e特别大，利用<code>wiener attack</code>脚本分解；</li><li>然后利用一般方法求解即可。</li></ol><h2 id="02-代码-7"><a href="#02-代码-7" class="headerlink" title="02 代码"></a>02 代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">continued_fractions_expansion</span><span class="params">(numerator,denominator)</span>:</span><span class="comment">#(e,N)</span></span><br><span class="line">    result=[]</span><br><span class="line"> </span><br><span class="line">    divident=numerator%denominator</span><br><span class="line">    quotient=numerator/denominator</span><br><span class="line">    result.append(quotient)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> divident!=<span class="number">0</span>:</span><br><span class="line">        numerator=numerator-quotient*denominator</span><br><span class="line"> </span><br><span class="line">        tmp=denominator</span><br><span class="line">        denominator=numerator</span><br><span class="line">        numerator=tmp</span><br><span class="line"> </span><br><span class="line">        divident=numerator%denominator</span><br><span class="line">        quotient=numerator/denominator</span><br><span class="line">        result.append(quotient)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convergents</span><span class="params">(expansion)</span>:</span></span><br><span class="line">    convergents=[(expansion[<span class="number">0</span>],<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(expansion)):</span><br><span class="line">        numerator=<span class="number">1</span></span><br><span class="line">        denominator=expansion[i]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            numerator+=expansion[j]*denominator</span><br><span class="line">            <span class="keyword">if</span> j==<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            tmp=denominator</span><br><span class="line">            denominator=numerator</span><br><span class="line">            numerator=tmp</span><br><span class="line">        convergents.append((numerator,denominator))<span class="comment">#(k,d)</span></span><br><span class="line">    <span class="keyword">return</span> convergents</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">newtonSqrt</span><span class="params">(n)</span>:</span></span><br><span class="line">    approx = n/<span class="number">2</span></span><br><span class="line">    better = (approx + n/approx)/<span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> better != approx:</span><br><span class="line">        approx = better</span><br><span class="line">        better = (approx + n/approx)/<span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> approx</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wiener_attack</span><span class="params">(cons,e,N)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> cs <span class="keyword">in</span> cons:</span><br><span class="line">        k,d=cs</span><br><span class="line">        <span class="keyword">if</span> k==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        phi_N=(e*d<span class="number">-1</span>)/k</span><br><span class="line">        <span class="comment">#x**2-((N-phi_N)+1)*x+N=0</span></span><br><span class="line">        a=<span class="number">1</span></span><br><span class="line">        b=-((N-phi_N)+<span class="number">1</span>)</span><br><span class="line">        c=N</span><br><span class="line">        delta = b*b - <span class="number">4</span>*a*c</span><br><span class="line">        <span class="keyword">if</span> delta&lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        x1= (newtonSqrt(delta)-b)/(<span class="number">2</span>*a)</span><br><span class="line">        x2=-(newtonSqrt(delta)+b)/(<span class="number">2</span>*a)</span><br><span class="line">        <span class="keyword">if</span> x1*x2==N:</span><br><span class="line">            <span class="keyword">return</span> [x1,x2,k,d]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">N = ...</span><br><span class="line">e = ...</span><br><span class="line"> </span><br><span class="line">expansion = continued_fractions_expansion(e,N)</span><br><span class="line">cons = convergents(expansion)</span><br><span class="line"> </span><br><span class="line">p, q, k, d = wiener_attack(cons, e, N)</span><br><span class="line"><span class="keyword">print</span> p</span><br><span class="line"><span class="keyword">print</span> q</span><br><span class="line"></span><br><span class="line">c = ... <span class="comment">#密文</span></span><br><span class="line"></span><br><span class="line">d = gmpy2.invert(e, (p - <span class="number">1</span>) * (q - <span class="number">1</span>))</span><br><span class="line">m = pow(c, d, N)</span><br><span class="line"><span class="keyword">print</span> libnum.n2s(m)</span><br></pre></td></tr></table></figure><hr><h1 id="0x0-reference"><a href="#0x0-reference" class="headerlink" title="0x0 reference"></a>0x0 reference</h1><ul><li><a href="https://blog.csdn.net/qq_28573835/article/details/86164877" target="_blank" rel="noopener">Ubuntu 安装gmpy2模块</a></li><li><a href="https://bestwing.me/Common-types-of-RSA.html" target="_blank" rel="noopener">一大波RSA就要来了~~</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区块链的那些事</title>
      <link href="/2020/06/27/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
      <url>/2020/06/27/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>　　有人说区块链是一场伟大的实验，有人说区块链是一场革命，有人说区块链是一个世纪骗局，还有人说区块链是百年难得一遇的良机，人人参与是社会发展的必然趋势<strong>[1]</strong>。而且，区块链的发明者中本聪是何许人也？仍然未知，无疑为其蒙上了一层神秘面纱。<br>　　这里需要指出的是不要将区块链与比特币混淆，区块链是以比特币为代表的加密货币的底层支撑技术；比特币是区块链的一个应用。巴菲特表示：“这是一个赌博的东西……有很多欺诈与之有关。比特币没有产生任何价值<strong>[2]</strong>。” 换言之，与其说比特币用来投资，倒不如说是用来投机。否定比特币并不意味着否定区块链，恰恰相反，我们应该好好领悟区块链的技术原理。国家支持区块链的技术的发展：在2019年10月24日中央政治局第十八次集体学习中，习总书记指出：区块链技术应用已延伸到数字金融、物联网、智能制造、供应链管理、数字资产交易等多个领域，要加快推动区块链技术和产业创新发展，积极推进区块链和经济社会融合发展<strong>[3]</strong>。 2020年4月20日国家发改委也正式将区块链技术纳入新基建范畴<strong>[3]</strong>。</p><p>　　表明立场，谈技术。技术主要是来自于《比特币白皮书》，<a href="https://dragonliu.ml/lun-wen-ji-lei/qu-kuai-lian/bitcoin-a-peer-to-peer-electronic-cash-system" target="_blank" rel="noopener">我跳</a>。</p><h1 id="01-介绍"><a href="#01-介绍" class="headerlink" title="01 介绍"></a>01 介绍</h1><p>　　区块链技术依靠共识机制和分布式账本，不需要第三方信用机构就可以避免双重支付问题；同时，通过“工作量证明”（POW，proof of work）及“权益证明”（proof of stake），区块链使得所有参与者可以在某些方面达成一致，无需信任单个节点，从而解决拜占庭将军问题。</p><p>　　比特币网络的全节点时时刻刻都在进行数学运算（挖矿、工作量证明），每个节点贡献自己的算力来竞争解决一个动态可调整的数学问题（进行 SHA256 运算的结果小于某个值），成功解决该数学问题的节点将获得一定数量的比特币以及该区块的记账权，并且该节点将当前时间段的所有交易打包计入一个新的区块，获得基于自愿原则的交易手续费，所有的交易都会经过算法处理（SHA256），并且经过验证，产生一定格式的区块并将该区块链接到主链上。整个比特币网络周而复始，比特币网络顺利运行。</p><p>中本聪在其比特币白皮书中非常详细地介绍了区块链系统的建立过程：</p><p>第１步 新的交易向全网所有节点广播；</p><p>第２步 每个节点把收到的交易都写入到一个区块中；</p><p>第３步 每个节点都在新的区块上进行计算，寻找一个工作量证明解；</p><p>第４步 某个节点找到工作量证明解时，就把其所在区块向全网进行广播；</p><p>第５步 其他节点收到广播的这个区块后对其进行验证，只有所有交易都被 验证是有效的且未被使用的之后，该区块才能被认可；</p><p>第６步 每个节点通过将此区块的哈希值作为父哈希值来进行下一个区块的 计算，表示节点认可了此区块有效。</p><p>由于每个区块都带有前一区块的特征，想要篡改一个区块的交易记录，必须要重新计算该块之后的所有区块，需要修改时间越久的区块，所花费的算力越大。一般来说，一个区块后面有 6 个区块，这个区块就无法被修改了，也就是认为这个区块可信。[6]</p><h1 id="02-自问自答"><a href="#02-自问自答" class="headerlink" title="02 自问自答"></a>02 自问自答</h1><ul><li><p><strong>问</strong>：比特币就是区块链吗？</p></li><li><p><strong>答</strong>：虽然前面有提及，但仍需再重复一遍。以比特币为代表的加密货币的底层支撑技术被称为区块链技术，比特币是区块链的一个应用。</p></li><li><p><strong>问</strong>：为什么要设计工作量证明呢？</p></li><li><p><strong>答</strong>：这个问题从两个方面回答：</p><ul><li>为了控制比特币生成的速度。中本聪的设计是比特币最多被细分到小数点后8位，之后将再也无法被细分。且第一个区块会有50个比特币奖励，每过21万个区块，比特币的产量减半。中本聪通过调节工作量证明的难度，使每一个新区块生成大概需要10分钟。所以比特币每四年产出速度减半一次，直到2140年，每一个区块的比特币将不能再被细分，这时比特币就开采完毕了，等比数列求和可得总量约为2100万个。</li><li>如果不设计工作量证明，将无法抵御黑客的攻击。例如，你在饿了么上支付了18元你的外卖费用。你作为黑客，如果想要修改这一笔交易，就必须重新玩一次这个区块上的新的跳一跳到1000分，且这笔交易所在的区块，之后的所有区块，你都必须完成游戏并修改直到你的链子是全网络最长的一条时，你才修改成功了。当然，中本聪实际设计的“游戏”要比跳一跳难的多，他会消耗全网巨大的CPU算力，只要黑客手上的算力无法达到全网算力的51%,要改变任意一笔交易将会变得很难，且难度系数会随着时间成指数增长。</li></ul><hr></li></ul><h1 id="03-常见攻击"><a href="#03-常见攻击" class="headerlink" title="03 常见攻击"></a>03 常见攻击</h1><h2 id="0x01-doublespend"><a href="#0x01-doublespend" class="headerlink" title="0x01  doublespend"></a>0x01  doublespend</h2><p>　　翻译为双重支付，或直译为“双花”。所表达的意思也很简单，一笔数字资产既支付给了A，又支付给了B。结合<strong>51％的攻击力</strong>一起食用。</p><h2 id="0x02-Selfish-mining"><a href="#0x02-Selfish-mining" class="headerlink" title="0x02 Selfish mining"></a>0x02 Selfish mining</h2><p>​        目前还没有找到中文解释，先直译为“私自挖矿攻击”。正常挖矿过程中，矿工挖到矿了都会立刻广播结果，生怕别人跟我来抢这个区块。但是在Selfish mining中则不然。假设目前所有矿工都工作在区块0上。这时攻击者首先发信新的区块（区块1），他会保留刚挖到的区块，把该区块当做自己的私有链，在私有连上进行挖下一个区块。假如攻击者又挖到了第二个区块（区块2），而这时其他矿工挖到了新区块（区块1’，因为没有听到区块1，还工作在区块0上），攻击者会直接提交两个区块。因为这时候0-1-2这条链长于0-1’这条链，0-1-2会被选做主链。因此，攻击者能获得2个区块的奖励，而别人的算力浪费了，无法获得奖励。[3]</p><h2 id="0x03-DoS-amp-DDoS"><a href="#0x03-DoS-amp-DDoS" class="headerlink" title="0x03 DoS &amp; DDoS"></a>0x03 DoS &amp; DDoS</h2><p>　　计算中的分布式拒绝服务（DDOS）攻击是一种攻击，其中犯罪者试图通过向网络充斥大量多余请求以试图使系统过载，使其用户无法使用网络资源。这是一种攻击不仅是区块链，而且任何在线服务都会受到影响。 [5]</p><h2 id="0x04-Sybil-女巫攻击"><a href="#0x04-Sybil-女巫攻击" class="headerlink" title="0x04 Sybil 女巫攻击"></a>0x04 Sybil 女巫攻击</h2><p>　　Sybil 攻击是通过创建多个虚假身份来尝试操纵 P2P 网络。 对于观察者来说，这些不同的身份看起来像个人用户，但在幕后，单个实体一次控制所有这些假实体。特别是当您考虑在线投票时，这种类型的攻击非常重要。 我们看到 Sybil 攻击的另一个领域是社交网络，过多假账户可以引导公众的讨论。</p><p>　　Sybil 攻击的另一个可能用途是审查某些参与者。 许多 Sybil 节点可以围绕您的节点，并阻止它连接到网络上的其他诚实节点。这样可以防止您向网络发送或接收信息。</p><p>　　缓解 Sybil 攻击的一种方法是引入或提高创建身份的成本。这个成本必须仔细平衡。它必须足够低，以便不限制新参与者加入网络并创建合法身份。它同时也必须足够高，以至于在短时间内创建大量身份变得非常困难。在 PoW 区块链中，实际对交易打包的节点是挖矿节点。有一个现实世界的成本，即购买矿机的成本，与创建虚假的“采矿标识”相关联。另外，拥有大量挖掘节点仍然不足以对网络产生巨大影响。要产生大影响，你还需要大量的算力。换句话说，您需要大型计算机集群。相关的成本使 Sybil 难以对工作证明区块链发起攻击。[5]</p><h2 id="0x05-51％的攻击力"><a href="#0x05-51％的攻击力" class="headerlink" title="0x05 51％的攻击力"></a>0x05 51％的攻击力</h2><p>　　对公共 PoW 区块链的最著名的攻击类型是 51％的攻击。51％攻击的目标是执行双重花费，这意味着将硬币同时花出去两次。要对区块链网络执行 51％的攻击，您需要控制网络的大部分哈希率或计算能力，正如名字一样，需要控制 51% 的算力才能发起攻击。</p><p>　　想要执行双花攻击的恶意矿工，他首先创建一个常规交易，再将其硬币存到交易所，再换成好币或其它货币。这发生在下面的<strong>40</strong> 区块中。与此同时，他们将开始私下挖出一条私链。这意味着他们将遵循通常的挖掘协议，但有两个例外。</p><p><img alt data-src="https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/ggggg.jpg" class="lozad"></p><p>　　首先，他们不会将自己的交易打包在自己的私人开采的链中。其次，他们不会将他们找到的块广播到网络，因此我们将其称为私有链。</p><p>　　如果他们控制大部分算力，他们的链条平均出块速度将比诚实链条快。PoW 区块链中的最长链规则，也称为中本聪共识，用于在这种情况下发生的情况。具有更多区块的分支链，被认为是有效链。</p><p>　　一旦攻击者收到用他们的硬币购买的货币或其他货币，他们就会将私链广播到整个网络。所有诚实的矿工将放弃诚实的链条，并开始挖掘恶意链。攻击者的交易视为从未发生过，因为攻击者未将其包含在恶意链中。攻击者仍在控制他们的资金，现在可以再次使用它们。</p><hr><h1 id="04-名词解释"><a href="#04-名词解释" class="headerlink" title="04 名词解释"></a>04 名词解释</h1><h2 id="0x01-Inter-block-time"><a href="#0x01-Inter-block-time" class="headerlink" title="0x01 Inter-block time"></a>0x01 Inter-block time</h2><p>　　This is the time elapsed between the generation of each block. For bitcoin the blocks are generated every 10 minutes, for litecoin it’s 2.5 minutes. Any value can be used but an appropriate value is usually between a few minutes; if the generation time is too fast it might destabilize the blockchain, if it’s too slow it may not attract many users[4].</p><h2 id="0x02-proof-of-work-PoW"><a href="#0x02-proof-of-work-PoW" class="headerlink" title="0x02 proof of work(PoW)"></a>0x02 proof of work(PoW)</h2><p>　　工作证明（Proof Of Work，POW），也称为工作量的证明。这里的工作是指找到一个合理的区块哈希值，它需要不断地进行大量的计算，计算时间取决于当前目标的难度和机器的运算速度。当一个节点找到这个值之后，就说明该节点确实经过了大量的计算，这就是工作量证明。由于验证只需对结果值进行一次哈希运算，因此ＰＯＷ的验证效率很高。</p><h2 id="0x03-Hash"><a href="#0x03-Hash" class="headerlink" title="0x03 Hash"></a>0x03 Hash</h2><p>　　哈希（也称为散列）算法将任意长度的输入值映射为较短的固定长度的二进制值。例如，SHA256算法就是将任意长度的输入映射为长度为256位的固定长度输出，这个二进制值称为哈希值（也称为散列值）。数据的哈希值可以检验数据的完整性，一般用于快速查找和加密算法。哈希算法广泛应用于区块链中，区块链通常不保存原始数据，而是保存该数据的哈希值。</p><h2 id="0x04-Merkle-树"><a href="#0x04-Merkle-树" class="headerlink" title="0x04 Merkle 树"></a>0x04 Merkle 树</h2><p>　　Merkle树是由Ralph Merkle发明的一种基于数据哈希构建的树。区块链系统采用二叉树型的 Merkle树对该区块的所有交易进行归纳表示，同时生成该交易集合的数字签名。</p><h2 id="0x05-时间戳服务"><a href="#0x05-时间戳服务" class="headerlink" title="0x05 时间戳服务"></a>0x05 时间戳服务</h2><p>　　区块链系统通过给每一笔交易盖上正确的时间戳，以此证明在这个时刻这笔交易确实发生，交易中资金的所属权已经转移，之前资金所有者再次使用这笔资金时就会报错，从而解决重复支付问题。另外，每一个区块也会盖上正确的时间戳，从而形成一个按时间顺序发展的正确链表。</p><h2 id="0x06-拜占庭将军问题-Byzantine-failures"><a href="#0x06-拜占庭将军问题-Byzantine-failures" class="headerlink" title="0x06 拜占庭将军问题(Byzantine failures)"></a>0x06 拜占庭将军问题(Byzantine failures)</h2><p>　　拜占庭将军问题，是由莱斯利·兰伯特提出的点对点通信中的基本问题。含义是在存在消息丢失的不可靠信道上试图通过消息传递的方式达到一致性是不可能的。</p><p>　　拜占庭将军问题是一个协议问题，拜占庭帝国军队的将军们必须全体一致的决定是否攻击某一支敌军。问题是这些将军在地理上是分隔开来的，并且将军中存在叛徒。叛徒可以任意行动以达到以下目标：欺骗某些将军采取进攻行动；促成一个不是所有将军都同意的决定，如当将军们不希望进攻时促成进攻行动；或者迷惑某些将军，使他们无法做出决定。如果叛徒达到了这些目的之一，则任何攻击行动的结果都是注定要失败的，只有完全达成一致的努力才能获得胜利。[7]</p><hr><h1 id="05-发展现状"><a href="#05-发展现状" class="headerlink" title="05 发展现状"></a>05 发展现状</h1><h2 id="0x01-信息共享领域"><a href="#0x01-信息共享领域" class="headerlink" title="0x01 信息共享领域"></a>0x01 信息共享领域</h2><p>　　区块链与其他行业融合的应用，其中最直接的一个领域就是信息领域。首先，区块链本身就是需要保持各个节点的数据一致性的，可以说是自带信息共享功能；其次，实时的问题通过区块链的P2P技术可以实现；最后，利用区块链的不可篡改和共识机制，可构建其一条安全可靠的信息共享通道。[1]</p><h2 id="0x02-版权保护"><a href="#0x02-版权保护" class="headerlink" title="0x02 版权保护"></a>0x02 版权保护</h2><p><strong>区块链 + 鉴证证明</strong></p><p><strong>流程简化</strong>：区块链应用到鉴证证明后，无论是登记还是查询都非常方便，无需再奔走于各个部门之间。</p><p><strong>安全可靠</strong>：区块链的去中心化存储，<strong>保证没有一家机构可以任意篡改数据</strong>。</p><p><strong>应用案例</strong>：2017年12月,微众银行 仲裁委(广州仲裁委) 杭州亦笔科技有限公司共同推出的仲裁联盟链,用于司法场景下的存证;2018年3月,广州首个 仲裁链 判决书出炉。[1]</p><h2 id="0x03-物流链"><a href="#0x03-物流链" class="headerlink" title="0x03 物流链"></a>0x03 物流链</h2><p>　　区块链没有中心化节点，各节点是平等的，掌握单个节点无法实现修改数据；需要掌控足够多的节点，才可能伪造数据，大大提高伪造数据的成本。</p><p>　　区块链天生的开放、透明，使得任何人都可以公开查询，伪造数据被发现的概率大增。</p><p>　　区块链的数据不可篡改性，也保证了已销售出去的产品信息已永久记录，无法通过简单复制防伪信息蒙混过关，实现二次销售。 </p><p>　　物流链的所有节点接入区块链后，商品从生产商到消费者手里都有迹可循，形成完整链条；商品缺失的环节越多，将暴露出其是伪劣产品概率更大。</p><p>　　应用案例：目前,入局物流链的玩家较多,包括腾讯 阿里 京东 沃尔玛等。[1]</p><h1 id="06-参考"><a href="#06-参考" class="headerlink" title="06 参考"></a>06 参考</h1><p>[1] <a href="https://www.zhihu.com/question/55570521" target="_blank" rel="noopener">知乎：区块链怎么赚钱，有什么经济前景？</a></p><p>[2] <a href="https://finance.sina.com.cn/stock/usstock/c/2019-05-04/doc-ihvhiqax6629170.shtml" target="_blank" rel="noopener">巴菲特:比特币是一种“赌博” 很多欺诈行为与之有关</a></p><p>[3] <a href="http://www.vodvv.com/index.php/2020/06/25/9018/" target="_blank" rel="noopener">【区块链技术】区块链技术如何赋能智能制造？</a></p><p>[4] <a href="https://learning.oreilly.com/library/view/mastering-blockchain-/9781788839044/" target="_blank" rel="noopener">Mastering Blockchain - Second Edition by Imran Bashir</a></p><p>[5] <a href="chainnews.com/articles/114443917083.htm">科普：区块链里常见的攻击</a></p><p>[6] <a href="https://blog.csdn.net/qq_36764147/article/details/89766063?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=Deconstructing%20the%20Blockchain%20&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-89766063#1.%20%E6%AF%94%E7%89%B9%E5%B8%81%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B%5B4%5D" target="_blank" rel="noopener">区块链技术概述</a></p><p>[7] <a href="[https://baike.baidu.com/item/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98#4](https://baike.baidu.com/item/拜占庭将军问题#4">百度百科：拜占庭将军问题</a>)</p><hr><ul><li>回形针视频介绍：<a href="https://www.bilibili.com/video/BV1oJ411E7Lg?p=1&amp;share_medium=android&amp;share_plat=android&amp;share_source=COPY&amp;share_tag=s_i&amp;timestamp=1593348364&amp;unique_k=TEpPdG" target="_blank" rel="noopener">区块链到底是什么？</a></li><li><a href="https://www.youtube.com/watch?v=g_fSistU3MQ" target="_blank" rel="noopener">比特币和区块链啥原理？矿机挖矿咋回事？李永乐老师讲比特币(1)</a></li><li><a href="https://www.youtube.com/watch?v=pbAVauYsqP0" target="_blank" rel="noopener">比特币交易如何防伪？私钥公钥地址啥意思？李永乐老师讲比特币(2)</a></li><li><a href="https://www.youtube.com/watch?v=e9KVmyI1eCg" target="_blank" rel="noopener">拜占庭将军问题是什么？区块链如何解决防范恶意节点？</a></li><li><a href="https://www.bilibili.com/video/av12465079" target="_blank" rel="noopener">【官方双语】想知道比特币（和其他加密货币）的原理吗？</a></li><li><a href="https://www.ruanyifeng.com/blog/2017/12/blockchain-tutorial.html" target="_blank" rel="noopener">区块链入门教程</a></li><li><a href="https://zhuanlan.zhihu.com/p/79450808" target="_blank" rel="noopener">比特币挖矿攻击中的PAW和BSM</a></li><li><a href="https://zhuanlan.zhihu.com/p/52901666" target="_blank" rel="noopener">比特币中的挖矿攻击</a></li><li><a href="https://zhuanlan.zhihu.com/p/32585236" target="_blank" rel="noopener">区块链数字货币的9种共识机制比较</a></li><li><a href="https://zhuanlan.zhihu.com/p/102893427" target="_blank" rel="noopener">从POW到POS看区块链共识的发展</a></li></ul><h1 id="07-一些网站"><a href="#07-一些网站" class="headerlink" title="07 一些网站"></a>07 一些网站</h1><ul><li>寻找中本聪：<a href="https://nakamotoinstitute.org/" target="_blank" rel="noopener">Satoshi Nakamoto Institute</a></li><li><a href="https://www.blockchain.com/explorer?utm_campaign=expnav_explorer" target="_blank" rel="noopener">Blockchain</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 未定义 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/09/13/hello-world/"/>
      <url>/2019/09/13/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="install-Hexo"><a href="#install-Hexo" class="headerlink" title="install Hexo"></a>install Hexo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo -g</span><br></pre></td></tr></table></figure><h3 id="upgrade-Hexo"><a href="#upgrade-Hexo" class="headerlink" title="upgrade Hexo"></a>upgrade Hexo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm update hexo -g</span><br></pre></td></tr></table></figure><h3 id="init-Blog"><a href="#init-Blog" class="headerlink" title="init Blog"></a>init Blog</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">"My New Post"</span> </span><br><span class="line">hexo n <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><h3 id="Clear-cache"><a href="#Clear-cache" class="headerlink" title="Clear cache"></a>Clear cache</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure><h3 id="Local-Testing"><a href="#Local-Testing" class="headerlink" title="Local Testing"></a>Local Testing</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo server <span class="comment">#Hexo会监视文件变动并自动更新，无须重启服务器</span></span><br><span class="line">hexo server -s <span class="comment">#静态模式</span></span><br><span class="line">hexo server -p 5000 <span class="comment">#更改端口</span></span><br><span class="line">hexo server -i 192.168.1.1 <span class="comment">#自定义 IP</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 未定义 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
