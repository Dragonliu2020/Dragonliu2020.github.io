<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java中调用Python程序</title>
      <link href="/2022/05/29/Java%E4%B8%AD%E8%B0%83%E7%94%A8Python%E7%A8%8B%E5%BA%8F/"/>
      <url>/2022/05/29/Java%E4%B8%AD%E8%B0%83%E7%94%A8Python%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Python-列表-生成列表</title>
      <link href="/2022/05/12/Python-%E5%88%97%E8%A1%A8-%E7%94%9F%E6%88%90%E5%88%97%E8%A1%A8/"/>
      <url>/2022/05/12/Python-%E5%88%97%E8%A1%A8-%E7%94%9F%E6%88%90%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-问题"><a class="markdownIt-Anchor" href="#1-问题"></a> 1 问题</h1><p>需求：生成1-10的列表；生成10个0的列表</p><h1 id="2-解决"><a class="markdownIt-Anchor" href="#2-解决"></a> 2 解决</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># list方法</span></span><br><span class="line">init_list = list(range(<span class="number">1</span>, <span class="number">10</span>+<span class="number">1</span>))  <span class="comment"># [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># []方法</span></span><br><span class="line">init_list = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>+<span class="number">1</span>)]  <span class="comment"># [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环方法</span></span><br><span class="line">init_list = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>+<span class="number">1</span>):</span><br><span class="line">    init_list.append(i)</span><br><span class="line">print(init_list)  <span class="comment"># [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 乘法</span></span><br><span class="line">init_list = [<span class="number">0</span>] * <span class="number">10</span>  <span class="comment"># [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</span></span><br></pre></td></tr></table></figure><h1 id="x-参考"><a class="markdownIt-Anchor" href="#x-参考"></a> X 参考</h1><ul><li><a href="https://blog.csdn.net/QQ18180564/article/details/105839040" target="_blank" rel="noopener">python------用多种方法生成1到100的列表并打印</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>matplotlib画图出现中文乱码</title>
      <link href="/2022/05/12/matplotlib%E7%94%BB%E5%9B%BE%E5%87%BA%E7%8E%B0%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/"/>
      <url>/2022/05/12/matplotlib%E7%94%BB%E5%9B%BE%E5%87%BA%E7%8E%B0%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-问题描述"><a class="markdownIt-Anchor" href="#1-问题描述"></a> 1 问题描述</h1><p>使用matplotlib画图，其中x和y轴标题中出现中文乱码。</p><h1 id="2-解决"><a class="markdownIt-Anchor" href="#2-解决"></a> 2 解决</h1><p>在代码前面加入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pylab <span class="keyword">import</span> *</span><br><span class="line">mpl.rcParams[<span class="string">'font.sans-serif'</span>] = [<span class="string">'SimHei'</span>]</span><br><span class="line">mpl.rcParams[<span class="string">'axes.unicode_minus'</span>] = <span class="literal">False</span></span><br></pre></td></tr></table></figure><h1 id="3-参考"><a class="markdownIt-Anchor" href="#3-参考"></a> 3 参考</h1><ul><li><a href="https://blog.csdn.net/xjh163/article/details/101076551" target="_blank" rel="noopener">python中画图显示中文乱码</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 环境与工具 </category>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>git报错之error: object file .git/objects/31/65329bb680e30595f242b7c4d8406ca63eeab0 is empty</title>
      <link href="/2022/05/11/git%E6%8A%A5%E9%94%99%E4%B9%8Berror-object-file-git-objects-31-65329bb680e30595f242b7c4d8406ca63eeab0-is-empty/"/>
      <url>/2022/05/11/git%E6%8A%A5%E9%94%99%E4%B9%8Berror-object-file-git-objects-31-65329bb680e30595f242b7c4d8406ca63eeab0-is-empty/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-问题"><a class="markdownIt-Anchor" href="#1-问题"></a> 1 问题</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error: object file .git/objects/31/65329bb680e30595f242b7c4d8406ca63eeab0 is empty</span><br><span class="line">fatal: loose object 3165329bb680e30595f242b7c4d8406ca63eeab0 (stored <span class="keyword">in</span> .git/objects/31/65329bb680e30595f242b7c4d8406ca63eeab0) is corrupt</span><br></pre></td></tr></table></figure><h1 id="2-解决"><a class="markdownIt-Anchor" href="#2-解决"></a> 2 解决</h1><h1 id="3-参考"><a class="markdownIt-Anchor" href="#3-参考"></a> 3 参考</h1><ul><li><a href="https://segmentfault.com/a/1190000008734662" target="_blank" rel="noopener">git错误：对象文件为空（object-file-is-empty）解决方案</a></li><li><a href="https://stackoverflow.com/questions/11706215/how-can-i-fix-the-git-error-object-file-is-empty" target="_blank" rel="noopener">How can I fix the Git error “object file … is empty”?</a></li><li><a href="https://localcoder.org/git-status-shows-fatal-bad-object-head" target="_blank" rel="noopener">git status shows fatal: bad object HEAD</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 环境与工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git报错之error: refs/heads/pa2 does not point to a valid object</title>
      <link href="/2022/05/10/git%E6%8A%A5%E9%94%99%E4%B9%8Berror-refs-heads-pa2-does-not-point-to-a-valid-object/"/>
      <url>/2022/05/10/git%E6%8A%A5%E9%94%99%E4%B9%8Berror-refs-heads-pa2-does-not-point-to-a-valid-object/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-问题引入"><a class="markdownIt-Anchor" href="#1-问题引入"></a> 1 问题引入</h1><p>目前项目有两个分支：pa1和pa2。pa1分支没有更新到云端，需要更新；pa2分支出现问题。</p><p><strong>目标</strong>：删除pa2分支，将pa1 push到云端。</p><h1 id="2-解决"><a class="markdownIt-Anchor" href="#2-解决"></a> 2 解决</h1><ol><li><p>切换到pa1分支，<code>git checkout pa1</code></p><img src="https://s2.loli.net/2022/05/10/FZmLMNhPlxiUCd1.png" width="550" height="300" alt="图片名称" align="center" id="199"></li><li><p>提交本地pa2修改的代码，出现如下报错：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br><span class="line">$ git commit</span><br><span class="line">fatal: could not parse HEAD</span><br></pre></td></tr></table></figure></li><li><p>强制切换pa1分支：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -f pa1</span><br></pre></td></tr></table></figure></li><li><p>将pa1分支push到云端，出现报错：</p><img src="https://s2.loli.net/2022/05/10/iNlGDgz2kVKxjoW.png" width="650" height="100" alt="图片名称" align="center" id="200"></li><li><p>执行下面的操作再进行push操作，成功执行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm .git/refs/heads/pa2</span><br></pre></td></tr></table></figure></li></ol><h1 id="3-参考"><a class="markdownIt-Anchor" href="#3-参考"></a> 3 参考</h1><ul><li><a href="https://stackoverflow.com/questions/20694882/how-do-i-delete-a-local-git-branch-when-it-cant-look-up-commit-object-in-refs" target="_blank" rel="noopener">How do I delete a local git branch when it can’t look up commit object in ‘refs/heads’?</a></li><li><a href="https://zhuanlan.zhihu.com/p/426003354" target="_blank" rel="noopener">解决git报错fatal: could not parse HEAD</a></li><li><a href="https://blog.csdn.net/SMonkeyKing/article/details/89850416" target="_blank" rel="noopener">【git操作】强制切换到本地某个分支</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 环境与工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-os模块-文件(夹)操作</title>
      <link href="/2022/04/23/Python-os%E6%A8%A1%E5%9D%97-%E6%96%87%E4%BB%B6-%E5%A4%B9-%E6%93%8D%E4%BD%9C/"/>
      <url>/2022/04/23/Python-os%E6%A8%A1%E5%9D%97-%E6%96%87%E4%BB%B6-%E5%A4%B9-%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-判断文件夹是否存在"><a class="markdownIt-Anchor" href="#1-判断文件夹是否存在"></a> 1 判断文件(夹)是否存在</h1><p><strong>参考</strong>：<a href="https://www.cnblogs.com/jhao/p/7243043.html" target="_blank" rel="noopener">Python判断文件是否存在的三种方法</a></p><p><code>os</code>模块中的<code>os.path.exists()</code>方法用于检验文件是否存在。</p><p>判断文件(夹)是否存在：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.path.exists(path)</span><br><span class="line"><span class="comment">#True</span></span><br><span class="line"></span><br><span class="line">os.path.exists(path)</span><br><span class="line"><span class="comment">#False</span></span><br></pre></td></tr></table></figure><p><strong>问题</strong>：如果文件夹和文件同路径+同名会出现bug。</p><p>只检查文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.path.isfile(<span class="string">"test-data"</span>)</span><br></pre></td></tr></table></figure><h1 id="2-创建目录"><a class="markdownIt-Anchor" href="#2-创建目录"></a> 2 创建目录</h1><p><strong>参考</strong>：<a href="https://blog.csdn.net/MuWinter/article/details/77215768" target="_blank" rel="noopener">python创建目录（文件夹）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.path.exists(path) <span class="comment"># 判断一个目录是否存在</span></span><br><span class="line"></span><br><span class="line">os.makedirs(path) <span class="comment"># 创建多级目录</span></span><br><span class="line"></span><br><span class="line">os.mkdir(path) <span class="comment"># 创建单级目录</span></span><br></pre></td></tr></table></figure><h1 id="3-复制文件"><a class="markdownIt-Anchor" href="#3-复制文件"></a> 3 复制文件</h1><p><strong>参考</strong>：<a href="https://zhuanlan.zhihu.com/p/35725217" target="_blank" rel="noopener">用Python复制文件的9个方法</a></p><p>这是运行任何系统命令的最常用方式。使用 system() 方法，你可以调用 subshell 中的任何命令。在内部，该方法将调用 C 语言的标准库函数。该方法返回该命令的退出状态。</p><p>对于 Windows 系统：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.system(<span class="string">'copy 1.txt.py 2.txt.py'</span>)</span><br><span class="line">os.system(<span class="string">f'copy <span class="subst">&#123;source&#125;</span> <span class="subst">&#123;target&#125;</span>'</span>)</span><br></pre></td></tr></table></figure><p>对于 Liunx 系统：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.system(<span class="string">'cp 1.txt.py 2.txt.py'</span>)</span><br></pre></td></tr></table></figure><p>速度较慢，大量文件复制效果不佳。</p><h1 id="4-路径拼接"><a class="markdownIt-Anchor" href="#4-路径拼接"></a> 4 路径拼接</h1><p>os.path.join()函数用于路径拼接文件路径：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">dir = <span class="string">"xxx"</span></span><br><span class="line">file_name = <span class="string">"xxx"</span></span><br><span class="line"></span><br><span class="line">path = os.path.join(dir, file_name)</span><br></pre></td></tr></table></figure><h1 id="5-删除文件夹"><a class="markdownIt-Anchor" href="#5-删除文件夹"></a> 5 删除文件(夹)</h1><p><strong>参考</strong>：<a href="https://developer.51cto.com/article/648822.html" target="_blank" rel="noopener">Python中删除文件的几种方法</a></p><p><strong>删除文件</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.remove(path)</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：如果文件在之前被打开，会出现报错：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    os.remove(file_path)</span><br><span class="line">PermissionError: [WinError <span class="number">32</span>] 另一个程序正在使用此文件，进程无法访问。: <span class="string">'data3\\dataset\\test\\Benign\\4447.txt'</span></span><br></pre></td></tr></table></figure><p>所以删除前要关闭文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">file_path = os.path.join(type_dir, name)</span><br><span class="line">f = open(file_path, <span class="string">"r"</span>)</span><br><span class="line">f.close()</span><br><span class="line">os.remove(file_path)</span><br></pre></td></tr></table></figure><hr><p><strong>删除目录</strong>：Python中的<code>os.remove()</code>方法用于删除文件路径。此方法无法删除目录。如果指定的路径是目录，则该方法将引发OSError。可以使用下面代码删除目录：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.rmdir(dir_path)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>pylab.show()或plt.show()报错</title>
      <link href="/2022/04/22/pylab-show-%E6%88%96plt-show-%E6%8A%A5%E9%94%99/"/>
      <url>/2022/04/22/pylab-show-%E6%88%96plt-show-%E6%8A%A5%E9%94%99/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-pylabshow问题"><a class="markdownIt-Anchor" href="#1-pylabshow问题"></a> 1 pylab.show()问题</h1><p>最近使用实验室的机子进行模型训练，<strong>发生报错</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XIO:  fatal IO error 0 (Success) on X server <span class="string">"localhost:13.0"</span></span><br><span class="line">      after 355 requests (355 known processed) with 2 events remaining.</span><br></pre></td></tr></table></figure><p><strong>定位代码</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pylab.show()</span><br></pre></td></tr></table></figure><p><strong>原因</strong>：机子没有界面，导致显示失败。</p><p><strong>解决</strong>：只需将图片保存，而非显示。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pylab.show()</span></span><br><span class="line">pylab.savefig(<span class="string">'./data/net_pic/textcnn_100_0.001_300.jpg'</span>)</span><br></pre></td></tr></table></figure><h1 id="2-pltshow问题"><a class="markdownIt-Anchor" href="#2-pltshow问题"></a> 2 plt.show()问题</h1><p>之前一个同学也遇到了类似的报错：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UserWarning: Matplotlib is currently using agg, <span class="built_in">which</span> is a non GUI backend, so cannot show the figure.</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><strong>定位代码</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><strong>解决方法</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># plt.show()</span></span><br><span class="line">plt.savefig(<span class="string">'./data/net_pic/textcnn_100_0.001_300.jpg'</span>)</span><br></pre></td></tr></table></figure><h1 id="x-参考"><a class="markdownIt-Anchor" href="#x-参考"></a> X 参考</h1><ul><li><a href="https://blog.csdn.net/m0_37052320/article/details/79640467" target="_blank" rel="noopener">python matplotlib 画图保存图片简单例子</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 环境与工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Pycharm远程开发</title>
      <link href="/2022/04/21/PyCharm%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
      <url>/2022/04/21/PyCharm%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-引入"><a class="markdownIt-Anchor" href="#1-引入"></a> 1 引入</h1><p>最近跑深度学习模型，自己的笔记本吃不消了，于是打算使用实验室的机子。为了提高开发效率，使用PyCharm进行远程开发。</p><h1 id="2-查看远程环境"><a class="markdownIt-Anchor" href="#2-查看远程环境"></a> 2 查看远程环境</h1><ol><li><p>使用<code>MobaXterm</code>软件登陆实验室的机子，并将代码+数据集上传至指定位置；（其实这一步可以不做，在后面使用PyCharm进行同步）</p></li><li><p>查看机子的系统：Centos7</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/os-release</span><br><span class="line">NAME=<span class="string">"CentOS Linux"</span></span><br><span class="line">VERSION=<span class="string">"7 (Core)"</span></span><br><span class="line">ID=<span class="string">"centos"</span></span><br><span class="line">ID_LIKE=<span class="string">"rhel fedora"</span></span><br><span class="line">VERSION_ID=<span class="string">"7"</span></span><br><span class="line">PRETTY_NAME=<span class="string">"CentOS Linux 7 (Core)"</span></span><br><span class="line">ANSI_COLOR=<span class="string">"0;31"</span></span><br><span class="line">CPE_NAME=<span class="string">"cpe:/o:centos:centos:7"</span></span><br><span class="line">HOME_URL=<span class="string">"https://www.centos.org/"</span></span><br><span class="line">BUG_REPORT_URL=<span class="string">"https://bugs.centos.org/"</span></span><br><span class="line"></span><br><span class="line">CENTOS_MANTISBT_PROJECT=<span class="string">"CentOS-7"</span></span><br><span class="line">CENTOS_MANTISBT_PROJECT_VERSION=<span class="string">"7"</span></span><br><span class="line">REDHAT_SUPPORT_PRODUCT=<span class="string">"centos"</span></span><br><span class="line">REDHAT_SUPPORT_PRODUCT_VERSION=<span class="string">"7"</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="3-配置远程python环境"><a class="markdownIt-Anchor" href="#3-配置远程python环境"></a> 3 配置远程Python环境</h1><ol><li><p>发现机子是使用conda管理python的，查看系统中的所有环境：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(base) [ccyin@localhost Malware-Detection]$ conda info -e</span><br><span class="line"><span class="comment"># conda environments:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">base                  *  /home/ccyin/miniconda3</span><br><span class="line">junxuan                  /home/ccyin/miniconda3/envs/junxuan</span><br></pre></td></tr></table></figure></li><li><p>创建环境，名称为<code>malware</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda create --name malware python=3.9</span><br><span class="line"><span class="comment"># 指定Python版本是3.9（不用管是3.9.x，conda会为我们自动寻找3.9.x中的最新版本）</span></span><br></pre></td></tr></table></figure></li><li><p>激活环境：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(base) [ccyin@localhost Malware-Detection]$ <span class="built_in">source</span> activate malware</span><br><span class="line">(malware) [ccyin@localhost Malware-Detection]$</span><br></pre></td></tr></table></figure><p>命令行前出现<code>(malware)</code>证明成功激活<code>malware</code>环境</p></li><li><p>查看python版本：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(malware) [ccyin@localhost Malware-Detection]$ python --version</span><br><span class="line">Python 3.9.12</span><br></pre></td></tr></table></figure></li><li><p>安装一些库：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install torch</span><br><span class="line">pip install torchvision</span><br><span class="line">pip install d2l</span><br></pre></td></tr></table></figure></li><li><p>查看已经安装的库：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda list</span><br></pre></td></tr></table></figure></li></ol><h1 id="4-本地代码备份"><a class="markdownIt-Anchor" href="#4-本地代码备份"></a> 4 本地代码备份</h1><p>后期本地与服务器的代码同步，以防万一，把本地代码整到GitHub上。</p><ol><li><p>在项目主目录生成空版本库；</p></li><li><p>由于数据集占空间较大，不上传云端，所以新建<code>.gitignore</code>将一些文件夹进行忽略：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.idea</span><br><span class="line">__pycache__</span><br><span class="line">data</span><br><span class="line">model</span><br></pre></td></tr></table></figure></li><li><p>Github上新建仓库，然后将本地代码push上去。</p></li></ol><h1 id="5-配置pycharm"><a class="markdownIt-Anchor" href="#5-配置pycharm"></a> 5 配置PyCharm</h1><ol><li><p>将本地的<code>Python Interperter</code>更换为远端的，新建python解释器，选择<code>SSH Interpreter</code>，输入IP+用户名+密码：</p><img src="https://s2.loli.net/2022/04/21/mQNWwoLCqUBE3Zi.png" width="800" height="500" alt="图片名称" align="center" id="191"></li><li><p>查找conda虚拟环境<code>malware</code>中的解释器：（<code>3 配置远程Python环境</code>中已经创建好<code>malware</code>虚拟环境）</p><p>首先确定虚拟环境<code>malware</code>的目录：<code>/home/ccyin/miniconda3/envs/malware</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ conda info -e</span><br><span class="line"><span class="comment"># conda environments:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">base                     /home/ccyin/miniconda3</span><br><span class="line">malware               *  /home/ccyin/miniconda3/envs/malware</span><br></pre></td></tr></table></figure><p>然后点开<code>bin</code>，选择<code>python</code>（<strong>注意是<code>python</code>不是<code>python3</code></strong>）</p><img src="https://s2.loli.net/2022/04/21/6VolZ1XPqikx7rB.png" width="750" height="500" alt="图片名称" align="center" id="192"></li><li><p>选择好解释器之后，就要确定项目在服务器上的同步路径，默认是在<code>/tmp/</code>下的文件夹中，现在修改为之前上传的目录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(malware) [ccyin@localhost Malware-Detection]$ <span class="built_in">pwd</span></span><br><span class="line">/home/ccyin/zhenlong/Malware-Detection</span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2022/04/21/35wchZX61t7Jqnv.png" width="750" height="500" alt="图片名称" align="center" id="193"></li><li><p>点击确定后，然后在<code>Collectiong files...</code>和<code>Uploading xxx</code>，应该是更新远端文件，因为数据集中有许多文件，所以比较慢；（这样看来，之前上传代码+数据集显得多此一举🥦）</p></li><li><p>更新完毕后，可以<strong>从右边“remote host”中看到服务器上的文件</strong>，而且标绿了，表示其为我们对应的同步路径：</p><img src="https://s2.loli.net/2022/04/22/Mu5KH72ORaS6oQi.png" width="550" height="500" alt="图片名称" align="center" id="194"></li><li><p><strong>要对该文件进行修改时，注意一定要先Download下来</strong>，<strong>不可直接双击点开</strong>。Remote Host里的文件，当你执行非打开操作的时候，所指代的都是服务器上的文件，比如你可以从这里选择下载，进行比对操作等。但是当你从Remote Host双击打开文件时，这时打开的就不是服务器上的，而是一个镜像文件。所以如果直接修改从Remote Host双击打开的文件，修改是无效的。一定要先下载下来，进行修改，然后再上传过去。（<strong>第7步设置自动同步，这样本地的修改会自动上传至远端，但是在远端修改或添加删除文件，不会影响本地</strong>）</p><img src="https://s2.loli.net/2022/04/22/QaDvPkOryYlbmgx.png" width="450" height="250" alt="图片名称" align="center" id="195"></li><li><p>确保工具栏中的<code>Tools/Deployment/Automatic Upload</code>前面有对勾（默认有），这样以来，在本地的修改会自动同步到服务器上，我不需要手动进行上传。</p><img src="https://s2.loli.net/2022/04/22/lVEc6rSKUWR5LPi.png" width="450" height="300" alt="图片名称" align="center" id="196"></li><li><p>此外，如果运行python文件需要使用到命令行参数的时候，可以在<code>Configurations</code>中进行增加：</p><img src="https://s2.loli.net/2022/04/22/yYbOl6i5cxI2zXg.png" width="750" height="400" alt="图片名称" align="center" id="197"></li></ol><h1 id="6-后台运行py脚本"><a class="markdownIt-Anchor" href="#6-后台运行py脚本"></a> 6 后台运行py脚本</h1><p>训练脚本耗时长，使用pycharm直接运行脚本，可能会因为笔记本息屏、断网等因素而中断，所以考虑将脚本挂在后台运行。</p><ol><li><p>使用<code>MobaXterm</code>登陆远程主机；</p></li><li><p>切换到项目目录并激活虚拟机环境；</p></li><li><p>后台运行脚本：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(malware) [ccyin@localhost Malware-Detection]$ nohup python -u train_textcnn.py &gt; textcnn.log 2&gt;&amp;1 &amp;</span><br><span class="line">[1] 46583</span><br><span class="line">(malware) [ccyin@localhost Malware-Detection]$ nohup python -u train_rnn.py &gt; rnn.log 2&gt;&amp;1 &amp;</span><br><span class="line">[2] 46823</span><br></pre></td></tr></table></figure></li><li><p>检查下后台是否运行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(malware) [ccyin@localhost Malware-Detection]$ ps aux|grep python</span><br><span class="line">...</span><br><span class="line">ccyin     46583 70.4  4.3 67868816 11451892 pts/13 Rl 14:20   1:47 python -u train_textcnn.py</span><br><span class="line">ccyin     46823  129  0.8 41704128 2243816 pts/13 Rl 14:23   0:09 python -u train_rnn.py</span><br></pre></td></tr></table></figure></li><li><p>此时后台成功运行，笔记本断网、关机都不会影响脚本的运行。</p></li></ol><h1 id="7-取消后台运行"><a class="markdownIt-Anchor" href="#7-取消后台运行"></a> 7 取消后台运行</h1><ol><li><p>确定运行脚本的进程ID(<code>6.3</code>中已经给出ID)，也可以通过下面的命令获取：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(malware) [ccyin@localhost Malware-Detection]$ ps aux|grep python</span><br><span class="line">...</span><br><span class="line">ccyin     46583 70.4  4.3 67868816 11451892 pts/13 Rl 14:20   1:47 python -u train_textcnn.py</span><br><span class="line">ccyin     46823  129  0.8 41704128 2243816 pts/13 Rl 14:23   0:09 python -u train_rnn.py</span><br></pre></td></tr></table></figure></li><li><p>杀掉进程：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">kill</span> -9 46583</span><br><span class="line">$ <span class="built_in">kill</span> -9 46823</span><br></pre></td></tr></table></figure></li></ol><h1 id="x-参考"><a class="markdownIt-Anchor" href="#x-参考"></a> X 参考</h1><ul><li><a href="https://www.jianshu.com/p/a09a9b40ad20" target="_blank" rel="noopener">Git忽略文件.gitignore的使用</a></li><li><a href="https://zhuanlan.zhihu.com/p/44398592" target="_blank" rel="noopener">Conda使用指南</a></li><li><a href="https://zhuanlan.zhihu.com/p/93236936" target="_blank" rel="noopener">PyCharm远程开发的配置与流程</a></li><li><a href="https://www.jianshu.com/p/4041c4e6e1b0" target="_blank" rel="noopener">linux 下后台运行python脚本</a></li><li><a href="https://blog.csdn.net/lingyunxianhe/article/details/119328987" target="_blank" rel="noopener">nohup后台python3程序及关闭</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 环境与工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL-错误1153：max_allowed_packet</title>
      <link href="/2022/04/20/MySQL-%E9%94%99%E8%AF%AF1153%EF%BC%9Amax_allowed_packet/"/>
      <url>/2022/04/20/MySQL-%E9%94%99%E8%AF%AF1153%EF%BC%9Amax_allowed_packet/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-问题"><a class="markdownIt-Anchor" href="#1-问题"></a> 1 问题</h1><p>编码过程中，有个字段使用<code>TEXT</code>无法存储，改用<code>TEXT(65536)</code> 后成功存储，但是导入mysql时报错：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (1153, <span class="string">"Got a packet bigger than 'max_allowed_packet' bytes"</span>)</span><br></pre></td></tr></table></figure><p>原因：<code>TEXT(65536)</code>为16M，超过了上限<code>max_allowed_packet</code>。</p><h1 id="2-解决"><a class="markdownIt-Anchor" href="#2-解决"></a> 2 解决</h1><p>修改<code>max_allowed_packet</code>值即可，在Mysql命令行运行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="built_in">set</span> global net_buffer_length=1000000; </span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="built_in">set</span> global max_allowed_packet=1000000000;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><h1 id="3-参考"><a class="markdownIt-Anchor" href="#3-参考"></a> 3 参考</h1><ul><li><a href="https://stackoverflow.com/questions/93128/mysql-error-1153-got-a-packet-bigger-than-max-allowed-packet-bytes" target="_blank" rel="noopener">MySQL Error 1153 - Got a packet bigger than ‘max_allowed_packet’ bytes</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++新标准</title>
      <link href="/2022/04/19/C++%E6%96%B0%E6%A0%87%E5%87%86/"/>
      <url>/2022/04/19/C++%E6%96%B0%E6%A0%87%E5%87%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><ul><li>《面向对象C++程序设计》皮德常 编著 清华大学出版社 2017</li><li>《C++ Primer Plus (第6版)中文版》Stephen Prata 著 张海龙 袁国忠 译 人民邮电出版社 2012</li></ul></blockquote><h1 id="1-c11-的新特性"><a class="markdownIt-Anchor" href="#1-c11-的新特性"></a> 1 C++11 的新特性</h1><ol><li>核心特性：<strong>智能指针、右值引用、移动语义、完美转发、lambda 表达式</strong>（必答）</li><li>其它特性：auto、decltype、long long、函数返回类型自动推导、删除函数、列表初始化、nullptr、using 声明、限定作用域的枚举类型、const_iterator、override 声明、noexcept 声明、constexpr、范围 for 循环</li></ol><h1 id="2-智能指针"><a class="markdownIt-Anchor" href="#2-智能指针"></a> 2 智能指针</h1><p>C++11 中引入了智能指针的概念，<strong>方便管理堆内存</strong>。</p><ul><li>智能指针是利用了一种叫做 RAII（资源获取即初始化）的技术对普通的指针进行封装，这使得智能指针实质是一个对象，行为表现的却像一个指针。</li><li>智能指针的作用是防止忘记调用delete释放内存和程序异常的进入catch块忘记释放内存。另外指针的释放时机也是非常有考究的，多次释放同一个指针会造成程序崩溃，这些都可以通过智能指针来解决。</li><li>智能指针还有一个作用是把值语义转换成引用语义。</li></ul><ol><li><strong>unique_ptr</strong>：实现的是专属所有权的语义，它是智能指针的默认选项。unique_ptr 是个只移型别，不能复制或共享。unique_ptr 小巧高效，大小等同于一个指针且支持右值引用，从而可实现快速插入和对 STL 集合的检索。</li><li><strong>shared_ptr</strong>：采用引用计数的智能指针。如果你想要将一个裸指针分配给多个所有者，请使用该指针。直至所有 shared_ptr 所有者超出了范围或放弃所有权，才会删除裸指针。大小为两个裸指针：一个用于指向裸指针指向的对象，另一个用于指向包含引用计数的共享控制块。</li><li><strong>weak_ptr</strong> ：结合 shared_ptr 使用的特例智能指针。 weak_ptr 提供对一个或多个 shared_ptr 实例拥有的对象的访问，但不参与引用计数。如果你想要观察某个对象但不需要其保持活动状态，请使用该实例。在某些情况下，用于断开 shared_ptr 实例间的循环引用。</li></ol><p><a href="https://www.cnblogs.com/wxquare/p/4759020.html" target="_blank" rel="noopener">https://www.cnblogs.com/wxquare/p/4759020.html</a></p><h1 id="3-右值引用"><a class="markdownIt-Anchor" href="#3-右值引用"></a> 3 右值引用</h1><p>左值和右值的概念</p><p>值引用的目的是为了延长用来初始化对象的生命周期。</p><p><a href="https://zhuanlan.zhihu.com/p/54050093" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/54050093</a></p><h1 id="4-移动语义"><a class="markdownIt-Anchor" href="#4-移动语义"></a> 4 移动语义</h1><p>将内存的所有权从一个对象转移到另外一个对象，高效的移动用来替换效率低下的复制，对象的移动语义需要实现移动构造函数（move constructor）和移动赋值运算符（move assignment operator）。</p><h1 id="5-完美转发"><a class="markdownIt-Anchor" href="#5-完美转发"></a> 5 完美转发</h1><p>定义一个函数模板，该函数模板可以接收任意类型参数，然后将参数转发给其它目标函数，且保证目标函数接受的参数其类型与传递给模板函数的类型相同。</p><h1 id="6-lambda-表达式"><a class="markdownIt-Anchor" href="#6-lambda-表达式"></a> 6 lambda 表达式</h1><p>利用Lambda表达式，可以方便的定义和创建匿名函数。</p><p><a href="https://www.cnblogs.com/DswCnblog/p/5629165.html" target="_blank" rel="noopener">https://www.cnblogs.com/DswCnblog/p/5629165.html</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++编译与底层</title>
      <link href="/2022/04/19/C++%E7%BC%96%E8%AF%91%E4%B8%8E%E5%BA%95%E5%B1%82/"/>
      <url>/2022/04/19/C++%E7%BC%96%E8%AF%91%E4%B8%8E%E5%BA%95%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><ul><li>《面向对象C++程序设计》皮德常 编著 清华大学出版社 2017</li><li>《C++ Primer Plus (第6版)中文版》Stephen Prata 著 张海龙 袁国忠 译 人民邮电出版社 2012</li></ul></blockquote><h1 id="1-栈区和堆区的区别"><a class="markdownIt-Anchor" href="#1-栈区和堆区的区别"></a> 1 栈区和堆区的区别</h1><ol><li><p><strong>申请方式</strong></p><ul><li>栈区：由编译器自动分配释放，存放函数的参数值，局部变量值等；</li><li>堆区：一般由程序员分配释放（使用new/delete或malloc/free），若程序员不释放，程序结束时可能由OS回收。</li></ul></li><li><p><strong>操作方式</strong></p><ul><li>栈区：操作方式类似于数据结构中的栈；</li><li>堆区：不同于数据结构中的堆，分配方式类似于链表。</li></ul></li><li><p><strong>申请后系统的响应</strong></p><ul><li>栈区：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出；</li><li>堆区：操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。</li></ul></li><li><p><strong>申请大小的限制</strong></p><ul><li>栈区：在Windows下，栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。</li><li>堆区：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</li></ul></li><li><p><strong>申请效率的比较</strong></p><ul><li><p>栈区：系统自动分配，速度较快。但程序员是无法控制的。</p></li><li><p>堆区：由new分配的内存，一般速度比较慢，而且容易产生内存碎片，不过用起来最方便.</p></li></ul></li><li><p><strong>堆和栈中的存储内容</strong></p><ul><li>栈区：在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。</li></ul></li></ol><ul><li>堆区：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。</li></ul><h1 id="2-c语言程序从源代码到二进制行程序都经历了那些过程"><a class="markdownIt-Anchor" href="#2-c语言程序从源代码到二进制行程序都经历了那些过程"></a> 2 C语言程序从源代码到二进制行程序都经历了那些过程？</h1><p><a href="https://www.cnblogs.com/CarpenterLee/p/5994681.html" target="_blank" rel="noopener">https://www.cnblogs.com/CarpenterLee/p/5994681.html</a></p><ol><li>预处理(Preprocessing)：预处理用于将所有的#include头文件以及宏定义替换成其真正的内容，预处理之后得到的仍然是文本文件，但文件体积会大很多。gcc的预处理是预处理器cpp来完成的；</li><li>编译(Compilation)：将经过预处理之后的程序转换成特定汇编代码(assembly code)的过程；命令中<code>-S</code>让编译器在编译之后停止，不进行后续过程。</li><li>汇编(Assemble)：将上一步的汇编代码转换成机器码(machine code)，这一步产生的文件叫做目标文件，是二进制格式。gcc汇编过程通过as命令完成。</li><li>链接(Linking)：链接过程将多个目标文以及所需的库文件(.so等)链接成最终的可执行文件(executable file)。</li></ol><h1 id="3-cc的内存分配方式"><a class="markdownIt-Anchor" href="#3-cc的内存分配方式"></a> 3 <strong>C/C++的内存分配方式</strong></h1><h2 id="31-c"><a class="markdownIt-Anchor" href="#31-c"></a> 3.1 C</h2><img src="https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/24708340_1325647816h2y2.jpg" width="400" height="400" alt="图片名称" align="center" id="190"><table><thead><tr><th style="text-align:center">栈(stack)</th><th style="text-align:left">由编译器自动分配、翻译。存放函数的参数值和局部变量值。操作方式类似数据结构中的栈</th></tr></thead><tbody><tr><td style="text-align:center">堆(heap)</td><td style="text-align:left">由程序员分配释放。程序员不释放，程序结束时有可能由OS释放。与数据结构中的堆不同，操作方式类似于链表</td></tr><tr><td style="text-align:center">bss</td><td style="text-align:left">存放未初始化的全局变量和静态变量</td></tr><tr><td style="text-align:center">数据段data</td><td style="text-align:left">存放初始化之后的全局变量、静态变量和常量</td></tr><tr><td style="text-align:center">代码段text</td><td style="text-align:left">程序代码主体，函数主体等。注意为二进制格式</td></tr></tbody></table><h2 id="32-c"><a class="markdownIt-Anchor" href="#32-c"></a> 3.2 C++</h2><ol><li>栈</li><li>堆</li><li>全局/静态存储区</li><li>常量存储区</li><li>程序代码区</li></ol><h1 id="4-int-有几个字节"><a class="markdownIt-Anchor" href="#4-int-有几个字节"></a> 4 <strong>int 有几个字节？</strong></h1><p>C语言标准规定了每种数据类型的最小取值范围，例如int类型至少应为16位(2字节)，int类型数据具体的取值范围则由ABI规范规定。通常，int型在16位机器中为16位，在32位和64位机器中都为32位。(计组课本P42)</p><p>ABI指应用二进制接口，规定了二进制程序两个模块之间或者二进制程序与操作系统之间的接口。</p><p>2 或 4 个字节，具体取决于编译器。<strong>千万不要直接答4个字节</strong></p><h1 id="5-内存对齐的原则"><a class="markdownIt-Anchor" href="#5-内存对齐的原则"></a> 5 内存对齐的原则</h1><p>从0位置开始存储；变量存储的起始位置是该变量大小的整数倍；结构体总的大小是其最大元素的整数倍，不足的后面要补齐。</p><ol><li>数据成员对齐规则：结构体的数据成员，第一个数据成员放在offset为0的地方，之后的每个数据成员存储的起始位置要从该成员大小的整数倍开始（比如int在32位机子上为4字节，所以要从4的整数倍地址开始存储）。</li><li>结构体作为成员：如果一个结构体里同时包含结构体成员，则结构体成员要从其内部最大元素大小的整数倍地址开始存储（如struct a里有struct b，b里有char,int,double等元素，那么b应该从8(即double类型的大小)的整数倍开始存储）。</li><li>结构体的总大小：即sizeof的结果。在按之前的对齐原则计算出来的大小的基础上，必须还得是其内部最大成员的整数倍，不足的要补齐（如struct里最大为double，现在计算得到的已经是11，则总大小为16）。</li></ol><h1 id="6-main-函数执行以前还会执行什么代码"><a class="markdownIt-Anchor" href="#6-main-函数执行以前还会执行什么代码"></a> 6 <strong>main 函数执行以前，还会执行什么代码？</strong></h1><p>全局对象的构造函数会在 main 函数之前执行。</p><h1 id="7-空类编译器会自动生成哪些函数"><a class="markdownIt-Anchor" href="#7-空类编译器会自动生成哪些函数"></a> 7 <strong>空类编译器会自动生成哪些函数</strong></h1><p>默认构造函数、析构函数、拷贝构造函数、赋值函数。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++STL</title>
      <link href="/2022/04/19/C++STL/"/>
      <url>/2022/04/19/C++STL/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><ul><li>《面向对象C++程序设计》皮德常 编著 清华大学出版社 2017</li><li>《C++ Primer Plus (第6版)中文版》Stephen Prata 著 张海龙 袁国忠 译 人民邮电出版社 2012</li></ul></blockquote><h1 id="1-c容器类的底层实现"><a class="markdownIt-Anchor" href="#1-c容器类的底层实现"></a> 1 C++容器类的底层实现</h1><p><strong>以下分别用<code>K</code>、<code>T</code>指代泛型参数</strong>。</p><table><thead><tr><th>C++</th><th>特点</th><th>底层数据结构</th></tr></thead><tbody><tr><td><code>T 变量名[数值]</code>、<code>array&lt;T,数值&gt;</code></td><td>固定大小数组。支持快速随机访问，不能添加和删除元素</td><td>普通数组</td></tr><tr><td><code>vector&lt;T&gt;</code></td><td>可变大小数组。支持快速随机访问，在尾部之外的位置插入或删除元素可能很慢</td><td>数组</td></tr><tr><td><code>list&lt;T&gt;</code></td><td>双向循环链表。只支持双向顺序访问，在任何位置进行插入删除操作都很快</td><td>链表</td></tr><tr><td><code>forward_list&lt;T&gt;</code></td><td>单向链表。只支持单向顺序访问，在任何位置进行插入删除操作都很快</td><td>链表</td></tr><tr><td><code>stack&lt;T&gt;</code></td><td>栈。后进先出容器</td><td>数组或链表</td></tr><tr><td><code>queue&lt;T&gt;</code></td><td>队列。先进先出容器</td><td>数组或链表</td></tr><tr><td><code>deque&lt;T&gt;</code></td><td>双端队列。支持首尾快速增删，也支持随机访问</td><td>底层数据结构为一个中央控制器和多个缓冲区</td></tr><tr><td><code>priority_queue&lt;T&gt;</code></td><td>优先级队列。队列中的元素具有优先级，优先级最高的元素位于队首，队首元素可以弹出队列</td><td>二叉大根堆</td></tr><tr><td><code>unordered_set&lt;T&gt;</code></td><td>集合。关键字无序且不可重复出现</td><td>哈希表</td></tr><tr><td><code>set&lt;T&gt;</code></td><td>集合。关键字有序且不可重复出现</td><td>红黑树</td></tr><tr><td><code>unordered_map&lt;K,T&gt;</code></td><td>关联数组。保存键值对，键值对无序且键不可重复出现</td><td>哈希表</td></tr><tr><td><code>map&lt;K,T&gt;</code></td><td>关联数组。保存键值对，键值对有序且键不可重复出现</td><td>红黑树</td></tr></tbody></table><p>注意 stack、queue、priority_queue 均为容器适配器。stack 和 queue 底层一般用 list 或 deque 实现，不用 vector 的原因应该是容量大小有限制，扩容耗时。priority_queue 一般用 vector 作底层容器。</p><h1 id="2-unordered_map-和-map-区别"><a class="markdownIt-Anchor" href="#2-unordered_map-和-map-区别"></a> 2 unordered_map 和 map 区别</h1><ol><li>map 内部实现了一个红黑树（红黑树是非严格平衡二叉搜索树，而 AVL 是严格平衡二叉搜索树），因此 map 内部的所有元素都是有序的，存取一个元素时间复杂度是 O(logn)</li><li>unordered_map 内部实现了一个哈希表，其元素的排列顺序是无序的，取一个元素时间复杂度是 O(1)</li></ol><h1 id="3-红黑树"><a class="markdownIt-Anchor" href="#3-红黑树"></a> 3 红黑树</h1><p>红黑树是一颗满足如下性质的二叉查找树：</p><ol><li>每个结点或者为黑色或者为红色；</li><li>根结点为黑色；</li><li>每个叶节点为黑色；</li><li>如果一个结点为红色，那么他的两个子结点为黑色；</li><li>对于每个结点，从该节点到其所有子孙叶结点的路径中，所包含的黑色结点数量必须相同。</li></ol><p>红黑树的每个结点的属性除了有一个key、3个指针(parent、lchild、rchild)以外，还有个color属性。</p><p>通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，<strong>红黑树确保没有一条路径会比其它路径长出两倍</strong>。</p><h1 id="4-vector-和-list-区别"><a class="markdownIt-Anchor" href="#4-vector-和-list-区别"></a> 4 vector 和 list 区别</h1><h1 id="5-vector-扩容原理"><a class="markdownIt-Anchor" href="#5-vector-扩容原理"></a> 5 vector 扩容原理</h1><h1 id="6-迭代器失效问题"><a class="markdownIt-Anchor" href="#6-迭代器失效问题"></a> 6 迭代器失效问题</h1><h1 id="7-使用-map-的使用不是基础数据类型需要重载什么运算符"><a class="markdownIt-Anchor" href="#7-使用-map-的使用不是基础数据类型需要重载什么运算符"></a> 7 使用 map 的使用不是基础数据类型需要重载什么运算符</h1><h1 id="8-list-和-map-的区别"><a class="markdownIt-Anchor" href="#8-list-和-map-的区别"></a> 8 list 和 map 的区别</h1><h1 id="9-二叉搜索树-平衡二叉树和红黑树的区别"><a class="markdownIt-Anchor" href="#9-二叉搜索树-平衡二叉树和红黑树的区别"></a> 9 二叉搜索树、平衡二叉树和红黑树的区别</h1><p><a href="https://zhuanlan.zhihu.com/p/258078863" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/258078863</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++模板</title>
      <link href="/2022/04/19/C++%E6%A8%A1%E6%9D%BF/"/>
      <url>/2022/04/19/C++%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><ul><li>《面向对象C++程序设计》皮德常 编著 清华大学出版社 2017</li><li>《C++ Primer Plus (第6版)中文版》Stephen Prata 著 张海龙 袁国忠 译 人民邮电出版社 2012</li></ul></blockquote><h1 id="1-模版特化"><a class="markdownIt-Anchor" href="#1-模版特化"></a> 1 模版特化</h1><p>模板特化分为全特化和偏特化，模板特化的目的就是对于某一种变量类型具有不同的实现，因此需要特化版本。</p><p>模板偏特化（Template Partitial Specialization）是模板特化的一种特殊情况，指显示指定部分模板参数而非全部模板参数，或者指定模板参数的部分特性而非全部特性，也称为模板部分特化。与模板偏特化相对的是模板全特化，指对所有的模板参数进行特化。模板全特化与模板偏特化共同组成模板特化。</p><p>模板偏特化主要分为两种，一种是指对部分模板参数进行全特化，另一种是对模板参数特性进行特化，包括将模板参数特化为指针、引用或是另外一个模板类。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++类</title>
      <link href="/2022/04/19/C++%E7%B1%BB/"/>
      <url>/2022/04/19/C++%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><ul><li>《面向对象C++程序设计》皮德常 编著 清华大学出版社 2017</li><li>《C++ Primer Plus (第6版)中文版》Stephen Prata 著 张海龙 袁国忠 译 人民邮电出版社 2012</li></ul></blockquote><h1 id="1-构造函数与析构函数"><a class="markdownIt-Anchor" href="#1-构造函数与析构函数"></a> 1 构造函数与析构函数</h1><h2 id="11-构造函数定义或作用"><a class="markdownIt-Anchor" href="#11-构造函数定义或作用"></a> 1.1 构造函数定义或作用</h2><p><strong>初始化类对象的数据成员。</strong></p><p>即类的对象被创建的时候，编译系统对该对象分配内存空间，并自动调用构造函数，完成类成员的初始化。</p><p><strong>构造函数的特点：以类名作为函数名，无返回类型。</strong></p><p>常见的构造函数有三种写法：</p><ul><li><p>无参构造函数</p><ul><li><p>如果创建一个类，没有写任何构造函数，则系统会自动生成默认的无参构造函数，且此函数为空。</p><blockquote><p>默认构造函数（default constructor）就是在没有显式提供初始化式时调用的构造函数。如果定义某个类的变量时没有提供初始化时就会使用默认构造函数。</p></blockquote></li></ul></li><li><p>一般构造函数</p></li><li><p>复制构造函数</p><ul><li><p>复制构造函数，也称为拷贝构造函数。复制构造函数参数为类对象本身的引用，根据一个已存在的对象复制出一个新的对象，一般在函数中会将已存在对象的数据成员的值复制一份到新创建的对象中。</p></li><li><p>注意：若没有显示定义复制构造函数，则系统会默认创建一个复制构造函数，当类中有指针成员时，由系统默认创建的复制构造函数会存在“浅拷贝”的风险，因此必须显示定义复制构造函数。</p><blockquote><ul><li>浅拷贝指的是在对对象复制时，只对对象中的数据成员进行简单的赋值，若存在动态成员，就是增加一个指针，指向原来已经存在的内存。这样就造成两个指针指向了堆里的同一个空间。当这两个对象生命周期结束时，析构函数会被调用两次，同一个空间被两次free，造成野指针。</li><li>深拷贝就是对于对象中的动态成员，不是简单的赋值，而是重新分配空间。</li></ul></blockquote></li></ul></li></ul><p>C++的构造函数可以有多个，创建对象时编译器会根据传入的参数不同调用不同的构造函数。</p><h2 id="12-析构函数定义或作用"><a class="markdownIt-Anchor" href="#12-析构函数定义或作用"></a> 1.2 析构函数定义或作用</h2><p><strong>C++析构函数概述</strong></p><p>C++析构函数是一个特殊的成员函数，它的名字是类名的前面加一个～符号，作用与构造函数相反，当对象的生命期结束时，会自动执行析构函数。</p><p><strong>C++执行析构函数的情况</strong></p><p>如果在一个函数中定义了一个对象，当这个函数被调用结束时，对象应该释放，在对象释放前自动执行析构函数。</p><p>static局部对象在函数调用结束时对象并不释放，因此也不调用析构函数，只在main函数结束调用exit函数结束程序时，才调用static局部对象的析构函数。</p><p>如果定义了一个全局对象，则在程序的流程离开其作用域时，调用该全局对象的析构函数。</p><p>如果用new运算符动态地建立了一个对象，当用delete运算符释放该对象时，先调用该对象的析构函数。</p><p><strong>C++析构函数详解</strong></p><p>析构函数的作用并不是删除对象，而是在撤销对象占用的内存之前完成一些清理工作，使这部分内存可以被程序分配给新对象使用。</p><p>析构函数不返回任何值，没有函数类型，也没有函数参数，因此不能重载，一个类可以有多个构造函数，但只能有一个析构函数。</p><p>析构函数的作用并不仅限于释放资源方面，它还可以被用来执行程序员希望在最后一次使用对象之后所执行的任何操作。</p><p>如果没有定义析构函数，C++编译系统会自动生成一个析构函数，但它只是徒有析构函数的名称和形式，实际上什么都不执行，要想让析构函数执行，必须在定义的析构函数中指定。</p><h2 id="13-c类内静态成员的内存释放问题"><a class="markdownIt-Anchor" href="#13-c类内静态成员的内存释放问题"></a> 1.3 C++类内静态成员的内存释放问题</h2><p>C/C++中静态成员变量存放在全局内存的静态区域，因此，我们虽然delete掉了这个类，但是并不代表我们真的释放掉了类内静态成员的内存，这些静态成员的内存会在整个进程退出的时候由系统回收。</p><h2 id="14-构造析构顺序"><a class="markdownIt-Anchor" href="#14-构造析构顺序"></a> 1.4 构造析构顺序</h2><ol><li>存在继承关系时，先执行父类的构造函数，再执行子类的构造函数；析构的时候恰好相反：先调用派生类的析构函数、然后调用基类的析构函数。</li><li>当一个类中含有对象成员时，在启动本类的构造函数之前，先分配对象空间，按对象成员的声明顺序执行他们各自的构造函数，再执行本类的构造函数。</li><li>对于非静态的局部对象，他们的析构函数的执行顺序与构造函数相反。</li><li>构造：父类-&gt;对象成员&gt;子类</li></ol><h2 id="15-析构函数能抛出异常吗"><a class="markdownIt-Anchor" href="#15-析构函数能抛出异常吗"></a> 1.5 析构函数能抛出异常吗?</h2><p>C++标准指明析构函数不能、也不应该抛出异常。</p><ol><li>如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题。</li><li>通常异常发生时，c++的机制会调用已经构造对象的析构函数来释放资源，此时若析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃的问题。</li></ol><h2 id="16-调用拷贝构造函数的情况"><a class="markdownIt-Anchor" href="#16-调用拷贝构造函数的情况"></a> 1.6 调用拷贝构造函数的情况</h2><ul><li>用对象初始化同类的另一个对象</li><li>函数形参是对象，当进行参数传递时将调用copyconstruct</li><li>函数返回值是对象，函数执行结束时，将调用拷贝构造函数对无名临时对象初始化</li></ul><h1 id="2-多态与虚函数"><a class="markdownIt-Anchor" href="#2-多态与虚函数"></a> 2 多态与虚函数</h1><h2 id="21-多态性"><a class="markdownIt-Anchor" href="#21-多态性"></a> 2.1 多态性</h2><p>多态性指&quot;一个接口，多种方法&quot;。C++支持两种多态性：编译时多态性，运行时多态性。</p><ol><li><strong>编译时多态性(静态多态)</strong>：通过重载函数和泛型编程实现</li><li><strong>运行时多态性(动态多态)</strong>：通过虚函数实现</li></ol><blockquote><p>静态与动态的实质区别就是函数地址是早绑定还是晚绑定。</p><p>如果函数的调用，在编译器编译期间就可以确定函数的调用地址，并生产代码，是静态的，就是说地址是早绑定的。</p><p>而如果函数调用的地址不能在编译器期间确定，需要在运行时才确定，这就属于晚绑定。</p></blockquote><h2 id="22-动态绑定的概念"><a class="markdownIt-Anchor" href="#22-动态绑定的概念"></a> 2.2 动态绑定的概念</h2><p>动态绑定是指在运行时（非编译期）将过程调用与相应代码链接起来的过程称为动态绑定。</p><p>C<ins>中，通过基类的引用或指针调用虚函数时，发生动态绑定。C</ins>中动态绑定是通过虚函数实现的，而虚函数是通过一张虚函数表实现的。这个表中记录了虚函数的地址，保证动态绑定时能够根据对象的实际类型调用正确的函数。编译器必须保证虚函数表的指针存在于对象实例中最前面的位置（这是为了保证正确取到虚函数的偏移量）。这意味着我们通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。</p><h2 id="23-虚函数和纯虚函数"><a class="markdownIt-Anchor" href="#23-虚函数和纯虚函数"></a> 2.3 虚函数和纯虚函数</h2><p>用 virtual 关键字修饰的成员函数就是虚函数，虚函数的作用就是实现多态性。纯虚函数是一种特殊的虚函数，在基类中不能对虚函数给出有意义的实现，而把它的实现留给派生类去做。只含有虚函数的类可以被实例化，含有纯虚函数的类不能被实例化。</p><p><strong>注意</strong>：</p><ol><li>只有类的成员函数才能声明为虚函数，虚函数仅适用于有继承关系的类对象。普通函数不能声明为虚函数。</li><li>静态成员函数不能是虚函数，因为静态成员函数不受限于某个对象。</li><li>内联函数（inline）不能是虚函数，因为内联函数不能在运行中动态确定位置。</li><li>构造函数不能是虚函数。</li><li>析构函数可以是虚函数，而且建议声明为虚函数。</li></ol><h2 id="24-c类中定义虚函数和不定义在初始化的时候大小是不是一样"><a class="markdownIt-Anchor" href="#24-c类中定义虚函数和不定义在初始化的时候大小是不是一样"></a> 2.4 C++类中定义虚函数和不定义在初始化的时候大小是不是一样？</h2><p>定义了虚函数的类要大一些，因为要建立虚函数表</p><h2 id="25-构造函数能不能声明成虚函数"><a class="markdownIt-Anchor" href="#25-构造函数能不能声明成虚函数"></a> 2.5 构造函数能不能声明成虚函数？</h2><p>不能。</p><ol><li>当创建一个派生类对象时，会先调用基类的构造函数，但是派生类已经覆盖了基类的构造函数，所以也就无法进一步执行，导致程序出错。</li><li>在创建对象时，首先要调用构造函数，然后构造函数是虚函数，就需要用虚函数指针去调用，但是，对象都还没构造，也就没有虚函数指针，造成了一个循环调用的问题。</li></ol><h2 id="26-基类的析构函数不是虚函数会带来什么问题"><a class="markdownIt-Anchor" href="#26-基类的析构函数不是虚函数会带来什么问题"></a> 2.6 基类的析构函数不是虚函数，会带来什么问题？</h2><p>delete 指向派生类对象的基类指针时，只有基类的内存被释放，派生类的没有。这样就内存泄漏了。</p><h2 id="27-构造函数和析构函数中调用虚函数吗"><a class="markdownIt-Anchor" href="#27-构造函数和析构函数中调用虚函数吗"></a> 2.7 构造函数和析构函数中调用虚函数吗？</h2><p>从语法上讲，调用完全没有问题。但是从效果上看，往往不能达到多态的效果。<br>Effective C<ins>的解释是：派生类对象的基类成分会在派生类自身成分被构造之前先构造妥当，派生类对象构造期间会首先进入基类的构造函数，在基类构造函数执行时继承类的成员变量尚未初始化，对象类型是基类类型，而不是派生类类型，虚函数会被编译器解析为基类，若使用运行时类型信息，也会把对象视为基类类型，构造期间调用虚函数，会调用自己的虚函数，此时虚函数和普通函数没有区别了，达不到多态的效果。<br>同样，进入基类析构函数时，对象也是基类类型。C</ins>中派生类在构造时会先调用基类的构造函数再调用派生类的构造函数，析构时则相反，先调用派生类的析构函数再调用基类的析构函数。一旦派生类析构函数运行，这个对象的派生类数据成员就被视为未定义的值，所以 C++ 就将它们视为不再存在。假设一个派生类的对象进行析构，首先调用了派生类的析构，然后再调用基类的析构时，遇到了一个虚函数，这个时候有两种选择：</p><ol><li>编译器调用这个虚函数的基类版本，那么虚函数则失去了运行时调用正确版本的意义；</li><li>编译器调用这个虚函数的派生类版本，但是此时对象的派生类部分已经完成析构，“数据成员就被视为未定义的值”，这个函数调用会导致未知行为。</li></ol><h2 id="28-重载overload和重写overried有的书也叫做覆盖的区别"><a class="markdownIt-Anchor" href="#28-重载overload和重写overried有的书也叫做覆盖的区别"></a> 2.8 重载(overload)和重写(overried，有的书也叫做“覆盖”)的区别？</h2><ul><li><strong>重载</strong>：是指允许存在多个同名函数，而这些函数的参数列表不同</li><li><strong>重写</strong>：是指派生类重新定义基类虚函数的方法。</li></ul><h2 id="29-虚函数表存放的内容以及在内存中的位置"><a class="markdownIt-Anchor" href="#29-虚函数表存放的内容以及在内存中的位置"></a> 2.9 虚函数表存放的内容以及在内存中的位置</h2><ul><li>每个对象里有虚(函数表)指针，指向虚函数表，虚函数表里存放了虚函数的地址。虚函数表是顺序存放虚函数地址的，不需要用到链表。</li><li>还有类的类型信息，在《深度探索C++对象模型》中有提到</li><li>C<ins>中**虚函数表位于只读数据段（.rodata），也就是C</ins>内存模型中的常量区；而虚函数则位于代码段（.text），也就是C++内存模型中的代码区。**</li></ul><h2 id="210-如果虚函数非常有效我们是否可以把每个函数都声明为虚函数"><a class="markdownIt-Anchor" href="#210-如果虚函数非常有效我们是否可以把每个函数都声明为虚函数"></a> 2.10 如果虚函数非常有效，我们是否可以把每个函数都声明为虚函数？</h2><p>不行，这是因为虚函数是有代价的：</p><ul><li>由于每个虚函数的对象都必须维护一个虚函数表，因此在使用虚函数的时候会产生一个系统开销。如果仅是一个很小的类，且不想派生其他类，那么根本没必要使用虚函数。</li><li><strong>虚函数效率低</strong>。因为虚函数需要一次间接的寻址，而一般的函数可以在编译时定位到函数的地址。虚函数(动态类型调用)是要根据某个指针定位到函数的地址。多增加了一个过程，效率肯定会低一些，但带来了运行时的多态。</li></ul><h1 id="3-继承"><a class="markdownIt-Anchor" href="#3-继承"></a> 3 继承</h1><h2 id="31-继承的概念"><a class="markdownIt-Anchor" href="#31-继承的概念"></a> 3.1 继承的概念</h2><p>派生类可以具有基类的特性，共享基类的成员函数，使用基类的数据成员，还可以定义自己的数据成员和函数成员。从一个基类派生的称为单继承，从多个基类派生的称为多继承。</p><p><strong>C++中，继承方式有 3 种</strong>：</p><ol><li>公有继承：public、protected、private 权限均不变</li><li>私有继承：public、protected 权限变为 private</li><li>保护继承：public 变为 protected</li></ol><p><strong>实现的访问控制如下</strong>：</p><ol><li>public：自己、友元、派生类、外界均可访问</li><li>protected：自己、友元、派生类可以访问</li><li>private：自己、友元可以访问</li></ol><h2 id="32-多继承的优缺点"><a class="markdownIt-Anchor" href="#32-多继承的优缺点"></a> 3.2 多继承的优缺点</h2><p><strong>优点</strong></p><ol><li>**简单，清晰，更有利于复用。**不会因为基类一个小小的改变而大张旗鼓去改代码。</li></ol><p><strong>缺点</strong></p><ol><li>**二义性。**两个基类中有同名方法的时候，需要在子类的调用中指明此方法出自那个基类。</li><li><strong>使用父类指针指向子类对象变得复杂</strong>。你不得不用到C++中提供的dynamic_cast来执行强制转换。至于dynamic_cast，也是个麻烦的家伙，它是在运行期间而非编译期间进行转换的（因为编译期间它不能确定到底要转向一个什么类型），因此除了会带来一些轻微的性能损失，它要求编译器允许RTTI（Runtime Type Information，运行时类型信息），也就是要求编译器保存所有类在运行时的信息。</li><li><strong>使得子类的vtable变得不同寻常</strong>。单继承的vtable只是在父类vtable的表尾加上新的虚函数，子类对象的vtable中包含了有序的父类vtable。而对于多重继承，两个父类可能有完全不同的vtable，因此，子类的vtable中绝对不可能包含完整的有序的两个父类的vtable。子类的vtable中可能包含了两块不相连的父类vtable，因此每个父类都被迫追加了一个vtable，也就是，每个父类的对象都添加了一个指针。</li></ol><p>孰优孰劣，自己把握。没有永远最好的，只有当前适合的。Java中摒弃了多重继承可能也是出于太过复杂，可能有不可料知的结果的原因。</p><p>不要随意使用多重继承。大多数的情况，用容器（也就是类的组合法）会更好些。</p><p><a href="https://blog.csdn.net/woodforestbao/article/details/4500406" target="_blank" rel="noopener">https://blog.csdn.net/woodforestbao/article/details/4500406</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基础</title>
      <link href="/2022/04/19/C++%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/04/19/C++%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><ul><li>《面向对象C++程序设计》皮德常 编著 清华大学出版社 2017</li><li>《C++ Primer Plus (第6版)中文版》Stephen Prata 著 张海龙 袁国忠 译 人民邮电出版社 2012</li></ul></blockquote><h1 id="1-c-和-c-的区别"><a class="markdownIt-Anchor" href="#1-c-和-c-的区别"></a> 1 c 和 c++ 的区别</h1><ul><li>C是一种结构化语言，重点在于算法和数据结构。C程序的设计首先考虑的是如何通过一个过程，对输入(或环境条件)进行运算处理得到输出(或实现过程(事务)控制)。</li><li>而对于C++，首先考虑的是如何构造一个对象模型，让这个模型能够契合与之对应的问题域，这样就可以通过获取对象的状态信息得到输出或实现过程(事务)控制。</li><li>C++中new和delete是对内存分配的运算符，取代了C中的malloc和free。</li><li>标准C++中的字符串类取代了标准C函数库头文件中的字符数组处理函数（C中没有字符串类型）。</li><li>C++中用来做控制态输入输出的iostream类库替代了标准C中的stdio函数库。</li><li>C++中的try/catch/throw异常处理机制取代了标准C中的setjmp()和longjmp()函数。</li><li>在C<ins>中，允许有相同的函数名，不过它们的参数类型不能完全相同，这样这些函数就可以相互区别开来。而这在C语言中是不允许的。也就是C</ins>可以重载，C语言不允许。</li><li>C<ins>语言中，允许变量定义语句在程序中的任何地方，只要在是使用它之前就可以；而C语言中，必须要在函数开头部分。而且C</ins>允许重复定义变量，C语言也是做不到这一点的</li><li>在C++中，除了值和指针之外，新增了引用。引用型变量是其他变量的一个别名，我们可以认为他们只是名字不相同，其他都是相同的。</li><li>C++相对与C增加了一些关键字，如：bool、using、dynamic_cast、namespace等等</li></ul><h1 id="2-newdelete-mallocfree"><a class="markdownIt-Anchor" href="#2-newdelete-mallocfree"></a> 2 new/delete、malloc/free</h1><h2 id="21-newdelete-mallocfree-区别"><a class="markdownIt-Anchor" href="#21-newdelete-mallocfree-区别"></a> 2.1 new/delete、malloc/free 区别</h2><table><thead><tr><th style="text-align:center">特征</th><th style="text-align:center">new/delete</th><th style="text-align:center">malloc/free</th></tr></thead><tbody><tr><td style="text-align:center">分配内存的位置</td><td style="text-align:center">自由存储区</td><td style="text-align:center">堆</td></tr><tr><td style="text-align:center">内存分配成功的返回值</td><td style="text-align:center">完整类型指针</td><td style="text-align:center">void*</td></tr><tr><td style="text-align:center">内存分配失败的返回值</td><td style="text-align:center">默认抛出异常</td><td style="text-align:center">返回 NULL</td></tr><tr><td style="text-align:center">分配内存的大小</td><td style="text-align:center">由编译器根据类型计算得出</td><td style="text-align:center">必须显式指定字节数</td></tr><tr><td style="text-align:center">处理数组</td><td style="text-align:center">有处理数组的 new 版本 new[]</td><td style="text-align:center">需要用户计算数组的大小后进行内存分配</td></tr><tr><td style="text-align:center">是否相互调用</td><td style="text-align:center">可以，看具体的 operator new/delete 实现</td><td style="text-align:center">不可调用 new</td></tr><tr><td style="text-align:center">函数重载</td><td style="text-align:center">允许</td><td style="text-align:center">不允许</td></tr><tr><td style="text-align:center">构造函数与析构函数</td><td style="text-align:center">调用</td><td style="text-align:center">不调用</td></tr></tbody></table><h2 id="22-c有了mallocfree为什么还需要newdelete"><a class="markdownIt-Anchor" href="#22-c有了mallocfree为什么还需要newdelete"></a> 2.2 C++有了malloc/free，为什么还需要new/delete?</h2><ul><li>malloc/free是C++/C语言的标准库函数，new/delete是C++的运算符。他们都可用于申请动态内存和释放内存。</li><li>对于非内部数据类型的对象而言，只用malloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。</li><li>因此C++需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete。new/delete不是库函数，是运算符。</li></ul><h2 id="23-delete-与-delete-区别"><a class="markdownIt-Anchor" href="#23-delete-与-delete-区别"></a> 2.3 delete 与 delete []区别</h2><p>delete 只会调用一次析构函数，而 delete[]会针对每一个成员都调用一次析构函数。</p><h2 id="24-内存泄漏与定位"><a class="markdownIt-Anchor" href="#24-内存泄漏与定位"></a> 2.4 内存泄漏与定位</h2><p>内存泄漏并非指的是内存在物理上的消失，而是分配某段内存后，失去了对该内存的控制，造成内存的浪费。比如 C++ new 之后没有 delete。</p><p><strong>定位内存泄露</strong>：</p><ol><li>在windows平台下通过CRT中的库函数进行检测；</li><li>在可能泄漏的调用前后生成块的快照，比较前后的状态，定位泄漏的位置</li><li>Linux下通过工具valgrind检测</li></ol><h1 id="3-结构体-联合体"><a class="markdownIt-Anchor" href="#3-结构体-联合体"></a> 3 结构体、联合体</h1><h2 id="31-结构体与联合有何区别"><a class="markdownIt-Anchor" href="#31-结构体与联合有何区别"></a> 3.1 结构体与联合有何区别</h2><ol><li>结构体和联合都是由多个不同的数据类型成员组成，但在任何同一时刻，联合中只存放了一个被选中的成员（所有成员共用一块地址空间），而结构体的所有成员都存在（不同成员的存放地址不同）。</li><li>对于联合的不同成员赋值，将会对其它成员重写，原来成员的值就不存在了。而对于结构体的不同成员赋值是互不影响的。</li></ol><h2 id="32-union的好处"><a class="markdownIt-Anchor" href="#32-union的好处"></a> 3.2 union的好处</h2><ol><li>节省内存空间</li><li>测大小端存储（大相反（低位存高位），小相同（低位存低位），叉八六（X86计算机)，必小端。）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">typedef union un&#123;</span><br><span class="line">   int i;</span><br><span class="line">   char ch[2];</span><br><span class="line">&#125; un;</span><br><span class="line">int main()&#123;</span><br><span class="line">    un u;</span><br><span class="line">    u.ch[0] = 10;</span><br><span class="line">    u.ch[1] = 1;</span><br><span class="line">    printf(&quot;%d&quot;, (short)u.i);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析： 10 相当于 0000 1010     低地址 1  相当于 0000 0001     高地址 如果是小端模式，低地址存放高位，高地址存放低位，那么该值按照正常顺序书写就是： 0000 0001 0000 1010，结果为266。</p><h2 id="33-struct可以有构造-析构等成员函数吗如果有那么与class还有区别吗"><a class="markdownIt-Anchor" href="#33-struct可以有构造-析构等成员函数吗如果有那么与class还有区别吗"></a> 3.3 struct可以有构造、析构等成员函数吗？如果有，那么与class还有区别吗？</h2><ul><li>struct可以有构造函数、析构函数，之间也可以继承。</li><li>C++中的struct其实和class意义一样，唯一不同的就是struct里面默认的访问控制是public，class中默认的访问控制是private。</li><li>C<ins>中存在struct关键字的唯一意义就是为了让C程序员有个归属感，是为了让C</ins>编译器兼容以前用C开发的项目。</li></ul><p><strong>相同点</strong></p><ul><li>两者都拥有成员函数、公有和私有部分</li><li>任何可以使用class完成的工作，同样可以使用struct完成</li></ul><p><strong>不同点</strong></p><ul><li>两者中如果不对成员不指定公私有，struct默认是公有的，class则默认是私有的</li><li>class默认是private继承，而struct模式是public继承</li><li>class可以作为模板类型，struct不行</li></ul><p><strong>引申</strong>：C++和C的struct区别</p><ul><li>C语言中：struct是用户自定义数据类型（UDT）；C<ins>中struct是抽象数据类型（ADT），支持成员函数的定义，（C</ins>中的struct能继承，能实现多态）</li><li>C中struct是没有权限的设置的，且struct中只能是一些变量的集合体，可以封装数据却不可以隐藏数据，而且成员不可以是函数</li><li>C++中，struct增加了访问权限，且可以和类一样有成员函数，成员默认访问说明符为public（为了与C兼容）</li><li>struct作为类的一种特例是用来自定义数据结构的。一个结构标记声明后，在C中必须在结构标记前加上struct，才能做结构类型名（除：typedef struct class{};）;C<ins>中结构体标记（结构体名）可以直接作为结构体类型名使用，此外结构体struct在C</ins>中被当作类的一种特例</li></ul><h1 id="4-c语言关键字及其对应的含义"><a class="markdownIt-Anchor" href="#4-c语言关键字及其对应的含义"></a> 4 C语言关键字及其对应的含义</h1><ul><li>数据类型关键字<ul><li>A基本数据类型（5个）<ul><li>void：声明函数无返回值或无参数，声明无类型指针，显式丢弃运算结果</li><li>char：字符型类型数据，属于整型数据的一种</li><li>int：整型数据，通常为编译器指定的机器字长</li><li>float：单精度浮点型数据，属于浮点数据的一种</li><li>double：双精度浮点型数据，属于浮点数据的一种</li></ul></li><li>B类型修饰关键字（4个）<ul><li>short：修饰int，短整型数据，可省略被修饰的int。</li><li>long：修饰int，长整形数据，可省略被修饰的int。</li><li>signed：修饰整型数据，有符号数据类型</li><li>unsigned：修饰整型数据，无符号数据类型</li></ul></li><li>C复杂类型关键字（5个）<ul><li>struct：结构体声明</li><li>union：共用体声明</li><li>enum：枚举声明</li><li>typedef：声明类型别名</li><li>sizeof：得到特定类型或特定类型变量的大小</li></ul></li><li>D存储级别关键字（6个）<ul><li>auto：指定为自动变量，由编译器自动分配及释放。通常在栈上分配</li><li>static：指定为静态变量，分配在静态变量区，修饰函数时，指定函数作用域为文件内部</li><li>register：指定为寄存器变量，建议编译器将变量存储到寄存器中使用，也可以修饰函数形参，建议编译器通过寄存器而不是堆栈传递参数</li><li>extern：指定对应变量为外部变量，即在另外的目标文件中定义，可以认为是约定由另外文件声明的对象的一个“引用“</li><li>const：与volatile合称“cv特性”，指定变量不可被当前线程/进程改变（但有可能被系统或其他线程/进程改变）</li><li>volatile：与const合称“cv特性”，指定变量的值有可能会被系统或其他进程/线程改变，强制编译器每次从内存中取得该变量的值</li></ul></li></ul></li><li>流程控制关键字<ul><li>A跳转结构（4个）<ul><li>return：用在函数体中，返回特定值（或者是void值，即不返回值）</li><li>continue：结束当前循环，开始下一轮循环</li><li>break：跳出当前循环或switch结构</li><li>goto：无条件跳转语句</li></ul></li><li>B分支结构（5个）<ul><li>if：条件语句</li><li>else：条件语句否定分支（与if连用）</li><li>switch：开关语句（多重分支语句）</li><li>case：开关语句中的分支标记</li><li>default：开关语句中的“其他”分治，可选。</li></ul></li><li>C循环结构（3个）：for、do、while</li></ul></li></ul><h1 id="5-变量存储类型"><a class="markdownIt-Anchor" href="#5-变量存储类型"></a> 5 变量存储类型</h1><h2 id="51-c语言支持的四种变量存储类型"><a class="markdownIt-Anchor" href="#51-c语言支持的四种变量存储类型"></a> 5.1 C语言支持的四种变量存储类型</h2><ol><li><p><strong>auto</strong>：auto称为自动变量（局部变量）</p></li><li><p>static</p><p>：static称为静态变量，根据变量的类型可以分为静态局部变量和静态全局变量。</p><ul><li><strong>静态局部变量</strong>：它与局部变量的区别在于，在函数退出时，这个变量始终存在，但不能被其它函数使用；当再次进入该函数时，将保存上次的结果。</li><li><strong>静态全局变量</strong>：只在定义它的源文件中可见而在其它源文件中不可见的变量。它与全局变量的区别是：全局变量可以被其它源文件使用，而静态全局变量只能被所在的源文件使用。</li></ul></li><li><p><strong>extern</strong>：extern称为外部申明。为了使变量或者函数除了在定义它的源文件中可以使用外，还可以被其它文件使用。因此通知每一个程序模块文件，此时可用extern来说明。</p></li><li><p><strong>register</strong>：register称为寄存器变量。它只能用于整型和字符型变量。定义符register说明的变量被存储在CPU的寄存器中，定义一个整型寄存器变量可写成: <code>register int a</code>;</p></li></ol><p>对于以上四种数据的存储位置：register变量存在CPU的寄存器中；auto类型变量存在内存的栈；static型的局部变量和全局变量以及extern型变量（即全局变量），存在于内存的静态区。</p><h2 id="52-static-的作用"><a class="markdownIt-Anchor" href="#52-static-的作用"></a> 5.2 static 的作用</h2><ol><li><p><strong>隐藏</strong>：当同时编译多个文件时，所有未加 static 前缀的全局变量和函数都具有全局可见性，其它的源文件也能访问。如果加了 static，就会对其它源文件隐藏。利用这一特性可以在不同的文件中定义同名函数和同名变量，而不必担心命名冲突。static 可以用作函数和变量的前缀，对于函数来讲，static 的作用仅限于隐藏。</p></li><li><p><strong>保持变量内容的持久</strong>：存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。如果作为 static 局部变量在函数内定义，它的生存期为整个源程序，但是其作用域仍与局部变量相同，只能在定义该变量的函数内使用该变量。退出该函数后，尽管该变量还继续存在，但不能使用它。</p></li><li><p>默认初始化为 0</p></li><li><p>在类中声明 static 变量或者函数时，初始化时使用作用域运算符来标明它所属类，因此，静态数据成员是类的成员，而不是对象的成员，这样就出现以下作用：</p><ol><li>类的静态成员函数是属于整个类而非类的对象，所以它没有 this 指针，这就导致了它仅能访问类的静态数据和静态成员函数。</li><li>不能将静态成员函数定义为虚函数。</li><li>静态成员变量地址是指向其数据类型的指针，静态成员函数地址类型是一个“非成员函数指针”。</li><li>static 并没有增加程序的时空开销，相反它还缩短了派生类对基类静态成员的访问时间，节省了派生类的内存空间。</li><li>静态数据成员是静态存储的，所以必须对它进行初始化。（程序员手动初始化，否则编译时一般不会报错，但是在链接时会报错误）</li><li>静态成员为基类和派生类共享，但在派生类中重复定义了基类中的静态成员，不会引起错误。</li></ol><p>注意，静态成员初始化与一般数据成员初始化不同:</p><ol><li>初始化在类体外进行，而前面不加 static，以免与一般静态变量或对象相混淆；</li><li>初始化时不加该成员的访问权限控制符 private，public 等；</li><li>初始化时使用作用域运算符来标明它所属类；</li></ol><p>所以我们得出静态数据成员初始化的格式：<code>&lt;数据类型&gt;&lt;类名&gt;::&lt;静态数据成员名&gt;=&lt;值&gt;</code></p></li></ol><h2 id="53-请说出-const-与define-相比有何优点"><a class="markdownIt-Anchor" href="#53-请说出-const-与define-相比有何优点"></a> 5.3 <strong>请说出 const 与#define 相比，有何优点？</strong></h2><p>const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，并且在字符替换可能会产生意料不到的错误。</p><p><strong>const还具有以下优点</strong>：</p><ol><li>提高代码安全性。</li><li>提高代码的可读性和可维护性。</li><li>提高程序的效率。</li><li>当 const 和 non-const 成员函数具有本质上相同的实现的时候，使用 non-const 版本调用 const 版本可以避免重复代码。</li></ol><h2 id="54-c中顶层-const-和底层-const"><a class="markdownIt-Anchor" href="#54-c中顶层-const-和底层-const"></a> 5.4 C++中顶层 const 和底层 const</h2><p>如果 const 右结合修饰的为类型或者*，那这个 const 就是一个底层 const，表示指针所指向的对象是个常量。</p><p>如果 const 右结合修饰的为标识符，那这个 const 就是一个顶层 const，表示指针本身是个常量。</p><h2 id="55-const-关键字的使用"><a class="markdownIt-Anchor" href="#55-const-关键字的使用"></a> 5.5 const 关键字的使用</h2><ol><li>阻止一个<strong>变量</strong>被改变，可以使用const关键字。在定义该const变量时，通常需要(必须)对它进行初始化，因为以后就没有机会再去改变它了；</li><li>对<strong>指针</strong>来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；</li><li>在一个<strong>函数声明</strong>中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；</li><li>对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量，类的常对象只能访问类的常成员函数；</li><li>对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”。</li><li>const成员函数可以访问非const对象的非const数据成员、const数据成员，也可以访问const对象内的所有数据成员；</li><li>非const成员函数可以访问非const对象的非const数据成员、const数据成员，但不可以访问const对象的任意数据成员；</li><li>一个没有明确声明为const的成员函数被看作是将要修改对象中数据成员的函数，而且编译器不允许它为一个const对象所调用。因此const对象只能调用const成员函数。</li><li>const类型变量可以通过类型转换符const_cast将const类型转换为非const类型；</li><li>const类型变量必须定义的时候进行初始化，因此也导致如果类的成员变量有const类型的变量，那么该变量必须在类的初始化列表中进行初始化；</li><li>对于函数值传递的情况，因为参数传递是通过复制实参创建一个临时变量传递进函数的，函数内只能改变临时变量，但无法改变实参。则这个时候无论加不加const对实参不会产生任何影响。但是在引用或指针传递函数调用中，因为传进去的是一个引用或指针，这样函数内部可以改变引用或指针所指向的变量，这时const 才是实实在在地保护了实参所指向的变量。因为在编译阶段编译器对调用函数的选择是根据实参进行的，所以，只有引用传递和指针传递可以用是否加const来重载。一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来。</li></ol><h2 id="56-volatile-关键字的使用"><a class="markdownIt-Anchor" href="#56-volatile-关键字的使用"></a> 5.6 volatile 关键字的使用</h2><ol><li>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。</li><li>当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。</li><li>volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。多线程中被几个任务共享的变量需要定义为volatile类型。</li><li>volatile 指针和 const 修饰词类似，const 有常量指针和指针常量的说法，volatile 也有相应的概念</li><li>可以把一个非volatile int赋给volatile int，但是不能把非volatile对象赋给一个volatile对象。</li><li>除了基本类型外，对用户定义类型也可以用volatile类型进行修饰。</li><li>C++中一个有volatile标识符的类只能访问它接口的子集，一个由类的实现者控制的子集。用户只能用const_cast来获得对类型接口的完全访问。此外，volatile向const一样会从类传递到它的成员。</li><li><strong>多线程下的volatile</strong>：有些变量是用volatile关键字声明的。当两个线程都要用到某一个变量且该变量的值会被改变时，应该用volatile声明，该关键字的作用是防止优化编译器把变量从内存装入CPU寄存器中。如果变量被装入寄存器，那么两个线程有可能一个使用内存中的变量，一个使用寄存器中的变量，这会造成程序的错误执行。volatile的意思是让编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的值。</li></ol><h2 id="57-一个参数可以既是const又是volatile吗解释为什么"><a class="markdownIt-Anchor" href="#57-一个参数可以既是const又是volatile吗解释为什么"></a> 5.7 一个参数可以既是const又是volatile吗？解释为什么</h2><ul><li>可以。一个例子就是只读的状态寄存器。它是volatile，因为他可能被意想不到地改变；她又是const，因为程序不应该试图去改变它。</li><li>尽管这并不很正常。一个例子就是当一个中断服务子程序修改一个指向一个buffer的指针时。</li></ul><h1 id="6-c-字符串和-c字符串的区别"><a class="markdownIt-Anchor" href="#6-c-字符串和-c字符串的区别"></a> 6 <strong>C 字符串和 C++字符串的区别</strong></h1><ol><li>C 字符串是基本数据类型，即字符数组；C++字符串是类 string</li><li>C 字符串函数是外部函数，字符串作为参数被传进来；C++字符串函数是字符串类内部定义的，用<code>.</code>来直接使用</li><li>C++字符串中对一些运算符进行了重载</li></ol><h1 id="7-引用和指针"><a class="markdownIt-Anchor" href="#7-引用和指针"></a> 7 引用和指针</h1><h2 id="71-引用与指针区别"><a class="markdownIt-Anchor" href="#71-引用与指针区别"></a> 7.1 引用与指针区别</h2><ol><li><p><strong>初始化区别</strong>：引用必须被初始化，指针不必。</p></li><li><p><strong>可修改区别</strong>：引用初始化以后不能被改变，指针可以改变所指的对象。</p></li><li><p><strong>非空区别</strong>：不存在指向空值的引用，但是存在指向空值的指针。</p></li><li><p><strong>合法性区别</strong>：在使用引用之前不需要测试他的合法性；相反，指针则应该总是被测试，防止其为空。</p></li><li><p>应用区别</p><p>：</p><ul><li>使用指针的情况<ul><li>考虑到存在不指向任何对象的可能(在这种情况下，能够设置指针为空)</li><li>需要能够在不同时刻指向不同对象(在这种情况下，能够改变指针的指向)</li></ul></li><li><strong>使用引用的情况</strong>：总是指向一个对象并且一旦指向一个对象后就不会改变指向</li></ul></li></ol><h2 id="72-在什么时候需要使用常引用"><a class="markdownIt-Anchor" href="#72-在什么时候需要使用常引用"></a> 7.2 <strong>在什么时候需要使用“常引用”？</strong></h2><p>如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改变，就应使用常引用。</p><h2 id="73-将引用作为函数返回值类型的优点和注意事项"><a class="markdownIt-Anchor" href="#73-将引用作为函数返回值类型的优点和注意事项"></a> 7.3 <strong>将“引用”作为函数返回值类型的优点和注意事项</strong></h2><p>好处：在内存中不产生被返回值的副本，提高效率</p><p><strong>注意事项</strong>：</p><ol><li>不能返回局部变量的引用。主要原因是局部变量会在函数返回后被销毁，因此被返回的引用就成为了&quot;无所指&quot;的引用，程序会进入未知状态。</li><li>不能返回函数内部 new 分配的内存的引用。原因是引用所指向的空间就无法释放，造成内存泄漏。</li><li>可以返回类成员的引用，但最好是 const。主要原因是如果其它对象可以获得该属性的非常量引用（或指针），那么对该属性的单纯赋值就会破坏业务规则的完整性。</li><li>流操作符和赋值操作符重载返回值申明为引用。</li><li>在另外的一些操作符中，却千万不能返回引用，例如四则运算符。</li></ol><h2 id="74-句柄和指针的区别与联系"><a class="markdownIt-Anchor" href="#74-句柄和指针的区别与联系"></a> 7.4 句柄和指针的区别与联系</h2><p>句柄和指针其实是两个截然不同的概念。</p><ul><li>Windows系统用句柄标记系统资源，隐藏系统的信息。只要知道有这个东西，然后去调用即可，他是一个32bit的uint。</li><li>指针则标记某个物理内存地址。</li></ul><h2 id="75-指针常量和常量指针"><a class="markdownIt-Anchor" href="#75-指针常量和常量指针"></a> 7.5 指针常量和常量指针</h2><ul><li>常量指针是一个指针，读成常量的指针，指向一个只读变量。如<code>int const *p</code>或<code>const int *p</code></li><li>指针常量是一个不能给改变指向的指针。指针是个常量，不能中途改变指向，如<code>int *const p</code></li></ul><p><strong>技巧</strong>：* 前面的是对被指向对象的修饰，* 后面的是对指针本身的修饰。</p><h1 id="8-递归的优缺点"><a class="markdownIt-Anchor" href="#8-递归的优缺点"></a> 8 <strong>递归的优缺点</strong></h1><ul><li><strong>优点</strong>：代码简洁，容易理解</li><li><strong>缺点</strong>：时间效率低，递归爆栈</li></ul><h1 id="9-c四种类型转换static_cast-dynamic_cast-const_cast-reinterpret_cast"><a class="markdownIt-Anchor" href="#9-c四种类型转换static_cast-dynamic_cast-const_cast-reinterpret_cast"></a> 9 C++四种类型转换：static_cast, dynamic_cast, const_cast, reinterpret_cast</h1><ol><li>static_cast 用的最多，能用于多态向上转化，如果向下转能成功但是不安全。</li><li>dynamic_cast 用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回 NULL，对于引用抛异常。</li><li>const_cast 用于将 const 变量转为非 const</li><li>reinterpret_cast 几乎什么都可以转，比如将 int 转指针，可能会出问题，尽量少用。</li></ol><p>C 的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。</p><h1 id="10-c是不是类型安全的"><a class="markdownIt-Anchor" href="#10-c是不是类型安全的"></a> 10 <strong>C++是不是类型安全的？</strong></h1><p>不是。<strong>两个不同类型的指针之间可以强制转换</strong></p><h1 id="11-内联函数与宏定义的区别"><a class="markdownIt-Anchor" href="#11-内联函数与宏定义的区别"></a> 11 <strong>内联函数与宏定义的区别</strong></h1><p>所谓的内联函数就是那些完整地定义在类内部的函数成员。</p><p>C++ 宏定义将一个标识符定义为一个字符串，源程序中的该标识符均以指定的字符串来代替。</p><ul><li>宏定义在预编译的时候就会进行宏替换；内联函数在编译阶段，在调用内联函数的地方进行替换，减少了函数的调用过程，但是使得编译文件变大。因此，内联函数适合简单函数，对于复杂函数，即使定义了内联，编译器可能也不会按照内联的方式进行编译。</li><li>内联函数相比宏定义更安全，内联函数可以检查参数，而宏定义只是简单的文本替换。因此推荐使用内联函数，而不是宏定义。</li></ul><hr><h1 id="补充1-c笔记"><a class="markdownIt-Anchor" href="#补充1-c笔记"></a> <strong>补充1 C笔记</strong></h1><ol><li>exe已停止工作：1)漏&amp;；2)分母为0</li><li>定义整型，输入实型：自动截取小数部分，eg:2.5-&gt;2(赋值亦是)。</li><li>输出数据出错：格式字符与变量类型未对应；为赋初值。特别注意除号“/”和等号“==”。</li><li>数据范围与补码：-1全1，正负0全0，负数min为“1+全0”;溢出取低位，小数对应21,22,23…小数转二进制数: x/2取整数部分直到小数为0。</li><li>else就近结合。</li><li>|| 和 &amp;&amp; 的短路特性。</li><li>数组a[]: scanf(&quot;%d&quot;, a)指对a[0]赋值。</li><li>字符串：scanf(&quot;%s&quot;, a)-&gt;遇’ ‘, ‘\0’, ‘\t’为截点(’\n’跳出)开始不计；puts()=printf(&quot;%s&quot;, a)-&gt;遇’\0’结束；gets()遇回车结束，前无截点。</li><li>x *= y+8 等价于 x = x + (y+8)</li><li>C语言的函数体中，可以调用但不能定义其他函数。</li><li>puts()自动换行，putchar()不自动换行。</li></ol><h1 id="补充2-c笔记"><a class="markdownIt-Anchor" href="#补充2-c笔记"></a> <strong>补充2 C++笔记</strong></h1><ol><li><p>endl = ‘\n’ + flush(刷新缓冲区)</p></li><li><p>cin跳过空白字符，cin.get()读取包含空白字符的字符</p></li><li><p>浮点数和整型注意转化中的除号</p></li><li><p>递归调用次数可用二叉树解决</p></li><li><p>C++, 字符串拷贝用&quot;=&quot;, 字符串比较&quot;==&quot;</p></li><li><p>汉字占两个字符，故name[0]无法输出，&quot;cout&lt;&lt;name[0]&lt;&lt;name[1]&quot;输出一个汉字</p></li><li><p>cin对象遇’\n’结束</p></li><li><p>nullptr能够避免在整数(0或NULL)和指针(nullptr)之间发生混淆</p></li><li><p><strong>函数传参</strong>：数据较小，按值传递，但修改时用引用；数组用指针；结构体用指针或引用；对象用引用</p></li><li><p><strong>缺省函数</strong>：声明函数(最先且一次)时为其参数指定默认值</p></li><li><p><strong>sizeof()</strong>: 测字节(包含’\0’)区分数组与指针<strong>strlen()</strong>: 不区分数组还是指针，读到’\0’为止返回长度(\t,\n不停)</p></li><li><p><strong>全局变量</strong>: int global -&gt; extern int global 声明到文件结尾<strong>局部变量</strong>: 从声明到函数结束<strong>静态变量</strong>: 函数退出保留值，下次调用</p></li><li><p>getline()读取换行符，但向数组存储时并不存储</p></li><li><p>初始化和赋值是不同概念</p></li><li><p>文本文件存储文件大小：char类型存储；二进制文件：&quot;01&quot;存储(内存大小)</p></li><li><p>引起缓存区刷新：缓存区满时(4K)；程序结束；flush语句；close语句；endl语句</p></li><li><p>解决<redefinition>：<em>#ifdef ``` #endif</em> 或 <em>#pragma once</em></redefinition></p></li><li><p>派生类的构造函数只能描述自己的成员和基类的初始化，不能去初始化基类的成员；基类的成员需要调用基类的构造函数初始化。</p></li><li><p>k = (a=1, b=2, a+b)逗号运算符</p></li><li><p>自身类的对象不能作为类的成员(存在无限初始化问题，构造成员变量-&gt;调用自身的构造函数)，而自身类对象的引用和指针可以。</p></li><li><p><strong>虚函数</strong>：特殊的成员函数，用来实现运行时的多态；动态决议(运行时才绑定)；基类说明virtual后，子类可缺省virtual<strong>静态成员函数</strong>：静态决议(编译时就绑定)，属于整个class，并不针对某个类的实例，为所有对象所共用，作用域为全局；不能直接使用this指针；virtual不能是static</p></li><li><p><strong>静态数据成员</strong>：class内声明：<em>static int num</em>; class外定义：<em>int className::num</em>(无static，默认0)</p></li><li><p><strong>继承中的析构函数</strong>：基类的指针可指向派生类对象(多态性); *if delete []p;*就会调用该指针指向的派生类析构函数，而其自动调用基类的析构函数，整个派生类的对象被完全释放。若析构函数不被声明成虚函数，则编译器是是静态绑定，再删除基类指针时，只会调用基类的析构函数而不调用派生类的析构函数，这样一来派生类对象析构不完全。</p></li><li><p>两个指针指向同一数组，可以相减，结果是两个指针之间的元素数目。</p></li><li><p><strong>函数模板</strong>：一个模板，专门用来生产函数的<strong>模板函数</strong>：是函数模板的实例化 <strong>注</strong>：类模板和模板类亦同</p></li><li><p>联编</p><p>：程序自身彼此关联的过程，确定程序中的操作调用与执行该操作的代码之间的关系。</p><ul><li><strong>静态联编</strong>：联编工作出现在联编阶段，用对象名或者类名来限定要调用的函数；</li><li><strong>动态联编</strong>：联编工作在程序运行时执行，在程序运行时才确定将要调用的函数。</li></ul></li><li><p>虚基类子对象是由最远派生类的构造函数通过调用虚基类的构造函数进行初始化的；初始化列表列出对虚基类调用，如未列出则用虚基类构造函数；先虚后非虚。</p></li><li><p><strong>虚基类</strong>：多条继承路径上有一个公共的基类，公共的基类会产生多个实例。<em>virtual class</em>是为了实例化一次基类存在的。eg: ios类是istream和ostream类的虚基类。</p></li><li><p>char = int + ‘0’</p></li><li><p><strong>指针数组</strong>：int *p[4]<strong>数组指针</strong>：int (*p)[4]</p></li><li><p><strong>Runtime Error</strong>: 除0操作；数组越界；栈溢出；未指定值的指针进行读写操作；已经释放空间的指针再次释放。</p></li><li><p>数组</p><p>：</p><ul><li><strong>int&amp;float&amp;double</strong>:初始化补零</li><li><strong>char</strong>: 初始化补’\0’</li><li><strong>对象</strong>：调用缺省构造函数</li></ul></li><li><p>常对象不能被更新，因此通过常对象只能调用他的常成员函数。</p></li><li><p>临时对象是在遇到其后第一个分号(语句结束处)析构的。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卫语句</title>
      <link href="/2022/04/18/%E5%8D%AB%E8%AF%AD%E5%8F%A5/"/>
      <url>/2022/04/18/%E5%8D%AB%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p><strong>转载</strong>：<a href="https://blog.csdn.net/qq_36631379/article/details/107951535" target="_blank" rel="noopener">浅谈使用卫语句重构方法</a></p></blockquote><h1 id="1-卫语句定义"><a class="markdownIt-Anchor" href="#1-卫语句定义"></a> 1 卫语句定义</h1><p>如果条件语句极其复杂，就应该将条件语句拆解开，然后逐个检查，并在条件为真时立刻从函数中返回，这样的单独检查通常被称之为“卫语句”(Guard Clauses)。</p><p><strong>说人话就是</strong>：写方法时在合适的时候尽快return，少用else</p><h1 id="2-按卫语句对函数进行重构应遵循"><a class="markdownIt-Anchor" href="#2-按卫语句对函数进行重构应遵循"></a> 2 按卫语句对函数进行重构应遵循</h1><ol><li>及时return，if中能return就return。(一旦满足条件return后你根本无需关注后面的代码)</li><li>能够return的就尽量少使用else。(用else太多，读者需要维护大量的栈在大脑中)</li><li>减少嵌套，一般嵌套超过4层读者就会产生阅读恐惧感。</li></ol><h1 id="3-示例"><a class="markdownIt-Anchor" href="#3-示例"></a> 3 示例</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>（it == 活的）&#123;</span><br><span class="line">    <span class="keyword">if</span>（it == 人）&#123;</span><br><span class="line">        <span class="keyword">if</span>（it ！= 女人）&#123;</span><br><span class="line">            <span class="keyword">return</span> 不喜欢；</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> 喜欢；</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> 不喜欢；</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> 不喜欢；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码无非就是表达 <code>我只喜欢活的女人</code> 的意思，但是代码一层套一层明显妨碍了我在第一时间获取最核心信息的效率，使用卫语句来表达就是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> （it ！= 活的）&#123;<span class="keyword">return</span> 不喜欢&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>（it！=人）&#123;<span class="keyword">return</span> 不喜欢&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>（it！=女人）&#123;<span class="keyword">return</span> 不喜欢&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>（it == 女人 &amp;&amp; it == 活的） &#123;<span class="keyword">return</span> 喜欢&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> 不喜欢</span><br></pre></td></tr></table></figure><p>这样看起来，代码就更明晰易懂。</p><p>有点<strong>逆向思维</strong>的意思。</p>]]></content>
      
      
      <categories>
          
          <category> 未分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 重构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git vs svn</title>
      <link href="/2022/04/18/git-vs-svn/"/>
      <url>/2022/04/18/git-vs-svn/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p><strong>转载</strong>：<a href="https://www.cnblogs.com/Sungeek/p/9152223.html#sg3" target="_blank" rel="noopener">SVN与Git比较的优缺点差异</a></p></blockquote><h1 id="1-集中式-vs-分布式"><a class="markdownIt-Anchor" href="#1-集中式-vs-分布式"></a> 1 集中式 vs 分布式</h1><h2 id="11-subversion属于集中式的版本控制系统"><a class="markdownIt-Anchor" href="#11-subversion属于集中式的版本控制系统"></a> 1.1 <strong>Subversion属于集中式的版本控制系统</strong></h2><p>集中式的版本控制系统都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。</p><img src="https://s2.loli.net/2022/04/18/bqmSZKA6HNOGxyu.png" width="300" height="300" alt="图片名称" align="center" id="172"><p><strong>Subversion的特点概括起来主要由以下几条：</strong></p><ul><li>每个版本库有唯一的URL（官方地址），每个用户都从这个地址获取代码和数据；</li><li>获取代码的更新，也只能连接到这个唯一的版本库，同步以取得最新数据；</li><li>提交必须有网络连接（非本地版本库）；</li><li>提交需要授权，如果没有写权限，提交会失败；</li><li>提交并非每次都能够成功。如果有其他人先于你提交，会提示“改动基于过时的版本，先更新再提交”… 诸如此类；</li><li>冲突解决是一个提交速度的竞赛：手快者，先提交，平安无事；手慢者，后提交，可能遇到麻烦的冲突解决。</li></ul><p><strong>好处</strong>：每个人都可以一定程度上看到项目中的其他人正在做些什么。而管理员也可以轻松掌控每个开发者的权限。</p><p><strong>缺点</strong>：</p><ul><li>中央服务器的单点故障。若是宕机一小时，那么在这一小时内，谁都无法提交更新、还原、对比等，也就无法协同工作。如果中央服务器的磁盘发生故障，并且没做过备份或者备份得不够及时的话，还会有丢失数据的风险。最坏的情况是彻底丢失整个项目的所有历史更改记录，被客户端提取出来的某些快照数据除外，但这样的话依然是个问题，你不能保证所有的数据都已经有人提取出来。</li><li>Subversion原理上只关心文件内容的具体差异。每次记录有哪些文件作了更新，以及都更新了哪些行的什么内容。</li></ul><h2 id="12-git属于分布式的版本控制系统"><a class="markdownIt-Anchor" href="#12-git属于分布式的版本控制系统"></a> 1.2 Git属于分布式的版本控制系统</h2><img src="https://s2.loli.net/2022/04/18/uryM1ZCEP6b2NRF.png" width="300" height="300" alt="图片名称" align="center" id="171"><p>Git记录版本历史只关心文件数据的<strong>整体</strong>是否发生变化。Git 不保存文件内容前后变化的差异数据。</p><p>实际上，Git 更像是把变化的文件作快照后，记录在一个微型的文件系统中。每次提交更新时，它会纵览一遍所有文件的指纹信息并对文件作一快照，然后保存一个指向这次快照的索引。为提高性能，若文件没有变化，Git 不会再次保存，而只对上次保存的快照作一连接。</p><p>在分布式版本控制系统中，客户端并不只提取最新版本的文件快照，而是把原始的代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。这类系统都可以指定和若干不同的远端代码仓库进行交互。籍此，你就可以在同一个项目中，分别和不同工作小组的人相互协作。你可以根据需要设定不同的协作流程。</p><p>另外，因为Git在本地磁盘上就保存着所有有关当前项目的历史更新，并且Git中的绝大多数操作都只需要访问本地文件和资源，不用连网，所以处理起来速度飞快。用SVN的话，没有网络或者断开VPN你就无法做任何事情。但用Git的话，就算你在飞机或者火车上，都可以非常愉快地频繁提交更新，等到了有网络的时候再上传到远程的镜像仓库。换作其他版本控制系统，这么做几乎不可能，抑或是非常麻烦。</p><p><strong>Git具有以下特点：</strong></p><ul><li>Git中每个克隆(clone)的版本库都是平等的。你可以从任何一个版本库的克隆来创建属于你自己的版本库，同时你的版本库也可以作为源提供给他人，只要你愿意。</li><li>Git的每一次提取操作，实际上都是一次对代码仓库的完整备份。</li><li>提交完全在本地完成，无须别人给你授权，你的版本库你作主，并且提交总是会成功。</li><li>甚至基于旧版本的改动也可以成功提交，提交会基于旧的版本创建一个新的分支。</li><li>Git的提交不会被打断，直到你的工作完全满意了，PUSH给他人或者他人PULL你的版本库，合并会发生在PULL和PUSH过程中，不能自动解决的冲突会提示您手工完成。</li><li>冲突解决不再像是SVN一样的提交竞赛，而是在需要的时候才进行合并和冲突解决。</li><li>Git 也可以模拟集中式的工作模式</li><li>Git版本库统一放在服务器中</li><li>可以为 Git 版本库进行授权：谁能创建版本库，谁能向版本库PUSH，谁能够读取（克隆）版本库</li><li>团队的成员先将服务器的版本库克隆到本地；并经常的从服务器的版本库拉（PULL）最新的更新；</li><li>团队的成员将自己的改动推（PUSH）到服务器的版本库中，当其他人和版本库同步（PULL）时，会自动获取改变</li><li>Git 的集中式工作模式非常灵活</li><li>你完全可以在脱离Git服务器所在网络的情况下，如移动办公／出差时，照常使用代码库</li><li>你只需要在能够接入Git服务器所在网络时，PULL和PUSH即可完成和服务器同步以及提交</li><li>Git提供 rebase 命令，可以让你的改动看起来是基于最新的代码实现的改动</li><li>Git 有更多的工作模式可以选择，远非 Subversion可比</li></ul><h1 id="2-版本库与工作区"><a class="markdownIt-Anchor" href="#2-版本库与工作区"></a> 2 版本库与工作区</h1><p>Subversion的工作区和版本库是截然分开的，而Git的工作区和版本库是如影随形的。</p><h2 id="21-svn的版本库和工作区是分离的"><a class="markdownIt-Anchor" href="#21-svn的版本库和工作区是分离的"></a> 2.1 SVN的版本库和工作区是分离的</h2><ul><li>Subversion 的工作区和版本库物理上分开：Subversion的版本库和工作区是存储在不同路径下，一般是在不同的主机中</li><li>Subversion的企业级部署中，版本库在服务器上，只能通过 https, http, svn 等协议访问，而不能直接被用户接触到。</li><li>Subversion的工作区是一份版本库在某个历史状态下的快照，如：版本库最新的数据检出到工作区。</li><li>Subversion的工作区中每一个目录下都包含一个名为 .svn 的控制目录（隐藏的目录），该目录的作用是：<ul><li>标识工作区和版本库的对应关系。</li><li>包含一份该子目录下检出文件的原始拷贝。当文件改动的差异比较或者本地改动的回退时，可以直接参考原始拷贝而无须通过网络访问远程版本库。</li></ul></li><li>Subversion 的 .svn 控制目录会引入很多麻烦：<ul><li>.svn 下的文件原始考本，会导致在目录下按照文件内容搜索时，多出一倍的搜索时间和搜索结果。</li><li>.svn 很容易在集成时，引入产品中，尤其是 Web 应用，将 .svn 目录带入Web服务器会导致安全隐患。因为一个不允许目录浏览的Web目录，可以通过 .svn/entries 文件查看到该目录下可能存在的文件。</li></ul></li></ul><h2 id="22-git-的版本库和工作区如影随形"><a class="markdownIt-Anchor" href="#22-git-的版本库和工作区如影随形"></a> 2.2 Git 的版本库和工作区如影随形</h2><ul><li>Git 的版本库和工作区在同一个目录下，工作区的根目录有一个.git的子目录，这个名为 .git的目录就是版本库本身，它是Git 用来保存元数据和对象数据库的地方。该目录非常重要，每次克隆镜像仓库的时候，实际拷贝的就是这个目录里面的数据。所以千万要小心删除这个文件。</li><li>工作区中其他文件为工作区文件，可能是从 .git 中检出的，或者是要检入的，或者是运行产生的临时文件等。</li><li>版本库可以脱离工作区而存在，成为 bare（赤裸）版本库。可以用 –bare 参数来创建。但是工作区不能脱离版本库而存在，即工作区的根目录下必须有一个名为 .git 的版本库克隆文件。</li><li>Git 的版本库因为就在工作区中，能直接被用户接触到。<ul><li>用户可以编辑 .git/config 文件，修改配置，增添新的源</li><li>用户可以编辑 .git/info/exclude 文件，创建本地忽略…</li></ul></li><li>Git 的工作区中只在工作区的根目录下有一个 .git 目录，此外再无任何控制目录。Git 工作区下唯一的 .git 目录是版本库，并非 .svn 的等价物，如果删除了 .git 目录，而又没有该版本库的其他镜像（克隆）的话，你破坏了整个历史，版本库也永远的失去了。</li><li>Git 在本地的 .git 版本库，提供了完全的改动历史。除了和其他人数据交换外，任何版本库相关的操作都在本地完成，更多的本地操作，避免了冗长的网络延迟，大大节省了时间。例如：查看 log，切换到任何历史版本等操作都无须连接网络。</li><li>Git如何保证安全：本地创建一个Git库，因为工作区和库是在同一个目录中，如果工作区删除了，或者所在的磁盘分区格式化了，数据不是全都没有了么？其实我们可以这样做：<ul><li>在一个磁盘分区中创建版本库（最好是用 –bare 参数创建），然后在另外的磁盘分区中克隆一个新的作为工作区。在工作区的提交要不时的PUSH到另外分区的版本库，这样就实现了本地的数据镜像。你甚至可以在本地创建更多的版本库镜像，安全性要比Subversion的一个库加上一个工作区安全。</li><li>另一个办法：把你的版本库共享给他人，当他人克隆了你的版本库时，你就拥有了一个异地备份。</li></ul></li></ul><h1 id="3-全局版本号和全球版本号"><a class="markdownIt-Anchor" href="#3-全局版本号和全球版本号"></a> 3 全局版本号和全球版本号</h1><p>SVN的全局版本号和CVS的每个文件都独立维护一套版本号相比，是一个非常大的进步。在看似简单的全局版本号的背后，是Subversion提供对于事物处理的支持，每一个事物处理（即一次提交）都具有整个版本库全局唯一的版本号。</p><p>Git的版本号则更进一步，版本号是全球唯一的。Git 对于每一次提交，通过对文件的内容或目录的结构计算出一个SHA-1 哈希值，得到一个40位的十六进制字符串，Git将此字符串作为版本号。</p><h2 id="31-svn与git版本号比较"><a class="markdownIt-Anchor" href="#31-svn与git版本号比较"></a> 3.1 SVN与Git版本号比较</h2><ul><li>所有保存在Git 数据库中的数据都是用此40位的哈希值作索引的，而不是靠文件名。</li><li>使用哈希值作版本号的好处就是对于一个分布式的版本控制系统，每个人每次提交后形成的版本号都不会出现重复。另一好处是保证数据的完整性，因为哈希值是根据内容或目录结构计算出来的，所以我们还可以据此来判断数据内容是否被篡改。</li><li>SVN 的版本号是连续的，可以预判下一个版本号，而 Git 的版本号则不是。<ul><li>因为 subversion 是集中式版本控制，很容易实现版本号的连续性。</li><li>Git 是分布式的版本控制系统，而且 Git 采用 40 位长的哈希值作为版本号，每个人的提交都是各自独立完成的，没有先后之分（即使提交有先后之分，也由于PUSH/PULL的方向和时机而不同）。Git 的版本号虽然不连续，但是是有线索的，即每一个版本都有对应的父版本（一个或者两个），进而可以形成一个复杂的提交链</li></ul></li><li>Git 的版本号简化：Git 可以使用从左面开始任意长度的字串作为简化版本号，只要该简化的版本号不产生歧义。一般采用7位的短版本号（只要不会出现重复的，你也可以使用更短的版本号）。</li></ul><h1 id="4-部分检出"><a class="markdownIt-Anchor" href="#4-部分检出"></a> 4 部分检出</h1><p>Subversion可以将整个库检出到工作区，也可以将某个目录检出到工作区。对于要使用一个庞大、臃肿的版本库的用户来说，部分检出是非常方便和实际的。</p><p>但是Git只能全部检出，不支持按照目录进行的部分检出。</p><h2 id="41-svn的部分检出"><a class="markdownIt-Anchor" href="#41-svn的部分检出"></a> 4.1 SVN的部分检出</h2><ul><li>在SVN中，从仓库checkout的一个工作树，每个子目录下都维护着自己的.svn目录，记录着该目录中文件的修改情况以及和服务器端仓库的对应关系。所以SVN可以checkout部分路径下的内容（部分检出），而不用checkout整个版本库或分支。</li><li>Subversion 有一条命令：svn export ，可以将 subversion 版本库的一个目录下所有内容导出到指定的目录下。Subversion 需要 svn export 命令是因为该命令可以导出一个干净的目录，即不包含 .svn 目录（包含配置文件和文件原始拷贝）。</li></ul><h2 id="42-git的检出"><a class="markdownIt-Anchor" href="#42-git的检出"></a> 4.2 Git的检出</h2><ul><li>Git 没有部分检出，这并不是说只有将整个库克隆下来才能查看文件。有很多 git 工具，提供直接浏览git库的功能，例如 gitweb, trac 的 git 版本库浏览, redmine 的 git 版本库浏览。</li><li>Git-submodule 可以实现版本库的模块化：Git 通过子模块处理这个问题。子模块允许你将一个Git 仓库当作另外一个Git仓库的子目录。这允许你克隆另外一个仓库到你的项目中并且保持你的提交相对独立。</li><li>Git 为什么没有实现 svn export 的功能？由于git的本地仓库信息完全维护在project根目录的.git目录下，（不像svn一样，每个子目录下都有单独的.svn目录）。所以，只要clone，checkout然后删除.git目录就可以了。</li></ul><h1 id="5-更新和提交"><a class="markdownIt-Anchor" href="#5-更新和提交"></a> 5 更新和提交</h1><h2 id="51-更新操作"><a class="markdownIt-Anchor" href="#51-更新操作"></a> 5.1 更新操作</h2><p>在SVN中，因为只有一个中心仓库，所以所谓的远程更新，也就是svn update ,通过此命令来使工作区和版本库保持同步。</p><p>对于git来说，别人的改动是存在于远程仓库上的，所以git checkout命令尽管在某些功能上和svn中的update类似（例如取仓库特定版本的内容），但是在远程更新这一点上，还是不同的，不属于git checkout的功能涵盖范围。 Git使用git fetch和git pull来完成远程更新任务，fetch操作只是将远程数据库的object拷贝到本地，然后更新remotes head的refs，git pull 的操作则是在git fetch的基础上对当前分支外加merge操作。</p><blockquote><p>大致上 git pull = git fetch + git merge</p></blockquote><h2 id="52-svn中的commit命令"><a class="markdownIt-Anchor" href="#52-svn中的commit命令"></a> 5.2 SVN中的commit命令</h2><p>对于SVN来说，由于是中心式的仓库管理形式，所以并不存在特殊的远程提交的概念，所有的commit操作都可以认为是对远程仓库的更新动作。在工作区中对文件进行添加、修改、删除操作要同步到版本库，必须使用 commit命令。</p><ul><li>add 命令，是将未标记为版本控制状态的文件标记为添加状态，并在下次提交时入库。</li><li>delete命令，是通过SVN来删除文件，并在下次提交后有效。</li><li>Subversion 有提交列表功能，即将某些文件加入一个修改列表，提交可以只提交处于该列表的文件。</li></ul><h2 id="53-git中的暂存区域stage"><a class="markdownIt-Anchor" href="#53-git中的暂存区域stage"></a> 5.3 Git中的暂存区域（stage）</h2><p>Git 管理项目时，文件在三个工作区域中流转：Git 的本地数据目录，工作目录以及暂存区域。暂存区域（stage）是介于 workcopy 和 版本库 HEAD 版本的一种中间状态。所谓的暂存区域只不过是个简单的文件，一般都放在git 目录中。有时候人们会把这个文件叫做索引文件，不过标准说法还是叫暂存区域。</p><p>要将一个文件纳入版本管理的范畴，首先是要用git add将文件纳入stage的监控范围，只有更新到stage中的内容才会在commit的时候被提交。另外，文件本身的改动并不会自动更新到stage中，每次的任何修改都必须重新更新到stage中去才会被提交。对于工作区直接删除的文件，需要用 git rm 命令进行标记，在下次提交时，在版本库中删除。</p><ul><li>工作区的文件改动（新增文件，修改文件，删除文件），必须用 git add 或者 git rm 命令标识，使得改动进入 stage</li><li>提交只对加入 stage 的改动进行提交</li><li>如果一个文件改动加入 stage 后再次改动，则后续改动不改变 stage。即该文件的改动有两个状态，一个是标记到 stage 中并将在下次提交时入库的改动，另外的后续改动则不被提交，除非再次使用 git add 命令将改动加入到 stage 中。</li><li>Git的stag让你在提交的时候清楚的知道git将要提交哪些改动。除非提交的时候使用 -a 参数（不建议使用）。</li></ul><p>我们可以从文件所处的位置来判断其状态：如果是git目录中保存着的特定版本文件，就属于已提交状态；如果作了修改并已放入暂存区域，就属于已暂存状态；如果自上次取出后，作了修改但还没有放到暂存区域，就是已修改状态，如果取出后未进行修改则是未修改状态。</p><p>在git中，因为有本地仓库和remote仓库之分，所以也就区别于commit 操作，存在额外的push命令，用于将本地仓库的数据更新到远程仓库中去。git push 可以选择需要提交的、更新的分支以及制定该分支在远程仓库上的名字。</p><h1 id="6-分支和里程碑的实现"><a class="markdownIt-Anchor" href="#6-分支和里程碑的实现"></a> 6 分支和里程碑的实现</h1><p>几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。在很多版本控制系统中，这是个昂贵的过程，常常需要创建一个源代码目录的完整副本，对大型项目来说会花费很长时间。</p><p>轻量级分支/里程碑的含义是，创建分支/里程碑的复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>，不会因为版本库的愈加庞大而变得缓慢。在CVS中，创建分支的复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>的，导致大的版本库的的分支创建非常缓慢。</p><blockquote><p>CVS （代码版本控制软件）：<a href="https://baike.baidu.com/item/CVS/405463" target="_blank" rel="noopener">百度百科</a></p></blockquote><h2 id="61-subversion的分支里程碑"><a class="markdownIt-Anchor" href="#61-subversion的分支里程碑"></a> 6.1 Subversion的分支/里程碑</h2><p>Subversion轻量级分支和里程碑的实现是通过svn cp命令，即带历史的拷贝就是创建快速创建分支和里程碑的秘籍。Subversion的版本库有特殊的设计，当你复制一个目录，你不需要担心版本库会变得十分巨大—Subversion并不是拷贝所有的数据，相反，它只是建立了一个已存在目录树的入口。这种“廉价的拷贝”就是创建分支/里程碑是轻量级的原因。</p><p>由于Svn的分支和标签是来自目录拷贝，约定俗成是拷贝在 branches/和tags/目录下。所谓分支，tag等概念都只是仓库中不同路径上的一个对象或索引而已，和普通的路径并没有什么本质的区别，谁也不能阻止在一个提交中同时修改不同分支中的数据。</p><p>里程碑是对某个历史提交所起的一个别名，作为历史的标记，是不应该被更改的。svn的里程碑要建立到 tags/目录下，要求不要在tags/下的里程碑目录下进行提交。但是谁也阻止不了对未进行权限控制的里程碑的篡改。</p><h2 id="62-git-的轻量级分支和里程碑"><a class="markdownIt-Anchor" href="#62-git-的轻量级分支和里程碑"></a> 6.2 Git 的轻量级分支和里程碑</h2><p>Git中的分支实际上仅是一个包含所指对象校验和（40个字符长度SHA-1 哈希值）的文件，所以创建和销毁一个分支就变得非常廉价。说白了，新建一个分支就是向一个文件写入41个字节（版本号外加一个换行符）那么简单，自然速度就很快了。 Git的实现与项目复杂度无关，它永远可以在几毫秒的时间内完成分支的创建和切换。这和大多数版本控制系统形成了鲜明对比。</p><p>Git的分支是完全隔离的，而Subversion则没有。分支本来就应该是相对独立的命名空间，一个提交一般只能发生在一个分支中。在Git中，其内部的对象层级依赖关系或许和SVN类似，但是其工作树的视图表现形式和SVN完全不同。工作树永远是一个完整的分支，不同的分支由不同的head索引去构建，你不可能在工作树中同时获得多个分支的内容。</p><p>Git使用的标签有两种类型：轻量级的（lightweight）和含附注的（annotated）。</p><p>① 轻量级标签就像是个不会变化的分支，实际上它就是个指向特定提交对象的引用。</p><p>② 而含附注标签，实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，电子邮件地址和日期，以及标签说明，标签本身也允许使用GNU Privacy Guard (GPG) 来签署或验证。</p><p>Git的里程碑是只读的，Git完全遵守历史不可更改这一时空法则。用户不能向git的里程碑中提交，否则里程碑就不是标记，而成了一个分支。当然Git允许用户删除里程碑再重新创建指定到不同历史提交。</p><h2 id="63-多分支间的切换"><a class="markdownIt-Anchor" href="#63-多分支间的切换"></a> 6.3 多分支间的切换</h2><p>SVN中提供了一个功能switch，使用switch可以在同一个工作树上，在不同的分支中进行切换。</p><p>Git在分支中进行切换使用的命令是checkout。</p><h1 id="7-分支与合并"><a class="markdownIt-Anchor" href="#7-分支与合并"></a> 7 分支与合并</h1><p>Git 和 Svn 的分支实现机制完全的不同，这也直接导致了 SVN 在分支合并中困难重重。尽管在 SVN 1.5 之后，通过 svn:mergeinfo 属性引入了合并追踪机制，但是在特定情况下，合并仍会出现很多困难。</p><h2 id="71-svn的分支合并"><a class="markdownIt-Anchor" href="#71-svn的分支合并"></a> 7.1 SVN的分支合并</h2><p>当你在一个分支上工作数周或几个月之后，主干的修改也同时在进行着，两条线的开发会区别巨大，当你想合并分支回主干，可能因为太多冲突，已经无法轻易合并你的分支和主干的修改。</p><p>另一个问题，Subversion不会记录任何合并操作，当你提交本地修改，版本库并不能判断出你是通过svn merge还是手工修改得到这些文件。所以你必须手工记录这些信息（说明合并的特定版本号或是版本号的范围）。</p><p>要解决以上的问题只有通过有规律的将主干合并到分支来避免，制定这样一个政策：每周将上周的修改合并到分支，注意这样做时需要小心，你必须手工记录合并的过程，以避免重复的合并，你需要小心的撰写合并的日志信息，精确的描述合并包括的范围。这样做看起来有点像是胁迫。</p><p>SVN 的版本号是连续的版本号。每一次新的提交都会版本号+1 ，而无论这个提交是在哪个分支中进行的。SVN一个提交可以同时修改不同分支的不同文件，因为提交命令可以在 /trunk, /branches, /tags 的上一级目录执行。</p><ul><li>SVN 的提交是单线索的，每一个提交（最原始的提交0除外）都只有一个父节点（版本号小一个的提交节点）</li><li>SVN 的提交链只有一条，仅从版本号和提交说明，我们无法获得分支图</li><li>SVN 的分支图在某些工具（如乌龟SVN）可以提供，那是需要对提交内容进行检查，对目录拷贝动作视为分支，对 svn:mergeinfo 的改动视为合并，但这会由于目录管理的灵活性，导致千奇百怪的分支图表。</li></ul><h2 id="72-git的分支合并"><a class="markdownIt-Anchor" href="#72-git的分支合并"></a> 7.2 Git的分支合并</h2><p>在 git 版本库中创建分支的成本几乎为零，所以，不必吝啬多创建几个分支。当第一次执行git-init时，系统就会创建一个名为”master”的分支。 而其它分支则通过手工创建。下面列举一些常见的分支策略。</p><p>① 创建一个属于自己的个人工作分支，以避免对主分支 master 造成太多的干扰，也方便与他人交流协作。<br>② 当进行高风险的工作时，创建一个试验性的分支，扔掉一个烂摊子总比收拾一个烂摊子好得多。<br>③ 合并别人修改的时候，最好创建一个临时的分支用来合并，合并完成后再“fatch”到自己的分支。</p><p>Git分支相关的操作命令</p><h1 id="8-撤消操作"><a class="markdownIt-Anchor" href="#8-撤消操作"></a> 8 撤消操作</h1><h2 id="81-提交的撤销"><a class="markdownIt-Anchor" href="#81-提交的撤销"></a> 8.1 提交的撤销</h2><p>在Subversion中一旦完成向服务器的数据提交，你就没有办法再从客户端追回，只能在后续的提交中修正（回退或者修改）等。因为Subversion作为集中式的版本控制，不能允许个人对已提交的数据进行篡改。Subversion具有一个非常重要的特性就是它的信息从不丢失，即使当你删除了文件或目录，它也许从最新版本中消失了 ，但这个对象依然存在于历史的早期版本中。</p><p>Git则不同，Git是分布式版本控制系统，代码库是属于个人，允许任意修改。Git通过对提交建立数字摘要来保证提交的唯一性和不可更改性，通过版本库在多人之间的多份拷贝来保障数据的安全性。Git可以丢弃最新的一个或几个提交，使用 git reset –hard命令可以永远丢弃最新的一个或者几个提交。</p><h2 id="82-提交说明的修改"><a class="markdownIt-Anchor" href="#82-提交说明的修改"></a> 8.2 提交说明的修改</h2><p>提交后如果对提交说明不满意，如何实现对提交说明的修改：</p><ol><li>Git可以使用命令git commit –amend修改提交说明。<ul><li>Git可以修改最后一次提交说明，并不是说不能修改历史版本的提交说明，只是修改最后一个版本提交说明拥有最简单的命令；</li><li>Git修改提交说明，会改变提交的commit-id。即修改提交说明后，将产生一个新的提交；</li><li>Git可以通过git reset –hard ，git commit –amend，git rebase onto 等命令来实现对历史提交的修改；</li><li>使用stg工具可以更为简单的修改历史提交的提交说明，包括提交内容；</li></ul></li><li>Subversion也可以修改提交说明，是通过修改提交的svn:log版本属性实现的：<ul><li>不但可以修改最后一次提交的说明，并且可以修改历史提交的提交说明；</li><li>Subversion修改提交说明是不可逆的操作，可能会造成说明被恶意修改；</li><li>Subversion缺省关闭修改提交说明的功能。管理员在设置了提交说明更改的邮件通知后，才可以打开该功能。</li></ul></li></ol><h2 id="83-修改和重构历史提交"><a class="markdownIt-Anchor" href="#83-修改和重构历史提交"></a> 8.3 修改和重构历史提交</h2><p>Git可以修改和重构历史提交：使用Git本身的reset以及 rebase 命令可以修改或者重整/重构历史提交，非常灵活。使用强大的 stg 可以使得历史提交的重构更为简洁，如果您对 stg 或者 Hg/MQ 熟悉的话。</p><p>Subversion 修改历史提交，只能由管理员完成。</p><p>Subversion 是集中式版本控制系统，从客户端一旦完成提交，就没有办法从客户端撤销提交。但是管理员可以在服务器端完成提交的撤销和修改，但是操作过程和代价较大。</p><h1 id="9-权限管理"><a class="markdownIt-Anchor" href="#9-权限管理"></a> 9 权限管理</h1><p>Subversion通过对文件目录授权来实现权限管理，子目录默认继承父目录的权限。但是也有缺憾，即权限不能在分支中继承，不能对单个文件授权。例如为 /trunk及其子目录的授权，不能继承到分支或者标签中相应的目录下。</p><p>Git 的授权做不到Subversion那样精细。Git的授权模型只能实现非零即壹式的授权，要么拥有全部的写权限，要么没有写权限，要么拥有整个版本库的读权限，要么禁用。</p><p>从技术上将，Git可能永远也做不到类似SVN的路径授权（读授权）：</p><ul><li>如果允许按照路径授权，则各个克隆的关系将不再是平等的关系，有的内容多，有的内容少，分布式的理念被破坏</li><li>如果只有部分路径可读，则克隆出来的提交和原始提交的提交ID可能不同。因为提交ID是和提交内容有关的，克隆中提交的部分内容被丢弃，势必提交的ID也要重新计算</li><li>允许全部代码可读，只允许部分代码可写，在版本控制的管理下，是没有多大实际意义的，而且导致了提交的逻辑上的不完整。</li></ul><p>那么有什么办法来解决授权的问题？</p><ol><li>公司内部代码开放。即代码在公司内部，对项目组成员一视同仁的开放。</li><li>公司对代码库进行合理分解，对每个代码库分别授权。即某个代码库对团队成员完全开放，对其它团队完全封闭。</li><li>公司使用Subversion做集中式的版本控制，个人和/或团队使用 Git-svn。这样在无法改变公司版本控制策略时，程序员可以采用的变通之法。</li><li>Git服务器的部署实际上可以使用钩子对分支和路径进行写授权，即可以控制谁能够创建分支，能够写特定文件。</li></ol><h1 id="10-优缺点比较"><a class="markdownIt-Anchor" href="#10-优缺点比较"></a> 10 优缺点比较</h1><h2 id="101-svn优缺点"><a class="markdownIt-Anchor" href="#101-svn优缺点"></a> 10.1 SVN优缺点</h2><p><strong>优点</strong>：</p><ol><li>管理方便，逻辑明确，符合一般人思维习惯。</li><li>易于管理，集中式服务器更能保证安全性。</li><li>代码一致性非常高。</li><li>适合开发人数不多的项目开发。</li></ol><p><strong>缺点</strong>：</p><ol><li>服务器压力太大，数据库容量暴增。</li><li>如果不能连接到服务器上，基本上不可以工作，看上面第二步，如果服务器不能连接上，就不能提交，还原，对比等等。</li><li>不适合开源开发（开发人数非常非常多，但是Google app engine就是用svn的）。但是一般集中式管理的有非常明确的权限管理机制（例如分支访问限制），可以实现分层管理，从而很好的解决开发人数众多的问题。</li></ol><h2 id="102-git优缺点"><a class="markdownIt-Anchor" href="#102-git优缺点"></a> 10.2 Git优缺点</h2><p><strong>优点</strong>：</p><ol><li>适合分布式开发，强调个体。</li><li>公共服务器压力和数据量都不会太大。</li><li>速度快、灵活。</li><li>任意两个开发者之间可以很容易的解决冲突。</li><li>离线工作。</li></ol><p><strong>缺点</strong>：</p><ol><li>学习周期相对而言比较长。</li><li>不符合常规思维。</li><li>代码保密性差，一旦开发者把整个库克隆下来就可以完全公开所有代码和版本信息。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 环境与工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指针 vs 引用 vs 指针引用</title>
      <link href="/2022/04/18/%E6%8C%87%E9%92%88-vs-%E5%BC%95%E7%94%A8-vs-%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8/"/>
      <url>/2022/04/18/%E6%8C%87%E9%92%88-vs-%E5%BC%95%E7%94%A8-vs-%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-引入"><a class="markdownIt-Anchor" href="#1-引入"></a> 1 引入</h1><p>待补充</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 待补充 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数打桩</title>
      <link href="/2022/04/18/%E5%87%BD%E6%95%B0%E6%89%93%E6%A1%A9/"/>
      <url>/2022/04/18/%E5%87%BD%E6%95%B0%E6%89%93%E6%A1%A9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p><strong>转载</strong>：<a href="https://sim41.com/2019/11/28/stub/" target="_blank" rel="noopener">stub</a></p></blockquote><h1 id="1-定义"><a class="markdownIt-Anchor" href="#1-定义"></a> 1 定义</h1><p>函数打桩，就是将一个函数用另一个函数实现(桩代码)进行替换，以达到在原有函数入口的位置执行新的实现。函数打桩类似于Windows系统中的钩子Hook，不过Hook针对的是事件，这里针对的是函数，或者说是函数的入口。在做C的Cunit单元测试时，遇到了这样的概念，在此梳理一下。</p><h1 id="2-目的"><a class="markdownIt-Anchor" href="#2-目的"></a> 2 目的</h1><p>函数打桩的目的一般是隔离、占位和控制，这里是参考其他博主的文章进行的大概分类，其实也不是很严格。</p><p>隔离就是将复杂的函数从程序中隔离，比如一个复杂的嵌套函数，如果只想要知道前几步的运行结果，则可以在调用下一层函数时替换一个简单的实现，甚至直接return。在进行流程的测试时比较常见。</p><p>占位就是对一些未实现的函数进行占位，多见于协同开发中，对于其他人完成的函数可以先使用空函数进行占位。</p><p>控制就是将原本的函数功能进行替换，控制流程。如在测试中，替换函数部分内容得到需要的结果，以进行单元测试。或者对一些系统函数进行替换，实现自己的功能。如常见的将内存分配的函数替换为自己重写的内存池分配等，这里就是一个函数Hook。</p><h1 id="3-方法"><a class="markdownIt-Anchor" href="#3-方法"></a> 3 方法</h1><h2 id="31-编译时打桩"><a class="markdownIt-Anchor" href="#31-编译时打桩"></a> 3.1 编译时打桩</h2><p>用宏定义#define，在预处理时进行字符串替换，将原函数定义成桩函数的形式。同时可以使用条件编译来控制编译选项。</p><h2 id="32-链接时打桩"><a class="markdownIt-Anchor" href="#32-链接时打桩"></a> 3.2 链接时打桩</h2><p>将桩函数定义到新的库文件中，并在原代码基础上增加条件编译选项，屏蔽原有的库，采用桩函数库。</p><h2 id="33-运行时打桩"><a class="markdownIt-Anchor" href="#33-运行时打桩"></a> 3.3 运行时打桩</h2><p>运行时打桩是对内存的应用，我们知道程序的函数是在代码段中存储，一个函数的操作对应一个栈帧的存储地址，如果在调用函数时，在一旦访问这个栈帧，我们就使它跳转到我们需要的桩函数去，那么也就实现了函数的打桩。这种方法要复杂一点，但是不需要对原有的代码进行修改，而是额外增加了打桩和还原的操作，在进行单元测试时也常用。</p><p>简单来说，就是读取到原函数指令的地址，并读取桩函数的地址，并使用jmp命令从原函数跳转到桩函数去，以实现打桩。</p><p>一个完整的打桩流程应该分为装载和卸载，因此需要做到的是记录原函数的函数指针，记录桩函数的函数指针，计算地址差值，调用jmp指令，完成桩函数的装载。使用完成后，再删除jmp指令，恢复原函数。此间由于操作系统对于进程的保护机制，可能存在对于进程内存的解锁和权限设置，将指定内存区域设定为可读可写可操作的权限。</p><h3 id="331-数据结构"><a class="markdownIt-Anchor" href="#331-数据结构"></a> 3.3.1 数据结构</h3><p>设定一个链表用于存储原函数、桩函数之间的对应关系，使用链表是为了动态分配同时记录多个函数。数据结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stub</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stub</span> *<span class="title">node</span>;</span></span><br><span class="line"><span class="keyword">void</span> *orig_f;<span class="comment">//原函数的函数指针</span></span><br><span class="line"><span class="keyword">void</span> *stub_f;<span class="comment">//桩函数的函数指针</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> old_flg;<span class="comment">//存储原有内存的权限</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> assm[<span class="number">5</span>];<span class="comment">//用于暂存原函数起始的5字节指令，用于被jmp指令(0xE9 + 4bytes地址)覆盖后恢复</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="332-设置内存的保护属性"><a class="markdownIt-Anchor" href="#332-设置内存的保护属性"></a> 3.3.2 设置内存的保护属性</h3><p>在Linux下，mprotect()函数可以用于更改指定内存区域的保护属性。原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mprotect</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> prot)</span></span>;</span><br><span class="line"><span class="comment">//addr为内存起始地址，必须是内存页的起始地址</span></span><br><span class="line"><span class="comment">//len为内存区域长度,以字节为单位，必须是页大小的整数倍</span></span><br><span class="line"><span class="comment">//prot为权限值，类似于Linux的权限值</span></span><br></pre></td></tr></table></figure><p>同样，在Windows下，采用读取系统的页大小:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">long</span> pagesize = sysconf(_SC_PAGESIZE);</span><br></pre></td></tr></table></figure><p>计算内存页的起始地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">pageof</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">void</span> *)((<span class="keyword">unsigned</span> <span class="keyword">long</span>)p &amp; ~(pagesize - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="333-安装桩函数"><a class="markdownIt-Anchor" href="#333-安装桩函数"></a> 3.3.3 安装桩函数</h3><p>计算原函数与桩函数地址的偏移量，将原函数的入口5字节指令替换为jmp [offset]，同时缓存原本的5字节，用于后续的恢复。</p><p>jmp指令对应0xE9，后续为4字节的偏移量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">install_stub</span><span class="params">(<span class="keyword">void</span> *orig_f, <span class="keyword">void</span> *stub_f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//初始化stub数据结构</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stub</span> *<span class="title">pstub</span> = <span class="title">calloc</span>(1, <span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">stub</span>));</span></span><br><span class="line">  pstub-&gt;orig_f = orig_f;</span><br><span class="line">  pstub-&gt;stub_f = stub_f;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//设置内存保护属性</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="number">-1</span> == mprotect(pageof(orig_f), pagesize * <span class="number">2</span>, PROT_READ | PROT_WRITE | PROT_EXEC))</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"mprotect to w+r+x faild"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(errno);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//缓存原函数orig_f头部的5字节指令</span></span><br><span class="line">  <span class="built_in">memcpy</span>(pstub-&gt;assm, pstub-&gt;orig_f, <span class="keyword">sizeof</span>(pstub-&gt;assm));</span><br><span class="line">  <span class="comment">//将头部重写为jmp [offset]</span></span><br><span class="line">  *((<span class="keyword">char</span>*)pstub-&gt;orig_f) = <span class="number">0xE9</span>;</span><br><span class="line">  offset = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)((<span class="keyword">long</span>)pstub-&gt;stub_f - ((<span class="keyword">long</span>)pstub-&gt;orig_f + <span class="number">5</span>));</span><br><span class="line">  *((<span class="keyword">unsigned</span> <span class="keyword">int</span>*)((<span class="keyword">char</span>*)pstub-&gt;orig_f + <span class="number">1</span>)) = offset;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//如果有多线程同时操作，加锁</span></span><br><span class="line">  <span class="comment">//lock()；</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//如果对多个函数打桩，维护struct stub 链表</span></span><br><span class="line">  <span class="comment">//list_add(&amp;ptsub-&gt;node, &amp;head)；</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//unlock();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="334-卸载桩函数"><a class="markdownIt-Anchor" href="#334-卸载桩函数"></a> 3.3.4 卸载桩函数</h3><p>将原函数开始的5字节恢复，并释放stub结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uninstall_stub</span><span class="params">(<span class="keyword">void</span> *stub_f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//从桩函数链表中找到要释放的桩函数对应的数据结构</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stub</span> *<span class="title">pstub</span> = <span class="title">NULL</span>:</span></span><br><span class="line">  pstub = find_pstub(stub_f);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//设置内存保护属性</span></span><br><span class="line">  mprotect(pageof(pstub-&gt;orig_f), pagesize * <span class="number">2</span>, PROT_READ | PROT_WRITE | PROT_EXEC);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//恢复原函数的初始5字节指令</span></span><br><span class="line">  <span class="built_in">memcpy</span>(pstub-&gt;orig_f, pstub-&gt;assm, <span class="keyword">sizeof</span>(pstub-&gt;assm));</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//删除节点</span></span><br><span class="line">  del_node(pstub)；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码只包含了关键代码，部分声明省略，并未对异常情况进行处理。</p><h1 id="4-进程内存安全"><a class="markdownIt-Anchor" href="#4-进程内存安全"></a> 4 进程内存安全</h1><p>这里的函数打桩利用jmp指令将原有的函数入口跳转到了我们指定的桩函数入口，自然会想到在非法情况下，也利用jmp将原本的函数跳转到指定的函数去。其实这也是一些病毒的做法，跳转到非法代码；或者一些软件破解的方法，将原本的验证机制跳转屏蔽。只不过我们打桩时是在同一进程内部进行了跳转，且是在获取源码到情况下进行的。而在破解和攻击时，一般只有可执行文件的二进制代码，此时可以通过反汇编得到程序的汇编指令，并找到需要修改的函数入口。在攻击时，也存在另外一个问题，就是跨进程的权限，在进程外对进程的内存进行修改。</p><p>操作系统对内存的保护，采取了虚拟地址空间（进程独立的虚拟内存），内存起点的随机偏移量（不能找到代码段段入口）等方式。而且mprotect()仅可以对同一进程的内存块进行修改。如果想要修改其他进程的内存块的保护属性，就要从两个方面下手，一是变成同一个进程，另一个则是对mprotect()动手脚。</p><p>当成同一个进程，可以使用代码注入，让我们的攻击代码从进程自身发出，则我们的代码就有了通过mprotect改变进程保护属性的权限。</p><p>而对mprotect()做手脚，即实现我们自己的mprotect()函数，让其模仿内核函数的行为，但是却拥有跨进程的能力。这就要编写一个类似于mprotect()函数功能的内核模块。</p><p>具体的操作暂时还没有深入了解，原理如上述所示。</p><h1 id="5-cunit的使用"><a class="markdownIt-Anchor" href="#5-cunit的使用"></a> 5 Cunit的使用</h1><p>CUnit是一个C语言的单元测试框架，以静态链接库的形式，连接到用户代码中。提供了语义丰富的断言和多种测试结果输出接口，可以方便地生成测试报告。可以结合 gcov/lcov等生成测试覆盖度报表。</p><h2 id="51-结构"><a class="markdownIt-Anchor" href="#51-结构"></a> 5.1 结构</h2><p>Cunit的结构基本如下图所示，分为三层，第一层是总的测试入口，第二层是测试包，第三层是测试用例。然后通过一系列的断言展示测试结果。</p><img src="https://s2.loli.net/2022/04/18/mIGRBMVLqA9Urha.jpg" width="500" height="400" alt="图片名称" align="center" id="164"><h2 id="52-基本流程"><a class="markdownIt-Anchor" href="#52-基本流程"></a> 5.2 基本流程</h2><ol><li>编写待测函数对应的测试函数（如果必要，需要写suite的init/cleanup函数）</li><li>初始化Test Registry - CU_initialize_registry()</li><li>把测试包（Test Suites）加入到Test Registry - CU_add_suite()</li><li>把测试用例（Test Case）加入到测试包当中 - CU_add_test()</li><li>使用适当的接口来运行测试测试程序，例如 CU_console_run_tests()</li><li>清除Test Registry - CU_cleanup_registry()</li></ol><h1 id="6-参考"><a class="markdownIt-Anchor" href="#6-参考"></a> 6 参考</h1><p><a href="https://blog.csdn.net/wangwencong/article/details/8189778" target="_blank" rel="noopener">wangwencong-认识单元测试中的打桩</a></p><p><a href="https://www.yanbinghu.com/2019/07/28/59484.html" target="_blank" rel="noopener">守望-库打桩机制-偷梁换柱</a></p><p><a href="https://m.2cto.com/kf/201708/667113.html" target="_blank" rel="noopener">一种C语言”打桩”的源码实现</a></p><p><a href="https://www.freebuf.com/articles/system/191865.html" target="_blank" rel="noopener">Covfefe-深入Linux | 如何在任意进程中修改内存保护（含PoC）</a></p><p><a href="https://promisechen.github.io/kbase/cunit.html" target="_blank" rel="noopener">陈令祥-CUnit测试工具</a></p>]]></content>
      
      
      <categories>
          
          <category> 未分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 待补充 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>华为实习任务-codecheck</title>
      <link href="/2022/04/18/%E5%8D%8E%E4%B8%BA%E5%AE%9E%E4%B9%A0%E4%BB%BB%E5%8A%A1-codecheck/"/>
      <url>/2022/04/18/%E5%8D%8E%E4%B8%BA%E5%AE%9E%E4%B9%A0%E4%BB%BB%E5%8A%A1-codecheck/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-引入"><a class="markdownIt-Anchor" href="#1-引入"></a> 1 引入</h1><p>在华为实习的三个月(2021.9-2021.11)中有两个月(9&amp;11月)都在做codecheck的工作，重复性操作，&quot;毫无&quot;技术含量可言。</p><p>令我惊讶的是：2022年4月份在实习答辩时，我说做了codecheck的工作。一位老师说（具体咋说的忘了，大致意思是：你是实习生，才三个月，华为不会让你改代码的（指核心代码？），你不要吹过头了），当时我愣住了，哈哈哈哈🥦。</p><p>答辩结束后仔细想了下，应该这样说：“实习期间，部门正好有codecheck的任务，我在其中做了一部分工作（包括xxx），改完代码后有检视人员保障代码质量。”</p><p>值得肯定的是：面对老师的奇怪语气+奇怪问法，没有进行反驳，毕竟到时间了（答辩每人10min），而且老师也没有听的意思。</p><p>总而言之，答辩时表达要得体（本次实习答辩自己多多少少存在这方面的问题，可能真是吹的口吻，只是自己没察觉）；认真听取老师的意见，一些情况下没必要进行反驳。还有就是要努力🥦🥦🥦</p><blockquote><p><a href="https://www.bookstack.cn/read/openharmony-1.0-zh-cn/contribute-OpenHarmony-cpp-coding-style-guide.md" target="_blank" rel="noopener">华为c++语言编程规范</a></p></blockquote><h1 id="2-冗余代码"><a class="markdownIt-Anchor" href="#2-冗余代码"></a> 2 冗余代码</h1><p><strong>规则4.4.3 不用的代码段直接删除，不要注释掉</strong></p><p>被注释掉的代码，无法被正常维护；当企图恢复使用这段代码时，极有可能引入易被忽略的缺陷。 正确的做法是，不需要的代码直接删除掉。若再需要时，考虑移植或重写这段代码。</p><p>这里说的注释掉代码，包括用 <code>/* */</code>和 <code>//</code>，还包括 <code>#if 0， #ifdef NEVER_DEFINED</code> 等等。</p><h1 id="3-圈复杂度cyclomatic-complexity"><a class="markdownIt-Anchor" href="#3-圈复杂度cyclomatic-complexity"></a> 3 圈复杂度（Cyclomatic complexity）</h1><p>详见 博客：<code>圈复杂度</code></p><p>定义：软件源码某部分的圈复杂度就是这部分代码中<a href="https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E6%97%A0%E5%85%B3/4705660" target="_blank" rel="noopener">线性无关</a>路径的数量。<a href="https://baike.baidu.com/item/%E5%9C%88%E5%A4%8D%E6%9D%82%E5%BA%A6/828737?fr=aladdin" target="_blank" rel="noopener">百度百科</a></p><p>含huge_cyclomatic_complexity和huge_cca_cyclomatic_complexity两个指标；cyclomatic_complexity和cca_cyclomatic_complexity的计算差异：</p><ul><li>cca_cyclomatic_complexity：不管switch里面有多少个case，圈复杂度只加1</li><li>cyclomatic_complexity：switch里面有多少个case，圈复杂度就加多少</li></ul><p>精髓：覆盖所有的可能情况最少使用的测试用例个数</p><ol><li>?: 三元运算符 +1</li><li>case +1</li><li>default +1</li><li>else +1</li></ol><p>华为规则：圈复杂度改到15以下</p><h1 id="4-超大目录"><a class="markdownIt-Anchor" href="#4-超大目录"></a> 4 超大目录</h1><p>华为规则：超大目录门槛50</p><p>拆分标准：根据数据库表，PDMReader</p><h1 id="5-降低文件重复率"><a class="markdownIt-Anchor" href="#5-降低文件重复率"></a> 5 降低文件重复率</h1><p><strong>问题</strong>：采用抽离函数的方式降DT重复率，但是cpp文件中重复代码过多且存在不同，所以会导致函数参数过多；抽离的函数中使用的if-else也会过多，导致圈复杂度上升；</p><p><strong>解决</strong>：将抽离函数按照功能块再拆分</p><h1 id="6-llvmclang-tidy"><a class="markdownIt-Anchor" href="#6-llvmclang-tidy"></a> 6 llvm(clang-tidy)</h1><p>llvm原生的，华为版本的</p><p>重新下库后需要执行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir cmake_build</span><br><span class="line"><span class="built_in">cd</span>  cmake_build</span><br><span class="line">cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=1 -DCMAKE_TOOLCHAIN_FILE=../cmake/scripts/gcc_all_toolchain.cmake ..</span><br><span class="line">cp ./compile_commands.json ..</span><br><span class="line"><span class="built_in">cd</span> ..</span><br></pre></td></tr></table></figure><p>在01_RB下执行命令，工具路径替换成自己的：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr1/dragon/llvm/tools/clang/tools/extra/clang-tidy/tool/run-clang-tidy.py -check=-*,modernize-use-nullptr,modernize-use-using,modernize-use-override -clang-tidy-binary=<span class="string">'/usr1/dragon/llvm/build/bin/clang-tidy'</span> -clang-apply-replacements-binary=<span class="string">'/usr1/dragon/llvm/build/bin/clang-apply-replacements'</span> -header-filter=./rating_charging/cppcode/tools/* -fix ./rating_charging/cppcode/tools</span><br></pre></td></tr></table></figure><p>自动化修复：</p><ul><li>modernize-use-nullptr</li><li>modernize-use-using：typedef-&gt;using</li><li>modernize-use-override</li></ul><h1 id="7-c类型风格转换"><a class="markdownIt-Anchor" href="#7-c类型风格转换"></a> 7 c++类型风格转换</h1><ul><li>先去了解清楚C++11类型转换的语法</li><li>几种转换使用的场景</li></ul><h1 id="8-超大函数huge-method"><a class="markdownIt-Anchor" href="#8-超大函数huge-method"></a> 8 超大函数（huge method）</h1><p>代码行大于阈值（阈值由产品CMC根据自身情况决策、定义）的函数</p><h1 id="9-gexp35-cpp-使用nullptr作为空指针常量"><a class="markdownIt-Anchor" href="#9-gexp35-cpp-使用nullptr作为空指针常量"></a> 9 G.EXP.35-CPP 使用<code>nullptr</code>作为空指针常量</h1><p><strong>【级别】</strong> 要求</p><p><strong>【描述】</strong></p><p>C++11开始引入了nullptr关键字代表空指针，在此之前使用NULL宏来表示空指针常量，导致出现如下问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL ((void*)0)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* str = <span class="literal">NULL</span>; <span class="comment">// 编译错误: void* 不能自动转换为 char*</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>(C::*pmf)() = &amp;C::Func;</span><br><span class="line"><span class="keyword">if</span> (pmf == <span class="literal">NULL</span>) &#123; <span class="comment">// 编译错误: void* 不能自动转换为指向成员函数的指针</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果把<code>NULL</code>被定义为<code>0</code>或<code>0L</code>。可以解决上面的问题。或者在需要空指针的地方直接使用<code>0</code>。</p><p>但这引入另一个问题，代码不清晰，特别是使用<code>auto</code>自动推导时更为突出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> result =Find(id);</span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">0</span>) &#123;<span class="comment">// Find() 返回的是 指针 还是 整数?</span></span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>0</code>字面上是<code>int</code>类型(<code>0L</code>是<code>long</code>)，所以<code>NULL</code>和<code>0</code>都不是指针类型。</p><p>当重载指针和整数类型的函数时，传递<code>NULL</code>或<code>0</code>都调用到整数类型重载的函数:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line">F(<span class="number">0</span>);<span class="comment">// 调用 F(int)，而非 F(int*)</span></span><br><span class="line">F(<span class="literal">NULL</span>);<span class="comment">// 调用 F(int)，而非 F(int*)</span></span><br></pre></td></tr></table></figure><p>另外，<code>sizeof(NULL) == sizeof(void*)</code>并不一定总是成立的，直接使用<code>0</code>或<code>0L</code>，代码不清晰，且无法做到类型安全；使用<code>NULL</code>无法做到类型安全。这些都是潜在的风险。</p><p><code>nullptr</code>的优势不仅仅是在字面上代表了空指针，使代码清晰，而且它不再是一个整数类型。</p><p><code>nullptr</code>是<code>std::nullptr_t</code>类型，而<code>std::nullptr_t</code>可以隐式的转换为所有的原始指针类型，这使得<code>nullptr</code>可以表现成指向任意类型的空指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span>*)</span></span>;</span><br><span class="line">F(<span class="literal">nullptr</span>);<span class="comment">// 调用 F(int*)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> result =Find(id);</span><br><span class="line"><span class="keyword">if</span> (result ==<span class="literal">nullptr</span>) &#123; <span class="comment">// Find() 返回的是 指针</span></span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="10-gexp03-cpp-使用using定义类型别名"><a class="markdownIt-Anchor" href="#10-gexp03-cpp-使用using定义类型别名"></a> 10 G.EXP.03-CPP 使用using定义类型别名</h1><p>**【级别】**建议</p><p><strong>【描述】</strong></p><p>类型的别名实际是对类型的封装。而通过封装，可以让代码更清晰，同时在很大程度上避免类型变化带来的散弹式修改。</p><p>在<code>C++11</code>之前，可以通过<code>typedef</code>定义类型的别名：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">uint32_t</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; SomeType;</span><br></pre></td></tr></table></figure><p>在<code>C++11</code>之后，提供<code>using</code>，实现<code>声明别名(alias declarations)</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> SomeType = <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">uint32_t</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;;</span><br></pre></td></tr></table></figure><p>对比两者的格式，使用using更容易理解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Type Alias; <span class="comment">// Type 在前，还是 Alias 在前，不宜历届</span></span><br><span class="line"><span class="keyword">using</span> Alias = Type; <span class="comment">// 符合'赋值'的用法，容易理解，不易出错</span></span><br></pre></td></tr></table></figure><p>如果觉得这点还不足以切换到<code>using</code>，我们接着看看<code>模板别名(alias template)</code>更简洁:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义模板的别名，一行代码</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; // <span class="title">template</span></span></span><br><span class="line"><span class="class"><span class="title">using</span> <span class="title">MyAllocatorVector</span> = <span class="title">std</span>:</span>:<span class="built_in">vector</span>&lt;T,MyAllocator&lt;T&gt;&gt;;</span><br><span class="line"></span><br><span class="line">MyAllocatorVector&lt;<span class="keyword">int</span>&gt; data;<span class="comment">// 使用 using 定义的别名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; // <span class="title">template</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        MyAllocatorVector&lt;<span class="keyword">int</span>&gt; data_;<span class="comment">// 模板类中使用 using 定义的别名</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而<code>typedef</code>不支持带模板参数的别名，只能”曲线救国”:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过模板包装 typedef，需要实现一个模板类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">MyAllocatorVector</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T,MyAllocator&lt;T&gt;&gt; type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyAllocatorVector&lt;<span class="keyword">int</span>&gt;::type data; <span class="comment">// 使用 typedef 定义的别名，多写 ::type</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typename</span> MyAllocatorVector&lt;<span class="keyword">int</span>&gt;::type data_; <span class="comment">// 模板类中使用，除了 ::type，还需要加上 typename</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实习中遇到的实例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">typedef</span> TChar NumArray[<span class="number">24</span>];</span><br><span class="line"><span class="keyword">using</span> NumArray = TChar[<span class="number">24</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体c++中，定义变量无需加关键字struct</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    TUInt4 uiAVPcode;</span><br><span class="line">    TUChar ucAVPflag_r : <span class="number">5</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125; AVPHEAD;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AVPHEAD</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数指针</span></span><br><span class="line"><span class="comment">// typedef 返回类型(*新类型)(参数表)</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">RETCODE</span> <span class="params">(*FnFmtFunc)</span><span class="params">(<span class="keyword">const</span> TChar* cdrBuff, TUInt4 cdrLen)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">using</span> FnFmtFunc = RETCODE (*)(<span class="keyword">const</span> TChar* cdrBuff, TUInt4 cdrLen) <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure><h1 id="10-gcls12-cpp-在重写虚函数时应明确指定override或final"><a class="markdownIt-Anchor" href="#10-gcls12-cpp-在重写虚函数时应明确指定override或final"></a> 10  G.CLS.12-CPP 在重写虚函数时应明确指定<code>override</code>或<code>final</code></h1><p>**【级别】**要求</p><p><strong>【描述】</strong></p><p>在重写虚函数时明确指定override或final，能保证该函数是重写了基类的虚函数，并且无需再添加virtual关键字。如果派生类函数与基类函数原型不一致，则产生编译错误。<code>final</code>还保证虚函数不会再被派生类重写。</p><ul><li>virtual 表示一个新的虚函数</li><li>override 表示重写了基类中的虚函数，可以再被派生类重写</li><li>final 表示重写了基类中的虚函数，不能再被派生类重写</li></ul><p>使用<code>override</code>或<code>final</code>关键字后，如果修改了基类虚函数原型，但忘记修改子类重写的虚函数，在编译期就可以发现。也可以避免有多个子类时，重写虚函数的修改遗漏。</p><p><strong>【正例】</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base();</span><br><span class="line">    <span class="keyword">virtual</span> ~Base();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Foo</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Foo</span><span class="params">(<span class="keyword">int</span> var)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Bar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">class <span class="title">Derived</span><span class="params">()</span>: <span class="keyword">public</span> Base </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived();</span><br><span class="line">    ~Derived() <span class="keyword">override</span>; <span class="comment">// 符合：析构函数添加override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">(<span class="keyword">int</span> var)</span> <span class="keyword">final</span></span>; <span class="comment">// 符合：重写基类函数，且Derived的派生类不能再重写此函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">()</span> <span class="keyword">override</span></span>;<span class="comment">// 符合：重写基类函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;<span class="comment">// 编译失败: Derived::Foo 和 Base::Foo 原型不一致，</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Bar</span><span class="params">()</span> <span class="keyword">override</span></span>;<span class="comment">// 编译失败: Base::Bar 不是虚函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><ol><li>基类首次定义虚函数，使用<code>virtual</code>关键字</li><li>子类重写基类虚函数（包括析构函数），使用<code>override</code>或<code>final</code>关键字（但不要两者一起使用），并且不使用<code>virtual</code>关键字</li><li>非虚函数，<code>virtual</code>、<code>override</code>和<code>final</code>都不使用</li></ol><p>【实习实例】</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_SERVICE_PLUGIN(CBypassMsgController);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_SERVICE_PLUGIN(CLASS_NAME) \</span></span><br><span class="line">DECLARE_SERVICE_COMPONET(CLASS_NAME); \</span><br><span class="line"><span class="keyword">protected</span>: \</span><br><span class="line">virtual const TChar* MyName() const \</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> #CLASS_NAME; \</span><br><span class="line">    &#125; \</span><br><span class="line">        </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_SERVICE_PLUGIN(CLASS_NAME) \</span></span><br><span class="line">DECLARE_SERVICE_COMPONET(CLASS_NAME); \</span><br><span class="line"><span class="keyword">protected</span>: \</span><br><span class="line">virtual const TChar* MyName() const override \</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> #CLASS_NAME; \</span><br><span class="line">    &#125; \</span><br></pre></td></tr></table></figure><h1 id="11-gexp29-cpp-比较两个表达式左侧倾向于变化右侧倾向于不变"><a class="markdownIt-Anchor" href="#11-gexp29-cpp-比较两个表达式左侧倾向于变化右侧倾向于不变"></a> 11 G.EXP.29-CPP 比较两个表达式，左侧倾向于变化，右侧倾向于不变</h1><p>**【级别】**建议</p><p><strong>【描述】</strong></p><p>当变量与常量比较时，如果常量放左边，如 if (MAX == v) 不符合阅读习惯，而 if (MAX &gt; v) 更是难于理解。 应当按人的正常阅读、表达习惯，将常量放右边。写成如下方式：</p><p><strong>【正例】</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (value == MAX) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (value &lt; MAX) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也有特殊情况，如：<code>if (MIN &lt; value &amp;&amp; value &lt; MAX)</code> 用来描述区间时，前半段是常量在左的。</p><p>不用担心将 <code>==</code> 误写成 <code>=</code>，因为<code>if (value = MAX)</code> 会有编译告警，其他静态检查工具也会报错。让工具去解决笔误问题，代码要符合可读性第一。</p><p><strong>【脚本误报】</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 逻辑或</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">'N'</span> == cSIPChgSubsNoType || <span class="string">'\0'</span> == cSIPChgSubsNoType) </span><br><span class="line"><span class="keyword">if</span> (cSIPChgSubsNoType == <span class="string">'N'</span> == cSIPChgSubsNoType || <span class="string">'\0'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 逻辑并</span></span><br><span class="line">TBool bContinue = <span class="number">0</span> &gt;= lSecUnpaid &amp;&amp; bSingle;</span><br><span class="line">TBool bContinue = lSecUnpaid &amp;&amp; bSingle &lt;= <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h1 id="12-其他"><a class="markdownIt-Anchor" href="#12-其他"></a> 12 其他</h1><ul><li>G.FMT.02-CPP 使用空格进行缩进，每次缩进4个空格</li><li>G.CMT.03-CPP 文件头注释包含版权说明</li><li>G.CMT.02-CPP 代码注释置于对应代码的上方或右边</li><li>G.FMT.06-CPP 换行时将操作符留在行末，新行缩进一层或进行同类对齐</li><li>G.FMT.09-CPP 构造函数初始化列表放在同一行或按4空格缩进并排多行</li><li>G.FMT.13-CPP case/default语句相对于switch缩进一层</li></ul>]]></content>
      
      
      <categories>
          
          <category> 未分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 重构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Clion项目配置教程</title>
      <link href="/2022/04/17/Clion%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/"/>
      <url>/2022/04/17/Clion%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-下载clion申请license"><a class="markdownIt-Anchor" href="#1-下载clion申请license"></a> 1 下载clion，申请license</h1><ol><li>在clion官网下载安装包（在华为实习时是在IT工具库下载的）；</li><li>申请license，学生邮箱免费使用（公司里面需要审批申请license）；</li></ol><h1 id="2-第一次打开clion前修改缓存位置"><a class="markdownIt-Anchor" href="#2-第一次打开clion前修改缓存位置"></a> 2 第一次打开clion前修改缓存位置</h1><ol><li><p>打开下载目录<code>bin</code>文件夹下<code>idea.properties</code>文件；</p></li><li><p>放开如下注释，并修改<code>idea.config.path</code>和<code>idea.system.path</code>的取值（事先创建这两个目录）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">idea.config.path=目录1</span><br><span class="line">idea.system.path=目录2</span><br><span class="line">idea.plugins.path=$&#123;idea.config.path&#125;/plugins</span><br><span class="line">idea.log.path=$&#123;idea.system.path&#125;/log</span><br></pre></td></tr></table></figure></li></ol><p>这一步是为了避免C盘存放JetBrains的工程缓存内容而被过度占用。</p><p>如果clion已经打开了，也可以修改此配置，只不过可能要重新配置一下clion的初始化步骤。</p><h1 id="3-下载01_rb代码用clion打开"><a class="markdownIt-Anchor" href="#3-下载01_rb代码用clion打开"></a> 3 下载01_RB代码，用clion打开</h1><ol><li>打开部门主仓库；</li><li>Fork自己的仓库；</li><li>安装git并配置，然后将自己的仓库拉到本地。</li></ol><h1 id="4-手动代理设置"><a class="markdownIt-Anchor" href="#4-手动代理设置"></a> 4 手动代理设置</h1><ol><li>点击<code>文件(File)</code>，选择<code>设置(setting)</code>，选择<code>外观和行为——系统设置——HTTP代理</code></li><li>进行配置：<ul><li>主机名：<code>proxy.huawei.com</code></li><li>端口：<code>8080</code></li><li>不为以下项使用代理：<code>127.0.0.1, 10.*.100.*, *.huawei.com</code></li></ul></li></ol><img src="https://s2.loli.net/2022/04/17/LdPivWetjscnFD9.png" width="800" height="400" alt="图片名称" align="center" id="1"><h1 id="5-安装插件"><a class="markdownIt-Anchor" href="#5-安装插件"></a> 5 安装插件</h1><ol><li>打开clion，点击<code>文件(File)</code>，选择<code>设置(settings)</code>，选择<code>插件(plugins)</code>；</li><li>安装以下插件：Chinese，（JetBrains Foundation，Huawei Jetbrains Marketplace，codecheck未找到）</li><li>重启IDE生效</li></ol><h1 id="6-配置远程工作模式"><a class="markdownIt-Anchor" href="#6-配置远程工作模式"></a> 6 配置远程工作模式</h1><ol><li><p><strong>配置工具链</strong>：点击<code>文件(File)</code>，选择<code>设置(setting)</code>，选择<code>构建、执行、部署——工具链</code>，添加远程主机，配置远程主机信息。凭据需要点击后方齿轮进行配置。Make，C编译器，C++编译器会自动检测，不需要配置。</p><img src="https://s2.loli.net/2022/04/17/1u7gXWixpfLIYHT.png" width="1000" height="500" alt="图片名称" align="center" id="2"></li><li><p><strong>配置CMake</strong>：</p><ul><li>CMake 选项：<code>-DCMAKE_TOOLCHAIN_FILE=../cmake/scripts/gcc_ut_toolchain.cmake ..</code></li><li>构建目录：<code>cmake-build-debug</code>（需要与自己项目中的目录对应）</li><li>构建选项：<code>-- -j 32</code>（多线程）</li><li>环境：<code>CHG_HOME=xxx;LD_LIBRARY_PATH=xxx</code>（需要和自己项目中的目录对应）</li></ul></li><li><p><strong>配置部署</strong>：点击<code>文件</code>，选择<code>设置</code>，选择<code>部署</code>，点击<code>映射</code>，配置部署路径：<code>/usr1/dragon/01_RB</code>（改成自己的，远程主机上的项目根目录）</p><img src="https://s2.loli.net/2022/04/17/2h1tioH4Q5snyrp.png" width="1000" height="300" alt="图片名称" align="center" id="3"></li><li><p><strong>Debug配置</strong>：登陆到远程主机，将环境变量添加到<code>~/.bashrc</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> CHG_HOME=xxx</span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=xxx</span><br><span class="line"><span class="built_in">export</span> TZ=BEST-8</span><br><span class="line"><span class="built_in">export</span> BILLING_HOME=xxx</span><br></pre></td></tr></table></figure></li></ol><h1 id="7-clang-format的使用"><a class="markdownIt-Anchor" href="#7-clang-format的使用"></a> 7 clang-format的使用</h1><ol><li>将<code>.clang-fromat</code>文件放到要打开项目的根目录下，CLion会自动启用ClangFormat并应用设置；</li><li>在<code>文件——设置——编辑器——代码样式</code>勾选启用<code>ClangFormat</code>，然后状态栏会显示<code>ClangFormat</code>；</li><li>使用快捷键<code>Ctrl+Alt+L</code>，可以重新格式化选定代码，没有选定代码时，会格式化整个文件；</li></ol><h1 id="8-ut的配置"><a class="markdownIt-Anchor" href="#8-ut的配置"></a> 8 UT的配置</h1><ol><li>选择<code>编辑配置--UTTest</code>，进行配置并应用：<ul><li>程序参数：<code>nolog --gtest_filter=&quot;xxx&quot;</code>（后面的–gtest_filter=&quot;…&quot;是根据CLion输出信息填写的，过滤掉无关报错）</li><li>环境变量：<code>CHG_HOME=xxx;LD_LIBRARY_PATH=xxx;TZ=BEST-8;BILLING_HOME=xxx</code></li></ul></li><li>单个执行配置，在当前界面点击<code>编辑配置模板</code>，选择<code>Google Test</code>，进行配置并应用：<ul><li>目标：选择<code>UTTest</code></li><li>程序参数：不用填</li><li>工作目录：<code>\usr1\dragon\01_RB\test\rating_charging\cppcode\90_uttest\bin</code> （需要改成自己的）</li><li>环境变量：<code>CHG_HOME=xxx;LD_LIBRARY_PATH=xxx;TZ=BEST-8;BILLING_HOME=xxx</code>（需要改成自己的）</li></ul></li></ol><h1 id="9-编译"><a class="markdownIt-Anchor" href="#9-编译"></a> 9 编译</h1><p>点击运行按钮，如果出现下面的报错：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c++: internal compiler error</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>编译内部错误有可能是后台内存不足导致的，点击左边的构建按钮，可能会编译成功。</p><p>如果后面再出现这种错误，就把<code>构建选项</code>中的数字改小一点：<code>-- -j 32</code></p>]]></content>
      
      
      <categories>
          
          <category> 环境与工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins配置定时发送邮件功能</title>
      <link href="/2022/04/16/Jenkins%E9%85%8D%E7%BD%AE%E5%AE%9A%E6%97%B6%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E5%8A%9F%E8%83%BD/"/>
      <url>/2022/04/16/Jenkins%E9%85%8D%E7%BD%AE%E5%AE%9A%E6%97%B6%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="0-安装jenkins"><a class="markdownIt-Anchor" href="#0-安装jenkins"></a> 0 安装Jenkins</h1><p><a href="https://cloud.tencent.com/developer/article/1666282" target="_blank" rel="noopener">如何在 Ubuntu 20.04 上安装 Jenkins</a></p><p>Jenkins 是最流行的，开源的，基于 Java 的自动化服务器，它允许你很容易地设置一个<a href="https://cloud.tencent.com/product/coding-ci?from=10680" target="_blank" rel="noopener">持续集成</a>和持续发布的管道。</p><p>持续集成 (CI)是一个 DevOps 实践。当团队成员正常提交代码到版本控制仓库时，会运行自动化构建和测试。持续发布（CD）是一系列实践，当代码修改后，自动构建，测试，并且发布到生产环境中。</p><p>Jenkins 可以被作为一个独立应用安装，作为 Java servlet 容器（例如 Apache Tomcat）中的一个 servlet 安装，或者 以 Docker 容器的形式运行。</p><p>独立服务的形式安装 Jenkins：</p><h1 id="1-发送邮件"><a class="markdownIt-Anchor" href="#1-发送邮件"></a> 1 发送邮件</h1><h2 id="11-设置参数"><a class="markdownIt-Anchor" href="#11-设置参数"></a> 1.1 设置参数</h2><p>为了使得下面脚本成功执行，需要设置以下参数：</p><ul><li><strong>Receiver</strong> 邮件接收邮箱</li><li><strong>Copyer</strong> 邮件抄送邮箱</li><li><strong>Subject</strong> 邮件主题</li><li><strong>ReportLink</strong> 邮件链接</li><li><strong>ReportFile</strong> 邮件报告文件（本次测试中未使用）</li></ul><p>样例如下：</p><img src="https://s2.loli.net/2022/04/17/jkUSXfEdhbH4C6M.png" width="700" height="500" alt="图片名称" align="center" id="162"><h2 id="12-运行脚本"><a class="markdownIt-Anchor" href="#12-运行脚本"></a> 1.2 运行脚本</h2><p>该脚本在<code>01_RB</code>工程中已存在，根据需求修改即可。路径：<code>test/install/AutoInstallRB/icp/send_report_email.py</code></p><p>运行脚本：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 send_report_email.py -u <span class="string">"用户ID/codehub密码的Base64编码"</span> <span class="string">"本人邮箱"</span> <span class="string">"<span class="variable">$Receiver</span>"</span> <span class="string">"<span class="variable">$Copyer</span>"</span> <span class="string">"<span class="variable">$ReportFile</span>"</span> <span class="string">"<span class="variable">$Subject</span>"</span> <span class="string">"<span class="variable">$ReportLink</span>"</span></span><br></pre></td></tr></table></figure><p><code>send_report_email.py</code>脚本路径目录：<code>E:\04 Worker_work\01 实习\202109-华为C++后端实习\hw-addlcov\CBS-SW\01_RB\scripts</code></p><h1 id="2-jenkins-定时任务时间设置"><a class="markdownIt-Anchor" href="#2-jenkins-定时任务时间设置"></a> 2 Jenkins 定时任务时间设置</h1><h2 id="21-定时任务的时间格式"><a class="markdownIt-Anchor" href="#21-定时任务的时间格式"></a> 2.1 定时任务的时间格式</h2><p>定时任务的时间格式设定遵循的是cron的语法规则。具体的格式划分为5个字段：分别为 分钟、小时、日、月、星期、通过tab或者空格进行隔离区分</p><table><thead><tr><th style="text-align:center">字段</th><th style="text-align:center">*</th><th style="text-align:center">*</th><th style="text-align:center">*</th><th style="text-align:center">*</th><th style="text-align:center">*</th></tr></thead><tbody><tr><td style="text-align:center">含义</td><td style="text-align:center">分钟</td><td style="text-align:center">小时</td><td style="text-align:center">日期</td><td style="text-align:center">月份</td><td style="text-align:center">星期</td></tr><tr><td style="text-align:center">取值范围</td><td style="text-align:center">0-59</td><td style="text-align:center">0-23</td><td style="text-align:center">1月30日</td><td style="text-align:center">1月11日</td><td style="text-align:center">0-7</td></tr><tr><td style="text-align:center"><strong>实例</strong></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">每隔15分钟执行一次</td><td style="text-align:center">H/15</td><td style="text-align:center">*</td><td style="text-align:center">*</td><td style="text-align:center">*</td><td style="text-align:center">*</td></tr><tr><td style="text-align:center">每隔2小时执行一次</td><td style="text-align:center">H</td><td style="text-align:center">H/2</td><td style="text-align:center">*</td><td style="text-align:center">*</td><td style="text-align:center">*</td></tr><tr><td style="text-align:center">每隔3天执行一次</td><td style="text-align:center">H</td><td style="text-align:center">H</td><td style="text-align:center">H/3</td><td style="text-align:center">*</td><td style="text-align:center">*</td></tr><tr><td style="text-align:center">每隔3天执行一次（每月1-15号）</td><td style="text-align:center">H</td><td style="text-align:center">H</td><td style="text-align:center">1-15/3</td><td style="text-align:center">*</td><td style="text-align:center">*</td></tr><tr><td style="text-align:center">每隔1、3、5执行一次</td><td style="text-align:center">H</td><td style="text-align:center">H</td><td style="text-align:center">*</td><td style="text-align:center">*</td><td style="text-align:center">1,3,5</td></tr><tr><td style="text-align:center"><strong>规则</strong></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">指定时间范围</td><td style="text-align:center">a-b</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">指定时间间隔</td><td style="text-align:center">/</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">指定变量取值</td><td style="text-align:center">a,b,c</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><p>参数含义：</p><ol><li>*代表 匹配范围内所有值</li><li>M-N 匹配M~N范围内所有值</li><li>M-N/X 或者 */X 在指定M~N范围内或整个有效区间内每隔X构建一次</li><li>A,B,…,Z 匹配多个值</li></ol><h2 id="22-一些常用的时间规则"><a class="markdownIt-Anchor" href="#22-一些常用的时间规则"></a> 2.2 一些常用的时间规则</h2><table><thead><tr><th style="text-align:center">时间规则</th><th style="text-align:center">规则内容</th></tr></thead><tbody><tr><td style="text-align:center">每天上午9点定时构建</td><td style="text-align:center">H 9 * * *</td></tr><tr><td style="text-align:center">每天上午11点和下午6点定时构建</td><td style="text-align:center">H 11,18 * * *</td></tr><tr><td style="text-align:center">每个小时的前30分钟内，每10分钟构建一次</td><td style="text-align:center">H(0-29)/10 * * * *</td></tr><tr><td style="text-align:center">周一到周五，9-16点，每2小时的第45分钟构建一次</td><td style="text-align:center">45 9-16/2 * * 1-5</td></tr><tr><td style="text-align:center">每个工作日从早上9点到下午5点这段时间内每间隔2小时之间的某刻。(或许在上午10:38, 下午12:38, 下午2:38 , 下午4:38)</td><td style="text-align:center">H H(9-16)/2 * * 1-5</td></tr><tr><td style="text-align:center">每月（除了12月）从1号到15号这段时间内某刻</td><td style="text-align:center">H H 1,15 1-11 *</td></tr></tbody></table><h2 id="23-样例"><a class="markdownIt-Anchor" href="#23-样例"></a> 2.3 样例</h2><img src="https://s2.loli.net/2022/04/17/YfT4HG5mLbhXBPF.png" width="800" height="500" alt="图片名称" align="center" id="163">]]></content>
      
      
      <categories>
          
          <category> 环境与工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>圈复杂度</title>
      <link href="/2022/04/15/%E5%9C%88%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
      <url>/2022/04/15/%E5%9C%88%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p><strong>转载</strong>：<a href="http://kaelzhang81.github.io/2017/06/18/%E8%AF%A6%E8%A7%A3%E5%9C%88%E5%A4%8D%E6%9D%82%E5%BA%A6/#" target="_blank" rel="noopener">详解圈复杂度</a></p></blockquote><h1 id="1-圈复杂度概念"><a class="markdownIt-Anchor" href="#1-圈复杂度概念"></a> 1 圈复杂度概念</h1><p>圈复杂度（Cyclomatic complexity，简写CC）也称为条件复杂度，是一种代码复杂度的衡量标准。由托马斯·J·麦凯布（Thomas J. McCabe, Sr.）于1976年提出，用来表示程序的复杂度，其符号为VG或是M。它可以用来衡量一个模块判定结构的复杂程度，数量上表现为独立现行路径条数，也可理解为覆盖所有的可能情况最少使用的测试用例数。圈复杂度大说明程序代码的判断逻辑复杂，可能质量低且难于测试和维护。程序的可能错误和高的圈复杂度有着很大关系。</p><h1 id="2-圈复杂度计算方法"><a class="markdownIt-Anchor" href="#2-圈复杂度计算方法"></a> 2 圈复杂度计算方法</h1><h2 id="21-点边计算法"><a class="markdownIt-Anchor" href="#21-点边计算法"></a> 2.1 点边计算法</h2><img src="https://s2.loli.net/2022/04/16/BrNW3etERXLkhgD.jpg" width="400" height="300" alt="图片名称" align="center" id="154"><p>圈复杂度的计算方法很简单，计算公式为：</p><blockquote><p>V(G) = E - N + 2</p></blockquote><p>其中，e表示控制流图中边的数量，n表示控制流图中节点的数量。</p><p>几个节点通过边连接。下面是典型的控制流程，如if-else，While，until和正常的流程顺序：</p><img src="https://s2.loli.net/2022/04/16/g4uVjXO2MIixykz.png" width="400" height="300" alt="图片名称" align="center" id="155"><h2 id="22-节点判定法"><a class="markdownIt-Anchor" href="#22-节点判定法"></a> 2.2 节点判定法</h2><p>其实，圈复杂度的计算还有更直观的方法，因为圈复杂度所反映的是“判定条件”的数量，所以圈复杂度实际上就是等于判定节点的数量再加上1，也即控制流图的区域数，对应的计算公式为：</p><blockquote><p>V (G) = P + 1</p></blockquote><p>其中P为判定节点数，判定节点举例：</p><ol><li>if语句</li><li>while语句</li><li>for语句</li><li>case语句</li><li>catch语句</li><li>and和or布尔操作</li><li>?:三元运算符</li></ol><p>对于多分支的CASE结构或IF-ELSEIF-ELSE结构，统计判定节点的个数时需要特别注意一点，要求必须统计全部实际的判定节点数，也即每个ELSEIF语句，以及每个CASE语句，都应该算为一个判定节点。</p><p>判定节点在模块的控制流图中很容易被识别出来，所以，针对程序的控制流图计算圈复杂度V(G)时，一般采用点边计算法，也即V(G)=e-n+2；而针对模块的控制流图时，可以直接使用统计判定节点数，这样更为简单。</p><h1 id="3-圈复杂度计算练习"><a class="markdownIt-Anchor" href="#3-圈复杂度计算练习"></a> 3 圈复杂度计算练习</h1><h2 id="31-练习1"><a class="markdownIt-Anchor" href="#31-练习1"></a> 3.1 练习1：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> * A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        j = i +<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span>(j &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] &lt; A[j])</span><br><span class="line">                 swap(A[i], A[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用点边计算法绘出控制流图：</p><img src="https://s2.loli.net/2022/04/16/12dtWP4XsOMEHjU.png" width="400" height="300" alt="图片名称" align="center" id="156"><p>其圈复杂度为：V(G) = 9 - 7 + 2 = 4</p><h2 id="32-练习2"><a class="markdownIt-Anchor" href="#32-练习2"></a> 3.2 练习2：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">U32 <span class="title">find</span> <span class="params">(<span class="built_in">string</span> match)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> var : <span class="built_in">list</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(var == match &amp;&amp; from != INVALID_U32) <span class="keyword">return</span> INVALID_U32;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//match step1</span></span><br><span class="line">    <span class="keyword">if</span>(session == getName() &amp;&amp; key == <span class="built_in">getKey</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; kv : Map)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (kv.second == last &amp;&amp; match == kv.first)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> last;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//match step2</span></span><br><span class="line">    <span class="keyword">auto</span> var = Map.<span class="built_in">find</span>(match);</span><br><span class="line">    <span class="keyword">if</span>(var != Map.<span class="built_in">end</span>()&amp;&amp; (from != var-&gt;second)) <span class="keyword">return</span> var-&gt;second;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//match step3</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> var: Map)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((var.first, match) &amp;&amp; from != var.second)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> var.second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> INVALID_U32;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其圈复杂度为：V(G) = 1(for) + 2(if) + 2(if) + 1(for) + 2(if) + 2(if) + 1(for) + 2(if) + 1= 14</p><h1 id="4-圈复杂度的意义"><a class="markdownIt-Anchor" href="#4-圈复杂度的意义"></a> 4 圈复杂度的意义</h1><p>在缺陷成为缺陷之前捕获它们。</p><h2 id="41-圈复杂度与缺陷"><a class="markdownIt-Anchor" href="#41-圈复杂度与缺陷"></a> 4.1 圈复杂度与缺陷</h2><p>一般来说圈复杂度大于10的方法存在很大的出错风险。圈复杂度和缺陷个数有高度的正相关：<strong>圈复杂度最高的模块和方法，其缺陷个数也可能最多。</strong></p><h2 id="42-圈复杂度与结构化测试"><a class="markdownIt-Anchor" href="#42-圈复杂度与结构化测试"></a> 4.2 圈复杂度与结构化测试</h2><p>此外，它还为测试设计提供很好的参考。一个好的用例设计经验是：**创建数量与被测代码圈复杂度值相等的测试用例，**以此提升用例对代码的分支覆盖率。</p><h2 id="43-圈复杂度与tdd"><a class="markdownIt-Anchor" href="#43-圈复杂度与tdd"></a> 4.3 圈复杂度与TDD</h2><p>TDD（测试驱动的开发，test-driven development)和低<strong>CC</strong>值之间存在着紧密联系。在编写测试时，开发人员会考虑代码的可测试性，倾向于编写简单的代码，因为复杂的代码难以测试。因此TDD的“代码、测试、代码、测试” 循环将导致频繁重构，驱使非复杂代码的开发。</p><h2 id="44-圈复杂度与遗留代码"><a class="markdownIt-Anchor" href="#44-圈复杂度与遗留代码"></a> 4.4 圈复杂度与遗留代码</h2><p>对于遗留代码的维护或重构，测量圈复杂度特别有价值。一般使用圈复杂度作为提升代码质量的切入点。</p><h2 id="45-圈复杂度与ci"><a class="markdownIt-Anchor" href="#45-圈复杂度与ci"></a> 4.5 圈复杂度与CI</h2><p>在持续集成环境中，可以基于时间变化维度来评估模块或函数的复杂度和增长值。如果<strong>CC</strong>值在不断增长，那么应该开展两项活动：</p><ol><li>确保相关测试的有效性，减少故障风险。</li><li>评估重构必要性和具体方式，以降低出现代码维护问题的可能性。</li></ol><h2 id="46-圈复杂度和软件质量"><a class="markdownIt-Anchor" href="#46-圈复杂度和软件质量"></a> 4.6 圈复杂度和软件质量</h2><table><thead><tr><th style="text-align:left">圈复杂度</th><th style="text-align:left">代码状况</th><th style="text-align:left">可测性</th><th style="text-align:left">维护成本</th></tr></thead><tbody><tr><td style="text-align:left">1-10</td><td style="text-align:left">清晰、结构化</td><td style="text-align:left">高</td><td style="text-align:left">低</td></tr><tr><td style="text-align:left">10-20</td><td style="text-align:left">复杂</td><td style="text-align:left">中</td><td style="text-align:left">中</td></tr><tr><td style="text-align:left">20-30</td><td style="text-align:left">非常复杂</td><td style="text-align:left">低</td><td style="text-align:left">高</td></tr><tr><td style="text-align:left">&gt;30</td><td style="text-align:left">不可读</td><td style="text-align:left">不可测</td><td style="text-align:left">非常高</td></tr></tbody></table><h1 id="5-降低圈复杂度的方法"><a class="markdownIt-Anchor" href="#5-降低圈复杂度的方法"></a> 5 降低圈复杂度的方法</h1><h2 id="51-重新组织你的函数"><a class="markdownIt-Anchor" href="#51-重新组织你的函数"></a> 5.1 重新组织你的函数</h2><h3 id="511-技巧1-提炼函数"><a class="markdownIt-Anchor" href="#511-技巧1-提炼函数"></a> 5.1.1 技巧1 提炼函数</h3><p>有一段代码可以被组织在一起并独立出来:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Example</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>( val &gt; MAX_VAL)</span><br><span class="line">&#123;</span><br><span class="line">val = MAX_VAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; val; i++)</span><br><span class="line">&#123;</span><br><span class="line">doSomething(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将这段代码放进一个独立函数中，并让函数名称解释该函数的用途:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getValidVal</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>( val &gt; MAX_VAL)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> MAX_VAL;</span><br><span class="line">&#125; </span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomethings</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; val; i++)</span><br><span class="line">&#123;</span><br><span class="line">doSomething(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Example</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    doSomethings(getValidVal(val));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后还要重新审视函数内容是否在统一层次上。</p><h3 id="512-技巧2-替换算法"><a class="markdownIt-Anchor" href="#512-技巧2-替换算法"></a> 5.1.2 技巧2 替换算法</h3><p>把某个算法替换为另一个更清晰的算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">foundPerson</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; peoples)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; people : peoples) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (people == <span class="string">"Don"</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Don"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (people == <span class="string">"John"</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"John"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (people == <span class="string">"Kent"</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Kent"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将函数实现替换为另一个算法:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">foundPerson</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; people)</span></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt;candidates&#123;</span><br><span class="line">    &#123; <span class="string">"Don"</span>, <span class="string">"Don"</span>&#125;,</span><br><span class="line">    &#123; <span class="string">"John"</span>, <span class="string">"John"</span>&#125;,</span><br><span class="line">    &#123; <span class="string">"Kent"</span>, <span class="string">"Kent"</span>&#125;,</span><br><span class="line">       &#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; people : peoples) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; it = candidates.<span class="built_in">find</span>(people);</span><br><span class="line">    <span class="keyword">if</span>(it != candidates.<span class="built_in">end</span>())</span><br><span class="line">        <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所谓的表驱动。</p><h2 id="52-简化条件表达式"><a class="markdownIt-Anchor" href="#52-简化条件表达式"></a> 5.2 简化条件表达式</h2><h3 id="521-技巧3-逆向表达"><a class="markdownIt-Anchor" href="#521-技巧3-逆向表达"></a> 5.2.1 技巧3 逆向表达</h3><p>在代码中可能存在条件表达如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((condition1() &amp;&amp; condition2()) || !condition1())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用逆向表达调换表达顺序后效果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(condition1() &amp;&amp; !condition2())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><h3 id="522-技巧4-分解条件"><a class="markdownIt-Anchor" href="#522-技巧4-分解条件"></a> 5.2.2 技巧4 分解条件</h3><p>在代码中存在复杂的条件表达：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(date.before (SUMMER_START) || date.after(SUMMER_END))</span><br><span class="line">    charge = quantity * _winterRate + _winterServiceCharge;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    charge = quantity * _summerRate;</span><br></pre></td></tr></table></figure><p>从if、then、else三个段落中分别提炼出独立函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(notSummer(date))</span><br><span class="line">    charge = winterCharge(quantity);</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    charge = summerCharge (quantity);</span><br></pre></td></tr></table></figure><h3 id="523-技巧5-合并条件"><a class="markdownIt-Anchor" href="#523-技巧5-合并条件"></a> 5.2.3 技巧5 合并条件</h3><p>一系列条件判断，都得到相同结果:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">disabilityAmount</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_seniority &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (_monthsDisabled &gt; <span class="number">12</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (_isPartTime) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// compute the disability amount</span></span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><p>将这些判断合并为一个条件式，并将这个条件式提炼成为一个独立函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">disabilityAmount</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isNotEligableForDisability()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// compute the disability amount</span></span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><h3 id="524-技巧6-移除控制标记"><a class="markdownIt-Anchor" href="#524-技巧6-移除控制标记"></a> 5.2.4 技巧6 移除控制标记</h3><p>在代码逻辑中，有时候会使用bool类型作为逻辑控制标记：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkSecurity</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; peoples)</span> </span>&#123;</span><br><span class="line"><span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; people : peoples) </span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">if</span> (! found) &#123;</span><br><span class="line"><span class="keyword">if</span> (people == <span class="string">"Don"</span>)&#123;</span><br><span class="line">sendAlert();</span><br><span class="line">found = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (people == <span class="string">"John"</span>)&#123;</span><br><span class="line">   sendAlert();</span><br><span class="line">   found = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用break和return取代控制标记：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkSecurity</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; peoples)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; people : peoples)</span><br><span class="line">&#123;     </span><br><span class="line"><span class="keyword">if</span> (people == <span class="string">"Don"</span> || people == <span class="string">"John"</span>)</span><br><span class="line">&#123;</span><br><span class="line">sendAlert();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="525-技巧7-以多态取代条件式"><a class="markdownIt-Anchor" href="#525-技巧7-以多态取代条件式"></a> 5.2.5 技巧7 以多态取代条件式</h3><p>条件式根据对象类型的不同而选择不同的行为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getSpeed</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (_type) &#123;</span><br><span class="line">        <span class="keyword">case</span> EUROPEAN:</span><br><span class="line">            <span class="keyword">return</span> getBaseSpeed();</span><br><span class="line">        <span class="keyword">case</span> AFRICAN:</span><br><span class="line">            <span class="keyword">return</span> getBaseSpeed() - getLoadFactor() *_numberOfCoconuts;</span><br><span class="line">        <span class="keyword">case</span> NORWEGIAN_BLUE:</span><br><span class="line">            <span class="keyword">return</span> (_isNailed) ? <span class="number">0</span> : getBaseSpeed(_voltage);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException (<span class="string">"Should be unreachable"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将整个条件式的每个分支放进一个子类的重载方法中，然后将原始函数声明为抽象方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">getSpeed</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getBaseSpeed</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EuropeanBird</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getSpeed</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getBaseSpeed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AfricanBird</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getSpeed</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getBaseSpeed() - getLoadFactor() *_numberOfCoconuts;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getLoadFactor</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">double</span> _numberOfCoconuts;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NorwegianBlueBird</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getSpeed</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (_isNailed) ? <span class="number">0</span> : getBaseSpeed(_voltage);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> _isNailed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="53-简化函数调用"><a class="markdownIt-Anchor" href="#53-简化函数调用"></a> 5.3 简化函数调用</h2><h3 id="531-技巧8-读写分离"><a class="markdownIt-Anchor" href="#531-技巧8-读写分离"></a> 5.3.1 技巧8 读写分离</h3><p>某个函数既返回对象状态值，又修改对象状态:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getTotalOutstandingAndSetReadyForSummaries</span><span class="params">(<span class="keyword">int</span> number)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建立两个不同的函数，其中一个负责查询，另一个负责修改:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getTotalOutstanding</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetReadyForSummaries</span><span class="params">(<span class="keyword">int</span> number)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="532-技巧9-参数化方法"><a class="markdownIt-Anchor" href="#532-技巧9-参数化方法"></a> 5.3.2 技巧9 参数化方法</h3><p>若干函数做了类似的工作，但在函数本体中却 包含了不同的值:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Dollars <span class="title">baseCharge</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> result = Math.<span class="built_in">min</span>(lastUsage(),<span class="number">100</span>) * <span class="number">0.03</span>;</span><br><span class="line">    <span class="keyword">if</span> (lastUsage() &gt; <span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        result += (Math.<span class="built_in">min</span> (lastUsage(),<span class="number">200</span>) - <span class="number">100</span>) * <span class="number">0.05</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lastUsage() &gt; <span class="number">200</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        result += (lastUsage() - <span class="number">200</span>) * <span class="number">0.07</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Dollars (result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建立单一函数，以参数表达那些不同的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Dollars <span class="title">baseCharge</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> result = usageInRange(<span class="number">0</span>, <span class="number">100</span>) * <span class="number">0.03</span>;</span><br><span class="line">    result += usageInRange (<span class="number">100</span>,<span class="number">200</span>) * <span class="number">0.05</span>;</span><br><span class="line">    result += usageInRange (<span class="number">200</span>, Integer.MAX_VALUE) * <span class="number">0.07</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Dollars (result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">usageInRange</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lastUsage() &gt; start) </span><br><span class="line">        <span class="keyword">return</span> Math.<span class="built_in">min</span>(lastUsage(),<span class="built_in">end</span>) -start;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="533-技巧10-以明确函数取代参数"><a class="markdownIt-Anchor" href="#533-技巧10-以明确函数取代参数"></a> 5.3.3 技巧10 以明确函数取代参数</h3><p>函数实现完全取决于参数值而采取不同反应：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setValue</span> <span class="params">(<span class="built_in">string</span> name, <span class="keyword">int</span> value)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="string">"height"</span>)</span><br><span class="line">        _height = value;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (name == <span class="string">"width"</span>)</span><br><span class="line">        _width = value;</span><br><span class="line">    Assert.shouldNeverReachHere();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对该参数的每一个可能值，建立一个独立函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">int</span> arg)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _height = arg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setWidth</span> <span class="params">(<span class="keyword">int</span> arg)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _width = arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="54-实战练习"><a class="markdownIt-Anchor" href="#54-实战练习"></a> 5.4 实战练习</h2><p>还是以之前统计<strong>CC</strong>值的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">U32 <span class="title">find</span> <span class="params">(<span class="built_in">string</span> match)</span></span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">auto</span> var : List)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span>(var == match &amp;&amp; from != INVALID_U32) </span><br><span class="line">    <span class="keyword">return</span> INVALID_U32;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//match step1</span></span><br><span class="line">       <span class="keyword">if</span>(session == getName() &amp;&amp; key == <span class="built_in">getKey</span>())</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; kv : Map)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">if</span> (kv.second == last &amp;&amp; match == kv.first)</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="keyword">return</span> last;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//match step2</span></span><br><span class="line">       <span class="keyword">auto</span> var = Map.<span class="built_in">find</span>(match);</span><br><span class="line">       <span class="keyword">if</span>(var != Map.<span class="built_in">end</span>()&amp;&amp; (from != var-&gt;second)) <span class="keyword">return</span> var-&gt;second;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//match step3</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">auto</span> var: Map)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span>((var.first, match) &amp;&amp; from != var.second)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">return</span> var.second;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> INVALID_U32;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure><p>综合运用降低CC值的技巧后：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Matcher</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        Matcher(<span class="built_in">string</span> name, <span class="built_in">string</span> key);</span><br><span class="line">        <span class="function">U32 <span class="title">find</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">except</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function">U32 <span class="title">matchStep1</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function">U32 <span class="title">matchStep2</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function">U32 <span class="title">matchStep3</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">isTheSameMatch</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> match;</span><br><span class="line">        U32 from;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Matcher::Matcher(<span class="built_in">string</span> name, <span class="built_in">string</span> key):</span><br><span class="line">        match(name + key)</span><br><span class="line">    &#123;</span><br><span class="line">        from = GetFrom();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">U32 <span class="title">Matcher::find</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (except())</span><br><span class="line">            <span class="keyword">return</span> INVALID_U32;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> result = matchStep1();</span><br><span class="line">        <span class="keyword">if</span> (result != INVALID_U32)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        result = matchStep2();</span><br><span class="line">        <span class="keyword">if</span> (result != INVALID_U32)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> matchStep3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Matcher::except</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> var : List)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(var == match &amp;&amp; from != INVALID_U32)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">U32 <span class="title">Matcher::matchStep1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!isTheSameMatch())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> INVALID_U32;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; kv : Map)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( last == kv.second &amp;&amp; match == kv.first)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> last;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> INVALID_U32;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Matcher::isTheSameMatch</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> match == getName() + <span class="built_in">getKey</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">U32 <span class="title">Matcher::matchStep2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> var = Map.<span class="built_in">find</span>(match);</span><br><span class="line">        <span class="keyword">if</span>(var != Map.<span class="built_in">end</span>()&amp;&amp; (from != var-&gt;second))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> var-&gt;second;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> INVALID_U32;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">U32 <span class="title">Matcher::matchStep3</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> var: Map)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(keyMatch(var.first, match) &amp;&amp; from != var.second)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> var.second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> INVALID_U32;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">U32 <span class="title">find</span> <span class="params">(<span class="built_in">string</span> match)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Matcher matcher;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> matcher.<span class="built_in">find</span>(match);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该例子将匹配算法都封装到Matcher类中，并将原有逻辑通过提炼函数（技巧1）和合并条件（技巧6）将匹配逻辑抽象成能力查询、粘滞、精确匹配及模糊匹配四个步骤，这样将循环和条件分支封入小函数中，从而降低接口函数（findPno）的圈复杂度，函数职责也更加单一和清晰。整体圈复杂度从单个函数的14降到多个函数最高的5。</p><h1 id="6-圈复杂度思辨"><a class="markdownIt-Anchor" href="#6-圈复杂度思辨"></a> 6 圈复杂度思辨</h1><h2 id="61-思辨1-高复杂度的代码是否可维护性差"><a class="markdownIt-Anchor" href="#61-思辨1-高复杂度的代码是否可维护性差"></a> 6.1 思辨1 高复杂度的代码是否可维护性差</h2><p>在实际项目中为了调试方便，经常会把消息号对应的名称打印出来：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">getMessageName</span><span class="params">(Message msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(msg)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> MSG_1:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"MSG_1"</span>;</span><br><span class="line">        <span class="keyword">case</span> MSG_2:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"MSG_2"</span>;</span><br><span class="line">        <span class="keyword">case</span> MSG_3:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"MSG_3"</span>;</span><br><span class="line">        <span class="keyword">case</span> MSG_4:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"MSG_4"</span>;</span><br><span class="line">        <span class="keyword">case</span> MSG_5:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"MSG_5"</span>;</span><br><span class="line">        <span class="keyword">case</span> MSG_6:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"MSG_6"</span>;</span><br><span class="line">        <span class="keyword">case</span> MSG_7:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"MSG_7"</span>;</span><br><span class="line">        <span class="keyword">case</span> MSG_8:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"MSG_8"</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"MSG_UNKNOWN"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码无论从可读性来说，还是从可维护性来说都是可以接收的。因此，当因为”高”复杂度就进行重构的话（例如：技巧2或技巧6），在降低圈复杂度的同时会带来不必要的逻辑复杂度。</p><p>当然，如果出现下面的情况的话，还是有必要进一步降低圈复杂度的：</p><ol><li>消息数过多。</li><li>switch…case…多处重复。 对于消息过多的情况，可以考虑将消息进行分类，然后采用技巧1进行重构。对于出现多处重复的情况，可以通过技巧6将同样case的内容内聚到一个具体的类的方法中，然后通过多态的方式来使用。</li></ol><h2 id="62-思辨2-复杂度相同的代码是否是一致的"><a class="markdownIt-Anchor" href="#62-思辨2-复杂度相同的代码是否是一致的"></a> 6.2 思辨2 复杂度相同的代码是否是一致的</h2><p>例如下面两个代码片段的圈复杂度都是6。 代码片段1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">getWeight</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"no weight"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">10</span>) </span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"light"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">20</span>) </span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"medium"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">30</span>) </span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"heavy"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">40</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"very heavy"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"super heavy"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码片段2</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumOfNonPrimes</span><span class="params">(<span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> bAdd = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &lt;= <span class="number">2</span>) </span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; i; ++j) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i % j == <span class="number">0</span>) </span><br><span class="line">                    &#123;</span><br><span class="line">                            bAdd = <span class="literal">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    bAdd = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (bAdd)</span><br><span class="line">                    sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是它们的代码无论从可读性上来说，还是从可维护性来说，代码片段1应该都优于代码片段2，代码片段2的坏味道更加浓郁。因此，圈复杂度还需要具体情况具体分析，其只能作为重构的一个度量指标，作为决策的一个参考依据。</p><h1 id="7-圈复杂度工具"><a class="markdownIt-Anchor" href="#7-圈复杂度工具"></a> 7 圈复杂度工具</h1><p>圈复杂度的工具有很多，大致有三类：</p><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">名称</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">专用工具（单语言）</td><td style="text-align:left">OCLint</td><td style="text-align:left">C语言相关</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">GMetrics</td><td style="text-align:left">Java</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">PyMetrics</td><td style="text-align:left">python</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">JSComplexity</td><td style="text-align:left">js</td></tr><tr><td style="text-align:left">通用工具（多语言）</td><td style="text-align:left">lizard</td><td style="text-align:left">支持多种语言：C/C++ (works with C++14)、Java、C#、JavaScript、Objective C、Swift、Python、Ruby、PHP、Scala等。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">sourcemonitor</td><td style="text-align:left">免费、Windows平台。支持语言包括C、C++、C#、Java、VB、Delphi和HTML。</td></tr><tr><td style="text-align:left">通用平台</td><td style="text-align:left">sonarqube</td><td style="text-align:left">一个用于代码质量管理的开源平台，支持20多种语言。通过插件机制可集成不同的测试工具，代码分析工具及持续集成工具</td></tr></tbody></table><h1 id="8-参考资料"><a class="markdownIt-Anchor" href="#8-参考资料"></a> 8 参考资料</h1><ol><li><a href="https://zh.wikipedia.org/wiki/%E5%BE%AA%E7%92%B0%E8%A4%87%E9%9B%9C%E5%BA%A6" target="_blank" rel="noopener">循環複雜度- 维基百科，自由的百科全书</a></li><li><a href="http://www.guru99.com/cyclomatic-complexity.html" target="_blank" rel="noopener">Learn Mccabe’s Cyclomatic Complexity with Example</a></li><li><a href="https://www.cqse.eu/en/blog/mccabe-cyclomatic-complexity/" target="_blank" rel="noopener">McCabe’s Cyclomatic Complexity and Why We Don’t Use It</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 未分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 待补充 </tag>
            
            <tag> 重构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码覆盖率</title>
      <link href="/2022/04/15/%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87/"/>
      <url>/2022/04/15/%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-介绍"><a class="markdownIt-Anchor" href="#1-介绍"></a> 1 介绍</h1><p><strong>代码覆盖率</strong>，是一种通过计算测试过程中被执行的源代码占全部源代码的比例，进而间接度量软件质量的方法。</p><p><strong>全量覆盖率</strong>：基于全部代码的代码覆盖率</p><p><strong>增量覆盖率</strong>：基于代码增量的代码覆盖率</p><p>按性质，它属于白盒测试的范畴，即主要依据源代码的内部结构来设计测试用例，通过设计不同的输入来测试软件的不同部分。</p><p>常见的编程语言，如C/C++，python和Java等，都有相应的代码覆盖率测试工具。</p><h1 id="2-意义"><a class="markdownIt-Anchor" href="#2-意义"></a> 2 意义</h1><ol><li>提升开发者测试意识，可以基于此在程序中寻找没有被测试用例测试过的地方，创建新的测试用例来增加覆盖率，从而提高软件质量；</li><li>也为代码管理提供了新的手段，降低管理成本。</li></ol><p><strong>注意</strong>：代码覆盖率不是灵丹妙药，它只是告诉我们有哪些代码没有被测试用例“执行到”而已，高百分比的代码覆盖率不等于高质量的有效测试。</p><p><strong>举例</strong>：假设代码覆盖率只在某一些模块代码覆盖率很高，但在一些关键模块并没有足够的测试用例覆盖，那样虽然代码覆盖率很高，但并不能说明产品质量就很高。</p><p>Martin Fowler <a href="https://link.zhihu.com/?target=https%3A//www.martinfowler.com/bliki/TestCoverage.html" target="_blank" rel="noopener">测试覆盖率</a> 写到：</p><blockquote><p>代码覆盖率是查找代码库中未测试部分的有用工具，然而它作为一个数字说明你的测试有多好用处不大。</p></blockquote><h1 id="3-分类"><a class="markdownIt-Anchor" href="#3-分类"></a> 3 分类</h1><h2 id="31-语句覆盖statement-coverage"><a class="markdownIt-Anchor" href="#31-语句覆盖statement-coverage"></a> 3.1 语句覆盖（statement coverage）</h2><p><strong>程序中的语句有多少被执行</strong>。它是最常用也是最简单的一种代码覆盖率度量方式，就是度量被测代码中每个可执行语句是否被执行到了。“可执行语句”，并不包括C++的头文件声明、代码注释和空行等。但是，单独一行的花括号｛｝ 常常也被统计进去。</p><h2 id="32-行覆盖率"><a class="markdownIt-Anchor" href="#32-行覆盖率"></a> 3.2 行覆盖率</h2><p><strong>有多少行的源代码被测试过</strong>。感觉和<code>语句覆盖</code>一样。</p><h2 id="33-判定覆盖率decision-coverageor-分支覆盖"><a class="markdownIt-Anchor" href="#33-判定覆盖率decision-coverageor-分支覆盖"></a> 3.3 判定覆盖率（decision coverage）or 分支覆盖</h2><p>又称<strong>分支覆盖</strong>，所有边界覆盖，基本路径覆盖，判定路径覆盖，它度量程序中每一个判定的分支是否都被测试到了。所谓判定，是指一条判断语句的结果，而不考虑其中包含的子判断的结果和组合情况。</p><h2 id="34-条件覆盖condition-coverage"><a class="markdownIt-Anchor" href="#34-条件覆盖condition-coverage"></a> 3.4 条件覆盖（condition coverage）</h2><p>它报告每一个子表达式的结果的true 或false 是否测试到了。即构造测试用例时，要使得每个判定语句中每个逻辑条件的可能值至少满足一次（即每一个被“逻辑与”或“逻辑非”分开的布尔表达式真假值情况）。但是，需要注意的是，条件覆盖不是将判定中的每个条件表达式的结果进行排列组合，而是只要每个条件表达式的结果true和false测试到了就可以了。</p><h2 id="35-修正条件判定覆盖modified-condition-decision-coverage"><a class="markdownIt-Anchor" href="#35-修正条件判定覆盖modified-condition-decision-coverage"></a> 3.5 修正条件判定覆盖（modified condition / decision coverage）</h2><p>前面提到的条件覆盖比语句覆盖和判定覆盖都要严格，但是由于它只关注每个条件表达式的结果是否都被测试到，而不要求对每个条件表达式的解果进行排列组合，所以它也只能覆盖一部分的情况。如果真要做到全覆盖，随着子表达式的增加，不仅测试用例设计的难度会越来越大，而且用例的数量也会指数级增长。</p><p>修正条件判定覆盖，要求在一个程序中每一种输入输出至少得出现一次，在程序中的每一个条件必须产生所有可能的输出结果至少一次，并且每一个判定中的每一个条件必须能够独立影响一个判定的输出，即在其他条件不变的前提下仅改变这个条件的值，而使判定结果改变。显然，修正条件判定覆盖的定义有点抽象，接下来还是以前面的代码为例介绍。</p><p>修正条件判定覆盖要求在每个判定中，每个条件都独立地影响判定结果至少一次（所谓独立影响就是在其他条件不变的情况下，改变该条件可以改变判定结果）。例如，要想a对判定独立影响，则b或function的结果必须为true；要想b对判定独立影响，则a必须为true；同理，要想function对判定独立影响，a也必须为true。如果列出测试用例表，则不难发现满足以上条件的测试用例的数量并不需要很多！主要因为有些用例是重复的。</p><h2 id="36-条件判定组合覆盖condition-decision-coverage"><a class="markdownIt-Anchor" href="#36-条件判定组合覆盖condition-decision-coverage"></a> 3.6 条件判定组合覆盖（condition decision coverage）</h2><h2 id="37-路径覆盖path-coverage"><a class="markdownIt-Anchor" href="#37-路径覆盖path-coverage"></a> 3.7 路径覆盖（path coverage）</h2><h2 id="38-多条件覆盖multi-condition-coverage"><a class="markdownIt-Anchor" href="#38-多条件覆盖multi-condition-coverage"></a> 3.8 多条件覆盖（multi-condition coverage）</h2><h2 id="39-方法覆盖率"><a class="markdownIt-Anchor" href="#39-方法覆盖率"></a> 3.9 方法覆盖率</h2><p><strong>程序中的方法/函数有多少被执行。</strong></p><h2 id="310-类覆盖率"><a class="markdownIt-Anchor" href="#310-类覆盖率"></a> 3.10 类覆盖率</h2><p><strong>程序中的类有多少被执行。</strong></p><h1 id="4-工作原理"><a class="markdownIt-Anchor" href="#4-工作原理"></a> 4 工作原理</h1><p>代码覆盖率测量主要有以下三种方式：</p><h2 id="41-source-code-instrumentation-源代码检测"><a class="markdownIt-Anchor" href="#41-source-code-instrumentation-源代码检测"></a> 4.1 Source code instrumentation - 源代码检测</h2><p>将检测语句添加到源代码中，并使用正常的编译工具链编译代码以生成检测的程序集。这是我们常说的插桩，Gcov 是属于这一类的代码覆盖率工具。</p><h2 id="42-runtime-instrumentation-运行时收集"><a class="markdownIt-Anchor" href="#42-runtime-instrumentation-运行时收集"></a> 4.2 Runtime instrumentation - 运行时收集</h2><p>这种方法在代码执行时从运行时环境收集信息以确定覆盖率信息。以我的理解 JaCoCo 和 Coverage 这两个工具的原理属于这一类别。</p><h2 id="43-intermediate-code-instrumentation-中间代码检测"><a class="markdownIt-Anchor" href="#43-intermediate-code-instrumentation-中间代码检测"></a> 4.3 Intermediate code instrumentation - 中间代码检测</h2><p>通过添加新的字节码来检测编译后的类文件，并生成一个新的检测类。说实话，我 Google 了很多文章并找到确定的说明哪个工具是属于这一类的。<a href="https://blog.csdn.net/Nathan1987_/article/details/100932502" target="_blank" rel="noopener">机器码(machine code)和字节码(byte code)是什么？</a></p><hr><p>了解这些工具的基本原理，结合现有的测试用例，有助于正确的选择代码覆盖率工具。比如：</p><ul><li>产品的源代码只有 E2E（端到端）测试用例，通常只能选择第一类工具，即通过插桩编译出的可执行文件，然后进行测试和结果收集。</li><li>产品的源代码有单元测试用例，通常选择第二类工具，即运行时收集。这类工具的执行效率高，易于做持续集成。</li></ul><h1 id="5-当前主流代码覆盖率工具"><a class="markdownIt-Anchor" href="#5-当前主流代码覆盖率工具"></a> 5 当前主流代码覆盖率工具</h1><p>代码覆盖率的工具有很多，以下是我用过的不同编程语言的代码覆盖率工具。在选择工具时，力求去选择那些开源、流行（活跃）、好用的工具。</p><table><thead><tr><th style="text-align:center">编程语言</th><th style="text-align:center">代码覆盖率工具</th></tr></thead><tbody><tr><td style="text-align:center">C/C++</td><td style="text-align:center">Gcov</td></tr><tr><td style="text-align:center">Java</td><td style="text-align:center">JaCoCo</td></tr><tr><td style="text-align:center">JavaScript</td><td style="text-align:center">Istanbul</td></tr><tr><td style="text-align:center">Python</td><td style="text-align:center"><a href="http://Coverage.py" target="_blank" rel="noopener">Coverage.py</a></td></tr><tr><td style="text-align:center">Golang</td><td style="text-align:center">cover</td></tr></tbody></table><h2 id="51-gcov"><a class="markdownIt-Anchor" href="#51-gcov"></a> 5.1 Gcov</h2><p>Gcov 工作流程图：</p><img src="https://s2.loli.net/2022/04/15/AHyX8j6SR2eGYqV.png" width="400" height="300" alt="图片名称" align="center" id="157"><p>主要分三步：</p><ol><li>在 GCC 编译的时加入特殊的编译选项<code>-ftest-coverage</code>，生成可执行文件和 <code>.gcno</code>；</li><li>运行（测试）生成的可执行文件，生成了 <code>.gcda</code> 数据文件；（<code>.gcda</code>的生成是因为程序在编译的时候引入了 <code>-fprofile-arcs</code>选项）</li><li>有了 <code>.gcno</code> 和 <code>.gcda</code>，通过源码生成 <code>.gcov</code> 文件，最后生成代码覆盖率报告。</li></ol><p>用GCC编译的时候加上-fprofile-arcs -ftest-coverage选项，链接的时候也加上。</p><p><code>fprofile-arcs</code>参数使gcc创建一个程序的流图，之后找到适合图的生成树。只有不在生成树中的弧被操纵（instrumented）：gcc添加了代码来清点这些弧执行的次数。当这段弧是一个块的唯一出口或入口时，操纵工具代码（instrumentation code)将会添加到块中，否则创建一个基础块来包含操纵工具代码。</p><p>gcov主要使用<code>.gcno</code>和<code>.gcda</code>两个文件：</p><ol><li><code>.gcno</code>是由<code>-ftest-coverage</code>产生的，它包含了重建基本块图和相应的块的源码的行号的信息。</li><li><code>.gcda</code>是由加了<code>-fprofile-arcs</code>编译参数的编译后的文件运行所产生的，它包含了弧跳变的次数和其他的概要信息（而gcda只能在程序运行完毕后才能产生的）</li></ol><p><strong>参考</strong>：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/402463278" target="_blank" rel="noopener">使用 Gcov 和 LCOV 度量 C/C++ 项目的代码覆盖率</a></li><li><a href="https://segmentfault.com/a/1190000040733605" target="_blank" rel="noopener">源码分析 | 使用 gcov 和 lcov 测试 PostgreSQL 代码覆盖率</a></li><li><a href="https://www.cnblogs.com/ChinaHook/p/5508660.html" target="_blank" rel="noopener">lcov收集覆盖率</a></li></ul><p><strong>实践部分详见</strong> 博客：<code>C/C++项目的全量覆盖率和增量覆盖率</code></p><h2 id="52-jacoco"><a class="markdownIt-Anchor" href="#52-jacoco"></a> 5.2 Jacoco</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/363864068" target="_blank" rel="noopener">Java代码覆盖率工具Jacoco上手指引</a></li><li><a href="https://juejin.cn/post/7001005602994389005" target="_blank" rel="noopener">基于Jacoco的增量覆盖率实现与落地</a></li><li><a href="https://zhuanlan.zhihu.com/p/337957182" target="_blank" rel="noopener">滴滴开源Super-jacoco：java代码覆盖率收集平台</a></li><li><a href="https://www.cxyzjd.com/article/zou90512/102163415" target="_blank" rel="noopener">DevOps - Java增量代码覆盖率工具_zou90512的专栏-程序员宅基地_java增量覆盖率</a></li><li><a href="https://www.bilibili.com/video/BV1ba4y1v7K6" target="_blank" rel="noopener">onthefly动态插桩覆盖率统计</a></li></ul><h1 id="x-参考"><a class="markdownIt-Anchor" href="#x-参考"></a> X 参考</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/144826192" target="_blank" rel="noopener">什么是代码覆盖率？</a></li><li><a href="https://zhuanlan.zhihu.com/p/397701541" target="_blank" rel="noopener">关于代码覆盖率(Code Coverage)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 未分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 待补充 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021年华为C++后端实习名词积累</title>
      <link href="/2022/04/15/2021%E5%B9%B4%E5%8D%8E%E4%B8%BAC++%E5%90%8E%E7%AB%AF%E5%AE%9E%E4%B9%A0%E5%90%8D%E8%AF%8D%E7%A7%AF%E7%B4%AF/"/>
      <url>/2022/04/15/2021%E5%B9%B4%E5%8D%8E%E4%B8%BAC++%E5%90%8E%E7%AB%AF%E5%AE%9E%E4%B9%A0%E5%90%8D%E8%AF%8D%E7%A7%AF%E7%B4%AF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-perl语言"><a class="markdownIt-Anchor" href="#1-perl语言"></a> 1 Perl语言</h1><p>本次实习主要成果：基于SR的全量/增量覆盖率统计。</p><p>部门之前的该部分脚本是使用Perl语言编写的，晦涩难懂，没有维护人员。</p><p><a href="https://www.runoob.com/perl/perl-intro.html" target="_blank" rel="noopener">菜鸟教程——Perl语言教程</a></p><h1 id="2-ut-it-st"><a class="markdownIt-Anchor" href="#2-ut-it-st"></a> 2 UT &amp; IT &amp; ST</h1><h2 id="21-utunit-test单元测试"><a class="markdownIt-Anchor" href="#21-utunit-test单元测试"></a> 2.1 UT（Unit Test）：单元测试</h2><img src="https://s2.loli.net/2022/04/15/zqP8duipHcGLo9A.png" width="800" height="450" alt="图片名称" align="center" id="142"><img src="https://s2.loli.net/2022/04/15/1rNEqOydYzTGlM8.png" width="800" height="450" alt="图片名称" align="center" id="143"><h2 id="22-itintegration-test集成测试"><a class="markdownIt-Anchor" href="#22-itintegration-test集成测试"></a> 2.2 IT（Integration Test）：集成测试</h2><h2 id="23-stsystem-test系统测试"><a class="markdownIt-Anchor" href="#23-stsystem-test系统测试"></a> 2.3 ST（System Test）：系统测试</h2><img src="https://s2.loli.net/2022/04/15/Pqu6ZcTo3V12Aki.png" width="800" height="450" alt="图片名称" align="center" id="144"><h1 id="3-dtdevelpor-test开发者测试"><a class="markdownIt-Anchor" href="#3-dtdevelpor-test开发者测试"></a> 3 DT（Develpor Test）：开发者测试</h1><img src="https://s2.loli.net/2022/04/15/LiBpyJIXtcT7Ehx.png" width="800" height="450" alt="图片名称" align="center" id="145"><img src="https://s2.loli.net/2022/04/15/iYqjF5adrbM64yP.png" width="800" height="450" alt="图片名称" align="center" id="146"><img src="https://s2.loli.net/2022/04/15/oOHX4u95I8UabyE.png" width="800" height="450" alt="图片名称" align="center" id="147"><p><strong>参考</strong>：</p><ul><li><a href="https://developer.huaweiuniversity.com/courses/course-v1:HuaweiX+20210203+Self-paced/courseware/25e635447c474515909fd984d075dee7/5bfcf9c7a1dc4f3b8c0d78038bd21e36/" target="_blank" rel="noopener">华为课程学习</a></li><li><a href="https://xie.infoq.cn/article/126ff8488cd203a65a60d9643" target="_blank" rel="noopener">开发者测试：你必须知道 7 件事</a></li></ul><h1 id="4-tddtest-driven-development测试驱动开发"><a class="markdownIt-Anchor" href="#4-tddtest-driven-development测试驱动开发"></a> 4 TDD（Test-Driven Development）：测试驱动开发</h1><p>测试驱动开发，在开发功能代码之前，先编写单元测试用例代码，测试代码确定需要编写什么产品代码。</p><h1 id="5-cleancode"><a class="markdownIt-Anchor" href="#5-cleancode"></a> 5 cleancode</h1><blockquote><p>详见博客<code>《代码整洁之道 clean code》笔记</code></p></blockquote><p>软件工程领域的大师级人物罗伯特·马丁(Robert C. Martin)所著的一本重量级经典图书《Clean Code》，中文译为代码整洁之道，书中提出代码质量与其整洁度成正比。 比如编程要遵守一些原则；命名、注释、函数。</p><p><strong>参考</strong>：<a href="https://blog.csdn.net/nkGavinGuo/article/details/103752914" target="_blank" rel="noopener">浅谈Clean Code</a></p><h1 id="6-sr-ar"><a class="markdownIt-Anchor" href="#6-sr-ar"></a> 6 SR &amp; AR</h1><ul><li><strong>IR（Initial Requirement）</strong>：初始需求</li><li><strong>SR（System Requirement）</strong>：系统需要</li><li><strong>AR（Allocation Requirement）</strong>：配置需求</li><li><strong>SA（System Analyst）</strong>：系统分析师，</li><li><strong>SE（System Engineer）</strong>：系统工程师</li><li><strong>MDE（Module Design Engineer）</strong>：模块设计师，当SE把不同模块之间的接口大致画清晰后，模块内部的设计交给MDE来进行；<a href="https://blog.csdn.net/isscollege/article/details/75022142" target="_blank" rel="noopener">敏捷之MDE认知</a></li><li><strong>User Story</strong>：用户故事； <a href="http://www.woshipm.com/user-research/1725827.html" target="_blank" rel="noopener">用户故事（一）：什么是用户故事？</a></li></ul><img src="https://s2.loli.net/2022/04/15/fJ74SagOE6NRM8e.png" width="800" height="450" alt="图片名称" align="center" id="148"><p><strong>步骤</strong>：</p><ol><li><p><strong>需求经理</strong>：将用户需求（user story）转换成 客户能够接受的 初始需求 IR（Initial Requirement）</p></li><li><p><strong>SA</strong>：IR 拆分为 SR</p></li><li><p><strong>SE</strong>：SR 继续拆分 AR</p></li><li><p><strong>MDE</strong>：当SE把不同模块之间的接口大致画清晰后，模块内部的设计交给MDE来进行；</p></li></ol><p><strong>参考</strong>：<a href="https://blog.csdn.net/minminzhe520/article/details/52164752" target="_blank" rel="noopener">我从华为身上学到的项目管理经验 – 需求篇</a></p><h1 id="7-敏捷开发"><a class="markdownIt-Anchor" href="#7-敏捷开发"></a> 7 敏捷开发</h1><p>敏捷开发是一种项目管理和软件开发的迭代方法，侧重于协作、客户反馈和快速发布。</p><p>敏捷开发以用户的需求进化为核心，采用迭代、循序渐进的方法进行软件开发，适用于竞争激烈，快速变化的市场。敏捷的客户协作观念，快速迭代能帮助团队以最小成本，最快速度满足客户真正的需求。</p><p>其特点：“个体与交互”胜过“过程与工具”、“可以工作的软件”胜过“面面俱到的文挡”、“客户协作”胜过“合同谈判”、“响应变化”胜过“遵循计划”。</p><p>敏捷开发迭代流程一般遵循以下五个步骤：需求分析（requirements analysis）、产品设计（design）、功能编码（coding）、功能测试（testing）、部署评估（deployment / evaluation）。流程图如下：</p><img src="https://s2.loli.net/2022/04/15/qWpRhD3SQ7NltMX.png" width="800" height="450" alt="图片名称" align="center" id="149"><p><strong>参考</strong>：<a href="https://kknews.cc/news/5r38jvl.html" target="_blank" rel="noopener">四種軟體開發模式（瀑布、疊代、螺旋、敏捷），對比分析</a></p><h1 id="8-持续集成"><a class="markdownIt-Anchor" href="#8-持续集成"></a> 8 持续集成</h1><p>持续集成是一种软件开发实践，即团队开发成员经常集成他们的工作，通常每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。</p><p>实习部门使用Jenkins自动化部署， Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。</p><h1 id="9-devops"><a class="markdownIt-Anchor" href="#9-devops"></a> 9 DevOps</h1><p>DevOps（Development和Operations的组合词）是一种重视“软件开发人员（Dev）”和“IT运维技术人员（Ops）”之间沟通合作的文化、运动或惯例。通过自动化“软件交付”和“架构变更”的流程，来使得构建、测试、发布软件能够更加地快捷、频繁和可靠。</p>]]></content>
      
      
      <categories>
          
          <category> 未分类 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>git操作手册</title>
      <link href="/2022/04/13/git%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/"/>
      <url>/2022/04/13/git%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-命令"><a class="markdownIt-Anchor" href="#1-命令"></a> 1 命令</h1><ul><li>show-log</li><li>show-diff</li><li>pull：大致上 git pull = git fetch + git merge</li><li>commit</li><li>push</li><li>rebase：可以对某一段线性提交历史进行编辑、删除、复制、粘贴 <a href="https://www.yiibai.com/git/git_rebase.html" target="_blank" rel="noopener">git rebase命令</a></li><li>delete（rm）</li><li>revert</li><li>新建本地分支</li><li>推到远程分支</li><li>切分支</li><li>cherry-pick</li><li>解冲突</li><li>.gitignore</li></ul><h1 id="2-举例"><a class="markdownIt-Anchor" href="#2-举例"></a> 2 举例</h1><h2 id="21-对方更新过代码然后自己也需要上传新增文件"><a class="markdownIt-Anchor" href="#21-对方更新过代码然后自己也需要上传新增文件"></a> 2.1 对方更新过代码，然后自己也需要上传新增文件</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拉下更新代码</span></span><br><span class="line">git pull</span><br><span class="line">git pull origin master:master</span><br><span class="line"><span class="comment"># 详细的。。。</span></span><br><span class="line">git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br><span class="line"><span class="comment"># 新增文件</span></span><br><span class="line">···</span><br><span class="line"><span class="comment"># 将所有新增文件添加到暂存区</span></span><br><span class="line">git add .</span><br><span class="line"><span class="comment"># 将暂存区内容添加到本地仓库中</span></span><br><span class="line">git commit -m <span class="string">"注释"</span></span><br><span class="line"><span class="comment"># 从将本地的分支版本上传到远程并合并</span></span><br><span class="line">git push</span><br><span class="line">git push origin master:master</span><br><span class="line"><span class="comment"># 详细的。。。</span></span><br><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt; <span class="comment"># 如果本地分支名与远程分支名相同，则可以省略冒号</span></span><br></pre></td></tr></table></figure><h2 id="22-贡献自己的代码"><a class="markdownIt-Anchor" href="#22-贡献自己的代码"></a> 2.2 贡献自己的代码</h2><p><strong>commit-&gt;pull-&gt;push-&gt;MR</strong></p><p><strong>冲突：resolved-&gt;修改（edited）-&gt;完成（resolved）</strong></p><h1 id="x-参考"><a class="markdownIt-Anchor" href="#x-参考"></a> X 参考</h1><ul><li><a href="https://www.runoob.com/git/git-tutorial.html" target="_blank" rel="noopener">菜鸟教程——git</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 环境与工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 待补充 </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-yield用法详解</title>
      <link href="/2022/04/04/Python-yield%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/04/04/Python-yield%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-前言"><a class="markdownIt-Anchor" href="#1-前言"></a> 1 前言</h1><p><strong>参考</strong>：<a href="https://blog.csdn.net/mieleizhi0522/article/details/82142856" target="_blank" rel="noopener">python中yield的用法详解——最简单，最清晰的解释</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 待补充 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-字符串-统计子串个数</title>
      <link href="/2022/04/04/Python-%E5%AD%97%E7%AC%A6%E4%B8%B2-%E7%BB%9F%E8%AE%A1%E5%AD%90%E4%B8%B2%E4%B8%AA%E6%95%B0/"/>
      <url>/2022/04/04/Python-%E5%AD%97%E7%AC%A6%E4%B8%B2-%E7%BB%9F%E8%AE%A1%E5%AD%90%E4%B8%B2%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-前言"><a class="markdownIt-Anchor" href="#1-前言"></a> 1 前言</h1><p><strong>参考</strong>：<a href="https://blog.csdn.net/u014675548/article/details/46332843" target="_blank" rel="noopener">Python里统计一个字符串中子字符串的个数</a></p><p>母串<code>str1 = 'ababa'</code>，子串<code>str2='aba'</code>，统计子串有两种情况：</p><ol><li>重复统计：被统计过的字符还可以参与统计，所以子串数量为3；</li><li>不重复统计：被统计过的字符不再参与统计，所以子串数量为2。</li></ol><h1 id="2-实现"><a class="markdownIt-Anchor" href="#2-实现"></a> 2 实现</h1><h2 id="21-重复统计"><a class="markdownIt-Anchor" href="#21-重复统计"></a> 2.1 重复统计</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">s = <span class="string">"abababa"</span></span><br><span class="line">reg = re.compile(<span class="string">"(?=aba)"</span>)</span><br><span class="line">length = len(reg.findall(s))</span><br><span class="line">print(length)  <span class="comment"># 3</span></span><br></pre></td></tr></table></figure><h2 id="22-不重复统计"><a class="markdownIt-Anchor" href="#22-不重复统计"></a> 2.2 不重复统计</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">"abababa"</span></span><br><span class="line">print(s.count(<span class="string">'aba'</span>))  <span class="comment"># 2</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python-列表-将list中的值拼接成字符串</title>
      <link href="/2022/04/04/Python-%E5%88%97%E8%A1%A8-%E5%B0%86list%E4%B8%AD%E7%9A%84%E5%80%BC%E6%8B%BC%E6%8E%A5%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2022/04/04/Python-%E5%88%97%E8%A1%A8-%E5%B0%86list%E4%B8%AD%E7%9A%84%E5%80%BC%E6%8B%BC%E6%8E%A5%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-前言"><a class="markdownIt-Anchor" href="#1-前言"></a> 1 前言</h1><p>在Python中，有时需要将list以字符串的形式输出。如<code>list = ['a', 'b', 'c']</code>，要求输出<code>abc</code>。</p><p><strong>参考</strong>：<a href="https://cloud.tencent.com/developer/article/1389881" target="_blank" rel="noopener">python技巧——将list中的每个int元素转换成str</a></p><h1 id="2-实现"><a class="markdownIt-Anchor" href="#2-实现"></a> 2 实现</h1><h2 id="21-元素是字符或字符串"><a class="markdownIt-Anchor" href="#21-元素是字符或字符串"></a> 2.1 元素是字符或字符串</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test_list = [<span class="string">"h"</span>, <span class="string">"e"</span>, <span class="string">"l"</span>, <span class="string">"l"</span>, <span class="string">"o"</span>]</span><br><span class="line"></span><br><span class="line">print(<span class="string">""</span>.join(test_list))  <span class="comment"># hello</span></span><br><span class="line">print(<span class="string">","</span>.join(test_list))  <span class="comment"># h,e,l,l,o</span></span><br></pre></td></tr></table></figure><h2 id="22-元素中含有数字"><a class="markdownIt-Anchor" href="#22-元素中含有数字"></a> 2.2 元素中含有数字</h2><h3 id="221-新建list"><a class="markdownIt-Anchor" href="#221-新建list"></a> 2.2.1 新建list</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test_list = [<span class="string">"h"</span>, <span class="string">"e"</span>, <span class="string">"l"</span>, <span class="string">"l"</span>, <span class="string">"o"</span>, <span class="number">6</span>]</span><br><span class="line">test_list_new = [str(x) <span class="keyword">for</span> x <span class="keyword">in</span> test_list]</span><br><span class="line"></span><br><span class="line">print(<span class="string">""</span>.join(test_list_new))  <span class="comment"># hello6</span></span><br><span class="line">print(<span class="string">","</span>.join(test_list_new))  <span class="comment"># h,e,l,l,o,6</span></span><br></pre></td></tr></table></figure><h3 id="222-lambda表达式"><a class="markdownIt-Anchor" href="#222-lambda表达式"></a> 2.2.2 lambda表达式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test_list = [<span class="string">"h"</span>, <span class="string">"e"</span>, <span class="string">"l"</span>, <span class="string">"l"</span>, <span class="string">"o"</span>, <span class="number">6</span>]</span><br><span class="line">test_list_new = map(<span class="keyword">lambda</span> x: str(x), test_list)</span><br><span class="line"></span><br><span class="line">print(<span class="string">""</span>.join(test_list_new))  <span class="comment"># hello6</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python-字符串-截取特定部分</title>
      <link href="/2022/04/03/Python-%E5%AD%97%E7%AC%A6%E4%B8%B2-%E6%88%AA%E5%8F%96%E7%89%B9%E5%AE%9A%E9%83%A8%E5%88%86/"/>
      <url>/2022/04/03/Python-%E5%AD%97%E7%AC%A6%E4%B8%B2-%E6%88%AA%E5%8F%96%E7%89%B9%E5%AE%9A%E9%83%A8%E5%88%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-引入"><a class="markdownIt-Anchor" href="#1-引入"></a> 1 引入</h1><p>截取字符串中特定部分的方法：可以使用 <code>str[beginIndex:endPosition]</code>，其中<code>str</code>为需要截取的字符串，<code>beginIndex</code>为需要截取的第一个字符的下标，<code>endPosition</code>为截取字符最后一个字符的下标。</p><p>该部分和 <code>Python-字符串-分割字符串</code> 有点类似。</p><p><strong>参考</strong>：<a href="https://www.php.cn/python-tutorials-465121.html" target="_blank" rel="noopener">python如何截取字符串中特定部分</a></p><h1 id="2-解决"><a class="markdownIt-Anchor" href="#2-解决"></a> 2 解决</h1><h2 id="21-切片"><a class="markdownIt-Anchor" href="#21-切片"></a> 2.1 切片</h2><p><code>str[l,r]</code>：字符串可以理解成一个下标从0开始的数组，这里表示<code>[l,r)</code>的部分；<code>l</code>不写默认0，<code>r</code>不写默认最后一个；<code>l</code>和<code>r</code>也可以是负数，表示截取方向从右到左。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test_str = <span class="string">"hello.python"</span></span><br><span class="line">print(test_str[<span class="number">1</span>:<span class="number">4</span>])  <span class="comment"># ell</span></span><br><span class="line">print(test_str[:<span class="number">4</span>])  <span class="comment"># hell</span></span><br><span class="line">print(test_str[<span class="number">1</span>:])  <span class="comment"># ello.python</span></span><br><span class="line">print(test_str[<span class="number">-3</span>:<span class="number">-1</span>])  <span class="comment"># ho</span></span><br><span class="line">print(test_str[<span class="number">-3</span>:])  <span class="comment"># hon</span></span><br></pre></td></tr></table></figure><h2 id="22-index切片"><a class="markdownIt-Anchor" href="#22-index切片"></a> 2.2 index+切片</h2><p>先获取字符的下标位置，再通过以上的方法截取。</p><p><code>a.index(b, begin, end)</code>：<code>a</code>为需要校验字符串，<code>b</code>为字符串，<code>begin</code> 为开始截取的字符的下标（默认为<code>0</code>），<code>end</code>结束字符下标（默认为字符长度），截取字符串<code>[begin,end)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test_str = <span class="string">"hello.python"</span></span><br><span class="line">ch = <span class="string">'.'</span></span><br><span class="line"></span><br><span class="line">print(test_str.index(ch))  <span class="comment"># 5</span></span><br><span class="line">print(test_str[:test_str.index(ch)])  <span class="comment"># Hello</span></span><br><span class="line">print(test_str[test_str.index(ch):])  <span class="comment"># .python</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python-列表-交集并集差集</title>
      <link href="/2022/04/03/Python-%E5%88%97%E8%A1%A8-%E4%BA%A4%E9%9B%86%E5%B9%B6%E9%9B%86%E5%B7%AE%E9%9B%86/"/>
      <url>/2022/04/03/Python-%E5%88%97%E8%A1%A8-%E4%BA%A4%E9%9B%86%E5%B9%B6%E9%9B%86%E5%B7%AE%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-list的集合运算"><a class="markdownIt-Anchor" href="#1-list的集合运算"></a> 1 list的集合运算</h1><h2 id="11-交集"><a class="markdownIt-Anchor" href="#11-交集"></a> 1.1 交集</h2><p><strong>方法1</strong>：朴素的遍历；如果列表出现重复元素，该方法会出现问题，<strong>重复元素可能会保留</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 无重复元素</span></span><br><span class="line">a = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">b = [<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>]</span><br><span class="line">tmp = [val <span class="keyword">for</span> val <span class="keyword">in</span> a <span class="keyword">if</span> val <span class="keyword">in</span> b]</span><br><span class="line">print(tmp)  <span class="comment"># [2, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 有重复元素 </span></span><br><span class="line">a = [<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">b = [<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>]</span><br><span class="line">tmp = [val <span class="keyword">for</span> val <span class="keyword">in</span> a <span class="keyword">if</span> val <span class="keyword">in</span> b]</span><br><span class="line">print(tmp)  <span class="comment"># [2, 2, 5]</span></span><br></pre></td></tr></table></figure><p><strong>方法2</strong>：转化为set操作，<strong>速度快</strong>；<strong>重复元素不会保留</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 无重复元素</span></span><br><span class="line">a = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">b = [<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>]</span><br><span class="line">print(list(set(a).intersection(set(b))))  <span class="comment"># [2, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 有重复元素</span></span><br><span class="line">a = [<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">b = [<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>]</span><br><span class="line">print(list(set(a).intersection(set(b))))  <span class="comment"># [2, 2, 5]</span></span><br></pre></td></tr></table></figure><h2 id="12-并集"><a class="markdownIt-Anchor" href="#12-并集"></a> 1.2 并集</h2><p><strong>方法1</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">b = [<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>]</span><br><span class="line">print(list(set(a+b)))  <span class="comment"># [2, 3, 4, 5, 8]</span></span><br></pre></td></tr></table></figure><p><strong>方法2</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">b = [<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>]</span><br><span class="line">print(list(set(a).union(set(b))))  <span class="comment"># [2, 3, 4, 5, 8]</span></span><br></pre></td></tr></table></figure><h2 id="13-差集"><a class="markdownIt-Anchor" href="#13-差集"></a> 1.3 差集</h2><p><strong>方法1</strong>：朴素的遍历；如果列表出现重复元素，该方法会出现问题，<strong>重复元素可能会保留</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 无重复元素</span></span><br><span class="line">a = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">b = [<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>]</span><br><span class="line">tmp = [val <span class="keyword">for</span> val <span class="keyword">in</span> b <span class="keyword">if</span> val <span class="keyword">not</span> <span class="keyword">in</span> a]  <span class="comment"># b中有而a中没有的</span></span><br><span class="line">print(tmp)  <span class="comment"># [8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 有重复元素 </span></span><br><span class="line">a = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">b = [<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">8</span>]</span><br><span class="line">tmp = [val <span class="keyword">for</span> val <span class="keyword">in</span> b <span class="keyword">if</span> val <span class="keyword">not</span> <span class="keyword">in</span> a]  <span class="comment"># b中有而a中没有的</span></span><br><span class="line">print(tmp)  <span class="comment"># [8, 8]</span></span><br></pre></td></tr></table></figure><p><strong>方法2</strong>：转化为set操作，<strong>速度快</strong>；<strong>重复元素不会保留</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 无重复元素</span></span><br><span class="line">a = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">b = [<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>]</span><br><span class="line">print(list(set(b).difference(set(a))))  <span class="comment"># [8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 有重复元素 </span></span><br><span class="line">a = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">b = [<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">8</span>]</span><br><span class="line">print(list(set(b).difference(set(a))))  <span class="comment"># [8]</span></span><br></pre></td></tr></table></figure><h1 id="2-set的集合运算"><a class="markdownIt-Anchor" href="#2-set的集合运算"></a> 2 set的集合运算</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">s = set([<span class="number">3</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">40</span>])  <span class="comment"># 创建一个数值集合</span></span><br><span class="line">t = set([<span class="number">3</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">29</span>, <span class="number">81</span>])  <span class="comment"># 创建一个数值集合</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># t 和 s的并集 ,等价于t.union(s)</span></span><br><span class="line">print(t | s)  <span class="comment"># &#123;1, 3, 5, 7, 40, 9, 10, 81, 20, 29&#125;</span></span><br><span class="line"><span class="comment"># t 和 s的交集 ,等价于t.intersection(s)</span></span><br><span class="line">print(t &amp; s)  <span class="comment"># &#123;9, 3, 5&#125;</span></span><br><span class="line"><span class="comment"># 求差集（项在t中，但不在s中）  ,等价于t.difference(s)</span></span><br><span class="line">print(t - s)  <span class="comment"># &#123;81, 1, 29, 7&#125;</span></span><br><span class="line"><span class="comment"># 对称差集（项在t或s中，但不会同时出现在二者中）,等价于t.symmetric_difference(s)</span></span><br><span class="line">print(t ^ s)  <span class="comment"># &#123;1, 7, 40, 10, 81, 20, 29&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python-字符串-分割字符串</title>
      <link href="/2022/04/03/Python-%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%88%86%E5%89%B2%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2022/04/03/Python-%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%88%86%E5%89%B2%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-前言"><a class="markdownIt-Anchor" href="#1-前言"></a> 1 前言</h1><p>工作过程中，会有分割字符串的需求，有可能是单个分隔符，也有可能是多个分隔符。</p><p><strong>参考</strong>：<a href="https://blog.csdn.net/zhuzuwei/article/details/78886662" target="_blank" rel="noopener">python split使用多个分隔符分割字符串</a></p><h1 id="2-实现"><a class="markdownIt-Anchor" href="#2-实现"></a> 2 实现</h1><h2 id="21-split"><a class="markdownIt-Anchor" href="#21-split"></a> 2.1 split()</h2><p><strong>参考</strong>：<a href="https://www.runoob.com/python/att-string-split.html" target="_blank" rel="noopener">Python split()方法</a></p><p><strong>缺点</strong>：python内建的<code>split()</code>函数只能使用<strong>单个分隔符</strong>，如果需要多个分隔符，需要使用下面的<code>re.split()</code>。</p><p><strong>描述</strong>：通过指定分隔符对字符串进行切片，如果参数 <code>num</code> 有指定值，则分隔 <code>num+1</code> 个子字符串。</p><p><strong>语法</strong>：<code>str.split(str=&quot;&quot;, num=string.count(str))</code></p><p><strong>参数</strong>：</p><ul><li><code>str</code>：分隔符，默认为所有的空字符，包括空格、换行(\n)、制表符(\t)等。</li><li><code>num</code>：分割次数。默认为 -1, 即分隔所有。</li></ul><p><strong>返回值</strong>：返回分割后的字符串列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">txt = <span class="string">"phx what\tphx\nai"</span>;</span><br><span class="line">print(txt.split())  <span class="comment"># ['phx', 'what', 'phx', 'ai']</span></span><br><span class="line">print(txt.split(<span class="string">' '</span>, <span class="number">1</span>))  <span class="comment"># ['phx', 'what\tphx\nai']</span></span><br><span class="line">print(txt.split(<span class="string">'phx'</span>))  <span class="comment"># ['', ' what\t', '\nai']</span></span><br></pre></td></tr></table></figure><h2 id="22-resplit"><a class="markdownIt-Anchor" href="#22-resplit"></a> 2.2 re.split()</h2><p><strong>优点</strong>：<code>re</code>模块的<code>split()</code>函数可以使用多个分隔符对句子进行分割，其中不同的分隔符要用 <code>|</code> 隔开。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">txt = <span class="string">"phx what\tphx\nai"</span>;</span><br><span class="line">print(re.split(<span class="string">" |\t"</span>, txt))  <span class="comment"># ['phx', 'what', 'phx\nai']</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python-文件-csv文件读取</title>
      <link href="/2022/04/03/Python-%E6%96%87%E4%BB%B6-csv%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/"/>
      <url>/2022/04/03/Python-%E6%96%87%E4%BB%B6-csv%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-前言"><a class="markdownIt-Anchor" href="#1-前言"></a> 1 前言</h1><p>最近在做毕设，数据集使用的天池竞赛的，csv数据格式的，下面整理下csv读取的几种方法。</p><p><strong>主要参考</strong>：<a href="https://blog.csdn.net/domoNaruto/article/details/81193281" target="_blank" rel="noopener">Python读取csv文件的几种方法</a></p><p>下面是测试文件<code>test.csv</code> 的内容（与下面的python代码同目录）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">file_id,label,api,tid,index</span><br><span class="line">1,5,LdrLoadDll,2488,0</span><br><span class="line">1,5,LdrGetProcedureAddress,2488,1</span><br><span class="line">1,5,LdrGetProcedureAddress,2488,2</span><br><span class="line">1,5,LdrGetProcedureAddress,2488,3</span><br><span class="line">1,5,LdrGetProcedureAddress,2488,4</span><br></pre></td></tr></table></figure><h1 id="2-读取操作"><a class="markdownIt-Anchor" href="#2-读取操作"></a> 2 读取操作</h1><h2 id="21-利用python-io读取文件"><a class="markdownIt-Anchor" href="#21-利用python-io读取文件"></a> 2.1 利用Python I/O读取文件</h2><h3 id="211-csvreader"><a class="markdownIt-Anchor" href="#211-csvreader"></a> 2.1.1 csv.reader()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_csv</span><span class="params">(csv_path)</span>:</span></span><br><span class="line">    data = []</span><br><span class="line">    <span class="keyword">with</span> open(csv_path) <span class="keyword">as</span> f:</span><br><span class="line">        csv_reader = csv.reader(f)  <span class="comment"># 使用csv.reader读取f中的内容</span></span><br><span class="line">        header = next(csv_reader)  <span class="comment"># 读取第一行每一列的标题</span></span><br><span class="line">        print(header)  <span class="comment"># ['file_id', 'label', 'api', 'tid', 'index']</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> csv_reader:  <span class="comment"># 将csv 文件中的数据保存到data中</span></span><br><span class="line">            data.append(row[<span class="number">1</span>])  <span class="comment"># 选择某一列加入到data数组中</span></span><br><span class="line">        print(data)  <span class="comment"># ['5', '5', '5', '5', '5']</span></span><br><span class="line">    f.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    csv_path = <span class="string">".\\test.csv"</span></span><br><span class="line">    read_csv(csv_path=csv_path)</span><br></pre></td></tr></table></figure><h3 id="212-csvdictreader"><a class="markdownIt-Anchor" href="#212-csvdictreader"></a> 2.1.2 csv.DictReader()</h3><p>可以获取字段名，参考 <a href="https://zhuanlan.zhihu.com/p/405847004" target="_blank" rel="noopener">csv.DictReader 读取字段名（headers）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_csv</span><span class="params">(csv_path)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(csv_path, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        reader = csv.DictReader(f)</span><br><span class="line">        headers = reader.fieldnames  <span class="comment"># 字段名</span></span><br><span class="line">        print(headers)  <span class="comment"># ['file_id', 'label', 'api', 'tid', 'index']</span></span><br><span class="line">        column = [row[<span class="string">'index'</span>] <span class="keyword">for</span> row <span class="keyword">in</span> reader]  <span class="comment"># weight 同列的数据</span></span><br><span class="line">        print(column)  <span class="comment"># ['0', '1', '2', '3', '4']</span></span><br><span class="line">    f.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    csv_path = <span class="string">".\\test.csv"</span></span><br><span class="line">    read_csv(csv_path=csv_path)</span><br></pre></td></tr></table></figure><h3 id="213-open"><a class="markdownIt-Anchor" href="#213-open"></a> 2.1.3 open()</h3><p>把csv文件当作文本文件，使用<code>open()</code>和<code>split</code>进行处理，但是存在明显缺点——<strong>如果字段中含有分隔符<code>,</code>，分割将会比较麻烦</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_csv</span><span class="params">(csv_path)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(csv_path) <span class="keyword">as</span> f:</span><br><span class="line">        column = []</span><br><span class="line">        column_id = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">            column.append(line.rstrip(<span class="string">"\n"</span>).split(<span class="string">','</span>)[column_id])</span><br><span class="line">        print(column)  <span class="comment"># ['file_id', '1', '1', '1', '1', '1']</span></span><br><span class="line">    f.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    csv_path = <span class="string">".\\test.csv"</span></span><br><span class="line">    read_csv(csv_path=csv_path)</span><br></pre></td></tr></table></figure><h2 id="22-利用numpy读取"><a class="markdownIt-Anchor" href="#22-利用numpy读取"></a> 2.2 利用numpy读取</h2><p>缺点：<strong>csv里面的值只能是数值型的，字符串类型会报错，读取的值是按照float存储的</strong></p><p>解释：<code>delimiter</code>是分隔符，<code>skiprows</code>是跳过前<code>n</code>行，<code>usecols</code>是使用的列数，例子中读取的是<code>3,4</code>列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_csv</span><span class="params">(csv_path)</span>:</span></span><br><span class="line">    n = <span class="number">1</span></span><br><span class="line">    data = np.loadtxt(open(csv_path, <span class="string">"rb"</span>), delimiter=<span class="string">","</span>, skiprows=n, usecols=[<span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">    print(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    csv_path = <span class="string">".\\test.csv"</span></span><br><span class="line">    read_csv(csv_path=csv_path)</span><br></pre></td></tr></table></figure><h2 id="23-利用pandas读取"><a class="markdownIt-Anchor" href="#23-利用pandas读取"></a> 2.3 利用pandas读取</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_csv</span><span class="params">(csv_path)</span>:</span></span><br><span class="line">    data = pd.read_csv(csv_path, sep=<span class="string">','</span>, header=<span class="string">'infer'</span>, usecols=[<span class="number">2</span>])</span><br><span class="line">    print(data)</span><br><span class="line">    array = data.values[<span class="number">0</span>::, <span class="number">0</span>::]  <span class="comment"># 读取全部行，全部列</span></span><br><span class="line">    print(array)  <span class="comment"># array是数组形式存储，顺序与data读取的数据顺序格式相同</span></span><br><span class="line">    print(array[<span class="number">0</span>][<span class="number">0</span>])  <span class="comment"># LdrLoadDll</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    csv_path = <span class="string">".\\test.csv"</span></span><br><span class="line">    read_csv(csv_path=csv_path)</span><br></pre></td></tr></table></figure><h1 id="x-参考"><a class="markdownIt-Anchor" href="#x-参考"></a> X 参考</h1>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【开源代码学习--若依】恶意样本界面空白</title>
      <link href="/2022/03/26/%E3%80%90%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0--%E8%8B%A5%E4%BE%9D%E3%80%91%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E7%95%8C%E9%9D%A2%E7%A9%BA%E7%99%BD/"/>
      <url>/2022/03/26/%E3%80%90%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0--%E8%8B%A5%E4%BE%9D%E3%80%91%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E7%95%8C%E9%9D%A2%E7%A9%BA%E7%99%BD/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-问题"><a class="markdownIt-Anchor" href="#1-问题"></a> 1 问题</h1><p>恶意样本界面空白，没有数据；恶意家族界面正常。</p><img src="https://s2.loli.net/2022/03/26/jS3IDeH8hlpN2at.png" width="800" height="300" alt="图片名称" align="center" id="125"><img src="https://s2.loli.net/2022/03/26/g3sXzGJT52E8Zdo.png" width="800" height="300" alt="图片名称" align="center" id="126"><h1 id="2-解决"><a class="markdownIt-Anchor" href="#2-解决"></a> 2 解决</h1><p>测试后端正常，数据也传到了前端。</p><p>最后排错，确定bug代码块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 动态分析-》图对话框 --&gt;</span><br><span class="line">&lt;el-dialog :title=&quot;title&quot; :visible.sync=&quot;open_dynamic_graph&quot; width=&quot;1100px&quot; append-to-body&gt;</span><br><span class="line">    &lt;el-image  :src=&quot;require(&apos;@/assets/graphviz_images/&apos;+this.img_path)&quot; :fit=&quot;cover&quot;&gt;&lt;/el-image&gt;</span><br><span class="line">&lt;/el-dialog&gt;</span><br></pre></td></tr></table></figure><p><strong>原因</strong>：<code>@/assets/graphviz_images/'+this.img_path</code> 文件不存在。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Element </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【开源代码学习--若依】vue+springboot文件下载</title>
      <link href="/2022/03/26/%E3%80%90%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0--%E8%8B%A5%E4%BE%9D%E3%80%91vue-springboot%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/"/>
      <url>/2022/03/26/%E3%80%90%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0--%E8%8B%A5%E4%BE%9D%E3%80%91vue-springboot%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-引入"><a class="markdownIt-Anchor" href="#1-引入"></a> 1 引入</h1><p>需要文件下载功能，如下图所示：</p><img src="https://s2.loli.net/2022/03/26/MiuO3xawsctC8Vg.png" width="900" height="300" alt="图片名称" align="center" id="124"><h1 id="2-解决"><a class="markdownIt-Anchor" href="#2-解决"></a> 2 解决</h1><h2 id="21-手写404无法下载"><a class="markdownIt-Anchor" href="#21-手写404无法下载"></a> 2.1 手写(404，无法下载)</h2><ul><li><p><a href="http://doc.ruoyi.vip/ruoyi/document/htsc.html#%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD" target="_blank" rel="noopener">若依手册——上传下载</a></p></li><li><p><a href="https://cloud.tencent.com/developer/article/1790636" target="_blank" rel="noopener">Java中将Map转String，String转Map</a></p></li><li><p><a href="https://www.cnblogs.com/javalinux/p/14807391.html" target="_blank" rel="noopener">vue+springboot文件下载</a></p></li><li><p><a href="https://www.freesion.com/article/77181445797/" target="_blank" rel="noopener">使用VUE和SPRING BOOT实现文件下载</a></p></li></ul><h2 id="22-使用官网提供的封装方法"><a class="markdownIt-Anchor" href="#22-使用官网提供的封装方法"></a> 2.2 使用官网提供的封装方法</h2><p><strong>参考</strong>：<a href="https://blog.51cto.com/YangRoc/5057161" target="_blank" rel="noopener">使用若依前后端分离下载需要授权的url文件 </a></p><ol><li><p>前端使用封装方法<code>this.$download.resource(resource);</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 表格中的下载按钮</span><br><span class="line">&lt;el-table-column label=&quot;下载报告&quot; align=&quot;center&quot; class-name=&quot;small-padding fixed-width&quot;&gt;</span><br><span class="line">    &lt;template slot-scope=&quot;scope&quot;&gt;</span><br><span class="line">&lt;el-button</span><br><span class="line">           size=&quot;mini&quot;</span><br><span class="line">           type=&quot;text&quot;</span><br><span class="line">           icon=&quot;el-icon-download&quot;</span><br><span class="line">           @click=&quot;handleDownload(scope.row)&quot;</span><br><span class="line">           v-hasPermi=&quot;[&apos;system:report:downLoad:test&apos;]&quot;</span><br><span class="line">           &gt;下载&lt;/el-button&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">&lt;/el-table-column&gt;</span><br><span class="line"></span><br><span class="line">// handleDownload(scope.row)函数实现</span><br><span class="line">/** 下载报告按钮操作 */</span><br><span class="line">handleDownload(row) &#123;</span><br><span class="line">    this.reset();</span><br><span class="line">    const id = row.id || this.ids</span><br><span class="line">    const resource = &quot;/profile/upload/&quot; + row.reportName;  // 不再设立实体类</span><br><span class="line">    // 默认方法</span><br><span class="line">    this.$download.resource(resource);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li><p>增加对xml文件的授权：修改<code>MimeTypeUtils.java</code>文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] DEFAULT_ALLOWED_EXTENSION = &#123;</span><br><span class="line">    <span class="comment">// 图片</span></span><br><span class="line">    <span class="string">"bmp"</span>, <span class="string">"gif"</span>, <span class="string">"jpg"</span>, <span class="string">"jpeg"</span>, <span class="string">"png"</span>,</span><br><span class="line">    <span class="comment">// word excel powerpoint</span></span><br><span class="line">    <span class="string">"doc"</span>, <span class="string">"docx"</span>, <span class="string">"xls"</span>, <span class="string">"xlsx"</span>, <span class="string">"ppt"</span>, <span class="string">"pptx"</span>, <span class="string">"html"</span>, <span class="string">"htm"</span>, <span class="string">"txt"</span>,</span><br><span class="line">    <span class="comment">// 压缩文件</span></span><br><span class="line">    <span class="string">"rar"</span>, <span class="string">"zip"</span>, <span class="string">"gz"</span>, <span class="string">"bz2"</span>,</span><br><span class="line">    <span class="comment">// 视频格式</span></span><br><span class="line">    <span class="string">"mp4"</span>, <span class="string">"avi"</span>, <span class="string">"rmvb"</span>,</span><br><span class="line">    <span class="comment">// pdf</span></span><br><span class="line">    <span class="string">"pdf"</span>,</span><br><span class="line">    <span class="comment">// xml</span></span><br><span class="line">    <span class="string">"xml"</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>修改资源默认路径，资源默认路径是<code>D:\ruoyi\uploadPath\upload</code>，修改文件<code>RuoYi-Vue\ruoyi-admin\src\main\resources\application.yml</code></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 项目相关配置</span></span><br><span class="line"><span class="attr">ruoyi:</span></span><br><span class="line">  <span class="comment"># 名称</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">RuoYi</span></span><br><span class="line">  <span class="comment"># 版本</span></span><br><span class="line">  <span class="attr">version:</span> <span class="number">3.8</span><span class="number">.1</span></span><br><span class="line">  <span class="comment"># 版权年份</span></span><br><span class="line">  <span class="attr">copyrightYear:</span> <span class="number">2022</span></span><br><span class="line">  <span class="comment"># 实例演示开关</span></span><br><span class="line">  <span class="attr">demoEnabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 文件路径 示例（ Windows配置D:/ruoyi/uploadPath，Linux配置 /home/ruoyi/uploadPath）</span></span><br><span class="line">  <span class="attr">profile:</span> <span class="string">E:/05</span> <span class="string">Code/RMDVS/uploadPath</span></span><br><span class="line">  <span class="comment"># 获取ip地址开关</span></span><br><span class="line">  <span class="attr">addressEnabled:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># 验证码类型 math 数组计算 char 字符验证</span></span><br><span class="line">  <span class="attr">captchaType:</span> <span class="string">math</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="23-补充修改日志默认路径"><a class="markdownIt-Anchor" href="#23-补充修改日志默认路径"></a> 2.3 补充(修改日志默认路径)</h2><p>日志默认路径：<code>E:\home\ruoyi\logs</code></p><p>修改文件：<code>RuoYi-Vue\ruoyi-admin\src\main\resources\logback.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 日志存放路径 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;property name="log.path" value="/home/ruoyi/logs" /&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"log.path"</span> <span class="attr">value</span>=<span class="string">"E:/05 Code/RMDVS/logs"</span> /&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【开源代码学习--若依】表格同列排序</title>
      <link href="/2022/03/26/%E3%80%90%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0--%E8%8B%A5%E4%BE%9D%E3%80%91%E8%A1%A8%E6%A0%BC%E5%90%8C%E5%88%97%E6%8E%92%E5%BA%8F/"/>
      <url>/2022/03/26/%E3%80%90%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0--%E8%8B%A5%E4%BE%9D%E3%80%91%E8%A1%A8%E6%A0%BC%E5%90%8C%E5%88%97%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-引入"><a class="markdownIt-Anchor" href="#1-引入"></a> 1 引入</h1><p>在表格中，需要根据同一列中的内容进行排序。如下图所示：</p><img src="https://s2.loli.net/2022/03/26/gDWL1YdseFHj7MQ.png" width="900" height="300" alt="图片名称" align="center" id="123"><h1 id="2-解决"><a class="markdownIt-Anchor" href="#2-解决"></a> 2 解决</h1><p>table标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-table v-loading=&quot;loading&quot; :data=&quot;familyList&quot; @selection-change=&quot;handleSelectionChange&quot; :default-sort=&quot;defaultSort&quot; @sort-change=&quot;handleSortChange&quot;&gt;</span><br></pre></td></tr></table></figure><p>table-column标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-table-column label=&quot;家族中样本平均得分&quot; align=&quot;center&quot; prop=&quot;averageScore&quot; sortable=&quot;custom&quot; :sort-orders=&quot;[&apos;descending&apos;, &apos;ascending&apos;]&quot; /&gt;</span><br></pre></td></tr></table></figure><p>涉及参数及函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认排序</span></span><br><span class="line">defaultSort: &#123;<span class="attr">prop</span>: <span class="string">'id'</span>, <span class="attr">order</span>: <span class="string">'ascending'</span>&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 排序触发事件 */</span></span><br><span class="line">handleSortChange(column, prop, order) &#123;</span><br><span class="line">  <span class="keyword">this</span>.queryParams.orderByColumn = column.prop;</span><br><span class="line">  <span class="keyword">this</span>.queryParams.isAsc = column.order;</span><br><span class="line">  <span class="keyword">this</span>.getList();</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Element </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【开源代码学习--若依】表格中跳转外部链接</title>
      <link href="/2022/03/26/%E3%80%90%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0--%E8%8B%A5%E4%BE%9D%E3%80%91%E8%A1%A8%E6%A0%BC%E4%B8%AD%E8%B7%B3%E8%BD%AC%E5%A4%96%E9%83%A8%E9%93%BE%E6%8E%A5/"/>
      <url>/2022/03/26/%E3%80%90%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0--%E8%8B%A5%E4%BE%9D%E3%80%91%E8%A1%A8%E6%A0%BC%E4%B8%AD%E8%B7%B3%E8%BD%AC%E5%A4%96%E9%83%A8%E9%93%BE%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-引入"><a class="markdownIt-Anchor" href="#1-引入"></a> 1 引入</h1><p>现在的需求：表格中需要加入跳转外部链接，链接是后端传入。</p><h1 id="2-解决"><a class="markdownIt-Anchor" href="#2-解决"></a> 2 解决</h1><p><strong>参考</strong>：<a href="https://blog.csdn.net/caimaomaocai/article/details/81334641" target="_blank" rel="noopener">在elementui中的table加入可跳转的链接</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-table-column label=&quot;VirusTotal链接&quot; align=&quot;center&quot;&gt;</span><br><span class="line">    &lt;template slot-scope=&quot;scope&quot;&gt;</span><br><span class="line">&lt;a :href=&quot;scope.row.permalink&quot;</span><br><span class="line">   target=&quot;_blank&quot;</span><br><span class="line">   class=&quot;buttonText&quot;</span><br><span class="line">   style=&quot;color: dodgerblue&quot;&gt;跳 转&lt;/a&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">&lt;/el-table-column&gt;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：</p><ol><li><code>scope.row.permalink</code>：表示表格当前行的<code>permalink</code>属性或参数</li><li><code>style=&quot;color: dodgerblue&quot;</code>：设置字体颜色，<a href="http://xh.5156edu.com/page/z1015m9220j18754.html" target="_blank" rel="noopener">颜色表链接</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Element </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【开源代码学习--若依】表格设置列宽</title>
      <link href="/2022/03/26/%E3%80%90%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0--%E8%8B%A5%E4%BE%9D%E3%80%91%E8%A1%A8%E6%A0%BC%E8%AE%BE%E7%BD%AE%E5%88%97%E5%AE%BD/"/>
      <url>/2022/03/26/%E3%80%90%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0--%E8%8B%A5%E4%BE%9D%E3%80%91%E8%A1%A8%E6%A0%BC%E8%AE%BE%E7%BD%AE%E5%88%97%E5%AE%BD/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-引入"><a class="markdownIt-Anchor" href="#1-引入"></a> 1 引入</h1><p><a href="https://element.eleme.cn/#/zh-CN/component/table" target="_blank" rel="noopener">官方文档——表格</a></p><p>表格中每列的文字长度不同，有些差距较大，所以需要修改表格的某一列宽度。</p><h1 id="2-解决"><a class="markdownIt-Anchor" href="#2-解决"></a> 2 解决</h1><h2 id="21宽度自适应效果不好"><a class="markdownIt-Anchor" href="#21宽度自适应效果不好"></a> 2.1宽度自适应（效果不好）</h2><p><a href="https://cloud.tencent.com/developer/article/1821511" target="_blank" rel="noopener">ElementUI 实现el-table 列宽自适应</a></p><h2 id="22-设置width属性"><a class="markdownIt-Anchor" href="#22-设置width属性"></a> 2.2 设置width属性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-table-column label=&quot;危害得分&quot; align=&quot;center&quot; prop=&quot;hazardScore&quot; width=&quot;140px&quot;/&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Element </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【开源代码学习--若依】表格分页问题</title>
      <link href="/2022/03/26/%E3%80%90%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0--%E8%8B%A5%E4%BE%9D%E3%80%91%E8%A1%A8%E6%A0%BC%E5%88%86%E9%A1%B5%E9%97%AE%E9%A2%98/"/>
      <url>/2022/03/26/%E3%80%90%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0--%E8%8B%A5%E4%BE%9D%E3%80%91%E8%A1%A8%E6%A0%BC%E5%88%86%E9%A1%B5%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-问题引入"><a class="markdownIt-Anchor" href="#1-问题引入"></a> 1 问题引入</h1><p><a href="https://cn.vuejs.org/" target="_blank" rel="noopener">Vue官方文档</a></p><p>表格实现了分页，但是点击页码后会将所有数据显示或不刷新页面，观察后台，并没有调用操作。</p><p><strong>原因</strong>：回调函数出了问题，没有正确传参。</p><h1 id="2-分页实现"><a class="markdownIt-Anchor" href="#2-分页实现"></a> 2 分页实现</h1><p><strong>参考</strong>：<a href="https://blog.csdn.net/BADAO_LIUMANG_QIZHI/article/details/108017635" target="_blank" rel="noopener">若依管理系统源码分析-分页的实现以及post请求时的分页</a></p><h2 id="21-前端调用"><a class="markdownIt-Anchor" href="#21-前端调用"></a> 2.1 前端调用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 一般在查询参数中定义分页变量</span><br><span class="line">queryParams: &#123;</span><br><span class="line">  pageNum: 1,</span><br><span class="line">  pageSize: 10</span><br><span class="line">&#125;,</span><br><span class="line"> </span><br><span class="line">// 页面添加分页组件，传入分页变量</span><br><span class="line">&lt;pagination</span><br><span class="line">  v-show=&quot;total&gt;0&quot;</span><br><span class="line">  :total=&quot;total&quot;</span><br><span class="line">  :page.sync=&quot;queryParams.pageNum&quot;</span><br><span class="line">  :limit.sync=&quot;queryParams.pageSize&quot;</span><br><span class="line">  @pagination=&quot;getList&quot;</span><br><span class="line">/&gt;</span><br><span class="line"> </span><br><span class="line">// 调用后台方法，传入参数 获取结果</span><br><span class="line">listUser(this.queryParams).then(response =&gt; &#123;</span><br><span class="line">    this.userList = response.rows;</span><br><span class="line">    this.total = response.total;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="22-后台逻辑实现"><a class="markdownIt-Anchor" href="#22-后台逻辑实现"></a> 2.2 后台逻辑实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/list"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TableDataInfo <span class="title">list</span><span class="params">(User user)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    startPage();  <span class="comment">// 此方法配合前端完成自动分页</span></span><br><span class="line">    List&lt;User&gt; list = userService.selectUserList(user);</span><br><span class="line">    <span class="keyword">return</span> getDataTable(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-解决"><a class="markdownIt-Anchor" href="#3-解决"></a> 3 解决</h1><p>回调函数进行参数传递：<code>@pagination=&quot;handleDynamic(dynamicRow)</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-table v-loading=&quot;dynamicLoading&quot; :data=&quot;dynamicList&quot; @selection-change=&quot;handleSelectionChange&quot; v-fit-columns&gt;</span><br><span class="line">    &lt;el-table-column label=&quot;行为类别&quot; align=&quot;center&quot; prop=&quot;category&quot; width=&quot;140px&quot;/&gt;</span><br><span class="line">    &lt;el-table-column label=&quot;危害等级&quot; align=&quot;center&quot; prop=&quot;hazardLevel&quot; width=&quot;140px&quot;/&gt;</span><br><span class="line">    &lt;el-table-column label=&quot;危害得分&quot; align=&quot;center&quot; prop=&quot;hazardScore&quot; width=&quot;140px&quot;/&gt;</span><br><span class="line">    &lt;el-table-column label=&quot;类目行为代表&quot; align=&quot;center&quot; prop=&quot;represent&quot; /&gt;</span><br><span class="line">&lt;/el-table&gt;</span><br><span class="line">&lt;pagination</span><br><span class="line">            v-show=&quot;dynamicTotal&gt;0&quot;</span><br><span class="line">            :total=&quot;dynamicTotal&quot;</span><br><span class="line">            :page.sync=&quot;queryDynamicParams.pageNum&quot;</span><br><span class="line">            :limit.sync=&quot;queryDynamicParams.pageSize&quot;</span><br><span class="line">            @pagination=&quot;handleDynamic(dynamicRow)&quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><p>其中：<code>v-loading</code> 作用为加载动画。</p><h1 id="4-其他问题未解决"><a class="markdownIt-Anchor" href="#4-其他问题未解决"></a> 4 其他问题(未解决)</h1><p>正常情况下，表格页面展示会默认从第一页开始。但是实践过程中会从上次表格页数展示，即使是不同的表格。</p><h1 id="x-参考"><a class="markdownIt-Anchor" href="#x-参考"></a> X 参考</h1><ul><li><a href="https://element.eleme.cn/#/zh-CN/component/table" target="_blank" rel="noopener">官方文档——表格</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Element </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【开源代码学习--若依】Element显示图片</title>
      <link href="/2022/03/26/%E3%80%90%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0--%E8%8B%A5%E4%BE%9D%E3%80%91Element%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87/"/>
      <url>/2022/03/26/%E3%80%90%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0--%E8%8B%A5%E4%BE%9D%E3%80%91Element%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-引用项目内部的图片"><a class="markdownIt-Anchor" href="#1-引用项目内部的图片"></a> 1 引用项目内部的图片</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-image  :src=&quot;require(&apos;@/assets/graphviz_images/&apos;+this.img_path)&quot; :fit=&quot;cover&quot;&gt;&lt;/el-image&gt;</span><br></pre></td></tr></table></figure><h1 id="2-参考"><a class="markdownIt-Anchor" href="#2-参考"></a> 2 参考</h1><ul><li><a href="https://element.eleme.cn/#/zh-CN/component/image" target="_blank" rel="noopener">官方文档——Image 图片</a></li><li><a href="https://blog.csdn.net/yssa1125001/article/details/106203695" target="_blank" rel="noopener">element ui 或者 element-admin 模板 img 标签 图片不能正常显示或者资源不能正常加载问题</a></li><li><a href="https://blog.csdn.net/qq_27702739/article/details/121213503" target="_blank" rel="noopener">element-ui Image组件中的隐藏功能el-image-viewer组件的使用</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Element </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【开源代码学习--若依】Element中的Icon图标</title>
      <link href="/2022/03/26/%E3%80%90%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0--%E8%8B%A5%E4%BE%9D%E3%80%91Element%E4%B8%AD%E7%9A%84Icon%E5%9B%BE%E6%A0%87/"/>
      <url>/2022/03/26/%E3%80%90%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0--%E8%8B%A5%E4%BE%9D%E3%80%91Element%E4%B8%AD%E7%9A%84Icon%E5%9B%BE%E6%A0%87/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-element简介"><a class="markdownIt-Anchor" href="#1-element简介"></a> 1 Element简介</h1><p>Element，一套为开发者、设计师和产品经理准备的基于 Vue 2.0 的桌面端组件库。</p><p><a href="https://element.eleme.cn/#/zh-CN" target="_blank" rel="noopener">官方文档</a></p><h1 id="2-icon-图标"><a class="markdownIt-Anchor" href="#2-icon-图标"></a> 2 Icon 图标</h1><p>Icon 图标提供了一套常用的图标集合。</p><p>直接通过设置类名为 el-icon-iconName 来使用即可。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;i class=&quot;el-icon-edit&quot;&gt;&lt;/i&gt;</span><br><span class="line">&lt;i class=&quot;el-icon-share&quot;&gt;&lt;/i&gt;</span><br><span class="line">&lt;i class=&quot;el-icon-delete&quot;&gt;&lt;/i&gt;</span><br><span class="line">&lt;el-button type=&quot;primary&quot; icon=&quot;el-icon-search&quot;&gt;搜索&lt;/el-button&gt;</span><br></pre></td></tr></table></figure><p><a href="https://element.eleme.cn/#/zh-CN/component/icon" target="_blank" rel="noopener">官方文档——Icon 图标</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Element </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-Mysql-sqlalchemy中的聚合函数</title>
      <link href="/2022/03/26/Python-Mysql-sqlalchemy%E4%B8%AD%E7%9A%84%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0/"/>
      <url>/2022/03/26/Python-Mysql-sqlalchemy%E4%B8%AD%E7%9A%84%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-引入"><a class="markdownIt-Anchor" href="#1-引入"></a> 1 引入</h1><p><strong>参考</strong>：<a href="https://www.yiibai.com/sql/sql-aggregate-functions.html" target="_blank" rel="noopener">SQL聚合函数</a></p><p>SQL聚合函数，包括：<code>AVG()</code>，<code>COUNT()</code>，<code>MIN()</code>，<code>MAX()</code>和<code>SUM()</code>。</p><p>SQL聚合函数计算一组值并返回单个值。 例如，平均函数(AVG)采用值列表并返回平均值。</p><h1 id="2-实验"><a class="markdownIt-Anchor" href="#2-实验"></a> 2 实验</h1><h2 id="21-构建数据表"><a class="markdownIt-Anchor" href="#21-构建数据表"></a> 2.1 构建数据表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy.ext.declarative <span class="keyword">import</span> declarative_base</span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine, Column, Integer, String</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> sessionmaker</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">'127.0.0.1'</span></span><br><span class="line">PORT = <span class="number">3306</span></span><br><span class="line">USERNAME = <span class="string">'xxx'</span>  <span class="comment"># mysql用户名</span></span><br><span class="line">PASSWORD = <span class="string">'xxx'</span>  <span class="comment"># mysql密码</span></span><br><span class="line">DB = <span class="string">'xxx'</span>  <span class="comment"># 数据库名称</span></span><br><span class="line"><span class="comment"># f代表可以使用&#123;&#125;引用变量</span></span><br><span class="line">DB_URI = <span class="string">f'mysql+pymysql://<span class="subst">&#123;USERNAME&#125;</span>:<span class="subst">&#123;PASSWORD&#125;</span>@<span class="subst">&#123;HOST&#125;</span>:<span class="subst">&#123;PORT&#125;</span>/<span class="subst">&#123;DB&#125;</span>'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建引擎</span></span><br><span class="line">engine = create_engine(DB_URI)</span><br><span class="line"><span class="comment"># 创建SQLORM基类，注意这里要加参数，参数为上一步创建的引擎</span></span><br><span class="line">Base = declarative_base(engine)</span><br><span class="line"><span class="comment"># 构建session对象</span></span><br><span class="line">session = sessionmaker(engine)()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建实体表Person</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(Base)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">'person'</span>  <span class="comment"># 表名</span></span><br><span class="line">    id = Column(Integer, primary_key=<span class="literal">True</span>, autoincrement=<span class="literal">True</span>)</span><br><span class="line">    name = Column(String(<span class="number">100</span>))</span><br><span class="line">    age = Column(Integer)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将模型映射到数据库中</span></span><br><span class="line"><span class="comment"># 即如果数据库中没有student表则创建映射表student</span></span><br><span class="line">Base.metadata.create_all()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 增：批量</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_batch</span><span class="params">(obj_list)</span>:</span></span><br><span class="line">    session.add_all(obj_list)</span><br><span class="line">    session.commit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除TestTable表</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">del_table</span><span class="params">()</span>:</span></span><br><span class="line">    Person.__table__.drop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    obj_list = [Person(name=<span class="string">"dragon"</span>, age=<span class="number">22</span>),</span><br><span class="line">                Person(name=<span class="string">"pig"</span>, age=<span class="number">23</span>),</span><br><span class="line">                Person(name=<span class="string">"SY"</span>, age=<span class="number">19</span>),</span><br><span class="line">                Person(name=<span class="string">"cat"</span>, age=<span class="number">7</span>),</span><br><span class="line">                Person(name=<span class="string">"toy"</span>, age=<span class="number">8</span>),</span><br><span class="line">                Person(name=<span class="string">"sen"</span>, age=<span class="number">23</span>),</span><br><span class="line">                Person(name=<span class="string">"tor"</span>, age=<span class="number">10</span>),</span><br><span class="line">                ]</span><br><span class="line">    insert_batch(obj_list)</span><br><span class="line">    <span class="comment"># del_table()</span></span><br></pre></td></tr></table></figure><p>数据表如下图所示：</p><img src="https://s2.loli.net/2022/03/26/h8yAv2Ts1OfipVX.png" width="800" height="200" alt="图片名称" align="center" id="120"><p><strong>下面的聚合函数，需要导入<code>func</code>：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> func</span><br></pre></td></tr></table></figure><h2 id="22-avg-返回集合中的平均值"><a class="markdownIt-Anchor" href="#22-avg-返回集合中的平均值"></a> 2.2 AVG() - 返回集合中的平均值</h2><p><strong>参考</strong>：<a href="https://blog.51cto.com/u_15127597/3800261" target="_blank" rel="noopener">SQLAlchemy（二)：SQLAlchemy对数据的增删改查操作、属性常用数据类型详解</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">age_avg = session.query(func.avg(Person.age)).scalar()  <span class="comment"># 16.0000</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：这里的<code>age</code>虽然是int类型的，但是最后的平均值是“准确”的小数。</p><h2 id="23-count-返回集合中的项目数"><a class="markdownIt-Anchor" href="#23-count-返回集合中的项目数"></a> 2.3 COUNT() - 返回集合中的项目数</h2><p><strong>参考</strong>：<a href="https://www.jianshu.com/p/b03e20cde341" target="_blank" rel="noopener">SQLAlchemy —— query</a></p><p>返回查询结果的对象的数目，下面的例子是找到了<code>toy</code>和<code>tor</code>两个对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u = session.query(Person).filter(Person.name.like(<span class="string">'to%'</span>)).count()  <span class="comment"># 2</span></span><br></pre></td></tr></table></figure><p>需要单独计算某一类对象的数量，可以用 <code>func()</code> 和 <code>group_by()</code> 配合查询：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u = session.query(Person.name, func.count(Person.name)).group_by(Person.name).all()</span><br><span class="line">print(u)  <span class="comment"># [('dragon', 1), ('pig', 1), ('SY', 1), ('cat', 1), ('toy', 1), ('sen', 1), ('tor', 1)]</span></span><br></pre></td></tr></table></figure><p>返回查询得到的的数值，我们使用 <code>scalar()</code> 方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u = session.query(func.count(Person.age)).scalar()  <span class="comment"># 7</span></span><br></pre></td></tr></table></figure><h2 id="24-min-返回集合的最小值"><a class="markdownIt-Anchor" href="#24-min-返回集合的最小值"></a> 2.4 MIN() - 返回集合的最小值</h2><p><strong>参考</strong>：<a href="https://blog.51cto.com/u_15127597/3800261" target="_blank" rel="noopener">SQLAlchemy（二)：SQLAlchemy对数据的增删改查操作、属性常用数据类型详解</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">age_min = session.query(func.min(Person.age)).scalar()  <span class="comment"># 7</span></span><br></pre></td></tr></table></figure><h2 id="25-max-返回集合的最大值"><a class="markdownIt-Anchor" href="#25-max-返回集合的最大值"></a> 2.5 MAX() - 返回集合的最大值</h2><p><strong>参考</strong>：<a href="https://blog.51cto.com/u_15127597/3800261" target="_blank" rel="noopener">SQLAlchemy（二)：SQLAlchemy对数据的增删改查操作、属性常用数据类型详解</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">age_max = session.query(func.max(Person.age)).scalar()  <span class="comment"># 23</span></span><br></pre></td></tr></table></figure><h2 id="26-sum-返回所有值的总和"><a class="markdownIt-Anchor" href="#26-sum-返回所有值的总和"></a> 2.6 SUM() - 返回所有值的总和</h2><p><strong>参考</strong>：<a href="https://blog.csdn.net/weixin_43303732/article/details/86476069" target="_blank" rel="noopener">sqlalchemy对数据进行求和</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">age_sum = session.query(func.sum(Person.age)).scalar()  <span class="comment"># 112</span></span><br><span class="line">age_sum = session.query(func.sum(Person.age)).filter(Person.name.like(<span class="string">"to%"</span>)).scalar()  <span class="comment"># 18</span></span><br></pre></td></tr></table></figure><h1 id="x-参考"><a class="markdownIt-Anchor" href="#x-参考"></a> X 参考</h1><ul><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL-错误1366：字段编码报错</title>
      <link href="/2022/03/26/MySQL-%E9%94%99%E8%AF%AF1366%EF%BC%9A%E5%AD%97%E6%AE%B5%E7%BC%96%E7%A0%81%E6%8A%A5%E9%94%99/"/>
      <url>/2022/03/26/MySQL-%E9%94%99%E8%AF%AF1366%EF%BC%9A%E5%AD%97%E6%AE%B5%E7%BC%96%E7%A0%81%E6%8A%A5%E9%94%99/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-引入"><a class="markdownIt-Anchor" href="#1-引入"></a> 1 引入</h1><p>在做毕设时，操作mysql时出现了这样的一个报错：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlalchemy.exc.DataError: (pymysql.err.DataError) (1366, <span class="string">"Incorrect string value: '\\xF2\\x88\\xBF\\xB6E ...' for column 'property' at row 1"</span>)</span><br></pre></td></tr></table></figure><p><strong>原因</strong>：UTF-8编码有可能是两个、三个、四个字节。Emoji表情或者某些特殊字符是4个字节，而Mysql的utf8编码最多3个字节，所以数据插不进去。</p><h1 id="2-解决"><a class="markdownIt-Anchor" href="#2-解决"></a> 2 解决</h1><h2 id="21-问题复现"><a class="markdownIt-Anchor" href="#21-问题复现"></a> 2.1 问题复现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy.ext.declarative <span class="keyword">import</span> declarative_base</span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> sessionmaker</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">'127.0.0.1'</span></span><br><span class="line">PORT = <span class="number">3306</span></span><br><span class="line">USERNAME = <span class="string">'xxx'</span></span><br><span class="line">PASSWORD = <span class="string">'xxx'</span></span><br><span class="line">DB = <span class="string">'xxx'</span></span><br><span class="line"><span class="comment"># f代表可以使用&#123;&#125;引用变量</span></span><br><span class="line">DB_URI = <span class="string">f'mysql+pymysql://<span class="subst">&#123;USERNAME&#125;</span>:<span class="subst">&#123;PASSWORD&#125;</span>@<span class="subst">&#123;HOST&#125;</span>:<span class="subst">&#123;PORT&#125;</span>/<span class="subst">&#123;DB&#125;</span>'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建引擎</span></span><br><span class="line">engine = create_engine(DB_URI)</span><br><span class="line"><span class="comment"># 创建SQLORM基类，注意这里要加参数，参数为上一步创建的引擎</span></span><br><span class="line">Base = declarative_base(engine)</span><br><span class="line"><span class="comment"># 构建session对象</span></span><br><span class="line">session = sessionmaker(engine)()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建实体表Encode</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Encode</span><span class="params">(Base)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">"string_encode"</span></span><br><span class="line">    id = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    property = Column(TEXT)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将模型映射到数据库中</span></span><br><span class="line"><span class="comment"># 即如果数据库中没有student表则创建映射表student</span></span><br><span class="line">Base.metadata.create_all()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 增：一个</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(obj)</span>:</span></span><br><span class="line">    session.add(obj)  <span class="comment"># 添加到session</span></span><br><span class="line">    session.commit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除Encode表</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">del_table</span><span class="params">()</span>:</span></span><br><span class="line">    Encode.__table__.drop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    property = <span class="string">"📦 🚀 森罗万象"</span></span><br><span class="line">    insert(Encode(property=property))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># del_table()</span></span><br></pre></td></tr></table></figure><p>出现报错：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sqlalchemy.exc.DataError: (pymysql.err.DataError) (1366, <span class="string">"Incorrect string value: '\\xF0\\x9F\\x93\\xA6 \\xF0...' for column 'property' at row 1"</span>)</span><br><span class="line">[SQL: INSERT INTO string_encode (property) VALUES (%(property)s)]</span><br><span class="line">[parameters: &#123;<span class="string">'property'</span>: <span class="string">'📦 🚀 森罗万象'</span>&#125;]</span><br><span class="line">(Background on this error at: https://sqlalche.me/e/14/9h9h)</span><br></pre></td></tr></table></figure><h2 id="22-尝试解决"><a class="markdownIt-Anchor" href="#22-尝试解决"></a> 2.2 尝试解决</h2><h3 id="221-sqlalchemy-设置表编码及引擎"><a class="markdownIt-Anchor" href="#221-sqlalchemy-设置表编码及引擎"></a> 2.2.1 Sqlalchemy 设置表编码及引擎</h3><p><strong>参考</strong>：<a href="https://blog.csdn.net/weixin_34015336/article/details/93760632" target="_blank" rel="noopener">Sqlalchemy 设置表编码及引擎</a></p><ol><li><p>设置引擎编码方式为utf8：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DB_URI = <span class="string">f'mysql+pymysql://<span class="subst">&#123;USERNAME&#125;</span>:<span class="subst">&#123;PASSWORD&#125;</span>@<span class="subst">&#123;HOST&#125;</span>:<span class="subst">&#123;PORT&#125;</span>/<span class="subst">&#123;DB&#125;</span>?charset=utf8'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认是utf8，所以上述代码无需修改</span></span><br><span class="line">DB_URI = <span class="string">f'mysql+pymysql://<span class="subst">&#123;USERNAME&#125;</span>:<span class="subst">&#123;PASSWORD&#125;</span>@<span class="subst">&#123;HOST&#125;</span>:<span class="subst">&#123;PORT&#125;</span>/<span class="subst">&#123;DB&#125;</span>'</span></span><br></pre></td></tr></table></figure></li><li><p>设置数据库表编码方式为utf8mb4：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Encode</span><span class="params">(Base)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">"string_encode"</span></span><br><span class="line">    id = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    property = Column(TEXT)</span><br><span class="line">    __table_args__ = &#123;</span><br><span class="line">        <span class="string">"mysql_charset"</span>: <span class="string">"utf8mb4"</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>删除原来的表，再次生成表结构就可以正常插入了：</p><img src="https://s2.loli.net/2022/03/26/TlzLxG3yScio7EY.png" width="800" height="200" alt="图片名称" align="center" id="119"></li></ol><p><strong>缺点</strong>：需要重新构建表，所以旧表存在大量数据就会比较麻烦；在这种情况下可以使用下面的方法。</p><h3 id="222-修改表的字符集为utf8mb4"><a class="markdownIt-Anchor" href="#222-修改表的字符集为utf8mb4"></a> 2.2.2 修改表的字符集为utf8mb4</h3><p><strong>参考</strong>：<a href="https://blog.csdn.net/qlzy_5418/article/details/91973353" target="_blank" rel="noopener">mysql之（1366，“Incorrect string value:’\xF0\x9F\x98\x82…’ for column ‘content’ at row 1”)20</a></p><ol><li><p>navicat右击需要修改的数据表，点击设计表；</p></li><li><p>选择要修改的字段<code>property</code>，将字符集修改为<code>utf8mb4</code>，然后保存：</p><img src="https://s2.loli.net/2022/03/26/Ne1f5wn8GOLZqxt.png" width="800" height="300" alt="图片名称" align="center" id="120"></li><li><p>现在就可以正常插入了：</p><img src="https://s2.loli.net/2022/03/26/8pfV65gsinLQFMS.png" width="800" height="300" alt="图片名称" align="center" id="121"></li></ol><p><strong>缺点</strong>：这种方法仅仅改变了当前表的字符集，如果以后项目迁移，重新生成表的情况，相同的问题将会再次出现。</p><h1 id="x-参考"><a class="markdownIt-Anchor" href="#x-参考"></a> X 参考</h1><ul><li><a href="https://blog.csdn.net/zz975896590/article/details/119991096" target="_blank" rel="noopener">Mysql错误1366的解决办法：Incorrect string value: ‘\xF0\x9F…’ for column ‘XXX’ at row 1</a></li><li><a href="https://blog.csdn.net/wenxingchen/article/details/118021258" target="_blank" rel="noopener">pymysql.err.DataError: (1366, “Incorrect string value: ‘\xF0\x9F\x92\xA1 \xE4…‘ for column ‘d</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL-错误1406：超长字符串</title>
      <link href="/2022/03/25/MySQL-%E9%94%99%E8%AF%AF1406%EF%BC%9A%E8%B6%85%E9%95%BF%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2022/03/25/MySQL-%E9%94%99%E8%AF%AF1406%EF%BC%9A%E8%B6%85%E9%95%BF%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-引入"><a class="markdownIt-Anchor" href="#1-引入"></a> 1 引入</h1><p>在做毕设时，操作mysql时出现了这样的一个报错：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlalchemy.exc.DataError: (pymysql.err.DataError) (1406, <span class="string">"Data too long for column 'actions' at row 1"</span>)</span><br></pre></td></tr></table></figure><p>这里显示字段的长度不够存放数据，也就是解决mysql超长字符串存储问题。</p><h1 id="2-解决"><a class="markdownIt-Anchor" href="#2-解决"></a> 2 解决</h1><h2 id="21-问题复现"><a class="markdownIt-Anchor" href="#21-问题复现"></a> 2.1 问题复现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy.ext.declarative <span class="keyword">import</span> declarative_base</span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> sessionmaker</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">'127.0.0.1'</span></span><br><span class="line">PORT = <span class="number">3306</span></span><br><span class="line">USERNAME = <span class="string">'xxx'</span></span><br><span class="line">PASSWORD = <span class="string">'xxx'</span></span><br><span class="line">DB = <span class="string">'xxx'</span></span><br><span class="line"><span class="comment"># f代表可以使用&#123;&#125;引用变量</span></span><br><span class="line">DB_URI = <span class="string">f'mysql+pymysql://<span class="subst">&#123;USERNAME&#125;</span>:<span class="subst">&#123;PASSWORD&#125;</span>@<span class="subst">&#123;HOST&#125;</span>:<span class="subst">&#123;PORT&#125;</span>/<span class="subst">&#123;DB&#125;</span>'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建引擎</span></span><br><span class="line">engine = create_engine(DB_URI)</span><br><span class="line"><span class="comment"># 创建SQLORM基类，注意这里要加参数，参数为上一步创建的引擎</span></span><br><span class="line">Base = declarative_base(engine)</span><br><span class="line"><span class="comment"># 构建session对象</span></span><br><span class="line">session = sessionmaker(engine)()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建实体表Length</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Length</span><span class="params">(Base)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">"string_length"</span></span><br><span class="line">    id = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    actions = Column(String(<span class="number">10</span>))  <span class="comment"># 修改此处debug</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将模型映射到数据库中</span></span><br><span class="line"><span class="comment"># 即如果数据库中没有student表则创建映射表student</span></span><br><span class="line">Base.metadata.create_all()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 增：一个</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(obj)</span>:</span></span><br><span class="line">    session.add(obj)  <span class="comment"># 添加到session</span></span><br><span class="line">    session.commit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除Data表</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">del_table</span><span class="params">()</span>:</span></span><br><span class="line">    Length.__table__.drop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    actions = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):  <span class="comment"># 修改长度进行测试</span></span><br><span class="line">        actions += <span class="string">"SY"</span></span><br><span class="line">    insert(Length(actions=actions))</span><br><span class="line">    del_table()</span><br></pre></td></tr></table></figure><p>出现报错：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sqlalchemy.exc.DataError: (pymysql.err.DataError) (1406, <span class="string">"Data too long for column 'actions' at row 1"</span>)</span><br><span class="line">[SQL: INSERT INTO string_length (actions) VALUES (%(actions)s)]</span><br><span class="line">[parameters: &#123;<span class="string">'actions'</span>: <span class="string">'SYSYSYSYSYSYSYSYSYSY'</span>&#125;]</span><br><span class="line">(Background on this error at: https://sqlalche.me/e/14/9h9h)</span><br></pre></td></tr></table></figure><h2 id="22-尝试解决"><a class="markdownIt-Anchor" href="#22-尝试解决"></a> 2.2 尝试解决</h2><ol><li><p>修改String的长度参数，可以解决：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">actions = Column(String(<span class="number">21842</span>))</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：VARCHAR(0-65535 bytes)，这里测试String的长度参数最大是<code>21842</code>，具体意思与大小还不清楚。</p></li><li><p>修改长度后就发生了之前的报错：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">actions = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">21842</span>):</span><br><span class="line">    actions += <span class="string">"SY"</span></span><br><span class="line">insert(Length(actions=actions))</span><br></pre></td></tr></table></figure><p>修改字段类型为<code>TEXT</code>可以解决上述问题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">actions = Column(TEXT)  <span class="comment"># 64K TEXT</span></span><br><span class="line">actions = Column(TEXT(<span class="number">65536</span>))  <span class="comment"># 16M MEDIUMTEXT</span></span><br><span class="line">actions = Column(TEXT(<span class="number">16777216</span>))  <span class="comment"># 32M LONGTEXT</span></span><br></pre></td></tr></table></figure><p>现在字符串最大长度可以到32M，可以cover大部分情况。</p></li></ol><h1 id="x-参考"><a class="markdownIt-Anchor" href="#x-参考"></a> X 参考</h1><ul><li><a href="https://blog.csdn.net/Darkman_EX/article/details/85211597" target="_blank" rel="noopener">mysql报错：“DataError: (pymysql.err.DataError) (1406, &quot;Data too long for column ‘pwd’ at row 1”</a></li><li><a href="https://blog.csdn.net/qq_41251963/article/details/86659549" target="_blank" rel="noopener">pymysql.err.DataError: (1406, “Data too long for column ‘字段名’ at row 1”)</a></li><li><a href="https://blog.csdn.net/qq392039757/article/details/83617260" target="_blank" rel="noopener">pymysql.err.DataError: (1406, “Data too long for column ‘url’ at row 1”)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL-数据类型以及sqlalchemy中的对应</title>
      <link href="/2022/03/25/MySQL-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BB%A5%E5%8F%8Asqlalchemy%E4%B8%AD%E7%9A%84%E5%AF%B9%E5%BA%94/"/>
      <url>/2022/03/25/MySQL-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BB%A5%E5%8F%8Asqlalchemy%E4%B8%AD%E7%9A%84%E5%AF%B9%E5%BA%94/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-mysql数据类型"><a class="markdownIt-Anchor" href="#1-mysql数据类型"></a> 1 MySQL数据类型</h1><ul><li><strong>参考</strong>：<a href="https://www.runoob.com/mysql/mysql-data-types.html" target="_blank" rel="noopener">MySQL 数据类型</a></li></ul><p>MySQL 支持多种类型，大致可以分为三类：数值、日期/时间和字符串(字符)类型。</p><h2 id="11-数值类型"><a class="markdownIt-Anchor" href="#11-数值类型"></a> 1.1 数值类型</h2><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">大小</th><th style="text-align:center">范围（有符号）</th><th style="text-align:center">范围（无符号）</th><th style="text-align:center">用途</th></tr></thead><tbody><tr><td style="text-align:center">TINYINT</td><td style="text-align:center">1 Bytes</td><td style="text-align:center">(-128，127)</td><td style="text-align:center">(0，255)</td><td style="text-align:center">小整数值</td></tr><tr><td style="text-align:center">SMALLINT</td><td style="text-align:center">2 Bytes</td><td style="text-align:center">(-32768，32767)</td><td style="text-align:center">(0，65 535)</td><td style="text-align:center">大整数值</td></tr><tr><td style="text-align:center">MEDIUMINT</td><td style="text-align:center">3 Bytes</td><td style="text-align:center">(-8388608，8388607)</td><td style="text-align:center">(0，16 777 215)</td><td style="text-align:center">大整数值</td></tr><tr><td style="text-align:center">INT或INTEGER</td><td style="text-align:center">4 Bytes</td><td style="text-align:center">(-2 147 483 648，2 147 483 647)</td><td style="text-align:center">(0，4 294 967 295)</td><td style="text-align:center">大整数值</td></tr><tr><td style="text-align:center">BIGINT</td><td style="text-align:center">8 Bytes</td><td style="text-align:center">(-9,223,372,036,854,775,808，9 223 372 036 854 775 807)</td><td style="text-align:center">(0，18 446 744 073 709 551 615)</td><td style="text-align:center">极大整数值</td></tr><tr><td style="text-align:center">FLOAT</td><td style="text-align:center">4 Bytes</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">单精度浮点数值</td></tr><tr><td style="text-align:center">DOUBLE</td><td style="text-align:center">8 Bytes</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">双精度浮点数值</td></tr><tr><td style="text-align:center">DECIMAL或DEC</td><td style="text-align:center">对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td><td style="text-align:center">依赖于M和D的值</td><td style="text-align:center">依赖于M和D的值</td><td style="text-align:center">小数值</td></tr></tbody></table><h2 id="12-日期和时间类型"><a class="markdownIt-Anchor" href="#12-日期和时间类型"></a> 1.2 日期和时间类型</h2><p>每个时间类型有一个有效值范围和一个&quot;零&quot;值，当指定不合法的MySQL不能表示的值时使用&quot;零&quot;值。</p><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">大小 ( bytes)</th><th style="text-align:center">范围</th><th style="text-align:center">格式</th><th style="text-align:center">用途</th></tr></thead><tbody><tr><td style="text-align:center">DATE</td><td style="text-align:center">3</td><td style="text-align:center">1000-01-01/9999-12-31</td><td style="text-align:center">YYYY-MM-DD</td><td style="text-align:center">日期值</td></tr><tr><td style="text-align:center">TIME</td><td style="text-align:center">3</td><td style="text-align:center">‘-838:59:59’/‘838:59:59’</td><td style="text-align:center">HH:MM:SS</td><td style="text-align:center">时间值或持续时间</td></tr><tr><td style="text-align:center">YEAR</td><td style="text-align:center">1</td><td style="text-align:center">1901/2155</td><td style="text-align:center">YYYY</td><td style="text-align:center">年份值</td></tr><tr><td style="text-align:center">DATETIME</td><td style="text-align:center">8</td><td style="text-align:center">1000-01-01 00:00:00/9999-12-31 23:59:59</td><td style="text-align:center">YYYY-MM-DD HH:MM:SS</td><td style="text-align:center">混合日期和时间值</td></tr><tr><td style="text-align:center">TIMESTAMP</td><td style="text-align:center">4</td><td style="text-align:center">1970-01-01 00:00:00/2038结束时间是第 <strong>2147483647</strong> 秒，北京时间 <strong>2038-1-19 11:14:07</strong>，格林尼治时间 2038年1月19日 凌晨 03:14:07</td><td style="text-align:center">YYYYMMDD HHMMSS</td><td style="text-align:center">混合日期和时间值，时间戳</td></tr></tbody></table><h2 id="13-字符串类型"><a class="markdownIt-Anchor" href="#13-字符串类型"></a> 1.3 字符串类型</h2><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">大小</th><th style="text-align:center">用途</th></tr></thead><tbody><tr><td style="text-align:center">CHAR</td><td style="text-align:center">0-255 bytes</td><td style="text-align:center">定长字符串</td></tr><tr><td style="text-align:center">VARCHAR</td><td style="text-align:center">0-65535 bytes</td><td style="text-align:center">变长字符串</td></tr><tr><td style="text-align:center">TINYBLOB</td><td style="text-align:center">0-255 bytes</td><td style="text-align:center">不超过 255 个字符的二进制字符串</td></tr><tr><td style="text-align:center">TINYTEXT</td><td style="text-align:center">0-255 bytes</td><td style="text-align:center">短文本字符串</td></tr><tr><td style="text-align:center">BLOB</td><td style="text-align:center">0-65 535 bytes</td><td style="text-align:center">二进制形式的长文本数据</td></tr><tr><td style="text-align:center">TEXT</td><td style="text-align:center">0-65 535 bytes</td><td style="text-align:center">长文本数据</td></tr><tr><td style="text-align:center">MEDIUMBLOB</td><td style="text-align:center">0-16 777 215 bytes</td><td style="text-align:center">二进制形式的中等长度文本数据</td></tr><tr><td style="text-align:center">MEDIUMTEXT</td><td style="text-align:center">0-16 777 215 bytes</td><td style="text-align:center">中等长度文本数据</td></tr><tr><td style="text-align:center">LONGBLOB</td><td style="text-align:center">0-4 294 967 295 bytes</td><td style="text-align:center">二进制形式的极大文本数据</td></tr><tr><td style="text-align:center">LONGTEXT</td><td style="text-align:center">0-4 294 967 295 bytes</td><td style="text-align:center">极大文本数据</td></tr></tbody></table><ul><li>char(n) 和 varchar(n) 中括号中 n 代表字符的个数，并不代表字节个数，比如 CHAR(30) 就可以存储 30 个字符。</li><li>CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。</li><li>BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。</li><li>BLOB 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。它们区别在于可容纳存储范围不同。</li><li>有 4 种 TEXT 类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。对应的这 4 种 BLOB 类型，可存储的最大长度不同，可根据实际情况选择。</li></ul><h1 id="2-mysql-sqlalchemy与python数据类型对应"><a class="markdownIt-Anchor" href="#2-mysql-sqlalchemy与python数据类型对应"></a> 2 MySQL、sqlalchemy与Python数据类型对应</h1><table><thead><tr><th style="text-align:center">Mysql类型</th><th style="text-align:center">sqlalchemy类型</th><th style="text-align:center">python类型</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">TINYINT(1B)</td><td style="text-align:center">Boolean</td><td style="text-align:center">bool</td><td style="text-align:center">布尔值</td></tr><tr><td style="text-align:center">SMALLINT(2B)</td><td style="text-align:center">SmallInteger</td><td style="text-align:center">int</td><td style="text-align:center">取值范围较小，一般为16位</td></tr><tr><td style="text-align:center">MEDIUMINT(3B)</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">INT或INTEGER(4B)</td><td style="text-align:center">Integer</td><td style="text-align:center">int</td><td style="text-align:center">普通整数，一般32位</td></tr><tr><td style="text-align:center">BIGINT(8B)</td><td style="text-align:center">BigInteger</td><td style="text-align:center">int/long</td><td style="text-align:center">不限精度的整数</td></tr><tr><td style="text-align:center">FLOAT(4B)</td><td style="text-align:center">Float</td><td style="text-align:center">float</td><td style="text-align:center">浮点数</td></tr><tr><td style="text-align:center">DOUBLE(8B)</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">DECIMAL或DEC</td><td style="text-align:center">Numeric</td><td style="text-align:center">decimal.Decimal</td><td style="text-align:center">定点数</td></tr><tr><td style="text-align:center">DATE(3B)</td><td style="text-align:center">Date</td><td style="text-align:center">datetime.date</td><td style="text-align:center">日期</td></tr><tr><td style="text-align:center">TIME(3B)</td><td style="text-align:center">Time</td><td style="text-align:center">date.time</td><td style="text-align:center">时间</td></tr><tr><td style="text-align:center">YEAR(1B)</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">DATETIME(8B)</td><td style="text-align:center">DateTime</td><td style="text-align:center">datetime.datetime</td><td style="text-align:center">日期和时间</td></tr><tr><td style="text-align:center">TIMESTAMP(4B)</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">CHAR</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">VARCHAR</td><td style="text-align:center">String</td><td style="text-align:center">str</td><td style="text-align:center">变长字符串，而且String后面需要长度参数，否则报错</td></tr><tr><td style="text-align:center">TINYBLOB</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">TINYTEXT</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">BLOB</td><td style="text-align:center">LargeBinary</td><td style="text-align:center">str</td><td style="text-align:center">二进制文件，64K=65535bytes</td></tr><tr><td style="text-align:center">TEXT</td><td style="text-align:center">Text</td><td style="text-align:center">str</td><td style="text-align:center">变长字符串，64K=65535bytes(255bytes)</td></tr><tr><td style="text-align:center">MEDIUMBLOB</td><td style="text-align:center">LargeBinary(65536)</td><td style="text-align:center">str</td><td style="text-align:center">二进制，16M=16777215bytes</td></tr><tr><td style="text-align:center">MEDIUMTEXT</td><td style="text-align:center">Text(65536)</td><td style="text-align:center">str</td><td style="text-align:center">变长字符串，16M=16777215bytes</td></tr><tr><td style="text-align:center">LONGBLOB</td><td style="text-align:center">LargeBinary(16777216)</td><td style="text-align:center">str</td><td style="text-align:center">二进制，32M=4294967295bytes</td></tr><tr><td style="text-align:center">LONGTEXT</td><td style="text-align:center">Text(16777216)</td><td style="text-align:center">str</td><td style="text-align:center">变长字符串，32M=4294967295bytes</td></tr><tr><td style="text-align:center">ENUM</td><td style="text-align:center">Enum</td><td style="text-align:center">str</td><td style="text-align:center">一组字符串</td></tr></tbody></table><h1 id="3-代码实战"><a class="markdownIt-Anchor" href="#3-代码实战"></a> 3 代码实战</h1><h2 id="31-建立mysql表"><a class="markdownIt-Anchor" href="#31-建立mysql表"></a> 3.1 建立MySQL表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy.ext.declarative <span class="keyword">import</span> declarative_base</span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> sessionmaker</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">'127.0.0.1'</span></span><br><span class="line">PORT = <span class="number">3306</span></span><br><span class="line">USERNAME = <span class="string">'xxx'</span>  <span class="comment"># mysql的用户名</span></span><br><span class="line">PASSWORD = <span class="string">'xxx'</span>  <span class="comment"># mysql的密码</span></span><br><span class="line">DB = <span class="string">'xxx'</span>  <span class="comment"># 数据库名称</span></span><br><span class="line"><span class="comment"># f代表可以使用&#123;&#125;引用变量</span></span><br><span class="line">DB_URI = <span class="string">f'mysql+pymysql://<span class="subst">&#123;USERNAME&#125;</span>:<span class="subst">&#123;PASSWORD&#125;</span>@<span class="subst">&#123;HOST&#125;</span>:<span class="subst">&#123;PORT&#125;</span>/<span class="subst">&#123;DB&#125;</span>'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建引擎</span></span><br><span class="line">engine = create_engine(DB_URI)</span><br><span class="line"><span class="comment"># 创建SQLORM基类，注意这里要加参数，参数为上一步创建的引擎</span></span><br><span class="line">Base = declarative_base(engine)</span><br><span class="line"><span class="comment"># 构建session对象</span></span><br><span class="line">session = sessionmaker(engine)()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建实体表Data</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span><span class="params">(Base)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">"data_type"</span></span><br><span class="line">    id = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    booleanData = Column(Boolean(<span class="number">0</span>))  <span class="comment"># TINYINT(1B)</span></span><br><span class="line">    smallInteger = Column(SmallInteger)  <span class="comment"># SMALLINT(2B)</span></span><br><span class="line">    integer = Column(Integer)  <span class="comment"># INT或INTEGER(4B)</span></span><br><span class="line">    bigInteger = Column(BigInteger)  <span class="comment"># BIGINT(8B)</span></span><br><span class="line">    floatData = Column(Float)  <span class="comment"># FLOAT(4B)</span></span><br><span class="line">    numericData = Column(Numeric)  <span class="comment"># DECIMAL或DEC</span></span><br><span class="line">    dateData = Column(Date)  <span class="comment"># DATE(3B)</span></span><br><span class="line">    timeData = Column(Time)  <span class="comment"># TIME(3B)</span></span><br><span class="line">    dateTime = Column(DateTime)  <span class="comment"># DATETIME(8B)</span></span><br><span class="line">    stringData = Column(String(<span class="number">250</span>))  <span class="comment"># VARCHAR</span></span><br><span class="line">    textData = Column(Text)</span><br><span class="line">    mediumText = Column(Text(<span class="number">65536</span>))</span><br><span class="line">    longText = Column(Text(<span class="number">16777216</span>))</span><br><span class="line">    largeBinary = Column(LargeBinary)</span><br><span class="line">    mediumBlob = Column(LargeBinary(<span class="number">65536</span>))</span><br><span class="line">    longBlob = Column(LargeBinary(<span class="number">16777216</span>))</span><br><span class="line">    enumData = Column(Enum(<span class="string">'father'</span>, <span class="string">'mother'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将模型映射到数据库中</span></span><br><span class="line"><span class="comment"># 即如果数据库中没有student表则创建映射表student</span></span><br><span class="line">Base.metadata.create_all()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除Data表</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">del_table</span><span class="params">()</span>:</span></span><br><span class="line">    Data.__table__.drop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    print(<span class="string">"test data type"</span>)</span><br><span class="line">    <span class="comment"># del_table()</span></span><br></pre></td></tr></table></figure><h2 id="32-mysql表结构"><a class="markdownIt-Anchor" href="#32-mysql表结构"></a> 3.2 MySQL表结构</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DESC data_type;</span><br><span class="line">+--------------+-------------------------+------+-----+---------+----------------+</span><br><span class="line">| Field        | Type                    | Null | Key | Default | Extra          |</span><br><span class="line">+--------------+-------------------------+------+-----+---------+----------------+</span><br><span class="line">| id           | int                     | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| booleanData  | tinyint(1)              | YES  |     | NULL    |                |</span><br><span class="line">| smallInteger | smallint                | YES  |     | NULL    |                |</span><br><span class="line">| <span class="built_in">integer</span>      | int                     | YES  |     | NULL    |                |</span><br><span class="line">| bigInteger   | bigint                  | YES  |     | NULL    |                |</span><br><span class="line">| floatData    | <span class="built_in">float</span>                   | YES  |     | NULL    |                |</span><br><span class="line">| numericData  | decimal(10,0)           | YES  |     | NULL    |                |</span><br><span class="line">| dateData     | date                    | YES  |     | NULL    |                |</span><br><span class="line">| timeData     | time                    | YES  |     | NULL    |                |</span><br><span class="line">| dateTime     | datetime                | YES  |     | NULL    |                |</span><br><span class="line">| stringData   | varchar(250)            | YES  |     | NULL    |                |</span><br><span class="line">| textData     | text                    | YES  |     | NULL    |                |</span><br><span class="line">| mediumText   | mediumtext              | YES  |     | NULL    |                |</span><br><span class="line">| longText     | longtext                | YES  |     | NULL    |                |</span><br><span class="line">| largeBinary  | blob                    | YES  |     | NULL    |                |</span><br><span class="line">| mediumBlob   | mediumblob              | YES  |     | NULL    |                |</span><br><span class="line">| longBlob     | longblob                | YES  |     | NULL    |                |</span><br><span class="line">| enumData     | enum(<span class="string">'father'</span>,<span class="string">'mother'</span>) | YES  |     | NULL    |                |</span><br><span class="line">+--------------+-------------------------+------+-----+---------+----------------+</span><br></pre></td></tr></table></figure><h1 id="x-参考"><a class="markdownIt-Anchor" href="#x-参考"></a> X 参考</h1><ul><li><a href="https://www.cnblogs.com/hzjdpawn/p/12893270.html" target="_blank" rel="noopener">Flask SQLAlchemy 数据类型和数据库的对应关系 </a></li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修复TortoiseGit文件夹和文件状态图标不显示问题</title>
      <link href="/2022/03/25/%E4%BF%AE%E5%A4%8DTortoiseGit%E6%96%87%E4%BB%B6%E5%A4%B9%E5%92%8C%E6%96%87%E4%BB%B6%E7%8A%B6%E6%80%81%E5%9B%BE%E6%A0%87%E4%B8%8D%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/"/>
      <url>/2022/03/25/%E4%BF%AE%E5%A4%8DTortoiseGit%E6%96%87%E4%BB%B6%E5%A4%B9%E5%92%8C%E6%96%87%E4%BB%B6%E7%8A%B6%E6%80%81%E5%9B%BE%E6%A0%87%E4%B8%8D%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-引入"><a class="markdownIt-Anchor" href="#1-引入"></a> 1 引入</h1><p>今天打开git仓库项目，突然发现文件夹和文件状态图标不再显示。</p><h1 id="2-解决修改注册表overlay的值"><a class="markdownIt-Anchor" href="#2-解决修改注册表overlay的值"></a> 2 解决(修改注册表Overlay的值)</h1><p>参考：<a href="https://www.cnblogs.com/xiesong/p/5761352.html" target="_blank" rel="noopener">【随记】修复TortoiseGit文件夹和文件状态图标不显示问题</a></p><ol><li><p>按<code>Win+R</code>键打开运行对话框，输入 <code>regedit</code> ，打开注册表；</p></li><li><p>在注册表中找到 <code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\ShellIconOverlayIdentifiers</code></p></li><li><p>修改tortoise相关的名称（如在名称前加一个空格前缀）使其置于开始位置：</p><img src="https://s2.loli.net/2022/03/25/fvyk7c52IzhD1HQ.png" width="900" height="400" alt="图片名称" align="center" id="117"></li><li><p>重启电脑，图标正常显示：</p><img src="https://s2.loli.net/2022/03/25/Ca8BDKsJQLfoqnY.png" width="900" height="300" alt="图片名称" align="center" id="118"></li></ol><h1 id="x-参考"><a class="markdownIt-Anchor" href="#x-参考"></a> X 参考</h1><ul><li><a href="https://blog.csdn.net/mcsbary/article/details/90665192" target="_blank" rel="noopener">TortoiseGit 显示文件状态图标</a></li><li><a href="https://blog.csdn.net/quantum7/article/details/84639445" target="_blank" rel="noopener">解决TortoiseGit文件夹和文件状态图标不显示问题</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 环境与工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>借助gitbook与Gitee Pages服务搭建静态网站</title>
      <link href="/2022/03/25/%E5%80%9F%E5%8A%A9gitbook%E4%B8%8EGitee-Pages%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99/"/>
      <url>/2022/03/25/%E5%80%9F%E5%8A%A9gitbook%E4%B8%8EGitee-Pages%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-引入"><a class="markdownIt-Anchor" href="#1-引入"></a> 1 引入</h1><p>在做PA助教，需要将讲义重新部署下，静态网站。讲义仓库在Gitee，所以使用 <code>gitbook + Gitee Pages</code> 实现该需求。本文将以自己的<code>Algorithm</code>仓库进行演示：</p><h1 id="2-实现"><a class="markdownIt-Anchor" href="#2-实现"></a> 2 实现</h1><p>主要参考：<a href="https://zhuanlan.zhihu.com/p/34946169" target="_blank" rel="noopener">使用 Gitbook 打造你的电子书</a></p><h2 id="21-本地安装gitbook"><a class="markdownIt-Anchor" href="#21-本地安装gitbook"></a> 2.1 本地安装gitbook</h2><h3 id="211-安装gitbook"><a class="markdownIt-Anchor" href="#211-安装gitbook"></a> 2.1.1 安装gitbook</h3><p>环境要求：</p><ul><li>NodeJS（推荐使用v4.0.0及以上版本）</li><li>Windows，Linux，Unix 或 Mac OS X</li></ul><p>Windows下在cmd中输入：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install gitbook-cli -g</span><br></pre></td></tr></table></figure><p>执行下面的命令，查看 GitBook 版本，以验证安装成功：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitbook -V</span><br></pre></td></tr></table></figure><h3 id="212-gitbook-项目结构"><a class="markdownIt-Anchor" href="#212-gitbook-项目结构"></a> 2.1.2 GitBook 项目结构</h3><p>GitBook使用简单的目录结构。在 SUMMARY （即 <a href="http://SUMMARY.md" target="_blank" rel="noopener">SUMMARY.md</a> 文件）中列出的所有 Markdown / Asciidoc 文件将被转换为 HTML。</p><p>一个基本的 GitBook 电子书结构通常如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── book.json</span><br><span class="line">├── README.md</span><br><span class="line">├── SUMMARY.md</span><br><span class="line">├── chapter-1/</span><br><span class="line">|   ├── README.md</span><br><span class="line">|   └── something.md</span><br><span class="line">└── chapter-2/</span><br><span class="line">    ├── README.md</span><br><span class="line">    └── something.md</span><br></pre></td></tr></table></figure><p>GitBook 特殊文件的功能：</p><table><thead><tr><th style="text-align:center">文件</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">book.json</td><td style="text-align:center">配置数据、包括插件配置(可选)</td></tr><tr><td style="text-align:center"><a href="http://README.md" target="_blank" rel="noopener">README.md</a></td><td style="text-align:center">电子书的前言或每个文件夹的简介(必选)</td></tr><tr><td style="text-align:center"><a href="http://SUMMARY.md" target="_blank" rel="noopener">SUMMARY.md</a></td><td style="text-align:center">电子书目录(可选)</td></tr><tr><td style="text-align:center"><a href="http://GLOSSARY.md" target="_blank" rel="noopener">GLOSSARY.md</a></td><td style="text-align:center">词汇/注释术语列表(可选)</td></tr></tbody></table><h3 id="213-创建bookjson与summarymd"><a class="markdownIt-Anchor" href="#213-创建bookjson与summarymd"></a> 2.1.3 <a href="http://xn--book-pj9fv59d.xn--jsonSUMMARY-hr8q.md" target="_blank" rel="noopener">创建book.json与SUMMARY.md</a></h3><ul><li>参考：<a href="https://www.jianshu.com/p/2160f1ba68a0" target="_blank" rel="noopener">Gitbook根据目录生成Summary.md</a></li></ul><p><code>book.json</code> 文件需要自己创建，<code>SUMMARY.md</code>文件可以使用插件(gitbook-plugin-summary)自动生成。</p><p>安装插件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i gitbook-plugin-summary --save</span><br></pre></td></tr></table></figure><p>在<code>Algorithm</code>项目根目录创建 <code>book.json</code> 文件，并输入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"plugins"</span>: [ </span><br><span class="line"><span class="string">"summary"</span></span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="214-目录顺序"><a class="markdownIt-Anchor" href="#214-目录顺序"></a> 2.1.4 目录顺序</h3><p>关于数字序号的顺序：<code>Ch10</code>、<code>Ch11</code>、<code>Ch1</code>、<code>Ch2</code>、<code>Ch3</code>、<code>Ch4</code>…</p><p>所以需要修改序号：<code>Ch1</code>、<code>Ch2</code>、<code>Ch3</code>、<code>Ch4</code>、…、<code>Ch10</code>、<code>Ch11</code></p><h3 id="215-数学公式"><a class="markdownIt-Anchor" href="#215-数学公式"></a> 2.1.5 数学公式</h3><p>使用<code>mathjax</code>，但是不支持行内公式，效果不好，后续再看怎么解决这一块。</p><p>参考：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/132638228" target="_blank" rel="noopener">gitbook使用mathjax</a></li><li><a href="https://blog.csdn.net/qq_42898299/article/details/106779945" target="_blank" rel="noopener">gitbook采坑笔记（一：Mathjax）</a></li></ul><h3 id="216-构建与启动服务"><a class="markdownIt-Anchor" href="#216-构建与启动服务"></a> 2.1.6 构建与启动服务</h3><p>使用下面的命令，会在项目的目录下生成一个 <code>_book</code> 目录，里面的内容为静态站点的资源文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitbook build</span><br></pre></td></tr></table></figure><p>使用下列命令会运行一个 web 服务, 通过 <code>http://localhost:4000/</code> 可以预览书籍：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitbook serve</span><br></pre></td></tr></table></figure><p>至此，<code>Algorithm</code>仓库对应的静态网站已经部署成功。</p><h2 id="22-实现在线访问"><a class="markdownIt-Anchor" href="#22-实现在线访问"></a> 2.2 实现在线访问</h2><p>在Gitee上打开<code>Algorithm</code>仓库，点击<code>服务</code>标签，选择<code>Gitee Pages</code>图标。</p><p><strong>注意</strong>：Gitee Pages服务需要实名认证，审核需要数个工作日。</p><img src="https://s2.loli.net/2022/03/25/w3mcMnqHIf4dyUG.png" width="800" height="400" alt="图片名称" align="center" id="116"><p><strong>部署目录需要是<code>_book</code></strong></p><p>现在访问 <a href="http://dragon-liu.gitee.io/algorithm" target="_blank" rel="noopener">http://dragon-liu.gitee.io/algorithm</a> 即可。</p>]]></content>
      
      
      <categories>
          
          <category> 环境与工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python-解决循环引用问题</title>
      <link href="/2022/03/09/Python-%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98/"/>
      <url>/2022/03/09/Python-%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-引入"><a class="markdownIt-Anchor" href="#1-引入"></a> 1 引入</h1><p>当项目中的模块过多，或功能划分不够清晰时会出现循环引用的问题。最近在做毕设，涉及后台管理系统时出现循环引用的问题。</p><p>主要copy于：<a href="https://www.jianshu.com/p/a1e91cc53b07" target="_blank" rel="noopener">python解决循环引用问题</a></p><h1 id="2-示例"><a class="markdownIt-Anchor" href="#2-示例"></a> 2 示例</h1><p><code>moduleA.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> moduleB <span class="keyword">import</span> b</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'aaaaaaaa'</span>)</span><br><span class="line">    b()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">c</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'cccc'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a()</span><br></pre></td></tr></table></figure><p><code>moduleB.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> moduleA <span class="keyword">import</span> c</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">b</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'bbbbbbbbbb'</span>)</span><br><span class="line">    c()</span><br></pre></td></tr></table></figure><p>运行<code>moduleA.py</code>出现以下报错：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ImportError: cannot import name <span class="string">'b'</span> from partially initialized module <span class="string">'moduleB'</span> (most likely due to a circular import)</span><br></pre></td></tr></table></figure><p>导入其实是要将 <code>被导入模块所有的代码都执行一遍，遇到函数和类的定义会作申明</code>。回到循环引用中，首先导入B，进入B中，发现B中又导入了A又回到A中，但是A又导入B这就形成了循环引用。</p><h1 id="3-解决"><a class="markdownIt-Anchor" href="#3-解决"></a> 3 解决</h1><h2 id="31-直接导入模块名通过模块调用其中的函数"><a class="markdownIt-Anchor" href="#31-直接导入模块名通过模块调用其中的函数"></a> 3.1 直接导入模块名，通过模块调用其中的函数</h2><p><code>moduleA.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> moduleB</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'aaaaaaaa'</span></span><br><span class="line">    moduleB.b()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">c</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'cccccc'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a()</span><br></pre></td></tr></table></figure><p><code>moduleB.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> moduleA</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">b</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'bbbbbbbbbb'</span></span><br><span class="line"></span><br><span class="line">    moduleA.c()</span><br></pre></td></tr></table></figure><h2 id="32-使用延迟导入lazy-import"><a class="markdownIt-Anchor" href="#32-使用延迟导入lazy-import"></a> 3.2 使用延迟导入(lazy import)</h2><p>在需要用的函数内部导入，或是在底部导入。</p><p><code>moduleA.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不变</span></span><br><span class="line"><span class="keyword">from</span> moduleB <span class="keyword">import</span> b</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'aaaaaaaa'</span>)</span><br><span class="line">    b()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">c</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'cccc'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a()</span><br></pre></td></tr></table></figure><p><code>moduleB.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">b</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'bbbbbbbbbb'</span>)</span><br><span class="line">    c()</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> moduleA <span class="keyword">import</span> c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">b</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">from</span> moduleA <span class="keyword">import</span> c</span><br><span class="line">    print(<span class="string">'bbbbbbbbbb'</span>)</span><br><span class="line">    c()</span><br></pre></td></tr></table></figure><h2 id="33-重新设计代码结构将代码和并或者分离"><a class="markdownIt-Anchor" href="#33-重新设计代码结构将代码和并或者分离"></a> 3.3 重新设计代码结构，将代码和并或者分离</h2><p>将公共功能的代码分离成单独模块，或者将一些具有关系的代码合并成一个模块。</p><p>本次毕设便采用了这个方法：将一些公共功能的代码分离，<a href="http://config.py" target="_blank" rel="noopener">config.py</a>(数据库配置)、<a href="http://entity.py" target="_blank" rel="noopener">entity.py</a>(实体类)</p><p><code>config.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">from</span> sqlalchemy.ext.declarative <span class="keyword">import</span> declarative_base</span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine, Column, Integer, String, TEXT</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> sessionmaker</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">'127.0.0.1'</span></span><br><span class="line">PORT = <span class="number">3306</span></span><br><span class="line">USERNAME = <span class="string">'xxx'</span>  <span class="comment"># mysql数据库用户名</span></span><br><span class="line">PASSWORD = <span class="string">'xxx'</span>  <span class="comment"># 密码</span></span><br><span class="line">DB = <span class="string">'xxx'</span>  <span class="comment"># 数据库名称</span></span><br><span class="line"><span class="comment"># f代表可以使用&#123;&#125;引用变量</span></span><br><span class="line">DB_URI = <span class="string">f'mysql+pymysql://<span class="subst">&#123;USERNAME&#125;</span>:<span class="subst">&#123;PASSWORD&#125;</span>@<span class="subst">&#123;HOST&#125;</span>:<span class="subst">&#123;PORT&#125;</span>/<span class="subst">&#123;DB&#125;</span>'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建引擎</span></span><br><span class="line">engine = create_engine(DB_URI)</span><br><span class="line"><span class="comment"># 创建SQLORM基类，注意这里要加参数，参数为上一步创建的引擎</span></span><br><span class="line">Base = declarative_base(engine)</span><br><span class="line"><span class="comment"># 构建session对象</span></span><br><span class="line">session = sessionmaker(engine)()</span><br></pre></td></tr></table></figure><p><code>entity.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> config <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建Report表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Report</span><span class="params">(Base)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">'report'</span>  <span class="comment"># 表名</span></span><br><span class="line">    id = Column(Integer, primary_key=<span class="literal">True</span>, autoincrement=<span class="literal">True</span>)</span><br><span class="line">    report_name = Column(String(<span class="number">100</span>))</span><br><span class="line">    report_size = Column(String(<span class="number">100</span>))</span><br><span class="line">    source_info = Column(String(<span class="number">100</span>))</span><br><span class="line">    operation = Column(String(<span class="number">100</span>))</span><br><span class="line">    tag = Column(String(<span class="number">100</span>))</span><br><span class="line">    hazard_level = Column(String(<span class="number">100</span>))</span><br><span class="line">    malware_static_info = Column(TEXT())</span><br><span class="line">    malware_dynamic_info = Column(TEXT())</span><br><span class="line">    upload_time = Column(String(<span class="number">100</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建MidFid表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MidFid</span><span class="params">(Base)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">'malware_mid_fid'</span>  <span class="comment"># 表名</span></span><br><span class="line">    id = Column(Integer, primary_key=<span class="literal">True</span>, autoincrement=<span class="literal">True</span>)</span><br><span class="line">    mid = Column(Integer())  <span class="comment"># 样本id</span></span><br><span class="line">    fid = Column(Integer())  <span class="comment"># 家族id</span></span><br></pre></td></tr></table></figure><h1 id="x-参考"><a class="markdownIt-Anchor" href="#x-参考"></a> X 参考</h1><ul><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python-列表-遍历</title>
      <link href="/2022/03/08/Python-%E5%88%97%E8%A1%A8-%E9%81%8D%E5%8E%86/"/>
      <url>/2022/03/08/Python-%E5%88%97%E8%A1%A8-%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-前言"><a class="markdownIt-Anchor" href="#1-前言"></a> 1 前言</h1><p>最近在使用python操作mysql，涉及列表操作比较多，整理一下列表遍历。</p><p>主要copy于<a href="https://blog.csdn.net/whatday/article/details/100557888" target="_blank" rel="noopener">python3 遍历列表list 四种方法</a></p><h1 id="2-方法"><a class="markdownIt-Anchor" href="#2-方法"></a> 2 方法</h1><h2 id="21-in"><a class="markdownIt-Anchor" href="#21-in"></a> 2.1 in</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">item_list = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'a'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> item_list:</span><br><span class="line">    print(item_list.index(item), item)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">0 a</span></span><br><span class="line"><span class="string">1 b</span></span><br><span class="line"><span class="string">2 c</span></span><br><span class="line"><span class="string">3 d</span></span><br><span class="line"><span class="string">0 a</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：按顺序输出值；如果列表中有重复值，下标会返回第一个值的下标，如上面的第二个<code>a</code>，但是这种bug只需要添加一个计数变量就解决了。</p><h2 id="22-enumerate"><a class="markdownIt-Anchor" href="#22-enumerate"></a> 2.2 enumerate()</h2><p><code>enumerate(sequence, [start=0])</code>，返回枚举对象(元组)</p><p>参数：</p><ul><li><code>sequence</code>：一个序列、迭代器或其他支持迭代对象。</li><li><code>start</code>：下标起始位置。</li></ul><p>用法实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">item_list = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'a'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> enumerate(item_list):</span><br><span class="line">    print(item)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">(0, 'a')</span></span><br><span class="line"><span class="string">(1, 'b')</span></span><br><span class="line"><span class="string">(2, 'c')</span></span><br><span class="line"><span class="string">(3, 'd')</span></span><br><span class="line"><span class="string">(4, 'a')</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, val <span class="keyword">in</span> enumerate(item_list):</span><br><span class="line">    print(index, val)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">0 a</span></span><br><span class="line"><span class="string">1 b</span></span><br><span class="line"><span class="string">2 c</span></span><br><span class="line"><span class="string">3 d</span></span><br><span class="line"><span class="string">4 a</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：按顺序输出值；下标会返回对应值的下标，解决了<code>2.1</code>的问题。</p><h2 id="23-iter迭代器"><a class="markdownIt-Anchor" href="#23-iter迭代器"></a> 2.3 iter()迭代器</h2><p><code>iter(object, [sentinel])</code>函数用来生成迭代器，返回迭代对象。</p><p>参数：</p><ul><li><code>object</code>：支持迭代的集合对象。</li><li><code>sentinel</code>：如果传递了第二个参数，则参数 object 必须是一个可调用的对象（如，函数），此时，iter 创建了一个迭代器对象，每次调用这个迭代器对象的__next__()方法时，都会调用 object。</li></ul><p>用法实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">item_list = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'a'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> iter(item_list):</span><br><span class="line">    print(item)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">a</span></span><br><span class="line"><span class="string">b</span></span><br><span class="line"><span class="string">c</span></span><br><span class="line"><span class="string">d</span></span><br><span class="line"><span class="string">a</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：按顺序输出。</p><h2 id="24-range函数"><a class="markdownIt-Anchor" href="#24-range函数"></a> 2.4 range()函数</h2><p><code>range(start, end, [step])</code> 函数返回类型是<code>ndarray</code>，可用<code>list()</code>返回一个整数列表，一般用在 <code>for</code> 循环中。</p><p>参数：</p><ul><li><code>start</code>：计数从 <code>start</code> 开始，默认是从 <code>0</code> 开始，例如<code>range(5)</code>等价于<code>range(0,5)</code>；</li><li><code>end</code>：计数到 <code>end</code> 结束，但不包括 <code>end</code>。例如：<code>range(0, 5)</code>是 <code>[0, 1, 2, 3, 4]</code> 没有 <code>5</code></li><li><code>step</code>：步长，默认为<code>1</code>。例如：<code>range(0, 5)</code> 等价于 <code>range(0, 5, 1)</code></li></ul><p>用法实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">item_list = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'a'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(item_list)):</span><br><span class="line">    print(item_list[i])</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">a</span></span><br><span class="line"><span class="string">b</span></span><br><span class="line"><span class="string">c</span></span><br><span class="line"><span class="string">d</span></span><br><span class="line"><span class="string">a</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：按顺序输出。</p><h2 id="25-倒序遍历"><a class="markdownIt-Anchor" href="#25-倒序遍历"></a> 2.5 倒序遍历</h2><h3 id="251-reversed函数"><a class="markdownIt-Anchor" href="#251-reversed函数"></a> 2.5.1 reversed函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">item_list = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'a'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> reversed(item_list):</span><br><span class="line">    print(item)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">a</span></span><br><span class="line"><span class="string">d</span></span><br><span class="line"><span class="string">c</span></span><br><span class="line"><span class="string">b</span></span><br><span class="line"><span class="string">a</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h3 id="252-range函数"><a class="markdownIt-Anchor" href="#252-range函数"></a> 2.5.2 range()函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">item_list = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'a'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(item_list)<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">    print(item_list[i])</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">a</span></span><br><span class="line"><span class="string">d</span></span><br><span class="line"><span class="string">c</span></span><br><span class="line"><span class="string">b</span></span><br><span class="line"><span class="string">a</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h3 id="253-切片"><a class="markdownIt-Anchor" href="#253-切片"></a> 2.5.3 切片</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">item_list = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'a'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> item_list[::<span class="number">-1</span>]:</span><br><span class="line">    print(item)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">a</span></span><br><span class="line"><span class="string">d</span></span><br><span class="line"><span class="string">c</span></span><br><span class="line"><span class="string">b</span></span><br><span class="line"><span class="string">a</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h1 id="x-参考"><a class="markdownIt-Anchor" href="#x-参考"></a> X 参考</h1><ul><li><a href="https://www.cnblogs.com/pizitai/p/6398276.html" target="_blank" rel="noopener">Python 列表(List) 的三种遍历(序号和值)方法</a></li><li><a href="https://www.cnblogs.com/GumpYan/p/12334839.html" target="_blank" rel="noopener">python列表遍历（包括倒序遍历的三种方法）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python-列表-排序</title>
      <link href="/2022/03/08/Python-%E5%88%97%E8%A1%A8-%E6%8E%92%E5%BA%8F/"/>
      <url>/2022/03/08/Python-%E5%88%97%E8%A1%A8-%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-前言"><a class="markdownIt-Anchor" href="#1-前言"></a> 1 前言</h1><p>最近在使用python操作mysql，涉及列表操作比较多，整理一下列表排序。</p><p>主要copy于 <a href="https://www.runoob.com/python/att-list-sort.html" target="_blank" rel="noopener">菜鸟教程——Python List sort()方法</a></p><h1 id="2-sort方法"><a class="markdownIt-Anchor" href="#2-sort方法"></a> 2 sort()方法</h1><p><code>sort()</code> 函数用于对原列表进行排序，如果指定参数，则使用比较函数指定的比较函数。</p><p><code>sort()</code>方法语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.sort(cmp=<span class="literal">None</span>, key=<span class="literal">None</span>, reverse=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p><strong>参数</strong>：</p><ul><li><code>cmp</code> – 可选参数, 如果指定了该参数会使用该参数的方法进行排序。</li><li><code>key</code> – 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。</li><li><code>reverse</code> – 排序规则，<strong>reverse = True</strong> 降序， <strong>reverse = False</strong> 升序（默认）。</li></ul><p><strong>返回值</strong>：</p><p>该方法没有返回值，但是会对列表的对象进行排序。</p><p>以下实例展示了 sort() 函数的使用方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">item_list = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'a'</span>]</span><br><span class="line"></span><br><span class="line">print(item_list)  <span class="comment"># ['a', 'b', 'c', 'd', 'a']</span></span><br><span class="line">item_list.sort()</span><br><span class="line">print(item_list)  <span class="comment"># ['a', 'a', 'b', 'c', 'd']</span></span><br></pre></td></tr></table></figure><p>关于<code>key</code>参数的使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取列表的第二个元素</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">takeSecond</span><span class="params">(elem)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> elem[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表</span></span><br><span class="line">random = [(<span class="number">2</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">4</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">3</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定第二个元素排序</span></span><br><span class="line">random.sort(key=takeSecond)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出类别</span></span><br><span class="line">print(random)  <span class="comment"># [(4, 1), (2, 2), (1, 3), (3, 4)]</span></span><br></pre></td></tr></table></figure><h1 id="x-参考"><a class="markdownIt-Anchor" href="#x-参考"></a> X 参考</h1><ul><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python-列表-去重</title>
      <link href="/2022/03/06/Python-%E5%88%97%E8%A1%A8-%E5%8E%BB%E9%87%8D/"/>
      <url>/2022/03/06/Python-%E5%88%97%E8%A1%A8-%E5%8E%BB%E9%87%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-前言"><a class="markdownIt-Anchor" href="#1-前言"></a> 1 前言</h1><p>最近在使用python操作mysql，涉及列表操作比较多，整理一下列表去重。</p><p>主要copy于<a href="https://zhuanlan.zhihu.com/p/364610029" target="_blank" rel="noopener">Python 列表去重的4种方式及性能对比</a></p><h1 id="2-辅助数组"><a class="markdownIt-Anchor" href="#2-辅助数组"></a> 2 辅助数组</h1><p>新建一个数组，遍历原数组，如果值不在新数组里便加入到新数组中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">item_list = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'a'</span>]</span><br><span class="line"></span><br><span class="line">unique = []</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> item_list:</span><br><span class="line">    <span class="keyword">if</span> item <span class="keyword">not</span> <span class="keyword">in</span> unique:</span><br><span class="line">        unique.append(item)</span><br><span class="line"></span><br><span class="line">print(unique)  <span class="comment"># ['a', 'b', 'c', 'd']</span></span><br></pre></td></tr></table></figure><p>上面使用了数组作为存储对象，实际上如果我们改成集合存储去重后的结果，性能会快不少：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">item_list = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'a'</span>]</span><br><span class="line"></span><br><span class="line">unique = set()</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> item_list:</span><br><span class="line">    <span class="keyword">if</span> item <span class="keyword">not</span> <span class="keyword">in</span> unique:</span><br><span class="line">        unique.add(item)</span><br><span class="line"></span><br><span class="line">print(unique)  <span class="comment"># &#123;'b', 'a', 'd', 'c'&#125;</span></span><br></pre></td></tr></table></figure><p>因为集合和数组的内在数据结构完全不同，集合使用了哈希表，因此速度会比列表快许多，但缺点在于无序。</p><h1 id="3-数组-集合-数组"><a class="markdownIt-Anchor" href="#3-数组-集合-数组"></a> 3 数组-&gt;集合-&gt;数组</h1><p>直接对数组进行集合转化，然后再转回数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">item_list = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'a'</span>]</span><br><span class="line"></span><br><span class="line">unique = list(set(item_list))</span><br><span class="line"></span><br><span class="line">print(unique)  <span class="comment"># ['d', 'a', 'b', 'c']</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：这种去重方式是最快的，但正如前面所说，集合是无序的，将数组转为集合后再转为列表，就失去了原有列表的顺序。</p><h1 id="4-保留原有数组顺序的去重dictfromkeys"><a class="markdownIt-Anchor" href="#4-保留原有数组顺序的去重dictfromkeys"></a> 4 保留原有数组顺序的去重（dict.fromkeys()）</h1><p>Python3.6+使用<code>dict.fromkeys()</code>函数，可以保留原有数组的顺序并去重：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">item_list = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'a'</span>]</span><br><span class="line"></span><br><span class="line">unique = list(dict.fromkeys(item_list))</span><br><span class="line"></span><br><span class="line">print(unique)  <span class="comment"># ['a', 'b', 'c', 'd']</span></span><br></pre></td></tr></table></figure><p>当然，它会比单纯用集合进行去重的方式耗时稍微久一点；<code>dict.fromkeys()</code>仅在Python3.6及以上才支持。</p><hr><p>在Python3.6以下，其实也存在fromkeys函数，只不过它由collections提供：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"></span><br><span class="line">item_list = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'a'</span>]</span><br><span class="line">unique = list(OrderedDict.fromkeys(item_list))</span><br><span class="line">print(unique)  <span class="comment"># ['a', 'b', 'c', 'd']</span></span><br></pre></td></tr></table></figure><p>比 Python3.6 的内置<code>dict.fromkeys()</code>慢一些，这是因为<code>OrderedDict</code>是用纯Python实现的。</p><h1 id="x-参考"><a class="markdownIt-Anchor" href="#x-参考"></a> X 参考</h1><ul><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【开源代码学习--若依】代码自动生成</title>
      <link href="/2022/03/04/%E3%80%90%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0--%E8%8B%A5%E4%BE%9D%E3%80%91%E4%BB%A3%E7%A0%81%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90/"/>
      <url>/2022/03/04/%E3%80%90%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0--%E8%8B%A5%E4%BE%9D%E3%80%91%E4%BB%A3%E7%A0%81%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-创建数据表"><a class="markdownIt-Anchor" href="#1-创建数据表"></a> 1 创建数据表</h1><h1 id="2-使用若依进行代码生成"><a class="markdownIt-Anchor" href="#2-使用若依进行代码生成"></a> 2 使用若依进行代码生成</h1><h1 id="3-打通前后端"><a class="markdownIt-Anchor" href="#3-打通前后端"></a> 3 打通前后端</h1><h2 id="31-controller"><a class="markdownIt-Anchor" href="#31-controller"></a> 3.1 controller</h2><p>MalwareDynamicController.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据mid查询malware_dynamic列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@PreAuthorize</span>(<span class="string">"@ss.hasPermi('system:dynamic:listmid')"</span>)</span><br><span class="line"><span class="meta">@GetMapping</span>(value = <span class="string">"/list/&#123;mid&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> TableDataInfo <span class="title">listByMid</span><span class="params">(MalwareDynamic malwareDynamic, @PathVariable(<span class="string">"mid"</span>)</span> Long mid)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    startPage();</span><br><span class="line">    List&lt;MalwareDynamic&gt; list = malwareDynamicService.selectMalwareDynamicListByMid(malwareDynamic, mid);</span><br><span class="line">    <span class="keyword">return</span> getDataTable(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="32-service"><a class="markdownIt-Anchor" href="#32-service"></a> 3.2 service</h2><p>IMalwareDynamicService.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询malware_dynamic列表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> malwareDynamic malware_dynamic</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> malware_dynamic集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;MalwareDynamic&gt; <span class="title">selectMalwareDynamicListByMid</span><span class="params">(MalwareDynamic malwareDynamic, Long mid)</span></span>;</span><br></pre></td></tr></table></figure><p>MalwareDynamicServiceImpl.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据mid查询malware_dynamic列表</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> malwareDynamic malware_dynamic</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> malware_dynamic</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;MalwareDynamic&gt; <span class="title">selectMalwareDynamicListByMid</span><span class="params">(MalwareDynamic malwareDynamic, Long mid)</span></span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> malwareDynamicMapper.selectMalwareDynamicListByMid(malwareDynamic, mid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="33-mapper"><a class="markdownIt-Anchor" href="#33-mapper"></a> 3.3 mapper</h2><p>MalwareDynamicMapper.java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询malware_dynamic列表</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> behavior behavior</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> behavior集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Behavior&gt; <span class="title">selectBehaviorList</span><span class="params">(Behavior behavior)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="34-malwaredynamicmapperxml"><a class="markdownIt-Anchor" href="#34-malwaredynamicmapperxml"></a> 3.4 MalwareDynamicMapper.xml</h2><p>MalwareDynamicMapper.xml:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="35-indexvue"><a class="markdownIt-Anchor" href="#35-indexvue"></a> 3.5 index.vue</h2><h2 id="36-reportjs"><a class="markdownIt-Anchor" href="#36-reportjs"></a> 3.6 report.js</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">srcu/exec/exec.c: In function ‘exec_wrapper’:</span><br><span class="line">srcu/exec/exec.c:<span class="number">238</span>:<span class="number">3</span>: error: ‘<span class="built_in">strcat</span>’ accessing <span class="number">81</span> <span class="keyword">or</span> more bytes at offsets <span class="number">264</span> <span class="keyword">and</span> <span class="number">184</span> may overlap <span class="number">1</span> byte at offset <span class="number">264</span> [-Werror=<span class="keyword">restrict</span>]</span><br><span class="line">   <span class="built_in">strcat</span>(decoding.asm_buf, decoding.assembly);</span><br></pre></td></tr></table></figure><h1 id="4-无效"><a class="markdownIt-Anchor" href="#4-无效"></a> 4 无效</h1><p>有时候出现<code>接口404</code>，此时需要关闭IDEA，然后重新打开后端项目</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 待补充 </tag>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-Mysql-通过SQLAlchemy操作</title>
      <link href="/2022/03/01/Python-Mysql-%E9%80%9A%E8%BF%87SQLAlchemy%E6%93%8D%E4%BD%9C/"/>
      <url>/2022/03/01/Python-Mysql-%E9%80%9A%E8%BF%87SQLAlchemy%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-简介"><a class="markdownIt-Anchor" href="#1-简介"></a> 1 简介</h1><p>Windows下安装Mysql参考：<a href="http://dragonliu.tk/2022/02/15/Windows%E4%B8%8B%E5%AE%89%E8%A3%85MySQL/" target="_blank" rel="noopener">博客——Windows下安装MySQL</a></p><p>SQLAlchemy是用Python编程语言开发的一个开源项目。它提供了SQL工具包和ORM（对象关系映射）工具，使用MIT许可证发行。</p><h1 id="2-安装"><a class="markdownIt-Anchor" href="#2-安装"></a> 2 安装</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip3 install sqlalchemy</span><br><span class="line">pip3 install pymysql</span><br></pre></td></tr></table></figure><p>本文使用MySQL作为数据库，使用pymysql作为驱动，因此需要安装pymysql。</p><h1 id="3-简单使用"><a class="markdownIt-Anchor" href="#3-简单使用"></a> 3 简单使用</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy.ext.declarative <span class="keyword">import</span> declarative_base</span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine, Column, Integer, String, TEXT</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> sessionmaker</span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> or_</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">'127.0.0.1'</span></span><br><span class="line">PORT = <span class="number">3306</span></span><br><span class="line">USERNAME = <span class="string">'xxx'</span>  <span class="comment"># mysql用户名</span></span><br><span class="line">PASSWORD = <span class="string">'xxx'</span>  <span class="comment"># mysql密码</span></span><br><span class="line">DB = <span class="string">'xxx'</span>  <span class="comment"># 数据库名称</span></span><br><span class="line"><span class="comment"># f代表可以使用&#123;&#125;引用变量</span></span><br><span class="line">DB_URI = <span class="string">f'mysql+pymysql://<span class="subst">&#123;USERNAME&#125;</span>:<span class="subst">&#123;PASSWORD&#125;</span>@<span class="subst">&#123;HOST&#125;</span>:<span class="subst">&#123;PORT&#125;</span>/<span class="subst">&#123;DB&#125;</span>'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建引擎</span></span><br><span class="line">engine = create_engine(DB_URI)</span><br><span class="line"><span class="comment"># 创建SQLORM基类，注意这里要加参数，参数为上一步创建的引擎</span></span><br><span class="line">Base = declarative_base(engine)</span><br><span class="line"><span class="comment"># 构建session对象</span></span><br><span class="line">session = sessionmaker(engine)()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建实体表Person</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(Base)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">'person'</span>  <span class="comment"># 表名</span></span><br><span class="line">    id = Column(Integer, primary_key=<span class="literal">True</span>, autoincrement=<span class="literal">True</span>)</span><br><span class="line">    name = Column(String(<span class="number">100</span>))</span><br><span class="line">    value = Column(TEXT())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将模型映射到数据库中</span></span><br><span class="line"><span class="comment"># 即如果数据库中没有student表则创建映射表student</span></span><br><span class="line">Base.metadata.create_all()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 增：一个</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(obj)</span>:</span></span><br><span class="line">    session.add(obj)  <span class="comment"># 添加到session</span></span><br><span class="line">    session.commit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 增：批量</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_batch</span><span class="params">(obj_list)</span>:</span></span><br><span class="line">    session.add_all(obj_list)</span><br><span class="line">    session.commit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">()</span>:</span></span><br><span class="line">    session.query(Person).filter(Person.name == <span class="string">'Pig'</span>).delete()</span><br><span class="line">    session.commit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 改</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 将查找到的对象全部修改</span></span><br><span class="line">    session.query(Person).filter(Person.name == <span class="string">'dragon'</span>).update(&#123;<span class="string">'value'</span>: <span class="string">'waiting'</span>&#125;)</span><br><span class="line">    session.commit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查：所有数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_all</span><span class="params">()</span>:</span></span><br><span class="line">    item_list = session.query(Person).all()</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> item_list:</span><br><span class="line">        print(item.name, item.value)</span><br><span class="line">    <span class="comment"># 若没有此句，后面执行删除表时会卡住</span></span><br><span class="line">    session.commit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查：指定列查询</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_in_cols</span><span class="params">()</span>:</span></span><br><span class="line">    item_list = session.query(Person.name).all()</span><br><span class="line">    print(item_list)</span><br><span class="line">    <span class="comment"># 若没有此句，后面执行删除表时会卡住</span></span><br><span class="line">    session.commit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查：获取返回数据的第一行</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_first_row</span><span class="params">()</span>:</span></span><br><span class="line">    item = session.query(Person.name).first()</span><br><span class="line">    print(item)</span><br><span class="line">    session.commit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查：使用filter()方法过滤</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_filter</span><span class="params">()</span>:</span></span><br><span class="line">    item_list = session.query(Person.name).filter(Person.value != <span class="string">"love"</span>).all()</span><br><span class="line">    print(item_list)</span><br><span class="line">    session.commit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查：使用order_by()进行排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_order</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 默认正序</span></span><br><span class="line">    item_list = session.query(Person.name, Person.value).order_by(Person.name).all()</span><br><span class="line">    print(item_list)</span><br><span class="line">    <span class="comment"># desc()倒序</span></span><br><span class="line">    item_list = session.query(Person.name, Person.value).order_by(Person.name.desc()).all()</span><br><span class="line">    print(item_list)</span><br><span class="line">    session.commit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查：多条件查询</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_multi_condition</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 多条件查询条件以,分隔默认为and</span></span><br><span class="line">    item_list = session.query(Person.name).filter(Person.name != <span class="string">"dragon"</span>, Person.value != <span class="string">"love"</span>).all()</span><br><span class="line">    print(item_list)</span><br><span class="line">    <span class="comment"># 使用or_连接多个条件</span></span><br><span class="line">    item_list = session.query(Person.name).filter(or_(Person.name != <span class="string">"dragon"</span>, Person.value != <span class="string">"love"</span>)).all()</span><br><span class="line">    print(item_list)</span><br><span class="line">    session.commit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查：模糊查询</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_like</span><span class="params">()</span>:</span></span><br><span class="line">    item_list = session.query(Person.name).filter(Person.name.like(<span class="string">'%ag%'</span>)).all()</span><br><span class="line">    print(item_list)</span><br><span class="line">    session.commit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查：是否包含传递参数列表类元素</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_in</span><span class="params">()</span>:</span></span><br><span class="line">    item_list = session.query(Person.name).filter(Person.name.in_([<span class="string">"SY"</span>, <span class="string">"dragon"</span>])).all()</span><br><span class="line">    print(item_list)</span><br><span class="line">    session.commit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查：计算个数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_count</span><span class="params">()</span>:</span></span><br><span class="line">    num = session.query(Person).count()</span><br><span class="line">    print(num)</span><br><span class="line">    session.commit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除TestTable表</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">del_table</span><span class="params">()</span>:</span></span><br><span class="line">    Person.__table__.drop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    insert(Person(name=<span class="string">"SY"</span>, value=<span class="string">"afascinatinggril"</span>))</span><br><span class="line">    obj_list = [Person(name=<span class="string">"dragon"</span>, value=<span class="string">"aunreasoningboy"</span>),</span><br><span class="line">                Person(name=<span class="string">"pig"</span>, value=<span class="string">"aquerulousboy"</span>),</span><br><span class="line">                ]</span><br><span class="line">    insert_batch(obj_list)</span><br><span class="line">    delete()</span><br><span class="line">    update()</span><br><span class="line">    select_all()</span><br><span class="line">    select_in_cols()</span><br><span class="line">    select_first_row()</span><br><span class="line">    select_filter()</span><br><span class="line">    select_order()</span><br><span class="line">    select_multi_condition()</span><br><span class="line">    select_like()</span><br><span class="line">    select_in()</span><br><span class="line">    select_count()</span><br><span class="line">    del_table()</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ol><li>增删改查除了查询不设计修改操作，其他增删改都需要使用commit()方法提交事务</li><li>执行查询操作后，不执行<code>session.commit()</code>，直接执行删除表操作会卡住</li></ol><h1 id="x-参考"><a class="markdownIt-Anchor" href="#x-参考"></a> X 参考</h1><ul><li><p><a href="https://www.cnblogs.com/minseo/p/15305003.html" target="_blank" rel="noopener">sqlalchemy的基本用法</a></p></li><li><p><a href="https://www.cnpython.com/qa/33649" target="_blank" rel="noopener">如何在SQLAlchemy中删除表？</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-字符串-字典与字符串互转</title>
      <link href="/2022/02/28/Python-%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%AD%97%E5%85%B8%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BA%92%E8%BD%AC/"/>
      <url>/2022/02/28/Python-%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%AD%97%E5%85%B8%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BA%92%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-字符串转为字典"><a class="markdownIt-Anchor" href="#1-字符串转为字典"></a> 1 字符串转为字典</h1><p>如果要将字符串转为字典，则可以使用 eval，但是原来双引号会变为单引号。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dict_str = <span class="string">"""</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    "key_a": 1,</span></span><br><span class="line"><span class="string">    "key_b": 2,</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">dict_new = eval(dict_str)</span><br><span class="line">print(type(dict_new)) <span class="comment"># &lt;class 'dict'&gt;</span></span><br><span class="line">print(dict_new) <span class="comment"># &#123;'key_a': 1, 'key_b': 2&#125;</span></span><br></pre></td></tr></table></figure><h1 id="2-字典转字符串"><a class="markdownIt-Anchor" href="#2-字典转字符串"></a> 2 字典转字符串</h1><p>将字典转为字符串的方式，可以使用 str，但是原来双引号会变为单引号。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dict_test = &#123;</span><br><span class="line">    <span class="string">"key_a"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">"key_b"</span>: <span class="number">2</span>,</span><br><span class="line">&#125;</span><br><span class="line">dict_str = str(dict_test)</span><br><span class="line">print(type(dict_str)) <span class="comment"># &lt;class 'str'&gt;</span></span><br><span class="line">print(dict_str) <span class="comment"># &#123;'key_a': 1, 'key_b': 2&#125;</span></span><br></pre></td></tr></table></figure><p>使用 json.dumps，就可以保住双引号；如果不用考虑双引号，则使用 str，毕竟比 json.dumps 快了一个数量级。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">dict_test = &#123;</span><br><span class="line">    <span class="string">"key_a"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">"key_b"</span>: <span class="number">2</span>,</span><br><span class="line">&#125;</span><br><span class="line">dict_str = json.dumps(dict_test)</span><br><span class="line">print(type(dict_str)) <span class="comment"># &lt;class 'str'&gt;</span></span><br><span class="line">print(dict_str) <span class="comment"># &#123;"key_a": 1, "key_b": 2&#125;</span></span><br></pre></td></tr></table></figure><h1 id="x-参考"><a class="markdownIt-Anchor" href="#x-参考"></a> X 参考</h1><ul><li><a href="https://blog.csdn.net/Kester_/article/details/113132295" target="_blank" rel="noopener">python字典转字符串</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python-os模块-获取文件信息</title>
      <link href="/2022/02/28/Python-os%E6%A8%A1%E5%9D%97-%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF/"/>
      <url>/2022/02/28/Python-os%E6%A8%A1%E5%9D%97-%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-获取文件大小创建时间访问时间修改时间"><a class="markdownIt-Anchor" href="#1-获取文件大小创建时间访问时间修改时间"></a> 1 获取文件大小，创建时间，访问时间，修改时间</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="string">'''把时间戳转化为时间: 1479264792 to 2016-11-16 10:53:12'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">TimeStampToTime</span><span class="params">(timestamp)</span>:</span></span><br><span class="line">    timeStruct = time.localtime(timestamp)</span><br><span class="line">    <span class="keyword">return</span> time.strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>,timeStruct)</span><br><span class="line"></span><br><span class="line"><span class="string">'''获取文件的大小,结果保留两位小数，单位为MB'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_FileSize</span><span class="params">(filePath)</span>:</span></span><br><span class="line">    filePath = filePath.encode(<span class="string">'utf-8'</span>)</span><br><span class="line">    fsize = os.path.getsize(filePath)</span><br><span class="line">    print(fsize, <span class="string">"B"</span>)</span><br><span class="line">    print(fsize/float(<span class="number">1024</span>), <span class="string">"KB"</span>)</span><br><span class="line">    print(fsize/float(<span class="number">1024</span>*<span class="number">1024</span>), <span class="string">"MB"</span>)</span><br><span class="line">    fsize = fsize/float(<span class="number">1024</span>*<span class="number">1024</span>)</span><br><span class="line">    <span class="keyword">return</span> round(fsize, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">'''获取文件的访问时间'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_FileAccessTime</span><span class="params">(filePath)</span>:</span></span><br><span class="line">    filePath = filePath.encode(<span class="string">'utf-8'</span>)</span><br><span class="line">    t = os.path.getatime(filePath)</span><br><span class="line">    <span class="keyword">return</span> TimeStampToTime(t)</span><br><span class="line"></span><br><span class="line"><span class="string">'''获取文件的创建时间'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_FileCreateTime</span><span class="params">(filePath)</span>:</span></span><br><span class="line">    filePath = filePath.encode(<span class="string">'utf-8'</span>)</span><br><span class="line">    t = os.path.getctime(filePath)</span><br><span class="line">    <span class="keyword">return</span> TimeStampToTime(t)</span><br><span class="line"></span><br><span class="line"><span class="string">'''获取文件的修改时间'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_FileModifyTime</span><span class="params">(filePath)</span>:</span></span><br><span class="line">    filePath = filePath.encode(<span class="string">'utf-8'</span>)</span><br><span class="line">    t = os.path.getmtime(filePath)</span><br><span class="line">    <span class="keyword">return</span> TimeStampToTime(t)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    file_path = <span class="string">"test1.py"</span></span><br><span class="line">    print(get_FileSize(file_path))</span><br><span class="line">    print(get_FileAccessTime(file_path))</span><br><span class="line">    print(get_FileCreateTime(file_path))</span><br><span class="line">    print(get_FileModifyTime(file_path))</span><br></pre></td></tr></table></figure><h1 id="x-参考"><a class="markdownIt-Anchor" href="#x-参考"></a> X 参考</h1><ul><li><a href="https://www.cnblogs.com/shaosks/p/5614630.html" target="_blank" rel="noopener">python 获取文件大小，创建时间和访问时间</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python-time模块-获取当前时间</title>
      <link href="/2022/02/28/Python-time%E6%A8%A1%E5%9D%97-%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4/"/>
      <url>/2022/02/28/Python-time%E6%A8%A1%E5%9D%97-%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-timetime"><a class="markdownIt-Anchor" href="#1-timetime"></a> 1 time.time()</h1><ul><li>返回当前时间戳，值为按秒计算的浮点数</li><li>表示从1970年1月1日0点0分开始，到当前时间，一共经历了多少秒</li></ul> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">test_time = time.time()</span><br><span class="line">print(type(test_time))  <span class="comment"># &lt;class 'float'&gt;</span></span><br><span class="line">print(test_time)  <span class="comment"># 1646054545.0786133</span></span><br></pre></td></tr></table></figure><h1 id="2-timelocaltime"><a class="markdownIt-Anchor" href="#2-timelocaltime"></a> 2 time.localtime()</h1><ul><li>格式化时间戳为本地的时间，年月日，时分秒等信息</li><li>若未输入参数，默认当前时间</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">test_time = time.localtime()</span><br><span class="line">print(type(test_time)) <span class="comment"># &lt;class 'time.struct_time'&gt;</span></span><br><span class="line">print(test_time) <span class="comment"># time.struct_time(tm_year=2022, tm_mon=2, tm_mday=28, tm_hour=21, tm_min=29, tm_sec=32, tm_wday=0, tm_yday=59, tm_isdst=0)</span></span><br><span class="line">print(test_time.tm_year) <span class="comment"># 年：2022</span></span><br><span class="line">print(test_time.tm_mon) <span class="comment"># 月：2</span></span><br><span class="line">print(test_time.tm_mday) <span class="comment"># 日：28</span></span><br><span class="line">print(test_time.tm_hour) <span class="comment"># 时：21</span></span><br><span class="line">print(test_time.tm_min) <span class="comment"># 分：29</span></span><br><span class="line">print(test_time.tm_sec) <span class="comment"># 秒：32</span></span><br><span class="line"></span><br><span class="line">t2 = time.time()</span><br><span class="line">print(time.localtime(t2)) <span class="comment"># time.struct_time(tm_year=2022, tm_mon=2, tm_mday=28, tm_hour=21, tm_min=32, tm_sec=44, tm_wday=0, tm_yday=59, tm_isdst=0)</span></span><br></pre></td></tr></table></figure><h1 id="3-timeasctime"><a class="markdownIt-Anchor" href="#3-timeasctime"></a> 3 time.asctime()</h1><ul><li>格式化时间</li><li>若未输入参数，默认当前时间</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">t1 = time.asctime()</span><br><span class="line">print(type(t1)) <span class="comment"># &lt;class 'str'&gt;</span></span><br><span class="line">print(t1) <span class="comment"># Mon Feb 28 21:37:53 2022</span></span><br><span class="line"></span><br><span class="line">t2 = time.localtime(time.time())</span><br><span class="line">print(time.asctime(t2)) <span class="comment"># Mon Feb 28 21:37:53 2022</span></span><br><span class="line"></span><br><span class="line">t3 = time.asctime(time.localtime())</span><br><span class="line">print(t3) <span class="comment"># Mon Feb 28 21:37:53 2022</span></span><br></pre></td></tr></table></figure><h1 id="4-timestrftime"><a class="markdownIt-Anchor" href="#4-timestrftime"></a> 4 time.strftime()</h1><ul><li>格式化时间</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">t1 = time.strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>, time.localtime())</span><br><span class="line">print(type(t1)) <span class="comment"># &lt;class 'str'&gt;</span></span><br><span class="line">print(t1) <span class="comment"># 2022-02-28 21:39:55</span></span><br><span class="line"></span><br><span class="line">t2 = time.strftime(<span class="string">'%a %b %d %H:%M:%S %Y'</span>, time.localtime())</span><br><span class="line">print(type(t2)) <span class="comment"># &lt;class 'str'&gt;</span></span><br><span class="line">print(t2) <span class="comment"># Mon Feb 28 21:39:55 2022</span></span><br></pre></td></tr></table></figure><h1 id="x-参考"><a class="markdownIt-Anchor" href="#x-参考"></a> X 参考</h1><ul><li><a href="https://blog.csdn.net/qq_36512295/article/details/99694528" target="_blank" rel="noopener">Python获取当前时间（time模块）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows下安装Redis</title>
      <link href="/2022/02/15/Windows%E4%B8%8B%E5%AE%89%E8%A3%85Redis/"/>
      <url>/2022/02/15/Windows%E4%B8%8B%E5%AE%89%E8%A3%85Redis/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-引入"><a class="markdownIt-Anchor" href="#1-引入"></a> 1 引入</h1><p>最近在Windows上运行若依系统，需要配置Redis，但是这台笔记本上还没安装，整理下。</p><p>Redis官网：<a href="http://www.redis.cn/" target="_blank" rel="noopener">http://www.redis.cn/</a></p><p>主要copy于 <a href="https://blog.csdn.net/BADAO_LIUMANG_QIZHI/article/details/107486313" target="_blank" rel="noopener">Windows中Redis的下载安装与修改密码并启动</a></p><h1 id="2-下载安装包"><a class="markdownIt-Anchor" href="#2-下载安装包"></a> 2 下载安装包</h1><p>Github下载安装包：<a href="https://github.com/microsoftarchive/redis/releases" target="_blank" rel="noopener">Redis Installer</a></p><p>选择 zip 和 msi 下载都可以，测试使用的 msi。</p><h1 id="3-安装redis"><a class="markdownIt-Anchor" href="#3-安装redis"></a> 3 安装Redis</h1><ol><li><p>双击下载好的安装文件<code>Redis-x64-3.0.504.msi</code>打开安装程序</p></li><li><p>安装时注意将路径加到PATH中：</p><img src="https://s2.loli.net/2022/02/15/DI97iLym3PEAgKQ.png" width="500" height="400" alt="图片名称" align="center" id="88"></li><li><p>其他的，如端口等默认选项即可：</p><img src="https://s2.loli.net/2022/02/15/qtfIWCcn57aK9iV.png" width="500" height="400" alt="图片名称" align="center" id="89"></li></ol><h1 id="4-测试"><a class="markdownIt-Anchor" href="#4-测试"></a> 4 测试</h1><ol><li><p><strong>启动服务端</strong>：在上述安装过程中已经自启动Redis了，如果没启动，则在Redis安装目录打开命令行并执行：<code>redis-server.exe redis.windows.conf</code></p><img src="https://s2.loli.net/2022/02/15/26qd8Am9QscVbBh.png" width="700" height="300" alt="图片名称" align="center" id="97"></li><li><p><strong>启动客户端</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里的123456是上面自己设置的密码</span></span><br><span class="line">D:\developer\database\redis\soft&gt;redis-cli.exe -h 127.0.0.1 -p 6379 -a 123456</span><br><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure></li></ol><h1 id="5-redis管理软件redis-desktop-manager"><a class="markdownIt-Anchor" href="#5-redis管理软件redis-desktop-manager"></a> 5 Redis管理软件（Redis Desktop Manager）</h1><ol><li><p>从<code>0.9.3.817</code>版本后就开始收费了。当然，源码始终是开源的，需要自行编译，有已经编译好的版本：</p><ul><li><a href="https://springboot.io/t/topic/2394" target="_blank" rel="noopener">新版的RedisDesktopManager下载</a></li><li><a href="https://github.com/qishibo/AnotherRedisDesktopManager/releases" target="_blank" rel="noopener">Github-AnotherRedisDesktopManager</a> （实验中使用的软件）</li></ul></li><li><p>新建连接，默认即可：</p><img src="https://s2.loli.net/2022/02/15/41cJfXTdwL75Zzj.png" width="600" height="400" alt="图片名称" align="center" id="90"></li><li><p>运行完若依系统后，已经有了数据：</p><img src="https://s2.loli.net/2022/02/15/jwqznTsJZMLPF21.png" width="600" height="400" alt="图片名称" align="center" id="96"></li></ol>]]></content>
      
      
      <categories>
          
          <category> 环境与工具 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows下安装MySQL</title>
      <link href="/2022/02/15/Windows%E4%B8%8B%E5%AE%89%E8%A3%85MySQL/"/>
      <url>/2022/02/15/Windows%E4%B8%8B%E5%AE%89%E8%A3%85MySQL/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-引入"><a class="markdownIt-Anchor" href="#1-引入"></a> 1 引入</h1><p>最近在Windows上运行若依系统，需要配置MySQL，但是这台笔记本上还没安装，整理下。</p><p>主要copy于 <a href="https://blog.csdn.net/zhouzezhou/article/details/52446608" target="_blank" rel="noopener">windows10上安装mysql（详细步骤)</a></p><h1 id="2-下载安装包"><a class="markdownIt-Anchor" href="#2-下载安装包"></a> 2 下载安装包</h1><p>官网下载：<a href="https://dev.mysql.com/downloads/installer/" target="_blank" rel="noopener">MySQL Installer</a></p><img src="https://s2.loli.net/2022/02/15/G5fRJ39EiONYtPk.png" width="500" height="300" alt="图片名称" align="center" id="77"><p>下载速度较慢，使用迅雷下载提速。</p><h1 id="3-安装mysql"><a class="markdownIt-Anchor" href="#3-安装mysql"></a> 3 安装Mysql</h1><ol><li><p>双击下载好的mysql安装文件<code>mysql-installer-community-8.0.28.0.msi</code>打开安装程序，打开后需要稍等一下</p></li><li><p>选择安装类型（根据个人需要）：此处我只需要server，所以选择<code>Custom</code></p><img src="https://s2.loli.net/2022/02/15/7WyjMUGDVnhOAqS.png" width="500" height="400" alt="图片名称" align="center" id="78"></li><li><p>Select Products：（注意这个地方把软件安装目录和数据目录换成非C盘，因为毕设后期数据量可能比较大）</p><img src="https://s2.loli.net/2022/02/15/HlXf5NxgyJtszQb.png" width="500" height="400" alt="图片名称" align="center" id="79"></li><li><p>点击“Execute”（执行）开始安装，安装过程中会显示安装的Progress（进度），等待安装完成后Status会显示Complete，mysql图标前会出现一个绿色的勾，然后点击“Next”按钮进入产品配置界面：</p><img src="https://s2.loli.net/2022/02/15/T2tvdulYaBz7gSh.png" width="500" height="400" alt="图片名称" align="center" id="80"></li><li><p><code>Type and Networking</code>：默认即可</p><img src="https://s2.loli.net/2022/02/15/wWPQ8dqK2MUaHso.png" width="500" height="400" alt="图片名称" align="center" id="81"></li><li><p><code>Authentication Method</code>：安装目的是学习使用，所以使用下面的选项即可：</p><img src="https://s2.loli.net/2022/02/15/E9vOgrqcRf1B4b2.png" width="500" height="400" alt="图片名称" align="center" id="82"></li><li><p>设置密码等默认操作即可，其中mysql server的名称默认是<code>MySQL80</code>，默认开机自启动。</p></li></ol><h1 id="4-配置mysql环境变量非必要"><a class="markdownIt-Anchor" href="#4-配置mysql环境变量非必要"></a> 4 配置mysql环境变量（非必要）</h1><p>说明：给mysql配置环境变量后我们就可以在cmd里运行mysql（开启、停止等操作）</p><ol><li><p>选中系统变量中的<code>path</code>，在path值开头处输入mysql安装目录下的bin文件夹所在路径（默认是<code>C:\Program Files\MySQL\MySQL Server x.x</code>，但是此处我做了修改），保存退出；</p></li><li><p>测试是否配置成功：打开cmd，输入</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Dragon Liu&gt;mysql -u root -p</span><br><span class="line">Enter password: ****</span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 10</span><br><span class="line">Server version: 8.0.28 MySQL Community Server - GPL</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2022, Oracle and/or its affiliates.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type <span class="string">'help;'</span> or <span class="string">'\h'</span> <span class="keyword">for</span> <span class="built_in">help</span>. Type <span class="string">'\c'</span> to clear the current input statement.</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><p>测试成功。</p><p>因为上面安装时默认开机自启动，所以这里mysql已经启动了，如果没启动可以管理员运行cmd，然后输入：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\system32&gt;net start MySQL80</span><br><span class="line">请求的服务已经启动。</span><br><span class="line"></span><br><span class="line">请键入 NET HELPMSG 2182 以获得更多的帮助。</span><br></pre></td></tr></table></figure></li></ol><h1 id="5-mysql管理软件navicat-for-mysql"><a class="markdownIt-Anchor" href="#5-mysql管理软件navicat-for-mysql"></a> 5 MySQL管理软件（Navicat for MySQL）</h1><ol><li><p>安装正版Navicat for MySQL：<a href="https://www.downkuai.com/soft/112947.html" target="_blank" rel="noopener">破解版</a></p></li><li><p>打开Navicat for MySQL</p></li><li><p>新建一个连接，填写连接信息：</p><img src="https://s2.loli.net/2022/02/15/yiUoY5KaZOpRWrq.png" width="400" height="500" alt="图片名称" align="center" id="83"></li></ol>]]></content>
      
      
      <categories>
          
          <category> 环境与工具 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【开源代码学习--若依】Windows下运行若依</title>
      <link href="/2022/02/15/%E3%80%90%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0--%E8%8B%A5%E4%BE%9D%E3%80%91Windows%E4%B8%8B%E8%BF%90%E8%A1%8C%E8%8B%A5%E4%BE%9D/"/>
      <url>/2022/02/15/%E3%80%90%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0--%E8%8B%A5%E4%BE%9D%E3%80%91Windows%E4%B8%8B%E8%BF%90%E8%A1%8C%E8%8B%A5%E4%BE%9D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-引入"><a class="markdownIt-Anchor" href="#1-引入"></a> 1 引入</h1><p>最近在为毕设选取后台管理框架，开始打算用自己熟悉的Flask，或者Django，毕竟后边恶意样本的检测和可视化编程主语言会是python，这样一来使用python系的框架会做到无缝衔接。</p><ul><li><strong>Flask</strong><ul><li><strong>redash</strong>：<a href="https://github.com/getredash/redash" target="_blank" rel="noopener">redash-Github</a>、<a href="https://gitee.com/mirrors/redash" target="_blank" rel="noopener">redash-Gitee</a>、<a href="https://cloud.tencent.com/developer/article/1669226" target="_blank" rel="noopener">redash-介绍</a>、<a href="https://redash.io/product/" target="_blank" rel="noopener">官网</a></li><li><strong>Flask-Admin-Dashboard</strong>：<a href="https://github.com/jonalxh/Flask-Admin-Dashboard" target="_blank" rel="noopener">Github</a></li></ul></li><li><strong>Django+Vue</strong><ul><li><strong>Medusa</strong>：<a href="https://github.com/Ascotbe/Medusa" target="_blank" rel="noopener">Github</a>、<a href="http://medusa.ascotbe.com/Documentation/#/Installation" target="_blank" rel="noopener">文档</a></li><li><a href="https://www.bilibili.com/video/BV1eK411p7Na/?spm_id_from=333.788.recommend_more_video.4" target="_blank" rel="noopener">Vue+Django整合</a></li></ul></li></ul><p>但是考虑到这些框架网上参考资料、视频教程较少，上手时间可能较长。所以最后决定使用若依前后端分离版本。</p><ul><li><strong>简介</strong>：基于SpringBoot、Spring Security、Jwt、Vue的前后端分离的后台管理系统，还有前后端不分离版本、cloud版本</li><li><strong>官网</strong>：<a href="http://ruoyi.vip/" target="_blank" rel="noopener">官网</a>、<a href="https://gitee.com/y_project/RuoYi-Vue" target="_blank" rel="noopener">源码</a>、<a href="http://doc.ruoyi.vip/ruoyi-vue/" target="_blank" rel="noopener">文档</a></li><li><strong>环境要求</strong>：<ul><li>JDK 1.8+ (推荐1.8版本)</li><li>Mysql (业务数据库) 5.7+ (推荐5.7版本)</li><li>Redis (缓存数据库) 3.0+</li><li>Maven 3.0+</li><li>Node 12+</li></ul></li><li><strong>开发工具</strong>：<ul><li><strong>IDEA</strong>：Spring Boot、Vue</li><li><strong>Navicat</strong>：mysql</li><li><strong>Another Redis Manager Desktop</strong>：Redis</li></ul></li></ul><p>主要参考教程：<a href="https://www.bilibili.com/video/BV1HT4y1d7oA?from=search&amp;seid=872568368355498822&amp;spm_id_from=333.337.0.0" target="_blank" rel="noopener">B站——楠哥教你学java</a></p><blockquote><p>使用开源项目的步骤：</p><ol><li>下载并运行</li><li>看懂业务流程</li><li>进行二次开发</li></ol></blockquote><h1 id="2-查看自己的环境"><a class="markdownIt-Anchor" href="#2-查看自己的环境"></a> 2 查看自己的环境</h1><p>打开<code>cmd</code>查看自己的环境，不满足上述 <strong>环境要求</strong> 的做出整改：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看java版本</span></span><br><span class="line">E:\&gt;java -version</span><br><span class="line">java version <span class="string">"1.8.0_301"</span></span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_301-b09)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.301-b09, mixed mode)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看maven版本</span></span><br><span class="line">E:\&gt;mvn -v</span><br><span class="line"><span class="string">'mvn'</span> 不是内部或外部命令，也不是可运行的程序</span><br><span class="line">或批处理文件。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看Node版本</span></span><br><span class="line">E:\&gt;node -v</span><br><span class="line">v12.5.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Redis版本</span></span><br><span class="line">D:\developer\database\redis\soft&gt;redis-server.exe -v</span><br><span class="line">Redis server v=3.0.504 sha=00000000:0 malloc=jemalloc-3.6.0 bits=64 build=a4f7a6e86f2d60b3</span><br><span class="line"></span><br><span class="line"><span class="comment"># Mysql版本查看</span></span><br><span class="line">E:\&gt;mysql --version</span><br><span class="line">mysql  Ver 8.0.28 <span class="keyword">for</span> Win64 on x86_64 (MySQL Community Server - GPL)</span><br></pre></td></tr></table></figure><h1 id="3-下载并打开"><a class="markdownIt-Anchor" href="#3-下载并打开"></a> 3 下载并打开</h1><p>IDEA从git链接导入项目，IDEA 打开总项目Spring Boot——<code>RuoYi-Vue</code>和前端项目Vue——<code>ruo-ui</code>。</p><p>下载源码之后<code>ruoyi-ui</code>是前端项目模块，<code>ruoyi-admin</code>是后端主模块，其他的是后端用到的其他模块。</p><p><code>sql</code>目录下会有两个sql文件，这两个sql文件就是数据文件，需要导入Mysql数据库。</p><h1 id="4-配置mysql"><a class="markdownIt-Anchor" href="#4-配置mysql"></a> 4 配置Mysql</h1><ol><li><p>安装MySQL：参考博客 <a href="https://dragonliu.tk/2022/02/15/Windows%E4%B8%8B%E5%AE%89%E8%A3%85MySQL/" target="_blank" rel="noopener">Windows下安装MySQL</a></p></li><li><p>打开Navicat，新建数据库：（<font color="red">切记在新建数据库时要将字符集设置为utf8不然在执行向数据库插入一些数据含有中文时会报错</font>）</p><img src="https://s2.loli.net/2022/02/15/NoME25r7z9hRUgj.png" width="600" height="400" alt="图片名称" align="center" id="84"></li><li><p>新建数据库完成后在数据库上右击-运行sql文件，这里使用的是Navicat连接工具。然后选中上面的sql目录下的<code>ry_20210908.sql</code>，点击开始，然后再执行sql目录下的<code>quartz.sql</code>；</p><img src="https://s2.loli.net/2022/02/15/htzbPfWQD9wXCV7.png" width="600" height="400" alt="图片名称" align="center" id="85"></li><li><p>初始化数据库完成之后，会在数据库下生成一些表，并在表中生成一些数据：</p><img src="https://s2.loli.net/2022/02/15/oSrLQtNIqgvYz2Z.png" width="1000" height="400" alt="图片名称" align="center" id="86"></li><li><p>在工程中配置数据库：</p><img src="https://s2.loli.net/2022/02/15/CiJu9dHyLBZoeTf.png" width="1000" height="200" alt="图片名称" align="center" id="87"></li></ol><h1 id="5-配置redis"><a class="markdownIt-Anchor" href="#5-配置redis"></a> 5 配置Redis</h1><ol><li><p>安装Redis：参考博客 <a href="https://dragonliu.tk/2022/02/15/Windows%E4%B8%8B%E5%AE%89%E8%A3%85Redis/" target="_blank" rel="noopener">Windows下安装Redis</a></p></li><li><p>在工程中配置数据库，若没修改Redis默认配置，无需改动下面的代码：</p><img src="https://s2.loli.net/2022/02/15/d14ySpXGZjfEAO3.png" width="1000" height="200" alt="图片名称" align="center" id="91"></li></ol><h1 id="6-运行后端"><a class="markdownIt-Anchor" href="#6-运行后端"></a> 6 运行后端</h1><p>找到启动程序，右键运行即可：</p><img src="https://s2.loli.net/2022/02/15/gOrfEjoFSdXpNH5.png" width="1000" height="200" alt="图片名称" align="center" id="92"><p>等待一段时间，Console中输出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">16:35:40.364 [restartedMain] INFO  o.a.c.h.Http11NioProtocol - [<span class="built_in">log</span>,173] - Starting ProtocolHandler [<span class="string">"http-nio-8080"</span>]</span><br><span class="line">16:35:40.534 [restartedMain] INFO  c.r.RuoYiApplication - [logStarted,61] - Started RuoYiApplication <span class="keyword">in</span> 6.585 seconds (JVM running <span class="keyword">for</span> 7.614)</span><br><span class="line">(♥◠‿◠)ﾉﾞ  若依启动成功   ლ(´ڡ`ლ)ﾞ  </span><br><span class="line"> .-------.       ____     __        </span><br><span class="line"> |  _ _   \      \   \   /  /    </span><br><span class="line"> | ( <span class="string">' )  |       \  _. /  '</span>       </span><br><span class="line"> |(_ o _) /        _( )_ .<span class="string">'         </span></span><br><span class="line"><span class="string"> | (_,_).'</span> __  ___(_ o _)<span class="string">'          </span></span><br><span class="line"><span class="string"> |  |\ \  |  ||   |(_,_)'</span>         </span><br><span class="line"> |  | \ `<span class="string">'   /|   `-'</span>  /           </span><br><span class="line"> |  |  \    /  \      /           </span><br><span class="line"> <span class="string">''</span>-<span class="string">'   `'</span>-<span class="string">'    `-..-'</span>              </span><br><span class="line">16:35:41.546 [Quartz Scheduler [RuoyiScheduler]] INFO  o.q.c.QuartzScheduler - [start,547] - Scheduler RuoyiScheduler_<span class="variable">$_LAPTOP</span>-NE344QFT1644914139051 started.</span><br><span class="line">16:36:15.811 [http-nio-8080-exec-1] INFO  o.a.c.c.C.[.[.[/] - [<span class="built_in">log</span>,173] - Initializing Spring DispatcherServlet <span class="string">'dispatcherServlet'</span></span><br></pre></td></tr></table></figure><p>打开浏览器，输入<code>http://localhost:8080/</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">欢迎使用RuoYi后台管理框架，当前版本：v3.8.1，请通过前端地址访问。</span><br></pre></td></tr></table></figure><p>至此，后端运行成功。</p><h1 id="7-运行前端"><a class="markdownIt-Anchor" href="#7-运行前端"></a> 7 运行前端</h1><p>在IDEA中打开 <code>Terminal</code> 标签，并输入 <code>npm install --registry=https://registry.npm.taobao.org</code> 安装依赖：</p><img src="https://s2.loli.net/2022/02/15/qAkZxnyW1PbSr7N.png" width="1000" height="200" alt="图片名称" align="center" id="93"><p>等待依赖安装完成，启动服务：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">E:\05 Code\RMDVS\RuoYi-Vue\ruoyi-ui&gt;npm run dev</span><br><span class="line"></span><br><span class="line">&gt; ruoyi@3.8.1 dev E:\05 Code\RMDVS\RuoYi-Vue\ruoyi-ui</span><br><span class="line">&gt; vue-cli-service serve</span><br><span class="line"></span><br><span class="line"> INFO  Starting development server...</span><br><span class="line">98% after emitting CopyPlugin</span><br><span class="line"></span><br><span class="line"> DONE  Compiled successfully <span class="keyword">in</span> 20312ms                                                                                                                                                               18:05:56</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  App running at:</span><br><span class="line">  - Local:   http://localhost:80/</span><br><span class="line">  - Network: http://192.168.1.7:80/</span><br><span class="line"></span><br><span class="line">  Note that the development build is not optimized.</span><br><span class="line">  To create a production build, run npm run build.</span><br></pre></td></tr></table></figure><p>启动成功后，会自动跳转到浏览器 <code>http://localhost:80/</code>，然后能出现验证码则是请求后台成功。</p><img src="https://s2.loli.net/2022/02/15/4TGiZCcwX827Eno.png" width="600" height="400" alt="图片名称" align="center" id="94"><p>登陆成功，至此前端启动成功。</p><img src="https://s2.loli.net/2022/02/15/gdFxAsfShMykPvw.png" width="800" height="400" alt="图片名称" align="center" id="95"><p>至此，若依系统前后端全部启动成功！！</p><h1 id="x-参考"><a class="markdownIt-Anchor" href="#x-参考"></a> X 参考</h1><ul><li><a href="https://blog.csdn.net/BADAO_LIUMANG_QIZHI/article/details/108465662" target="_blank" rel="noopener">若依前后端分离版手把手教你本地搭建环境并运行项目</a></li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>git clone失败整理</title>
      <link href="/2022/02/14/git-clone%E5%A4%B1%E8%B4%A5%E6%95%B4%E7%90%86/"/>
      <url>/2022/02/14/git-clone%E5%A4%B1%E8%B4%A5%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-errno-10054"><a class="markdownIt-Anchor" href="#1-errno-10054"></a> 1 errno 10054</h1><p>翻墙了，但是仍然出现下面的报错：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cloning into <span class="string">'redash'</span>...</span><br><span class="line">fatal: unable to access <span class="string">'https://github.com/getredash/redash.git/'</span>: OpenSSL SSL_read: Connection was reset, errno 10054</span><br></pre></td></tr></table></figure><p>可能是因为代码库太大，调高 <code>git buffer size</code> 即可：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法1 全局修改</span></span><br><span class="line">git config --global http.postBuffer 524288000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法2 只针对当前仓库</span></span><br><span class="line">git init</span><br><span class="line">git config http.postBuffer 524288000</span><br><span class="line">git remote add origin &lt;REPO URL&gt;</span><br><span class="line">git pull origin master</span><br></pre></td></tr></table></figure><p>重开cmd，倘若还不成功，重复几次即可。</p><ul><li><a href="https://stackoverflow.com/questions/46232906/git-clone-error-rpc-failed-curl-56-openssl-ssl-read-ssl-error-syscall-errno" target="_blank" rel="noopener">stackoverflow问答</a></li></ul><h1 id="2-443timed-out"><a class="markdownIt-Anchor" href="#2-443timed-out"></a> 2 443：Timed out</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cloning into <span class="string">'redash'</span>...</span><br><span class="line">fatal: unable to access <span class="string">'https://github.com/getredash/redash.git/'</span>: Failed to connect to github.com port 443: Timed out</span><br></pre></td></tr></table></figure><p>翻墙是一种方法，其他待整理</p><h1 id="3-openssl-ssl_connect-ssl_error_syscall"><a class="markdownIt-Anchor" href="#3-openssl-ssl_connect-ssl_error_syscall"></a> 3 OpenSSL SSL_connect: SSL_ERROR_SYSCALL</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cloning into <span class="string">'addlcov'</span>...</span><br><span class="line">fatal: unable to access <span class="string">'https://github.com/Dragonliu2018/addlcov.git/'</span>: OpenSSL SSL_connect: SSL_ERROR_SYSCALL <span class="keyword">in</span> connection to github.com:443</span><br></pre></td></tr></table></figure><p>又试了一次，成功下载。</p>]]></content>
      
      
      <categories>
          
          <category> 环境与工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 待补充 </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-取整</title>
      <link href="/2022/02/11/Python-%E5%8F%96%E6%95%B4/"/>
      <url>/2022/02/11/Python-%E5%8F%96%E6%95%B4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-向下取整int"><a class="markdownIt-Anchor" href="#1-向下取整int"></a> 1 向下取整——int()</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f1 = <span class="number">1.23</span></span><br><span class="line">print(int(f1))  <span class="comment"># 1</span></span><br><span class="line">f2 = <span class="number">1.73</span></span><br><span class="line">print(int(f2))  <span class="comment"># 1</span></span><br></pre></td></tr></table></figure><h1 id="2-向上取整ceil"><a class="markdownIt-Anchor" href="#2-向上取整ceil"></a> 2 向上取整——ceil()</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line">f1 = <span class="number">1.23</span></span><br><span class="line">print(math.ceil(f1))  <span class="comment"># 2</span></span><br><span class="line">f2 = <span class="number">1.73</span></span><br><span class="line">print(math.ceil(f2))  <span class="comment"># 2</span></span><br></pre></td></tr></table></figure><h1 id="3-四舍五入round"><a class="markdownIt-Anchor" href="#3-四舍五入round"></a> 3 四舍五入——round()</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f1 = <span class="number">1.23</span></span><br><span class="line">print(round(f1))  <span class="comment"># 1</span></span><br><span class="line">f2 = <span class="number">1.73</span></span><br><span class="line">print(round(f2))  <span class="comment"># 2</span></span><br></pre></td></tr></table></figure><h1 id="4-分别取整数和小数部分"><a class="markdownIt-Anchor" href="#4-分别取整数和小数部分"></a> 4 分别取整数和小数部分</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f1 = <span class="number">1.23</span></span><br><span class="line">print(math.modf(f1))  <span class="comment"># (0.22999999999999998, 1.0)</span></span><br></pre></td></tr></table></figure><p>至于小数部分不准确：涉及<strong>浮点数在计算机中的表示</strong>。在计算机中是无法精确的表示小数的，至少目前的计算机做不到这一点。Python 和 C 一样, 采用 <code>IEEE 754</code> 规范来存储浮点数。</p><h1 id="x-参考"><a class="markdownIt-Anchor" href="#x-参考"></a> X 参考</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/365406577" target="_blank" rel="noopener">python中取整数的四种方法</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python-类-使用简易教程</title>
      <link href="/2022/02/11/Python-%E7%B1%BB-%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"/>
      <url>/2022/02/11/Python-%E7%B1%BB-%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-模板"><a class="markdownIt-Anchor" href="#1-模板"></a> 1 模板</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Action</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># 类属性</span></span><br><span class="line">    is_fail = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, sid, fid)</span>:</span></span><br><span class="line">        self.id = sid  <span class="comment"># 唯一标志信息</span></span><br><span class="line">        self.fid = fid  <span class="comment"># 父进程唯一标志信息</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_id</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.id</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_fid</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.fid</span><br><span class="line"></span><br><span class="line">test_action = Action(sid=sid, fid=fid)</span><br><span class="line">print(test_action.get_id())</span><br><span class="line">print(Action.is_fail)</span><br></pre></td></tr></table></figure><p>更多参考：<a href="https://www.runoob.com/python3/python3-class.html" target="_blank" rel="noopener">菜鸟教程</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 待补充 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-多线程&amp;多进程-编程教程</title>
      <link href="/2022/02/11/Python-%E5%A4%9A%E7%BA%BF%E7%A8%8B&amp;%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E7%BC%96%E7%A8%8B/"/>
      <url>/2022/02/11/Python-%E5%A4%9A%E7%BA%BF%E7%A8%8B&amp;%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-引言"><a class="markdownIt-Anchor" href="#1-引言"></a> 1 引言</h1><p>最近在做恶意样本行为可视化，样本数量2w+，执行时间&gt;24h，所以需要多任务处理来提高效率。</p><blockquote><p>参考：<a href="https://blog.csdn.net/qq_40317897/article/details/89921083" target="_blank" rel="noopener">Python多进程和多线程（跑满CPU）</a></p></blockquote><p>任务可以理解为进程（process），如打开一个word就是启动一个word进程。在一个word进程之中不只是进行打字输入，还需要拼写检查、打印等子任务，我们可以把进程中的这些子任务称为线程（thread）。</p><p>同时执行多个任务通常各个任务之间并不是没有关联的，而是需要相互通信和协调，有时，任务1必须暂停等待任务2完成后才能继续执行，有时，任务3和任务4又不能同时执行，所以，多进程和多线程的程序的复杂度要远远高于我们前面写的单进程单线程的程序。</p><h1 id="2-多任务实现的3种方式"><a class="markdownIt-Anchor" href="#2-多任务实现的3种方式"></a> 2 多任务实现的3种方式</h1><h2 id="21-多进程模式"><a class="markdownIt-Anchor" href="#21-多进程模式"></a> 2.1 多进程模式</h2><p>启动多个进程，每个进程虽然只有一个线程，但多个进程可以一块执行多个任务。<font color="red">多个CPU核心可以一起做多个任务。</font></p><p>进程执行带有参数的任务：</p><table><thead><tr><th>参数名</th><th>说明</th></tr></thead><tbody><tr><td>args</td><td>以元祖的方式给任务传递参数, 顺序要正确</td></tr><tr><td>kwrags</td><td>以字典的方式给执行任务传递参数, key 跟参数名要一致</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(data)</span>:</span></span><br><span class="line">    print(data, <span class="string">'进程PID'</span>, os.getpid())</span><br><span class="line">    print(data, <span class="string">'进程父进程编号'</span>, os.getppid())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_multiprocess</span><span class="params">()</span>:</span></span><br><span class="line">    data_list = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">    core = <span class="number">4</span>  <span class="comment"># 4进程并行</span></span><br><span class="line">    mod = math.ceil(len(data_list) / core)  <span class="comment"># 向上取整</span></span><br><span class="line">    group_data = [data_list[i:i + mod] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(data_list), mod)]</span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> group_data:</span><br><span class="line">        <span class="comment"># process = multiprocessing.Process(target=func, args=(5,))</span></span><br><span class="line">        process = multiprocessing.Process(target=func, kwargs=&#123;<span class="string">'data'</span>: data&#125;)</span><br><span class="line">        process.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    test_multiprocess()</span><br></pre></td></tr></table></figure><h2 id="22-多线程模式"><a class="markdownIt-Anchor" href="#22-多线程模式"></a> 2.2 多线程模式</h2><p>启动一个进程，在一个进程内启动多个线程，这样，多个线程也可以一块执行多个任务。<font color="red">单个CPU核心可以同时做多个任务。</font></p><p><a href="https://www.runoob.com/python/python-multithreading.html" target="_blank" rel="noopener">菜鸟教程——多线程</a></p><h2 id="23-多进程多线程模式"><a class="markdownIt-Anchor" href="#23-多进程多线程模式"></a> 2.3 多进程+多线程模式</h2><p>启动多个进程，每个进程再启动多个线程，这样同时执行的任务就更多了，当然这种模型更复杂，实际很少采用。</p><h1 id="3-进程线程对比"><a class="markdownIt-Anchor" href="#3-进程线程对比"></a> 3 进程线程对比</h1><h2 id="31-关系对比"><a class="markdownIt-Anchor" href="#31-关系对比"></a> 3.1 关系对比</h2><ol><li>线程是依附在进程里边的, 没有进程就没有线程</li><li>一个进程默认提供一条线程, 进程可以创建多个线程</li></ol><h2 id="32-区别对比"><a class="markdownIt-Anchor" href="#32-区别对比"></a> 3.2 区别对比</h2><ol><li>进程创建的开销要比线程的开销要大</li><li>进程是操作系统资源分配的基本单位, 线程是cpu 调度的基本单位</li><li>线程不能独立执行, 必须依存进程</li></ol><h2 id="33-优缺点对比"><a class="markdownIt-Anchor" href="#33-优缺点对比"></a> 3.3 优缺点对比</h2><ol><li><p>进程优缺点:</p><p>优点：可以用多核</p><p>缺点：资源开销大</p></li><li><p>线程优缺点</p><p>优点: 资源开销小</p><p>缺点：不能使用多核</p></li></ol><h1 id="x-参考"><a class="markdownIt-Anchor" href="#x-参考"></a> X 参考</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/340657122" target="_blank" rel="noopener">在Python中优雅地用多进程</a></li><li><a href="https://blog.csdn.net/qq_43475705/article/details/115518463" target="_blank" rel="noopener">python多进程多线程,多个程序同时运行</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Pycharm(IntelliJ系列)的Low Memory问题</title>
      <link href="/2022/02/11/Pycharm-IntelliJ-%E7%9A%84Low-Memory%E9%97%AE%E9%A2%98/"/>
      <url>/2022/02/11/Pycharm-IntelliJ-%E7%9A%84Low-Memory%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-问题引入"><a class="markdownIt-Anchor" href="#1-问题引入"></a> 1 问题引入</h1><p>最近在跑恶意样本可视化的脚本，Pycharm出现：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Low Memory</span><br><span class="line">The IDE is running low on memory and this might affect performance. Please consider increasing available heap.</span><br></pre></td></tr></table></figure><p>原因是IDE内存不足（之前给pycharm设定了2048M，跑大项目会出现上述问题）。</p><p>主要copy于 <a href="https://www.cnblogs.com/baby123/p/15626312.html" target="_blank" rel="noopener">idea 的Low Memory问题</a></p><h1 id="2-解决方法"><a class="markdownIt-Anchor" href="#2-解决方法"></a> 2 解决方法</h1><p>下面的方法适用于IntelliJ系列产品，如Pycharm、idea等。</p><h2 id="21-直接配置"><a class="markdownIt-Anchor" href="#21-直接配置"></a> 2.1 直接配置</h2><img src="https://s2.loli.net/2022/02/11/ulXpqTxoQSt1mRB.png" width="800" height="200" alt="图片名称" align="center" id="68"><p>选择上图里的 Configure，修改堆大小：</p><img src="https://s2.loli.net/2022/02/11/luJ4ba1mBA3G2hE.png" width="300" height="200" alt="图片名称" align="center" id="69"><p>重启IDE生效。</p><h2 id="22-通过help配置修改"><a class="markdownIt-Anchor" href="#22-通过help配置修改"></a> 2.2 通过help配置修改</h2><p>菜单 Help -&gt; 选择 Edit Custom VM Options，会打开 pycharm64.exe.vmoptions文件，修改配置即可。</p><img src="https://s2.loli.net/2022/02/11/EgGpOs8Miow1VSe.png" width="600" height="400" alt="图片名称" align="center" id="70"><p>此时发现<code>Change Memory Settings</code>中已经发生了变化：</p><img src="https://s2.loli.net/2022/02/11/KPSpc5fVvUZR7ON.png" width="600" height="400" alt="图片名称" align="center" id="71"><p>最后重启IDE生效。</p>]]></content>
      
      
      <categories>
          
          <category> 环境与工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python-集合-操作教程</title>
      <link href="/2022/02/10/Python-%E9%9B%86%E5%90%88-%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/"/>
      <url>/2022/02/10/Python-%E9%9B%86%E5%90%88-%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-引言"><a class="markdownIt-Anchor" href="#1-引言"></a> 1 引言</h1><p>集合（set）是一个无序的不重复元素序列。</p><p>主要copy于<a href="https://www.runoob.com/python3/python3-set.html" target="_blank" rel="noopener">菜鸟教程</a></p><h1 id="2-使用"><a class="markdownIt-Anchor" href="#2-使用"></a> 2 使用</h1><h2 id="21-创建"><a class="markdownIt-Anchor" href="#21-创建"></a> 2.1 创建</h2><p>可以使用大括号 <strong>{ }</strong> 或者 <strong>set()</strong> 函数创建集合：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">set1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">print(set1)  <span class="comment"># &#123;1, 2, 3&#125;</span></span><br><span class="line"></span><br><span class="line">set2 = &#123;<span class="string">'pear'</span>, <span class="string">'apple'</span>&#125;</span><br><span class="line">print(set2)  <span class="comment"># &#123;'apple', 'pear'&#125;</span></span><br><span class="line"></span><br><span class="line">set3 = set(<span class="string">"apple"</span>)</span><br><span class="line">print(set3)  <span class="comment"># &#123;'l', 'p', 'e', 'a'&#125;</span></span><br><span class="line"></span><br><span class="line">set4 = set(&#123;<span class="string">'pear'</span>, <span class="string">'apple'</span>&#125;)</span><br><span class="line">print(set4)  <span class="comment"># &#123;'apple', 'pear'&#125;</span></span><br><span class="line"></span><br><span class="line">set5 = set((<span class="string">'pear'</span>, <span class="string">'apple'</span>))</span><br><span class="line">print(set5)  <span class="comment"># &#123;'pear', 'apple'&#125;</span></span><br></pre></td></tr></table></figure><p><font color="red">注意：创建一个空集合必须用 <strong>set()</strong> 而不是 <strong>{ }</strong>，因为 <strong>{ }</strong> 是用来创建一个空字典。</font></p><h2 id="22-集合运算"><a class="markdownIt-Anchor" href="#22-集合运算"></a> 2.2 集合运算</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 下面展示两个集合间的运算.</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = set(<span class="string">'abracadabra'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = set(<span class="string">'alacazam'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a                                  </span><br><span class="line">&#123;<span class="string">'a'</span>, <span class="string">'r'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a - b                              <span class="comment"># 集合a中包含而集合b中不包含的元素</span></span><br><span class="line">&#123;<span class="string">'r'</span>, <span class="string">'d'</span>, <span class="string">'b'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a | b                              <span class="comment"># 集合a或b中包含的所有元素</span></span><br><span class="line">&#123;<span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'r'</span>, <span class="string">'d'</span>, <span class="string">'b'</span>, <span class="string">'m'</span>, <span class="string">'z'</span>, <span class="string">'l'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a &amp; b                              <span class="comment"># 集合a和b中都包含了的元素</span></span><br><span class="line">&#123;<span class="string">'a'</span>, <span class="string">'c'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a ^ b                              <span class="comment"># 不同时包含于a和b的元素</span></span><br><span class="line">&#123;<span class="string">'r'</span>, <span class="string">'d'</span>, <span class="string">'b'</span>, <span class="string">'m'</span>, <span class="string">'z'</span>, <span class="string">'l'</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="23-基本操作"><a class="markdownIt-Anchor" href="#23-基本操作"></a> 2.3 基本操作</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">test_set = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line"><span class="comment"># 添加元素——add(x)</span></span><br><span class="line"><span class="comment">##将元素 x 添加到集合 s 中，如果元素已存在，则不进行任何操作。</span></span><br><span class="line">test_set.add(<span class="number">2</span>)  <span class="comment"># &#123;1, 2&#125;</span></span><br><span class="line">test_set.add(<span class="number">3</span>)  <span class="comment"># &#123;1, 2, 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加元素——update(x)</span></span><br><span class="line"><span class="comment">##参数是列表，元组，字典等，int会报错</span></span><br><span class="line"><span class="comment">##x 可以有多个，用逗号分开。</span></span><br><span class="line">test_set.update(<span class="number">4</span>)  <span class="comment"># TypeError: 'int' object is not iterable</span></span><br><span class="line">test_set.update(&#123;<span class="number">4</span>, <span class="number">5</span>&#125;)  <span class="comment"># &#123;1, 2, 3, 4, 5&#125;</span></span><br><span class="line">test_set.update([<span class="number">4</span>, <span class="number">5</span>], [<span class="number">5</span>, <span class="number">6</span>])  <span class="comment"># &#123;1, 2, 3, 4, 5, 6&#125;</span></span><br><span class="line">test_set.update((<span class="number">6</span>, <span class="number">7</span>))  <span class="comment"># &#123;1, 2, 3, 4, 5, 6, 7&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除元素——remove(x)</span></span><br><span class="line"><span class="comment">##将元素 x 从集合 s 中移除，如果元素不存在，则会发生错误。</span></span><br><span class="line">test_set.remove(<span class="number">8</span>)  <span class="comment"># KeyError: 8</span></span><br><span class="line">test_set.remove(<span class="number">7</span>)  <span class="comment"># &#123;1, 2, 3, 4, 5, 6&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除元素——discard(x)</span></span><br><span class="line"><span class="comment">##移除集合中的元素，且如果元素不存在，不会发生错误</span></span><br><span class="line">test_set.discard(<span class="number">7</span>)  <span class="comment"># 不报错 &#123;1, 2, 3, 4, 5, 6&#125;</span></span><br><span class="line">test_set.discard(<span class="number">6</span>)  <span class="comment"># &#123;1, 2, 3, 4, 5&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除元素——pop()</span></span><br><span class="line"><span class="comment">##随机删除集合中的一个元素</span></span><br><span class="line"><span class="comment">##对集合进行无序的排列，然后将这个无序排列集合的左面第一个元素进行删除。</span></span><br><span class="line">test_set.pop()  <span class="comment"># &#123;2, 3, 4, 5&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算元素个数——len</span></span><br><span class="line">len(test_set)  <span class="comment"># 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断元素是否存在于集合中——in</span></span><br><span class="line">print(<span class="number">2</span> <span class="keyword">in</span> test_set)  <span class="comment"># True</span></span><br><span class="line">print(<span class="number">1</span> <span class="keyword">in</span> test_set)  <span class="comment"># False</span></span><br><span class="line">print(<span class="number">1</span> <span class="keyword">not</span> <span class="keyword">in</span> test_set)  <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清空集合——clear</span></span><br><span class="line">test_set.clear()</span><br><span class="line">print(test_set)  <span class="comment"># set()</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows下安装与使用neo4j</title>
      <link href="/2022/02/10/Windows%E4%B8%8B%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8neo4j/"/>
      <url>/2022/02/10/Windows%E4%B8%8B%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8neo4j/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-引言"><a class="markdownIt-Anchor" href="#1-引言"></a> 1 引言</h1><p>最近在实现恶意样本行为可视化，使用 <a href="dragonliu.tk/2022/02/03/python%E6%A8%A1%E5%9D%97graphviz%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/">python模块graphviz使用教程</a> 可以达到既定要求；但是图数据库neo4j理论上也是个不错的选择，所以整理下。</p><p>思路：安装Neo4j数据库，python语言使用py2neo库进行使用。</p><h1 id="2-安装neo4j"><a class="markdownIt-Anchor" href="#2-安装neo4j"></a> 2 安装Neo4j</h1><p>主要copy于 <a href="https://cloud.tencent.com/developer/article/1387732" target="_blank" rel="noopener">图数据库neo4j的安装与基本使用(一)</a></p><h2 id="21-安装jdk"><a class="markdownIt-Anchor" href="#21-安装jdk"></a> 2.1 安装JDK</h2><p>Neo4j是基于Java的图形<a href="https://cloud.tencent.com/solution/database?from=10680" target="_blank" rel="noopener">数据库</a>，运行Neo4j需要启动JVM进程，因此必须安装JAVA SE的JDK。从Oracle官方网站下载 <a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">Java SE JDK</a>，当前的版本是JDK8。<font color="red">java版本的高低决定了Neo4j的版本</font></p><h2 id="22-安装neo4j"><a class="markdownIt-Anchor" href="#22-安装neo4j"></a> 2.2 安装Neo4j</h2><p>官网下载最新版本<a href="https://neo4j.com/download/other-releases/" target="_blank" rel="noopener">Neo4j</a></p><p>Neo4j应用程序有如下主要的目录结构：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bin目录：用于存储Neo4j的可执行程序；</span><br><span class="line">conf目录：用于控制Neo4j启动的配置文件；</span><br><span class="line">data目录：用于存储核心数据库文件；</span><br><span class="line">plugins目录：用于存储Neo4j的插件；</span><br></pre></td></tr></table></figure><h2 id="23-配置环境变量"><a class="markdownIt-Anchor" href="#23-配置环境变量"></a> 2.3 配置环境变量</h2><p>创建主目录环境变量NEO4J_HOME，并把主目录设置为变量值。</p><img src="https://s2.loli.net/2022/02/11/lkopux9h8Zn7PeE.png" width="600" height="200" alt="图片名称" align="center" id="72"><h2 id="24-启动neo4j"><a class="markdownIt-Anchor" href="#24-启动neo4j"></a> 2.4 启动neo4j</h2><h3 id="241-通过控制台启动neo4j程序"><a class="markdownIt-Anchor" href="#241-通过控制台启动neo4j程序"></a> 2.4.1 通过控制台启动Neo4j程序</h3><p>打开cmd，切换到Neo4j主目录下的<code>bin</code>目录，运行下面命令即可：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">neo4j.bat console</span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2022/02/11/3d7LJMoKpr2WxNC.png" width="800" height="200" alt="图片名称" align="center" id="73"><img src="https://s2.loli.net/2022/02/11/nFHPDW9Tfxz6LXY.png" width="600" height="300" alt="图片名称" align="center" id="74"><p>用户名和密码默认为<code>neo4j</code>，首次登陆需要修改密码(Neo4j)</p><p><font color="red">java与neo4j版本不对应的报错：</font></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">警告: ERROR! Neo4j cannot be started using java version <span class="number">1.8</span><span class="number">.0</span>_301</span><br><span class="line">警告: * Please use Oracle(R) Java(TM) <span class="number">11</span>, OpenJDK(TM) <span class="number">11</span> to run Neo4j Server.</span><br><span class="line">* Please see https://neo4j.com/docs/ <span class="keyword">for</span> Neo4j installation instructions.</span><br><span class="line">Invoke-Neo4j : This instance of Java <span class="keyword">is</span> <span class="keyword">not</span> supported</span><br><span class="line">所在位置 D:\developer\neo4j\neo4j-community<span class="number">-4.4</span><span class="number">.3</span>\bin\neo4j.ps1:<span class="number">21</span> 字符: <span class="number">7</span></span><br><span class="line">+ Exit (Invoke-Neo4j -Verbose:$Arguments.Verbose -CommandArgs $Argument ...</span><br><span class="line">+       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">    + CategoryInfo          : NotSpecified: (:) [Write-Error], WriteErrorException</span><br><span class="line">    + FullyQualifiedErrorId : Microsoft.PowerShell.Commands.WriteErrorException,Invoke-Neo4j</span><br></pre></td></tr></table></figure><p>当时我测试的版本(JDK8+Neo4j4.4.4)出现上面的报错，该换JDK8+Neo4j3.5.30后成功运行。</p><h3 id="242-把neo4j安装为服务windows-services"><a class="markdownIt-Anchor" href="#242-把neo4j安装为服务windows-services"></a> 2.4.2 把Neo4j安装为服务（Windows Services）</h3><p>请查阅  <a href="https://cloud.tencent.com/developer/article/1387732" target="_blank" rel="noopener">图数据库neo4j的安装与基本使用(一)</a></p><h1 id="3-python使用"><a class="markdownIt-Anchor" href="#3-python使用"></a> 3 python使用</h1><p>python通过调用<code>py2neo</code> 库实现对数据库的操作。</p><ul><li><p><a href="https://py2neo.org/v4/data.html#node-and-relationship-objects" target="_blank" rel="noopener">py2neo官网</a></p></li><li><p><a href="https://www.jianshu.com/p/a2497a33390f" target="_blank" rel="noopener">py2neo——Neo4j&amp;python的配合使用</a></p></li><li><p><a href="https://cloud.tencent.com/developer/article/1693445" target="_blank" rel="noopener">用Python中的py2neo库调用neo4j，搭建简单关联图谱</a></p></li></ul><h2 id="31-连接数据库"><a class="markdownIt-Anchor" href="#31-连接数据库"></a> 3.1 连接数据库</h2><p>安装py2neo库：<code>pip install py2neo</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> py2neo <span class="keyword">import</span> Graph</span><br><span class="line"></span><br><span class="line">test_graph = Graph(</span><br><span class="line">    <span class="string">"http://localhost:7474"</span>,</span><br><span class="line">    username=<span class="string">"neo4j"</span>,</span><br><span class="line">    password=<span class="string">"Neo4j"</span>  <span class="comment">#修改后的密码</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>测试时出现报错：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ValueError: The following settings are not supported: &#123;<span class="string">'username'</span>: <span class="string">'neo4j'</span>&#125;</span><br></pre></td></tr></table></figure><p>因为py2neo版本问题，需要做出以下修改：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> py2neo <span class="keyword">import</span> Graph</span><br><span class="line"></span><br><span class="line">test_graph = Graph(<span class="string">"http://localhost:7474"</span>, auth=(<span class="string">"neo4j"</span>, <span class="string">"Neo4j"</span>))</span><br></pre></td></tr></table></figure><p>详见 <a href="https://blog.csdn.net/u010785550/article/details/116856031" target="_blank" rel="noopener">关于使用Py2neo连接Neo4j图数据库出现“ValueError: The following settings are not supported”报错的解决方案</a></p><h2 id="32-基本操作"><a class="markdownIt-Anchor" href="#32-基本操作"></a> 3.2 基本操作</h2><p>参考：<a href="https://blog.csdn.net/michaelguangg/article/details/100704303" target="_blank" rel="noopener">py2neo在已有节点上批量创建关系</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> py2neo <span class="keyword">import</span> Graph, Node, Relationship, Subgraph</span><br><span class="line"></span><br><span class="line">test_graph = Graph(<span class="string">"http://localhost:7474"</span>, auth=(<span class="string">"neo4j"</span>, <span class="string">"Neo4j"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除数据库中以往的图，确保在一个空白的环境中进行操作</span></span><br><span class="line">test_graph.delete_all()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建顶点</span></span><br><span class="line">node_list = []</span><br><span class="line">node_list.append(Node(<span class="string">"Teacher"</span>, name=<span class="string">"Alice"</span>))  <span class="comment"># label(type) name(显示值)</span></span><br><span class="line">node_list.append(Node(<span class="string">"Student"</span>, name=<span class="string">"Bob"</span>))</span><br><span class="line">node_list.append(Node(<span class="string">"Student"</span>, name=<span class="string">"Dragon"</span>))</span><br><span class="line">node_list.append(Node(<span class="string">"Student"</span>, name=<span class="string">"Pig"</span>))</span><br><span class="line"><span class="comment">##subgraph加快导入速度</span></span><br><span class="line">nodes = Subgraph(node_list)</span><br><span class="line">test_graph.create(nodes)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建边</span></span><br><span class="line">edge_list = []</span><br><span class="line"><span class="comment">##找到对应节点</span></span><br><span class="line">node1 = test_graph.nodes.match(name=<span class="string">"Alice"</span>).first()</span><br><span class="line">node2 = test_graph.nodes.match(name=<span class="string">"Bob"</span>).first()</span><br><span class="line">edge_list.append(Relationship(node1, <span class="string">"teach"</span>, node2))</span><br><span class="line">node1 = test_graph.nodes.match(name=<span class="string">"Alice"</span>).first()</span><br><span class="line">node2 = test_graph.nodes.match(name=<span class="string">"Dragon"</span>).first()</span><br><span class="line">edge_list.append(Relationship(node1, <span class="string">"teach"</span>, node2))</span><br><span class="line">edges = Subgraph(relationships=edge_list)</span><br><span class="line">test_graph.create(edges)</span><br></pre></td></tr></table></figure><p>效果图如下：</p><img src="https://s2.loli.net/2022/02/11/4Li9RKwmuN7t6kV.png" width="700" height="400" alt="图片名称" align="center" id="75"><h1 id="4-拓展spade"><a class="markdownIt-Anchor" href="#4-拓展spade"></a> 4 拓展——SPADE</h1><p>当时参加A-ST竞赛时使用过，本次测试没进行。</p><p><a href="https://github.com/ashish-gehani/SPADE" target="_blank" rel="noopener">Github-Spade</a></p><h1 id="x-参考"><a class="markdownIt-Anchor" href="#x-参考"></a> X 参考</h1><ul><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> 环境与工具 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> neo4j </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-列表-分组</title>
      <link href="/2022/02/10/Python-%E5%88%97%E8%A1%A8-%E5%88%86%E7%BB%84/"/>
      <url>/2022/02/10/Python-%E5%88%97%E8%A1%A8-%E5%88%86%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-前言"><a class="markdownIt-Anchor" href="#1-前言"></a> 1 前言</h1><p>最近在整python多线程，需要对文件列表进行分组，下面整理下有关list分组的内容。</p><h1 id="2-分块"><a class="markdownIt-Anchor" href="#2-分块"></a> 2 分块</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">3</span></span><br><span class="line">data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">group_data = [data[i:i + num] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(data), num)]</span><br><span class="line">print(group_data)  <span class="comment"># [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10]]</span></span><br></pre></td></tr></table></figure><h1 id="3-groupby分组"><a class="markdownIt-Anchor" href="#3-groupby分组"></a> 3 groupby分组</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> groupby</span><br><span class="line"></span><br><span class="line">user_list = [</span><br><span class="line">    &#123;<span class="string">"uid"</span>: <span class="number">1</span>, <span class="string">"sex"</span>: <span class="string">"男"</span>, <span class="string">"age"</span>: <span class="number">10</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"uid"</span>: <span class="number">3</span>, <span class="string">"sex"</span>: <span class="string">"男"</span>, <span class="string">"age"</span>: <span class="number">20</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"uid"</span>: <span class="number">4</span>, <span class="string">"sex"</span>: <span class="string">"女"</span>, <span class="string">"age"</span>: <span class="number">20</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"uid"</span>: <span class="number">4</span>, <span class="string">"sex"</span>: <span class="string">"女"</span>, <span class="string">"age"</span>: <span class="number">31</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"uid"</span>: <span class="number">2</span>, <span class="string">"sex"</span>: <span class="string">"男"</span>, <span class="string">"age"</span>: <span class="number">10</span>&#125;</span><br><span class="line">]</span><br><span class="line"><span class="comment"># 多字段排序</span></span><br><span class="line">user_sort = sorted(user_list, key=<span class="keyword">lambda</span> x: (x[<span class="string">"sex"</span>], x[<span class="string">"age"</span>]))</span><br><span class="line"><span class="comment"># 多字段分组</span></span><br><span class="line">user_group = groupby(user_sort, key=<span class="keyword">lambda</span> x: (x[<span class="string">"sex"</span>], x[<span class="string">"age"</span>]))</span><br><span class="line"><span class="keyword">for</span> key, group <span class="keyword">in</span> user_group:</span><br><span class="line">    print(key, list(group))</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">('女', 20) [&#123;'uid': 4, 'sex': '女', 'age': 20&#125;]</span></span><br><span class="line"><span class="string">('女', 31) [&#123;'uid': 4, 'sex': '女', 'age': 31&#125;]</span></span><br><span class="line"><span class="string">('男', 10) [&#123;'uid': 1, 'sex': '男', 'age': 10&#125;, &#123;'uid': 2, 'sex': '男', 'age': 10&#125;]</span></span><br><span class="line"><span class="string">('男', 20) [&#123;'uid': 3, 'sex': '男', 'age': 20&#125;]</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p><font color="red">注意分组之前应先使用分组字段排好序。</font></p><h1 id="x-参考"><a class="markdownIt-Anchor" href="#x-参考"></a> X 参考</h1><ul><li><a href="https://blog.csdn.net/qq_21570029/article/details/84062979" target="_blank" rel="noopener">python list按规定的范围分组</a></li><li><a href="https://blog.csdn.net/xiaoc100200/article/details/111402566" target="_blank" rel="noopener">Python list列表groupby分组用法</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python-字典-判断dict或list中是否含有某个元素或key</title>
      <link href="/2022/02/09/Python-%E5%AD%97%E5%85%B8-%E5%88%A4%E6%96%ADdict%E6%88%96list%E4%B8%AD%E6%98%AF%E5%90%A6%E5%90%AB%E6%9C%89%E6%9F%90%E4%B8%AA%E5%85%83%E7%B4%A0%E6%88%96key/"/>
      <url>/2022/02/09/Python-%E5%AD%97%E5%85%B8-%E5%88%A4%E6%96%ADdict%E6%88%96list%E4%B8%AD%E6%98%AF%E5%90%A6%E5%90%AB%E6%9C%89%E6%9F%90%E4%B8%AA%E5%85%83%E7%B4%A0%E6%88%96key/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-自带函数has_key"><a class="markdownIt-Anchor" href="#1-自带函数has_key"></a> 1 自带函数has_key()</h1><p>在python的字典的属性方法里面有一个<code>has_key()</code>方法，这个方法使用起来非常简单。</p><p>Python 3.x不再支持 <code>has_key()</code> 函数，而被<code>__contains__()</code>所替代。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">'name'</span>: &#123;&#125;, <span class="string">'age'</span>: &#123;&#125;, <span class="string">'sex'</span>: &#123;&#125;&#125;</span><br><span class="line"><span class="comment"># print(d.has_key('name'))</span></span><br><span class="line">print(d.__contains__(<span class="string">'name'</span>))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure><h1 id="2-in-方法"><a class="markdownIt-Anchor" href="#2-in-方法"></a> 2 in 方法</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字典是否含有key</span></span><br><span class="line">d = &#123;<span class="string">'name'</span>: &#123;&#125;, <span class="string">'age'</span>: &#123;&#125;, <span class="string">'sex'</span>: &#123;&#125;&#125;</span><br><span class="line">print(<span class="string">"name"</span> <span class="keyword">in</span> d.keys())  <span class="comment"># True</span></span><br><span class="line">print(<span class="string">"name"</span> <span class="keyword">not</span> <span class="keyword">in</span> d.keys())  <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表是否含有value</span></span><br><span class="line">l = [<span class="string">'name'</span>, <span class="string">'age'</span>, <span class="string">'sex'</span>]</span><br><span class="line">print(<span class="string">"name"</span> <span class="keyword">in</span> l)  <span class="comment"># True</span></span><br><span class="line">print(<span class="string">"name"</span> <span class="keyword">not</span> <span class="keyword">in</span> l)  <span class="comment"># False</span></span><br></pre></td></tr></table></figure><h1 id="x-参考"><a class="markdownIt-Anchor" href="#x-参考"></a> X 参考</h1><ul><li><a href="https://blog.csdn.net/linjpg/article/details/82190565" target="_blank" rel="noopener">判断python字典或者列表中是否包含某个元素或者key</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python-字符串-去除首尾的指定字符</title>
      <link href="/2022/02/09/Python-%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%8E%BB%E9%99%A4%E9%A6%96%E5%B0%BE%E7%9A%84%E6%8C%87%E5%AE%9A%E5%AD%97%E7%AC%A6/"/>
      <url>/2022/02/09/Python-%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%8E%BB%E9%99%A4%E9%A6%96%E5%B0%BE%E7%9A%84%E6%8C%87%E5%AE%9A%E5%AD%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-前言"><a class="markdownIt-Anchor" href="#1-前言"></a> 1 前言</h1><p>最近在用到防止字符串转义函数——<code>repr</code>，但是他生成的字符串首尾会自动加上单引号，详见<a href="https://dragonliu.tk/2022/02/09/python%E4%B8%AD%E9%98%B2%E6%AD%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E4%B9%89/" target="_blank" rel="noopener">博客</a>，可以使用<code>strip</code>函数进行去除。</p><h1 id="2-实践"><a class="markdownIt-Anchor" href="#2-实践"></a> 2 实践</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># strip不传参数默认去掉空格</span></span><br><span class="line">test_str = <span class="string">'  string  '</span></span><br><span class="line"><span class="comment"># 去掉首尾空格</span></span><br><span class="line">print(test_str.strip())  <span class="comment"># string</span></span><br><span class="line"><span class="comment"># 去掉首空格</span></span><br><span class="line">print(test_str.lstrip())  <span class="comment"># string  </span></span><br><span class="line"><span class="comment"># 去掉尾空格</span></span><br><span class="line">print(test_str.rstrip())  <span class="comment">#   string</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定字符</span></span><br><span class="line">str1 = <span class="string">"123\tabc"</span></span><br><span class="line">str2 = repr(str1)</span><br><span class="line">print(str1)  <span class="comment"># 123abc</span></span><br><span class="line">print(str2)  <span class="comment"># '123\tabc'</span></span><br><span class="line">print(str2.strip(<span class="string">"\'"</span>))  <span class="comment"># 123\tabc</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python-文件-表格读写</title>
      <link href="/2022/02/09/Python-%E6%96%87%E4%BB%B6-%E8%A1%A8%E6%A0%BC%E8%AF%BB%E5%86%99/"/>
      <url>/2022/02/09/Python-%E6%96%87%E4%BB%B6-%E8%A1%A8%E6%A0%BC%E8%AF%BB%E5%86%99/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-问题引入"><a class="markdownIt-Anchor" href="#1-问题引入"></a> 1 问题引入</h1><p>今天实现恶意样本标签提取，用到了表格处理，下面进行整理。</p><p>python操作excel主要用到<code>xlrd</code>和<code>xlwt</code>这两个库，即<code>xlrd</code>是读excel，<code>xlwt</code>是写excel的库。这两个库使用pip进行安装。</p><h1 id="2-python写excelxlwt"><a class="markdownIt-Anchor" href="#2-python写excelxlwt"></a> 2 Python写excel——xlwt</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xlwt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导出表格</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">export_excel</span><span class="params">(output_file)</span>:</span></span><br><span class="line">    fields = [<span class="string">'姓名'</span>, <span class="string">'年龄'</span>]  <span class="comment"># 设置自己需要的Excel表头</span></span><br><span class="line">    book = xlwt.Workbook(encoding=<span class="string">'utf-8'</span>)  <span class="comment"># 获取excel对象</span></span><br><span class="line">    sheet = book.add_sheet(<span class="string">'人员信息表'</span>)  <span class="comment"># 设置excel的sheet名称</span></span><br><span class="line">    <span class="keyword">for</span> col, field <span class="keyword">in</span> enumerate(fields):  <span class="comment"># 写入excel表头</span></span><br><span class="line">        sheet.write(<span class="number">0</span>, col, field)</span><br><span class="line">    info_list = [[<span class="string">'Dragon'</span>, <span class="number">18</span>], [<span class="string">'Pig'</span>, <span class="number">21</span>], [<span class="string">'Cat'</span>, <span class="number">22</span>]]</span><br><span class="line">    row = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> name, age <span class="keyword">in</span> info_list:  <span class="comment"># 根据数据写入excel，col-单元格行标，field-单元格列标</span></span><br><span class="line">        sheet.write(row, <span class="number">0</span>, name)</span><br><span class="line">        sheet.write(row, <span class="number">1</span>, age)</span><br><span class="line">        row += <span class="number">1</span></span><br><span class="line">    book.save(output_file)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    output_file = <span class="string">"output.xls"</span></span><br><span class="line">    export_excel(output_file)</span><br></pre></td></tr></table></figure><p>表格信息如下：</p><img src="https://s2.loli.net/2022/02/09/B8mGXdCqurtDVJ6.png" width="600" height="300" alt="图片名称" align="center" id="64"><h1 id="3-python读excelxlrd"><a class="markdownIt-Anchor" href="#3-python读excelxlrd"></a> 3 Python读excel——xlrd</h1><p>整体思路为，打开文件，选定表格，读取行列内容，读取表格内数据</p><p>详细代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xlrd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入表格</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_excel</span><span class="params">(input_file)</span>:</span></span><br><span class="line">    <span class="comment"># 打开文件</span></span><br><span class="line">    wb = xlrd.open_workbook(filename=input_file)</span><br><span class="line">    <span class="comment"># 获取所有表格名字</span></span><br><span class="line">    print(wb.sheet_names())  <span class="comment"># ['人员信息表']</span></span><br><span class="line">    <span class="comment"># 通过索引获取表格</span></span><br><span class="line">    sheet1 = wb.sheet_by_index(<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># 通过名字获取表格</span></span><br><span class="line">    sheet2 = wb.sheet_by_name(<span class="string">'人员信息表'</span>)</span><br><span class="line">    print(sheet1, sheet2)  <span class="comment"># Sheet  0:&lt;人员信息表&gt; Sheet  0:&lt;人员信息表&gt;</span></span><br><span class="line"></span><br><span class="line">    print(sheet1.name, sheet1.nrows, sheet1.ncols)  <span class="comment"># 人员信息表 4 2</span></span><br><span class="line">    <span class="comment"># 获取第1行内容（编号从0开始）</span></span><br><span class="line">    rows = sheet1.row_values(<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 获取第1列内容（编号从0开始）</span></span><br><span class="line">    cols = sheet1.col_values(<span class="number">1</span>)</span><br><span class="line">    print(rows)  <span class="comment"># ['Dragon', 18.0]</span></span><br><span class="line">    print(cols)  <span class="comment"># ['年龄', 18.0, 21.0, 22.0]</span></span><br><span class="line">    <span class="comment"># 获取表格里的内容，三种方式</span></span><br><span class="line">    print(sheet1.cell(<span class="number">1</span>, <span class="number">0</span>).value)  <span class="comment"># Dragon</span></span><br><span class="line">    print(sheet1.cell_value(<span class="number">1</span>, <span class="number">0</span>))  <span class="comment"># Dragon</span></span><br><span class="line">    print(sheet1.row(<span class="number">1</span>)[<span class="number">0</span>].value)  <span class="comment"># Dragon</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    input_file = <span class="string">"output.xls"</span></span><br><span class="line">    read_excel(input_file)</span><br></pre></td></tr></table></figure><h1 id="4-xls和xlsx的异同"><a class="markdownIt-Anchor" href="#4-xls和xlsx的异同"></a> 4 xls和xlsx的异同</h1><ul><li><p>文件核心结构不同：</p><ul><li>xls核心结构是复合文档类型的；</li><li>xlsx 的核心结构是 XML 类型的结构，并且基于XML进行压缩（占用空间更小），所以也可以看做zip文件，将一个“.xlsx”文件的后缀改为ZIP后，用解压软件解压，可以看到里面有一个xml文件和文件的主要内容。</li></ul></li><li><p>版本不同：</p><ul><li>xls是excel2003及以前版本所生成的文件格式</li><li>xlsx是excel2007及以后版本所生成的文件格式</li><li>（excel 2007之后版本可以打开上述两种格式，但是excel2013只能打开xls格式）</li></ul></li></ul><p>进一步的详细解释参见：<a href="https://jingyan.baidu.com/article/1974b289c9aaefb5b0f7746b.html" target="_blank" rel="noopener">excel后缀.xls和.xlsx有什么区别</a></p><h1 id="x-参考"><a class="markdownIt-Anchor" href="#x-参考"></a> X 参考</h1><ul><li><a href="https://www.php.cn/python-tutorials-451228.html" target="_blank" rel="noopener">python如何处理表格？</a></li><li><a href="https://blog.csdn.net/weixin_44288604/article/details/120731317" target="_blank" rel="noopener">python实现——处理Excel表格（超详细）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python-字符串-统计词频</title>
      <link href="/2022/02/09/Python-%E5%AD%97%E7%AC%A6%E4%B8%B2-%E7%BB%9F%E8%AE%A1%E8%AF%8D%E9%A2%91/"/>
      <url>/2022/02/09/Python-%E5%AD%97%E7%AC%A6%E4%B8%B2-%E7%BB%9F%E8%AE%A1%E8%AF%8D%E9%A2%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-问题引入"><a class="markdownIt-Anchor" href="#1-问题引入"></a> 1 问题引入</h1><p>最近在做恶意样本的标签信息提取、投票表决方式确定样本的最终最终标签信息，恰好用到了词频统计，或者说查找数组中出现次数最多的元素。</p><h1 id="2-词频统计"><a class="markdownIt-Anchor" href="#2-词频统计"></a> 2 词频统计</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">txt = <span class="string">'''in a job interview or in a situation'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分解并提取英文文章的单词</span></span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> <span class="string">',.\n '</span>:</span><br><span class="line">    txt = txt.replace(s, <span class="string">' '</span>)</span><br><span class="line">txt = txt.lower()  <span class="comment"># 将字母变成小写，排除原文大小写差异对词频统计的干扰</span></span><br><span class="line">word_list = txt.split()</span><br><span class="line">print(word_list)  <span class="comment"># ['in', 'a', 'job', 'interview', 'or', 'in', 'a', 'situation']</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对每个单词进行计数</span></span><br><span class="line">count = dict()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> word_list:</span><br><span class="line">    count[i] = count.get(i, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">print(count)  <span class="comment"># &#123;'in': 2, 'a': 2, 'job': 1, 'interview': 1, 'or': 1, 'situation': 1&#125;</span></span><br><span class="line"><span class="comment"># 对单词的统计值从高到低进行排序</span></span><br><span class="line">sorted_word = sorted(count.items(), key=<span class="keyword">lambda</span> item: item[<span class="number">1</span>], reverse=<span class="literal">True</span>)</span><br><span class="line">print(sorted_word)  <span class="comment"># [('in', 2), ('a', 2), ('job', 1), ('interview', 1), ('or', 1), ('situation', 1)]</span></span><br></pre></td></tr></table></figure><h1 id="2-查找数组list中出现次数最多的元素"><a class="markdownIt-Anchor" href="#2-查找数组list中出现次数最多的元素"></a> 2 查找数组(list)中出现次数最多的元素</h1><h2 id="21-npargmaxnpbincount"><a class="markdownIt-Anchor" href="#21-npargmaxnpbincount"></a> 2.1 np.argmax(np.bincount())</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">array = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">print(np.bincount(array))  <span class="comment"># [1 1 2 1 3 1 1]</span></span><br><span class="line">print(np.argmax(np.bincount(array)))  <span class="comment"># 4</span></span><br></pre></td></tr></table></figure><p><code>np.argmax</code>：就是返回数组中最大值对应的下标，<br><code>np.bincount</code>：首先找到数组最大值max，然后返回0～max的各个数字出现的次数，<font color="red">只能处理不含负数的集合</font></p><h2 id="22-countermost_common"><a class="markdownIt-Anchor" href="#22-countermost_common"></a> 2.2 Counter().most_common</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line">array = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="string">'aswd'</span>]</span><br><span class="line">print(Counter(array))  <span class="comment"># Counter(&#123;4: 3, 2: 2, 0: 1, 1: 1, 3: 1, 5: 1, 6: 1, 'aswd': 1&#125;)</span></span><br><span class="line">print(Counter(array).most_common(<span class="number">1</span>)[<span class="number">0</span>][<span class="number">0</span>])  <span class="comment"># 4</span></span><br></pre></td></tr></table></figure><p>Counter用来对数组中元素出现次数进行统计，然后通过most_common函数找到出现次数最多的元素。这种方法对于数组就没有过多限制，甚至是各种类型元素混合的数组也可以。<font color="red">数组只能是array，不能是ndarray。</font></p><h2 id="23-自己实现"><a class="markdownIt-Anchor" href="#23-自己实现"></a> 2.3 自己实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">appear_times = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> label <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>]:</span><br><span class="line">    <span class="keyword">if</span> label <span class="keyword">in</span> appear_times:</span><br><span class="line">        appear_times[label] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        appear_times[label] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">most_common = max(appear_times, key=<span class="keyword">lambda</span> x: appear_times[x])</span><br><span class="line">print(appear_times)  <span class="comment"># &#123;1: 2, 2: 1, 3: 1, 4: 1, 5: 3&#125;</span></span><br><span class="line">print(most_common)  <span class="comment"># 5</span></span><br></pre></td></tr></table></figure><p>用max求最大值默认情况返回value值（出现次数）最大的key值（元素），而不是value值。</p><h1 id="x-参考"><a class="markdownIt-Anchor" href="#x-参考"></a> X 参考</h1><ul><li><a href="https://blog.csdn.net/qq_43527713/article/details/114482509?spm=1001.2101.3001.6650.3&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3.pc_relevant_default&amp;utm_relevant_index=6" target="_blank" rel="noopener">python之统计文本中出现最多的单词</a></li><li><a href="https://blog.csdn.net/aofavx/article/details/103097217" target="_blank" rel="noopener">python统计数组中出现次数最多的元素</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python-文件-解析xml文件</title>
      <link href="/2022/02/09/Python-%E6%96%87%E4%BB%B6-%E8%A7%A3%E6%9E%90xml%E6%96%87%E4%BB%B6/"/>
      <url>/2022/02/09/Python-%E6%96%87%E4%BB%B6-%E8%A7%A3%E6%9E%90xml%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-问题引入"><a class="markdownIt-Anchor" href="#1-问题引入"></a> 1 问题引入</h1><p>最近在做恶意样本行为可视化，样本的行为是xml文件形式给出，需要使用python对其解析。本次实验使用了dom进行的解析。</p><blockquote><p>XML 指可扩展标记语言（e<strong>X</strong>tensible <strong>M</strong>arkup <strong>L</strong>anguage），标准通用标记语言的子集，是一种用于标记电子文件使其具有结构性的标记语言。</p><p>XML 被设计用来传输和存储数据。</p><p>XML 是一套定义语义标记的规则，这些标记将文档分成许多部件并对这些部件加以标识。</p><p>它也是元标记语言，即定义了用于定义其他与特定领域有关的、语义的、结构化的标记语言的句法语言。</p><p>常见的 XML 编程接口有 DOM 和 SAX，这两种接口处理 XML 文件的方式不同，当然使用场合也不同。</p><p>Python 有三种方法解析 XML，SAX，DOM，以及 ElementTree</p></blockquote><p>主要参考：<a href="https://www.runoob.com/python3/python3-xml-processing.html" target="_blank" rel="noopener">菜鸟教程——Python3 XML 解析</a></p><h1 id="2-sax"><a class="markdownIt-Anchor" href="#2-sax"></a> 2 SAX</h1><p>待补充</p><h1 id="3-dom"><a class="markdownIt-Anchor" href="#3-dom"></a> 3 DOM</h1><p>文件对象模型（Document Object Model，简称DOM），是W3C组织推荐的处理可扩展置标语言的标准编程接口。</p><p>一个 DOM 的解析器在解析一个 XML 文档时，一次性读取整个文档，把文档中所有元素保存在内存中的一个树结构里，之后你可以利用DOM 提供的不同的函数来读取或修改文档的内容和结构，也可以把修改过的内容写入xml文件。</p><p>xml文件 <code>movies.xml</code> 如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">collection</span> <span class="attr">shelf</span>=<span class="string">"New Arrivals"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">movie</span> <span class="attr">title</span>=<span class="string">"Enemy Behind"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">type</span>&gt;</span>War, Thriller<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">format</span>&gt;</span>DVD<span class="tag">&lt;/<span class="name">format</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">year</span>&gt;</span>2003<span class="tag">&lt;/<span class="name">year</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">rating</span>&gt;</span>PG<span class="tag">&lt;/<span class="name">rating</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">stars</span>&gt;</span>10<span class="tag">&lt;/<span class="name">stars</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">description</span>&gt;</span>Talk about a US-Japan war<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">movie</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">movie</span> <span class="attr">title</span>=<span class="string">"Transformers"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">type</span>&gt;</span>Anime, Science Fiction<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">format</span>&gt;</span>DVD<span class="tag">&lt;/<span class="name">format</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">year</span>&gt;</span>1989<span class="tag">&lt;/<span class="name">year</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">rating</span>&gt;</span>R<span class="tag">&lt;/<span class="name">rating</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">stars</span>&gt;</span>8<span class="tag">&lt;/<span class="name">stars</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">description</span>&gt;</span>A schientific fiction<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">movie</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Python 中用 <code>xml.dom.minidom</code> 来解析 xml 文件，实例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> xml.dom.minidom</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用minidom解析器打开 XML 文档</span></span><br><span class="line">DOMTree = xml.dom.minidom.parse(<span class="string">"movies.xml"</span>)</span><br><span class="line">collection = DOMTree.documentElement</span><br><span class="line"><span class="keyword">if</span> collection.hasAttribute(<span class="string">"shelf"</span>):</span><br><span class="line">   <span class="keyword">print</span> (<span class="string">"Root element : %s"</span> % collection.getAttribute(<span class="string">"shelf"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在集合中获取所有电影</span></span><br><span class="line">movies = collection.getElementsByTagName(<span class="string">"movie"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印每部电影的详细信息</span></span><br><span class="line"><span class="keyword">for</span> movie <span class="keyword">in</span> movies:</span><br><span class="line">   <span class="keyword">print</span> (<span class="string">"*****Movie*****"</span>)</span><br><span class="line">   <span class="keyword">if</span> movie.hasAttribute(<span class="string">"title"</span>):</span><br><span class="line">      <span class="keyword">print</span> (<span class="string">"Title: %s"</span> % movie.getAttribute(<span class="string">"title"</span>))</span><br><span class="line"></span><br><span class="line">   type = movie.getElementsByTagName(<span class="string">'type'</span>)[<span class="number">0</span>]</span><br><span class="line">   <span class="keyword">print</span> (<span class="string">"Type: %s"</span> % type.childNodes[<span class="number">0</span>].data)</span><br><span class="line">   format = movie.getElementsByTagName(<span class="string">'format'</span>)[<span class="number">0</span>]</span><br><span class="line">   <span class="keyword">print</span> (<span class="string">"Format: %s"</span> % format.childNodes[<span class="number">0</span>].data)</span><br><span class="line">   rating = movie.getElementsByTagName(<span class="string">'rating'</span>)[<span class="number">0</span>]</span><br><span class="line">   <span class="keyword">print</span> (<span class="string">"Rating: %s"</span> % rating.childNodes[<span class="number">0</span>].data)</span><br><span class="line">   description = movie.getElementsByTagName(<span class="string">'description'</span>)[<span class="number">0</span>]</span><br><span class="line">   <span class="keyword">print</span> (<span class="string">"Description: %s"</span> % description.childNodes[<span class="number">0</span>].data)</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Root element : New Arrivals</span><br><span class="line">*****Movie*****</span><br><span class="line">Title: Enemy Behind</span><br><span class="line">Type: War, Thriller</span><br><span class="line">Format: DVD</span><br><span class="line">Rating: PG</span><br><span class="line">Description: Talk about a US-Japan war</span><br><span class="line">*****Movie*****</span><br><span class="line">Title: Transformers</span><br><span class="line">Type: Anime, Science Fiction</span><br><span class="line">Format: DVD</span><br><span class="line">Rating: R</span><br><span class="line">Description: A schientific fiction</span><br><span class="line">*****Movie*****</span><br></pre></td></tr></table></figure><p>完整的 DOM API 文档请查阅<a href="http://docs.python.org/library/xml.dom.html" target="_blank" rel="noopener">Python DOM APIs</a>。</p><h1 id="4-elementtree"><a class="markdownIt-Anchor" href="#4-elementtree"></a> 4 ElementTree</h1><p>待补充</p><h1 id="x-参考"><a class="markdownIt-Anchor" href="#x-参考"></a> X 参考</h1><ul><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python-time模块-测量程序运行时间</title>
      <link href="/2022/02/09/Python-time%E6%A8%A1%E5%9D%97-%E6%B5%8B%E9%87%8F%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4/"/>
      <url>/2022/02/09/Python-time%E6%A8%A1%E5%9D%97-%E6%B5%8B%E9%87%8F%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-问题引入"><a class="markdownIt-Anchor" href="#1-问题引入"></a> 1 问题引入</h1><p>最近做到恶意样本可视化，跑脚本需要测量程序运行时间，下面是几种测量方法：</p><h1 id="2-datetimedatetimenow"><a class="markdownIt-Anchor" href="#2-datetimedatetimenow"></a> 2 datetime.datetime.now()</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">starttime = datetime.datetime.now()</span><br><span class="line"><span class="comment">#long running</span></span><br><span class="line"><span class="comment">#do something other</span></span><br><span class="line">endtime = datetime.datetime.now()</span><br><span class="line">print((endtime - starttime).seconds)  <span class="comment"># 秒</span></span><br></pre></td></tr></table></figure><p><code>datetime.datetime.now()</code>获取的是当前日期，在程序执行结束之后，这个方式获得的时间值为<strong>程序执行的时间</strong>。</p><h1 id="3-timetime"><a class="markdownIt-Anchor" href="#3-timetime"></a> 3 time.time()</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line"><span class="comment">#long running</span></span><br><span class="line"><span class="comment">#do something other</span></span><br><span class="line">end = time.time()</span><br><span class="line">print(end - start)  <span class="comment"># 秒</span></span><br></pre></td></tr></table></figure><p><code>time.time()</code>获取自纪元以来的当前时间（以秒为单位）。如果系统时钟提供它们，则可能存在秒的分数。所以这个地方返回的是一个浮点型类型。这里获取的也是<strong>程序的执行时间</strong>。</p><h1 id="4-timeclock-或-timeperf_counter"><a class="markdownIt-Anchor" href="#4-timeclock-或-timeperf_counter"></a> 4 time.clock() 或 time.perf_counter()</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># start = time.clock()</span></span><br><span class="line">start = time.perf_counter()</span><br><span class="line"><span class="comment">#long running</span></span><br><span class="line"><span class="comment">#do something other</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">1e8</span>:</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"><span class="comment"># end = time.clock()</span></span><br><span class="line">end = time.perf_counter()</span><br><span class="line">print(end - start)  <span class="comment">#秒</span></span><br></pre></td></tr></table></figure><p><code>time.clock()</code>返回程序开始或第一次被调用<code>clock()</code>以来的CPU时间。 这具有与系统记录一样多的精度。返回的也是一个浮点类型。这里获得的是<strong>CPU的执行时间</strong>。</p><p>python3.8+ 不支持 clock 了，替换成 <code>time.perf_counter()</code> 就可以了</p><p><font color="red"><strong>注意</strong></font>：程序执行时间=cpu时间 + io时间 + 休眠或者等待时间</p><h1 id="x-参考"><a class="markdownIt-Anchor" href="#x-参考"></a> X 参考</h1><ul><li><a href="https://blog.csdn.net/wangshuang1631/article/details/54286551" target="_blank" rel="noopener">几种Python执行时间的计算方法</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python-os模块-遍历文件夹下的所有文件</title>
      <link href="/2022/02/09/Python-os%E6%A8%A1%E5%9D%97-%E9%81%8D%E5%8E%86%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E7%9A%84%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6/"/>
      <url>/2022/02/09/Python-os%E6%A8%A1%E5%9D%97-%E9%81%8D%E5%8E%86%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E7%9A%84%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-问题引入"><a class="markdownIt-Anchor" href="#1-问题引入"></a> 1 问题引入</h1><p>最近在实现恶意脚本的可视化，需要实现提取文件夹下的所有文件名，实现脚本自动化。</p><h1 id="2-文件夹下只有文件"><a class="markdownIt-Anchor" href="#2-文件夹下只有文件"></a> 2 文件夹下只有文件</h1><p>当目标文件夹中只有文件时，使用os模块的<code>listdir()</code>方法即可：该方法可以返回目标路径下的文件和文件夹的名字列表，参数就是目标路径。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">file_names = os.listdir(<span class="string">r'test'</span>)</span><br><span class="line">print(file_names)  <span class="comment"># ['1.txt', '2.txt', '3.txt']</span></span><br></pre></td></tr></table></figure><h1 id="3-文件夹下有文件和文件夹"><a class="markdownIt-Anchor" href="#3-文件夹下有文件和文件夹"></a> 3 文件夹下有文件和文件夹</h1><p>当目标文件中既有文件又有文件夹时，我们使用<code>listdir()</code>方法就只能获得第一层子文件或文件夹了，而子文件夹中的内容便获取不到了。</p><p>这时候我们需要用到<code>os.walk()</code>方法：传入目标路径即可。该方法可以递归的找出目标路径下的所有文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">file_names = os.listdir(<span class="string">r'test'</span>)</span><br><span class="line">print(file_names)  <span class="comment"># ['1.txt', '2.txt', '3.txt', 'sub-dir']</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> filepath, dirnames, filenames <span class="keyword">in</span> os.walk(<span class="string">r'test'</span>):</span><br><span class="line">    <span class="keyword">for</span> filename <span class="keyword">in</span> filenames:</span><br><span class="line">        print(filename)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">1.txt</span></span><br><span class="line"><span class="string">2.txt</span></span><br><span class="line"><span class="string">3.txt</span></span><br><span class="line"><span class="string">4.txt</span></span><br><span class="line"><span class="string">5.txt</span></span><br><span class="line"><span class="string">6.txt</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><hr><p><code>os.walk()</code>方法可以生成三元组，也就是我们代码中的<code>filepath</code>，<code>dirnames</code>，<code>filenames</code>。我们将他们分别打印出来可以看到：其中<code>filepath</code>就是目标路径下所有文件的路径，<code>dirnames</code>是我们目标路径的所有目录名称，<code>filenames</code>则是各个路径下的文件名称列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> filepath, dirnames, filenames <span class="keyword">in</span> os.walk(<span class="string">r'test'</span>):</span><br><span class="line">    print(filepath)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">test</span></span><br><span class="line"><span class="string">test\sub-dir</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">for</span> filepath, dirnames, filenames <span class="keyword">in</span> os.walk(<span class="string">r'test'</span>):</span><br><span class="line">    print(dirnames)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">['sub-dir']</span></span><br><span class="line"><span class="string">[]</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">for</span> filepath, dirnames, filenames <span class="keyword">in</span> os.walk(<span class="string">r'test'</span>):</span><br><span class="line">    print(filenames)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">['1.txt', '2.txt', '3.txt']</span></span><br><span class="line"><span class="string">['4.txt', '5.txt', '6.txt']</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h1 id="4-拓展获得目标路径下的所有文件的绝对路径"><a class="markdownIt-Anchor" href="#4-拓展获得目标路径下的所有文件的绝对路径"></a> 4 拓展—获得目标路径下的所有文件的绝对路径</h1><p>遍历目标路径下的各个文件，用<code>os.path.join()</code>方法将文件路径和文件名拼接在一起，就是各个文件的绝对路径了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> filepath, dirnames, filenames <span class="keyword">in</span> os.walk(<span class="string">r'test'</span>):</span><br><span class="line">    <span class="keyword">for</span> filename <span class="keyword">in</span> filenames:</span><br><span class="line">        print(os.path.join(filepath, filename))</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">test\1.txt</span></span><br><span class="line"><span class="string">test\2.txt</span></span><br><span class="line"><span class="string">test\3.txt</span></span><br><span class="line"><span class="string">test\sub-dir\4.txt</span></span><br><span class="line"><span class="string">test\sub-dir\5.txt</span></span><br><span class="line"><span class="string">test\sub-dir\6.txt</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h1 id="x-参考"><a class="markdownIt-Anchor" href="#x-参考"></a> X 参考</h1><ul><li><a href="https://blog.csdn.net/qq_39721240/article/details/90704223" target="_blank" rel="noopener">python遍历文件夹下的所有文件</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python-字符串-防止转义</title>
      <link href="/2022/02/09/Python-%E5%AD%97%E7%AC%A6%E4%B8%B2-%E9%98%B2%E6%AD%A2%E8%BD%AC%E4%B9%89/"/>
      <url>/2022/02/09/Python-%E5%AD%97%E7%AC%A6%E4%B8%B2-%E9%98%B2%E6%AD%A2%E8%BD%AC%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-问题引入"><a class="markdownIt-Anchor" href="#1-问题引入"></a> 1 问题引入</h1><p>最近在做xml解析、可视化时遇到一个问题：将字符串（文件路径）中的转义字符不进行转义<code>123\tabc</code>，正常print会将<code>\t</code>看作转义字符tab，需求是使字符串按原样输出。下面是不同场景下的解决方法：</p><h1 id="2-字符串常量"><a class="markdownIt-Anchor" href="#2-字符串常量"></a> 2 字符串常量</h1><p>如果是字符串常量，则在字符串前加<code>r</code> 即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"123\tabc"</span>)</span><br><span class="line"><span class="comment"># 123abc</span></span><br><span class="line">print(<span class="string">r"123\tabc"</span>)  <span class="comment"># test_str = r"123\tabc"</span></span><br><span class="line"><span class="comment"># 123\tabc</span></span><br></pre></td></tr></table></figure><h1 id="3-字符串变量"><a class="markdownIt-Anchor" href="#3-字符串变量"></a> 3 字符串变量</h1><p>如果字符串是变量，使用 <code>repr()</code> 方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="string">"123\tabc"</span></span><br><span class="line">str2 = repr(str1)</span><br><span class="line"></span><br><span class="line">print(str1)  <span class="comment"># 123abc</span></span><br><span class="line">print(str2)  <span class="comment"># '123\tabc'</span></span><br><span class="line">print(str2.strip(<span class="string">"\'"</span>))  <span class="comment"># 123\tabc</span></span><br></pre></td></tr></table></figure><p><font color="red"><strong>注意</strong></font>：字符串使用 <code>repr</code> 函数后输出是会在字符串前后自动加上单引号（见print第二行），print第三行是去掉了字符串首尾的单引号。关于<code>strip</code>函数，详见<a href="https://dragonliu.tk/2022/02/09/python%E5%8E%BB%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%A6%96%E5%B0%BE%E7%9A%84%E7%A9%BA%E6%A0%BC/" target="_blank" rel="noopener">博客</a>。</p><h1 id="4-文件读取"><a class="markdownIt-Anchor" href="#4-文件读取"></a> 4 文件读取</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file1 = open(<span class="string">"test.txt"</span>, <span class="string">"r"</span>)  <span class="comment"># 123\tabc</span></span><br><span class="line"></span><br><span class="line">print(file1.read())  <span class="comment"># 123\tabc</span></span><br></pre></td></tr></table></figure><p>文本文件读取测试发现字符串未发生转义。</p><p>拓展阅读：<a href="https://blog.csdn.net/ahalearner/article/details/119777972" target="_blank" rel="noopener">关于python中open函数读取和写入windows记事本的换行问题研究</a></p><h1 id="x-参考"><a class="markdownIt-Anchor" href="#x-参考"></a> X 参考</h1><ul><li><a href="https://www.cnblogs.com/hellofengying/p/10183057.html" target="_blank" rel="noopener">python中防止字符串转义</a></li><li><a href="https://blog.csdn.net/weixin_41813169/article/details/105702294" target="_blank" rel="noopener">python如何实现对变量的禁止转义操作</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python-graphviz模块-使用教程</title>
      <link href="/2022/02/03/Python-graphviz%E6%A8%A1%E5%9D%97-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
      <url>/2022/02/03/Python-graphviz%E6%A8%A1%E5%9D%97-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-情景引入"><a class="markdownIt-Anchor" href="#1-情景引入"></a> 1 情景引入</h1><p>前几个月师姐给了个任务——恶意样本行为可视化，输入为xml文件，一个文件代表一个恶意样本。请教学姐学长同学等，加上观看效果图，得出实现思路：python解析xml文件，使用python模块graphviz进行可视化；之后使用图数据库neo4j进行对比。</p><p>之后发现neo4j创建多个图数据库比较麻烦，但是按照行为分类等都比较直观，所以做辅助作用应该不错。</p><img src="https://s2.loli.net/2022/02/10/jnNf9Xrms8CYgxz.png" width="600" height="400" alt="图片名称" align="center" id="65"><p>下面对graphviz进行整理。</p><h1 id="2-graphviz"><a class="markdownIt-Anchor" href="#2-graphviz"></a> 2 Graphviz</h1><p>Graphviz 是一个自动排版的作图软件，可以生成 png pdf 等格式。</p><ul><li><a href="https://graphviz.org/documentation/" target="_blank" rel="noopener">Graphviz官网</a></li><li><a href="https://www.cnblogs.com/shuqin/p/11897207.html" target="_blank" rel="noopener">Graphviz 画图的一些总结</a></li></ul><h1 id="3-python-graphviz"><a class="markdownIt-Anchor" href="#3-python-graphviz"></a> 3 python graphviz</h1><p>python graphviz则是graphviz的python实现。我们可以通过python graphviz实现轻松完成各种流程图的绘制。</p><ul><li><a href="https://graphviz.readthedocs.io/en/stable/manual.html" target="_blank" rel="noopener">python graphviz官方文档</a></li><li><a href="https://blog.csdn.net/LuohenYJ/article/details/106172201" target="_blank" rel="noopener">[python] python模块graphviz使用入门</a></li></ul><h2 id="31-安装"><a class="markdownIt-Anchor" href="#31-安装"></a> 3.1 安装</h2><ol><li><p>安装python graphviz木块（本机使用的是python3.9）:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install graphviz</span><br></pre></td></tr></table></figure></li><li><p>除了python安装外，本机还需要安装Graphviz<a href="https://www.graphviz.org/download/" target="_blank" rel="noopener">(下载页面)</a>，并确保包含dot可执行文件的目录在系统路径上。安装过程中需要添加PATH：</p><img src="https://s2.loli.net/2022/02/10/mJkzIuyaMLCQbAS.png" width="400" height="300" alt="图片名称" align="center" id="35"><p>否则出现下面的报错：(重启Pycharm生效)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">graphviz.backend.execute.ExecutableNotFound: failed to execute WindowsPath(<span class="string">'dot'</span>), make sure the Graphviz executables are on your systems<span class="string">' PATH</span></span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/lizzy05/article/details/88529030" target="_blank" rel="noopener">graphviz.backend.ExecutableNotFound: failed to execute [‘dot’, ‘-Tpng’, ‘-O’, ‘t est.gv’]问题解决方法</a></p><p>解决报错：添加环境变量</p><img src="https://s2.loli.net/2022/02/10/Nbm9RlSDYFyxtZX.png" width="800" height="400" alt="图片名称" align="center" id="66"></li></ol><h2 id="32-使用"><a class="markdownIt-Anchor" href="#32-使用"></a> 3.2 使用</h2><p>该graphviz模块提供了两个类：Graph和 Digraph。它们分别以DOT语言为无向图和有向图创建图描述。它们具有相同的 API。示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> graphviz <span class="keyword">import</span> Digraph</span><br><span class="line"></span><br><span class="line">dot = Digraph(comment=<span class="string">'恶意样本行为可视化'</span>, format=<span class="string">'jpg'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化端点</span></span><br><span class="line">dot.node(name=<span class="string">'n1'</span>, label=<span class="string">'端点A'</span>, color=<span class="string">"#008000"</span>, fontcolor=<span class="string">"#000000"</span>, style=<span class="string">"filled"</span>, shape=<span class="string">"rectangle"</span>, fontname=<span class="string">"Microsoft YaHei"</span>)</span><br><span class="line">dot.node(name=<span class="string">'n2'</span>, label=<span class="string">'端点B'</span>, color=<span class="string">"#FFD700"</span>, fontcolor=<span class="string">"#000000"</span>, style=<span class="string">"filled"</span>, shape=<span class="string">"circle"</span>, fontname=<span class="string">"Microsoft YaHei"</span>)</span><br><span class="line">dot.node(name=<span class="string">'n3'</span>, label=<span class="string">'端点C'</span>, color=<span class="string">"#0000FF"</span>, fontcolor=<span class="string">"#FFFFFF"</span>, style=<span class="string">"filled"</span>, shape=<span class="string">"oval"</span>, fontname=<span class="string">"Microsoft YaHei"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 布局 L-左 R-右 T-上 B-下</span></span><br><span class="line">dot.attr(rankdir=<span class="string">'LR'</span>)  <span class="comment"># 自左向右</span></span><br><span class="line"><span class="comment"># dot.attr(rankdir='RL')</span></span><br><span class="line"><span class="comment"># dot.attr(rankdir='TB')  # 默认</span></span><br><span class="line"><span class="comment"># dot.attr(rankdir='BT')</span></span><br><span class="line"><span class="comment"># 初始化边</span></span><br><span class="line">dot.edge(<span class="string">'n1'</span>, <span class="string">'n2'</span>, label=<span class="string">"边1"</span>, color=<span class="string">"#000000"</span>, fontcolor=<span class="string">"#000000"</span>, style=<span class="string">""</span>, fontname=<span class="string">"Microsoft YaHei"</span>)</span><br><span class="line">dot.edge(<span class="string">'n1'</span>, <span class="string">'n3'</span>, label=<span class="string">"边2"</span>, color=<span class="string">"#FF0000"</span>, fontcolor=<span class="string">"#FF0000"</span>, style=<span class="string">"dashed"</span>, fontname=<span class="string">"Microsoft YaHei"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存文件，view=False时将不自动打开文件</span></span><br><span class="line"><span class="comment"># dot.render("test_graphviz.gv", format='jpg', view=True)</span></span><br><span class="line"><span class="comment"># 不保存文件，仅仅自动打开</span></span><br><span class="line">u = dot.unflatten(stagger=<span class="number">1</span>)</span><br><span class="line">u.view()</span><br></pre></td></tr></table></figure><p>显示如下：</p><img src="https://s2.loli.net/2022/02/10/hID7tuFsmfijoQv.png" width="400" height="300" alt="图片名称" align="center" id="67"><h2 id="33-中文乱码"><a class="markdownIt-Anchor" href="#33-中文乱码"></a> 3.3 中文乱码</h2><p>如果出现中文乱码，多半是因为没有设置fontname为支持中文显示的字体，只需要在node或者edge中添加<code>fontname=&quot;Microsoft YaHei&quot;</code>，即可正常显示。</p><ul><li><a href="https://blog.csdn.net/MAILLIBIN/article/details/100581857" target="_blank" rel="noopener">参考</a></li></ul><h2 id="34-端点-边-字体颜色"><a class="markdownIt-Anchor" href="#34-端点-边-字体颜色"></a> 3.4 端点、边、字体颜色</h2><p>在node或者edge中添加<code>color=&quot;#000000&quot;, fontcolor=&quot;#000000&quot;</code>即可，具体颜色可以参考：</p><ul><li><a href="https://graphviz.gitlab.io/doc/info/colors.html" target="_blank" rel="noopener">官网颜色</a></li><li><a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E9%A1%B5%E9%A2%9C%E8%89%B2" target="_blank" rel="noopener">维基百科——X11名称编码</a></li></ul><h2 id="35-端点的形状"><a class="markdownIt-Anchor" href="#35-端点的形状"></a> 3.5 端点的形状</h2><p>在node中添加<code>shape=&quot;xxx&quot;</code>即可，具体需要什么形状可以在<a href="https://graphviz.gitlab.io/doc/info/shapes.html" target="_blank" rel="noopener">官网</a>中查找。</p><h2 id="36-rank"><a class="markdownIt-Anchor" href="#36-rank"></a> 3.6 Rank</h2><p><a href="https://blog.csdn.net/youwen21/article/details/98397954" target="_blank" rel="noopener">GraphViz DOT有向图 (四)node节点布局控制之rank,group,subgraph</a></p><h2 id="37-排版"><a class="markdownIt-Anchor" href="#37-排版"></a> 3.7 排版</h2><p>如上面的示例，使用<code>dot.attr(rankdir='xx')</code>来确定排版，作用范围为使用该行代码之后，下一个<code>dot.attr(rankdir='xx')</code>代码之前。</p><h2 id="38-name参数中不能有英文冒号"><a class="markdownIt-Anchor" href="#38-name参数中不能有英文冒号"></a> 3.8 name参数中不能有英文冒号</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dot.node(name=<span class="string">'n1'</span>, label=<span class="string">'n1'</span>)</span><br><span class="line">dot.node(name=<span class="string">'n2:3'</span>, label=<span class="string">'n2:3'</span>)</span><br><span class="line">dot.edge(<span class="string">'n1'</span>, <span class="string">'n2:3'</span>)</span><br></pre></td></tr></table></figure><p><code>dot.node(name=&quot;xxx&quot;)</code> 如果name参数含有英文逗号，则会报错，导致画图错误：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Warning: node n2, port 3 unrecognized</span><br></pre></td></tr></table></figure><p>常见的思路是使用python将name参数改成中文冒号，label参数是原来的英文冒号，达到正确显示的目的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string = <span class="string">"http://gsstudio.info/panel"</span></span><br><span class="line">label = repr(string)</span><br><span class="line">name = repr(string.replace(<span class="string">":"</span>, <span class="string">"："</span>))</span><br></pre></td></tr></table></figure><p><code>repr</code>函数是防止字符串转义的，详细见<a href="dragonliu.tk/2022/02/09/python%E4%B8%AD%E9%98%B2%E6%AD%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E4%B9%89/">博客——python中防止字符串转义</a>。</p><h2 id="39-报错graphvizbackendexecutecalledprocesserror"><a class="markdownIt-Anchor" href="#39-报错graphvizbackendexecutecalledprocesserror"></a> 3.9 报错：graphviz.backend.execute.CalledProcessError</h2><p><strong>报错信息：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">subprocess.CalledProcessError: Command <span class="string">'[WindowsPath('</span>dot<span class="string">'), '</span>-Kdot<span class="string">', '</span>-Tjpg<span class="string">', '</span>-O<span class="string">', '</span>57630-0.xml.gv<span class="string">']'</span> returned non-zero <span class="built_in">exit</span> status 3221225477.</span><br><span class="line">...</span><br><span class="line">graphviz.backend.execute.CalledProcessError: Command <span class="string">'[WindowsPath('</span>dot<span class="string">'), '</span>-Kdot<span class="string">', '</span>-Tjpg<span class="string">', '</span>-O<span class="string">', '</span>57630-0.xml.gv<span class="string">']'</span> returned non-zero <span class="built_in">exit</span> status 3221225477. [stderr: b<span class="string">'dot: graph is too large for cairo-renderer bitmaps. Scaling by 0.876568 to fit\r\n'</span>]</span><br></pre></td></tr></table></figure><p><strong>现象：</strong></p><p><code>.gv</code>文件可以正常生成，图片文件<code>.jpg</code>无法生成。</p><p>定位报错语句：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dot = Digraph(comment=<span class="string">'恶意样本行为可视化'</span>, format=<span class="string">'jpg'</span>)</span><br><span class="line">...</span><br><span class="line">dot.render(output_dir + <span class="string">"\\"</span> + file_name + <span class="string">".gv"</span>, format=<span class="string">'jpg'</span>)</span><br></pre></td></tr></table></figure><p><strong>原因：</strong></p><p>生成的graph太大，dot无法导出，换成<code>pdf</code>或<code>svg</code>就可以了，<code>png</code>和<code>jpg</code>都不行。</p><p>最后选择pdf格式，因为导出的文件小。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dot = Digraph(comment=<span class="string">'恶意样本行为可视化'</span>, format=<span class="string">'pdf'</span>)</span><br><span class="line">...</span><br><span class="line">dot.render(output_dir + <span class="string">"\\"</span> + file_name + <span class="string">".gv"</span>, format=<span class="string">'pdf'</span>)</span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2022/02/12/59CK8EwoYSsyNiJ.png" width="900" height="200" alt="图片名称" align="center" id="76"><h1 id="x-参考"><a class="markdownIt-Anchor" href="#x-参考"></a> X 参考</h1><ul><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> 环境与工具 </category>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python-jupyter-使用教程</title>
      <link href="/2022/01/17/Python-jupyter-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
      <url>/2022/01/17/Python-jupyter-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-安装"><a class="markdownIt-Anchor" href="#1-安装"></a> 1 安装</h1><p>打开cmd，使用pip进行安装：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install jupyterlab</span><br></pre></td></tr></table></figure><h1 id="2-使用"><a class="markdownIt-Anchor" href="#2-使用"></a> 2 使用</h1><p>cmd输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter-lab</span><br></pre></td></tr></table></figure><p>在浏览器输入：<a href="http://localhost:8888/" target="_blank" rel="noopener">http://localhost:8888/</a></p>]]></content>
      
      
      <categories>
          
          <category> 环境与工具 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 待补充 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-matplotlib-使用简易教程</title>
      <link href="/2022/01/17/Python-matplotlib-%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"/>
      <url>/2022/01/17/Python-matplotlib-%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-基础知识"><a class="markdownIt-Anchor" href="#1-基础知识"></a> 1 基础知识</h1><p><a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.lines.Line2D.html" target="_blank" rel="noopener">官方文档</a></p><ul><li>画板figure，画纸Sublpot画质，可多图绘画</li><li>画纸上最上方是标题title，用来给图形起名字</li><li>坐标轴Axis，横轴叫x坐标轴label，纵轴叫y坐标轴ylabel</li><li>图例Legend 代表图形里的内容</li><li>网格Grid，图形中的虚线，True显示网格</li><li>点 Markers：表示点的形状。</li></ul><h1 id="2-绘图步骤"><a class="markdownIt-Anchor" href="#2-绘图步骤"></a> 2 绘图步骤</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#导入matplotlib的pyplot模块</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment">#1 基础绘图</span></span><br><span class="line"><span class="comment">#第1步：定义x和y坐标轴上的点   x坐标轴上点的数值</span></span><br><span class="line">x=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="comment">#y坐标轴上点的数值</span></span><br><span class="line">y=[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>]</span><br><span class="line"><span class="comment">#第2步：使用plot绘制线条第1个参数是x的坐标值，第2个参数是y的坐标值</span></span><br><span class="line">plt.plot(x,y)</span><br><span class="line"><span class="comment">#第3步：显示图形</span></span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#2 定义绘图属性</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">color：线条颜色，值r表示红色（red）</span></span><br><span class="line"><span class="string">marker：点的形状，值o表示点为圆圈标记（circle marker）</span></span><br><span class="line"><span class="string">linestyle：线条的形状，值dashed表示用虚线连接各点</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">plt.plot(x, y, color=<span class="string">'r'</span>,marker=<span class="string">'o'</span>,linestyle=<span class="string">'dashed'</span>)</span><br><span class="line"><span class="comment">#plt.plot(x, y, 'ro')</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">axis：坐标轴范围</span></span><br><span class="line"><span class="string">语法为axis[xmin, xmax, ymin, ymax]，</span></span><br><span class="line"><span class="string">也就是axis[x轴最小值, x轴最大值, y轴最小值, y轴最大值]</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">plt.axis([<span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">20</span>])</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#3 给图片提阿甲注释和标题等</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#第1步：定义x和y坐标轴上的点  x坐标轴上点的数值</span></span><br><span class="line">x=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="comment">#y坐标轴上点的数值</span></span><br><span class="line">y=[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#第2步：使用plot绘制线条 第1个参数是x的坐标值，第2个参数是y的坐标值</span></span><br><span class="line"><span class="comment"># 折线图</span></span><br><span class="line">plt.plot(x,y)</span><br><span class="line"><span class="comment"># 柱形图</span></span><br><span class="line"><span class="comment"># plt.barh(x,y)</span></span><br><span class="line"><span class="comment">#添加文本 #x轴文本</span></span><br><span class="line">plt.xlabel(<span class="string">'x坐标轴'</span>)</span><br><span class="line"><span class="comment">#y轴文本</span></span><br><span class="line">plt.ylabel(<span class="string">'y坐标轴'</span>)</span><br><span class="line"><span class="comment">#标题</span></span><br><span class="line">plt.title(<span class="string">'标题'</span>)</span><br><span class="line"><span class="comment">#添加注释 参数名xy：箭头注释中箭头所在位置，参数名xytext：注释文本所在位置，</span></span><br><span class="line"><span class="comment">#arrowprops在xy和xytext之间绘制箭头, shrink表示注释点与注释文本之间的图标距离</span></span><br><span class="line"></span><br><span class="line">plt.annotate(<span class="string">'我是注释'</span>, xy=(<span class="number">2</span>,<span class="number">5</span>), xytext=(<span class="number">2</span>, <span class="number">10</span>),</span><br><span class="line">            arrowprops=dict(facecolor=<span class="string">'black'</span>, shrink=<span class="number">0.01</span>),</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line"><span class="comment">#第3步：显示图形</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h1 id="3-多图绘制"><a class="markdownIt-Anchor" href="#3-多图绘制"></a> 3 多图绘制</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 柱形图</span></span><br><span class="line">fig, axs = plt.subplots(nrows=<span class="number">2</span>, ncols=<span class="number">2</span>, figsize=(<span class="number">20</span>, <span class="number">12</span>), dpi=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">axs[<span class="number">0</span>][<span class="number">0</span>].set_title(<span class="string">'HeatLoadLight'</span>)</span><br><span class="line">axs[<span class="number">0</span>][<span class="number">0</span>].set_xlabel(<span class="string">'DateTime'</span>)</span><br><span class="line">axs[<span class="number">0</span>][<span class="number">0</span>].set_ylabel(<span class="string">'LoadValue'</span>)</span><br><span class="line">axs[<span class="number">0</span>][<span class="number">0</span>].bar(range(<span class="number">12</span>), list, fc=<span class="string">'g'</span>)</span><br><span class="line"></span><br><span class="line">axs[<span class="number">0</span>][<span class="number">1</span>].set_title(<span class="string">'HeatLoadHeavy'</span>)</span><br><span class="line">axs[<span class="number">0</span>][<span class="number">1</span>].set_xlabel(<span class="string">'DateTime'</span>)</span><br><span class="line">axs[<span class="number">0</span>][<span class="number">1</span>].set_ylabel(<span class="string">'LoadValue'</span>)</span><br><span class="line">axs[<span class="number">0</span>][<span class="number">1</span>].bar(range(<span class="number">12</span>), list, fc=<span class="string">'g'</span>)</span><br><span class="line"></span><br><span class="line">axs[<span class="number">1</span>][<span class="number">0</span>].set_title(<span class="string">'CoolLoadLight'</span>)</span><br><span class="line">axs[<span class="number">1</span>][<span class="number">0</span>].set_xlabel(<span class="string">'DateTime'</span>)</span><br><span class="line">axs[<span class="number">1</span>][<span class="number">0</span>].set_ylabel(<span class="string">'LoadValue'</span>)</span><br><span class="line">axs[<span class="number">1</span>][<span class="number">0</span>].bar(range(<span class="number">12</span>), list, fc=<span class="string">'g'</span>)</span><br><span class="line"></span><br><span class="line">axs[<span class="number">1</span>][<span class="number">1</span>].set_title(<span class="string">'CoolLoadHeavy'</span>)</span><br><span class="line">axs[<span class="number">1</span>][<span class="number">1</span>].set_xlabel(<span class="string">'DateTime'</span>)</span><br><span class="line">axs[<span class="number">1</span>][<span class="number">1</span>].set_ylabel(<span class="string">'LoadValue'</span>)</span><br><span class="line">axs[<span class="number">1</span>][<span class="number">1</span>].bar(range(<span class="number">12</span>), list, fc=<span class="string">'g'</span>)</span><br><span class="line"></span><br><span class="line">fig.autofmt_xdate()</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 折线图</span></span><br><span class="line">fig, axs = plt.subplots(nrows=<span class="number">1</span>, ncols=<span class="number">2</span>, figsize=(<span class="number">20</span>, <span class="number">6</span>), dpi=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">axs[<span class="number">0</span>].set_title(<span class="string">'xxx'</span>)</span><br><span class="line">axs[<span class="number">0</span>].set_xlabel(<span class="string">'Hour'</span>)</span><br><span class="line">axs[<span class="number">0</span>].set_ylabel(<span class="string">'Value'</span>)</span><br><span class="line">axs[<span class="number">0</span>].plot(range(<span class="number">168</span>), Q_trans_light, c=<span class="string">'red'</span>, label=<span class="string">'Light'</span>)</span><br><span class="line">axs[<span class="number">0</span>].plot(range(<span class="number">168</span>), Q_trans_heavy, c=<span class="string">'blue'</span>, label=<span class="string">'Heavy'</span>)</span><br><span class="line">axs[<span class="number">0</span>].legend(loc=<span class="string">'best'</span>)</span><br><span class="line"></span><br><span class="line">axs[<span class="number">1</span>].set_title(<span class="string">"xxx"</span>)</span><br><span class="line">axs[<span class="number">1</span>].set_xlabel(<span class="string">'Hour'</span>)</span><br><span class="line">axs[<span class="number">1</span>].set_ylabel(<span class="string">'Value'</span>)</span><br><span class="line">axs[<span class="number">1</span>].plot(range(<span class="number">168</span>), Q_trans_light, c=<span class="string">'red'</span>, label=<span class="string">'Light'</span>)</span><br><span class="line">axs[<span class="number">1</span>].plot(range(<span class="number">168</span>), Q_trans_heavy, c=<span class="string">'blue'</span>, label=<span class="string">'Heavy'</span>)</span><br><span class="line">axs[<span class="number">1</span>].legend(loc=<span class="string">'best'</span>)</span><br><span class="line"></span><br><span class="line">fig.autofmt_xdate()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h1 id="x-参考"><a class="markdownIt-Anchor" href="#x-参考"></a> X 参考</h1><ul><li><a href="https://www.runoob.com/matplotlib/matplotlib-bar.html" target="_blank" rel="noopener">菜鸟教程——Matplotlib 柱形图</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 环境与工具 </category>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python-文件-读取整理</title>
      <link href="/2022/01/17/Python-%E6%96%87%E4%BB%B6-%E8%AF%BB%E5%8F%96%E6%95%B4%E7%90%86/"/>
      <url>/2022/01/17/Python-%E6%96%87%E4%BB%B6-%E8%AF%BB%E5%8F%96%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-按行读取文本文件"><a class="markdownIt-Anchor" href="#1-按行读取文本文件"></a> 1 按行读取文本文件</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">file_path = <span class="string">'xxx'</span></span><br><span class="line"><span class="keyword">with</span> open(file_path) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">        print(line)</span><br></pre></td></tr></table></figure><p><a href="https://www.runoob.com/python/python-func-open.html" target="_blank" rel="noopener">open详解</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 待补充 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++项目的全量覆盖率和增量覆盖率</title>
      <link href="/2021/09/27/C++%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%85%A8%E9%87%8F%E8%A6%86%E7%9B%96%E7%8E%87%E5%92%8C%E5%A2%9E%E9%87%8F%E8%A6%86%E7%9B%96%E7%8E%87/"/>
      <url>/2021/09/27/C++%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%85%A8%E9%87%8F%E8%A6%86%E7%9B%96%E7%8E%87%E5%92%8C%E5%A2%9E%E9%87%8F%E8%A6%86%E7%9B%96%E7%8E%87/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-引入"><a class="markdownIt-Anchor" href="#1-引入"></a> 1 引入</h1><p><strong>需求</strong>：生成C/C++项目的全量/增量覆盖率报告</p><p><strong>方案</strong>：gcov+lcov+addlcov</p><blockquote><p><strong>gcov</strong>：是Linux下GCC自带的一个C/C++代码覆盖率分析工具,因此只要安装了gcc，就不需要再次安装了。</p></blockquote><hr><blockquote><p><strong>lcov</strong>：生成全量覆盖率报告。gcov能够生成代码覆盖信息，但是不够直观，因此需要借助lcov直观展示覆盖率，主要特点有：</p><ul><li>基于Html输出，并生成一棵完整的HTML树</li><li>输出包括概述、覆盖率百分比、图表，能快速浏览覆盖率数据</li><li>支持大项目，提供三个级别的视图：目录视图、文件视图、源码视图</li></ul></blockquote><hr><blockquote><p><strong>addlcov</strong>：生成全量覆盖率报告。</p></blockquote><h1 id="2-准备"><a class="markdownIt-Anchor" href="#2-准备"></a> 2 准备</h1><p>文件目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C++_project</span><br><span class="line">Version_A</span><br><span class="line">hello_world.cpp</span><br><span class="line">Version_B</span><br><span class="line">hello_world.cpp</span><br></pre></td></tr></table></figure><p><code>Version_A/hello_world.cpp</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"hello world"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Version_B/hello_world.cpp</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"func true"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"func false"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"hello world"</span>);</span><br><span class="line">func();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-安装"><a class="markdownIt-Anchor" href="#3-安装"></a> 3 安装</h1><ol><li><p><strong>gcov</strong>：安装gcc和g++即可；</p></li><li><p><strong>lcov</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/Dragonliu2018/lcov.git</span><br><span class="line"><span class="built_in">cd</span> ./lcov</span><br><span class="line"><span class="comment"># 安装perl，否则可能出现报错</span></span><br><span class="line">apt-get install perl</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>在<code>./bin</code> 目录下生成了可执行文件 <code>lcov</code></p></li><li><p><strong>addlcov</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/Dragonliu2018/addlcov.git</span><br></pre></td></tr></table></figure><p>将<code>addlcov</code>脚本放到项目文件夹直接使用即可。</p></li></ol><h1 id="4-全量覆盖率报告"><a class="markdownIt-Anchor" href="#4-全量覆盖率报告"></a> 4 全量覆盖率报告</h1><h2 id="41-lcov常用的参数"><a class="markdownIt-Anchor" href="#41-lcov常用的参数"></a> 4.1 lcov常用的参数</h2><ol><li><code>-d</code> 项目路径，即.gcda .gcno所在的路径</li><li><code>-a</code> 合并（归并）多个lcov生成的info文件</li><li><code>-c</code> 捕获，也即收集代码运行后所产生的统计计数信息</li><li><code>--external</code> 捕获其它目录产生的统计计数文件</li><li><code>-i/--initial</code> 初始化所有的覆盖率信息，作为基准数据</li><li><code>-o</code> 生成处理后的文件</li><li><code>-r/--remove</code> 移除不需要关注的覆盖率信息文件</li><li><code>-z</code> 重置所有执行程序所产生的统计信息为0</li></ol><h2 id="42-生成步骤"><a class="markdownIt-Anchor" href="#42-生成步骤"></a> 4.2 生成步骤</h2><p>以<code>Version_A/hello_world.cpp</code>为例：</p><ol><li><p><code>g++ -fprofile-arcs -ftest-coverage hello_world.cpp -o hello_world</code></p><ul><li>生成<code>hello_world</code> 和 <code>hello_world.gcno</code></li><li>编译时候加两个参数：<code>-fprofile-arcs -ftest-coverage</code>, 此时会生成： <code>hello_world.gcno</code></li></ul></li><li><p><code>./hello_world</code></p><ul><li>生成 <code>hello_world.gcda</code></li></ul></li><li><p><code>gcov hello_world.cpp</code></p><p>生成 <code>hello_world.cpp.gcov</code>，是代码覆盖信息，但看起来并不直观</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-:    0:Source:hello_world.cpp</span><br><span class="line">-:    0:Graph:hello_world.gcno</span><br><span class="line">-:    0:Data:hello_world.gcda</span><br><span class="line">-:    0:Runs:1</span><br><span class="line">-:    0:Programs:1</span><br><span class="line">-:    1:<span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line">-:    2:</span><br><span class="line">1:    3:int main()</span><br><span class="line">-:    4:&#123;</span><br><span class="line">1:    5:        <span class="built_in">printf</span>(<span class="string">"hello world"</span>);</span><br><span class="line">1:    6:        <span class="built_in">return</span> 0;</span><br><span class="line">-:    7:&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>lcov -d . -t 'hello world' -o 'hello_world.info' -b . -c</code> (注意：如果提示lcov命令找不到，则使用lcov的绝对路径)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/drives/e/lcov/bin/lcov -d . -t <span class="string">'hello world'</span> -o <span class="string">'hello_world.info'</span> -b . -c</span><br></pre></td></tr></table></figure><p>借助lcov对<code>hello_world.cpp.gcov</code>进行改造，可以看见生成了<code>hello_world.info</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">TN:hello_world</span><br><span class="line">SF:/drives/e/10 temp/C++_project/Version_A/hello_world.cpp</span><br><span class="line">FN:3,main</span><br><span class="line">FNDA:1,main</span><br><span class="line">DA:3,1</span><br><span class="line">DA:5,1</span><br><span class="line">DA:6,1</span><br><span class="line">FNF:1</span><br><span class="line">FNH:1</span><br><span class="line">LF:3</span><br><span class="line">LH:3</span><br><span class="line">end_of_record</span><br></pre></td></tr></table></figure></li><li><p><code>genhtml -o result hello_world.info</code> (注意：如果提示genhtml命令找不到，则使用genhtml的绝对路径)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ /drives/e/lcov/bin/genhtml -o result hello_world.info</span><br><span class="line">Reading data file hello_world.info</span><br><span class="line">Found 1 entries.</span><br><span class="line">Found common filename prefix <span class="string">"/drives/e/10 temp/C++_project"</span></span><br><span class="line">Writing .css and .png files.</span><br><span class="line">Generating output.</span><br><span class="line">Processing file Version_A/hello_world.cpp</span><br><span class="line">Writing directory view page.</span><br><span class="line">Overall coverage rate:</span><br><span class="line">  lines......: 100.0% (3 of 3 lines)</span><br><span class="line">  <span class="built_in">functions</span>..: 100.0% (1 of 1 <span class="keyword">function</span>)</span><br></pre></td></tr></table></figure><p>生成了<code>result</code>文件夹，借助web服务器，结果直观</p><img src="https://s2.loli.net/2022/04/16/OR3lKZBv9F5tGAX.png" width="900" height="300" alt="图片名称" align="center" id="158"></li><li><p>用浏览器打开<code>index.html</code>：</p><img src="https://s2.loli.net/2022/04/16/nhQSp1a46MWjVGx.png" width="900" height="200" alt="图片名称" align="center" id="159"></li></ol><h1 id="5-增量覆盖率报告"><a class="markdownIt-Anchor" href="#5-增量覆盖率报告"></a> 5 增量覆盖率报告</h1><p>以<code>Version_A</code> 和 <code>Version_B</code> 为例：</p><h2 id="51-使用diff命令生成文件差异列表"><a class="markdownIt-Anchor" href="#51-使用diff命令生成文件差异列表"></a> 5.1 使用diff命令生成文件差异列表</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff -r  -N -x <span class="string">".git"</span> -x <span class="string">"*.gcov"</span> -u &lt;old_src_path&gt; &lt;new_src_path&gt; &gt; diff.txt</span><br></pre></td></tr></table></figure><p>其中<code>&lt;old_src_path&gt;</code>是<code>Version_A</code> 版本代码路径、&lt;new_src_path&gt;是<code>Version_B</code> 版本代码路径，生成的diff.txt中包含的就是<code>Version_B</code> 相比<code>Version_A</code>的增量代码</p><p><strong>所以执行命令</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff -r  -N -x <span class="string">"*.gc*"</span> -x <span class="string">"*.exe"</span> -x <span class="string">"result"</span> -u ./Version_A ./Version_B &gt; diff.txt</span><br></pre></td></tr></table></figure><p><code>diff.txt</code>中的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">--- ./Version_A/hello_world.cpp</span><br><span class="line">+++ ./Version_B/hello_world.cpp</span><br><span class="line">@@ -1,7 +1,17 @@</span><br><span class="line"> #include&lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">+void func()</span><br><span class="line">+&#123;</span><br><span class="line">+if (true) &#123;</span><br><span class="line">+printf(&quot;func true&quot;);</span><br><span class="line">+&#125; else &#123;</span><br><span class="line">+printf(&quot;func false&quot;);</span><br><span class="line">+&#125;</span><br><span class="line">+&#125;</span><br><span class="line">+ </span><br><span class="line"> int main()</span><br><span class="line"> &#123;</span><br><span class="line"> printf(&quot;hello world&quot;);</span><br><span class="line">+func();</span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="52-使用addlcov生成增量代码覆盖率文件"><a class="markdownIt-Anchor" href="#52-使用addlcov生成增量代码覆盖率文件"></a> 5.2 使用addlcov生成增量代码覆盖率文件</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addlcov --diff &lt;full_cov_file&gt; diff.txt -o &lt;add_cov_file&gt; --strip &lt;depth&gt; --path &lt;new_src_path&gt;</span><br></pre></td></tr></table></figure><p>其中<code>&lt;full_cov_file</code>&gt;为之前统计的<code>Version_B</code>版本上的全量覆盖率；<code>&lt;add_cov_file&gt;</code>为输出的增量覆盖率info文件；<code>&lt;depth&gt;</code>是要截取的代码深度；<code>&lt;new_src_path&gt;</code>是<code>Version_B</code>版本源码</p><p>这里的<code>&lt;depth&gt;</code>再做一下解释：源码路径一般比较长，假设我们源码路径是<code>a/b/c/d/e</code>，这里的depth取值3则后续生成报告的根目录就是d了，前面三级就被屏蔽掉了。</p><p><strong>所以执行命令</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cur_version_dir=<span class="string">"/drives/e/10 temp/C++_project/Version_B"</span></span><br><span class="line"></span><br><span class="line">depth=$(<span class="built_in">echo</span> <span class="variable">$&#123;cur_version_dir&#125;</span> | sed -e <span class="string">'s/\/*$//g'</span> | awk -F<span class="string">"/"</span> <span class="string">'&#123;print NF&#125;'</span>)</span><br><span class="line"></span><br><span class="line">./addlcov --diff ./Version_B/hello_world.info diff.txt -o addhello_world.info  --strip <span class="variable">$&#123;depth&#125;</span> --path ./Version_B</span><br></pre></td></tr></table></figure><p><strong>出现报错</strong>：(单文件出现下述问题，多文件无问题)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BReading tracefile ./Version_B/hello_world.info</span><br><span class="line">Reading diff diff.txt</span><br><span class="line">Removing /drives/e/10 temp/C++_project/Version_B/hello_world.cpp</span><br><span class="line">1 entry converted, 0 entries left unchanged.</span><br><span class="line">Writing data to addhello_world.info</span><br><span class="line">Summary coverage rate:</span><br><span class="line">  lines......: no data found</span><br><span class="line">  <span class="built_in">functions</span>..: no data found</span><br><span class="line">  branches...: no data found</span><br></pre></td></tr></table></figure><p><strong>解决</strong>：<code>--path</code>后面的<code>&lt;new_src_path&gt;</code>路径要使用绝对路径</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ ./addlcov --diff ./Version_B/hello_world.info diff.txt -o addhello_world.info  --strip <span class="variable">$&#123;depth&#125;</span> --path <span class="string">"/drives/e/10 temp/C++_project/Version_B"</span></span><br><span class="line"></span><br><span class="line">Reading tracefile ./Version_B/hello_world.info</span><br><span class="line">Reading diff diff.txt</span><br><span class="line">Converting /drives/e/10 temp/C++_project/Version_B/hello_world.cpp</span><br><span class="line">1 entry converted, 0 entries left unchanged.</span><br><span class="line">Writing data to addhello_world.info</span><br><span class="line">Summary coverage rate:</span><br><span class="line">  lines......: 100.0% (4 of 4 lines)</span><br><span class="line">  <span class="built_in">functions</span>..: 100.0% (2 of 2 <span class="built_in">functions</span>)</span><br><span class="line">  branches...: no data found</span><br></pre></td></tr></table></figure><h2 id="53-使用genhtml生成html格式的覆盖率报告"><a class="markdownIt-Anchor" href="#53-使用genhtml生成html格式的覆盖率报告"></a> 5.3 使用genhtml生成html格式的覆盖率报告</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">genhtml -o &lt;report_dir&gt; &lt;add_cov_file&gt;</span><br></pre></td></tr></table></figure><p>其中<code>&lt;report_dir&gt;</code>是想要生成的报告路径名称，<code>&lt;add_cov_file&gt;</code>是通过上一步生成的覆盖率文件</p><p><strong>所以执行指令</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">genhtml -o addresult addhello_world.info</span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2022/04/16/NRMOznwGYim619k.png" width="900" height="300" alt="图片名称" align="center" id="160"><img src="https://s2.loli.net/2022/04/16/unjqov89Ic5yQ7b.png" width="900" height="300" alt="图片名称" align="center" id="161"><h1 id="x-参考"><a class="markdownIt-Anchor" href="#x-参考"></a> X 参考</h1><ul><li><a href="https://www.cnblogs.com/fnlingnzb-learner/p/6943512.html" target="_blank" rel="noopener">代码覆盖工具(gcov、lcov)的使用 </a></li><li><a href="https://www.jianshu.com/p/a42bbd9de1b7" target="_blank" rel="noopener">关于代码覆盖lcov的使用</a></li><li><a href="https://blog.csdn.net/Ls4034/article/details/72911389" target="_blank" rel="noopener">使用gcov生成增量覆盖率报告</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++单元测试</title>
      <link href="/2021/09/27/C++%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
      <url>/2021/09/27/C++%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="0-情景导入"><a class="markdownIt-Anchor" href="#0-情景导入"></a> 0 情景导入</h1><p>在实习时，用到了C++中的单元测试，整理一下。分别在Windows和子系统（Ubuntu）中安装配置。</p><h1 id="1-安装googletest"><a class="markdownIt-Anchor" href="#1-安装googletest"></a> 1 安装googletest</h1><h2 id="11-环境配置"><a class="markdownIt-Anchor" href="#11-环境配置"></a> 1.1 环境配置</h2><ol><li><p>下载gtest：<code>git clone https://github.com/google/googletest.git</code></p></li><li><p>安装cmake：</p><blockquote><p>CMake 是一个开源的跨平台的自动化构建系统，主要用于 C++ 的工程构建、测试以及打包等自动化操作。它能根据开发者编写的 CMakeLists.txt 规则文件，在不同的平台输出所需要的工程文件，然后开发者可以按照常见的构建方式使用生成的工程文件编译最终的程序。</p><p>CMake 是 Cross platform Make 的缩写，虽然名字中含有“make”，但是 CMake 和 Linux 上常见的 make 系统有所区别，是更上一层的构建系统。</p></blockquote><ul><li><strong>Windows</strong>：首先打开 CMake 官方网站，在<a href="https://cmake.org/download/" target="_blank" rel="noopener">下载页面</a>选择 Windows win64-x64 Installer 下载并安装</li><li><strong>Ubuntu</strong>：<code>apt-get install cmake</code></li></ul></li><li><p>windows配置clion编译环境：<a href="https://www.jianshu.com/p/1aa989808e15" target="_blank" rel="noopener">Window10上CLion极简配置教程</a></p></li></ol><h2 id="12-编译gtest库"><a class="markdownIt-Anchor" href="#12-编译gtest库"></a> 1.2 编译gtest库</h2><ol><li><p>使用clion打开<code>googletest</code>代码目录，选择<code>gtest</code>项目编译生成：</p><img src="https://i.loli.net/2021/10/06/quPZfVpBdWGCriI.png" width="800" height="300" alt="图片名称" align="center" id="29"></li><li><p>显示下面的信息表明编译成功（显示<code>Error running</code>，不用管他），生成的<code>libgtestd.a</code>即为gtest的库文件，项目中引用这个库文件就能使用gtest了。</p><img src="https://i.loli.net/2021/10/06/c2JyQ41X3nImkTK.png" width="900" height="200" alt="图片名称" align="center" id="30"></li></ol><h1 id="2-使用googletest"><a class="markdownIt-Anchor" href="#2-使用googletest"></a> 2 使用googletest</h1><h2 id="21-引入库"><a class="markdownIt-Anchor" href="#21-引入库"></a> 2.1 引入库</h2><p>新建测试项目<code>cliontest</code>，将libgtestd.a文件拷贝到该代码根路径的lib路径下，在CMakeList.txt中加上以下内容：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加上库文件的路径，注意相对路径</span></span><br><span class="line"><span class="keyword">link_directories</span>(lib/)</span><br><span class="line"><span class="comment"># 添加可执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(cliontest main.cpp)</span><br><span class="line"><span class="comment"># 链接gtest库文件</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(cliontest libgtestd.a)</span><br></pre></td></tr></table></figure><h2 id="22-引入头文件"><a class="markdownIt-Anchor" href="#22-引入头文件"></a> 2.2 引入头文件</h2><p>拷贝<code>googletest/include</code>下的<code>gtest</code>目录到项目下的<code>include</code>目录下，然后在CMakeList.txt中添加上对应的调用：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include_directories</span>(</span><br><span class="line">    <span class="keyword">include</span>/</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>然后在代码中添加头文件gtest/gtest.h就可以使用了。</p><h2 id="23-测试"><a class="markdownIt-Anchor" href="#23-测试"></a> 2.3 测试</h2><p>修改<code>main.cpp</code>并运行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"gtest/gtest.h"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">TEST(add, zero) &#123;</span><br><span class="line">    EXPECT_EQ(<span class="number">0</span>, add(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">TEST(add, positive_number) &#123;</span><br><span class="line">    EXPECT_EQ(<span class="number">3</span>, add(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">TEST(add, negative_number) &#123;</span><br><span class="line">    EXPECT_EQ(<span class="number">-3</span>, add(<span class="number">-1</span>, <span class="number">-2</span>));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ::testing::InitGoogleTest();</span><br><span class="line">    <span class="keyword">return</span> RUN_ALL_TESTS();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-gtest的使用教程"><a class="markdownIt-Anchor" href="#3-gtest的使用教程"></a> 3 gtest的使用教程</h1><p>参考文档：<a href="https://github.com/google/googletest/blob/master/googletest/docs/primer.md" target="_blank" rel="noopener">Googletest Primer</a>，google官方出品。</p><p><a href="https://www.dyxmq.cn/program/usage-of-googletest.html" target="_blank" rel="noopener">https://www.dyxmq.cn/program/usage-of-googletest.html</a></p><h1 id="4-参考"><a class="markdownIt-Anchor" href="#4-参考"></a> 4 参考</h1><ul><li><a href="https://meishizaolunzi.com/cmake-an-zhuang-zhi-nan/" target="_blank" rel="noopener">CMake 安装指南</a></li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基于SR的全量/增量覆盖率统计</title>
      <link href="/2021/09/27/%E5%9F%BA%E4%BA%8ESR%E7%9A%84%E5%85%A8%E9%87%8F%E5%A2%9E%E9%87%8F%E8%A6%86%E7%9B%96%E7%8E%87%E7%BB%9F%E8%AE%A1/"/>
      <url>/2021/09/27/%E5%9F%BA%E4%BA%8ESR%E7%9A%84%E5%85%A8%E9%87%8F%E5%A2%9E%E9%87%8F%E8%A6%86%E7%9B%96%E7%8E%87%E7%BB%9F%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-情景导入"><a class="markdownIt-Anchor" href="#1-情景导入"></a> 1 情景导入</h1><p>2021.09.26华为实习任务复现，要求实现基于SR的全量/增量覆盖率统计。</p><p>源代码：<a href="https://gitee.com/dragon-liu/RB_01" target="_blank" rel="noopener">https://gitee.com/dragon-liu/RB_01</a></p><h1 id="2-部门现状"><a class="markdownIt-Anchor" href="#2-部门现状"></a> 2 部门现状</h1><ol><li><p>当前的代码覆盖率只能基于整个代码库进行统计，无法便捷跟踪每个需求引起的覆盖率变化，版本管理成本很高。</p><blockquote><p><strong>方案</strong>：基于SR的全量/增量覆盖率统计</p></blockquote></li><li><p>其次，脚本使用Perl语言编写，晦涩难懂，没有维护人员。</p><blockquote><p><strong>编程语言</strong>：Shell + Python</p></blockquote></li></ol><h1 id="3-解决方案"><a class="markdownIt-Anchor" href="#3-解决方案"></a> 3 解决方案</h1><ol><li>通过git跟踪不同需求引入的代码变更</li><li>基于变更代码生成差异文件：强行cherry-pick<ul><li>无冲突，直接做全量/增量分析，结果是准确的</li><li>有冲突需，自己获取差异代码行，结果是近似的<ul><li>根据SR获取commit id列表</li><li>以最后一笔提交为标准</li><li>倒序遍历commit id，找出每次提交的代码行（倒序的原因：一般的，越新的commit对当前代码库影响越大）</li></ul></li></ul></li><li>利用lcov以及addlcov生成对应需求的全量/增量覆盖率报告</li><li>通过genhtml工具和python工程库生成html报告</li><li>借助Jenkins定时运行脚本与发送邮件</li></ol><h1 id="4-jenkins使用"><a class="markdownIt-Anchor" href="#4-jenkins使用"></a> 4 Jenkins使用</h1><h2 id="41-ubuntu20安装jenkins"><a class="markdownIt-Anchor" href="#41-ubuntu20安装jenkins"></a> 4.1 Ubuntu20安装Jenkins</h2><ul><li><a href="https://cloud.tencent.com/developer/article/1666282" target="_blank" rel="noopener">如何在 Ubuntu 20.04 上安装 Jenkins</a></li><li><a href="https://blog.csdn.net/qq_35114214/article/details/88747597" target="_blank" rel="noopener">Ubuntu环境下Jenkins安装、卸载、配置</a></li></ul><h2 id="42-配置构建任务"><a class="markdownIt-Anchor" href="#42-配置构建任务"></a> 4.2 配置构建任务</h2><ul><li><a href="https://blog.csdn.net/qq_42559485/article/details/108511066" target="_blank" rel="noopener">Jenkins配置git仓库</a></li><li><a href="https://blog.csdn.net/u012599988/article/details/81871596" target="_blank" rel="noopener">Jenkins 之插件 Publish HTML reports 的使用</a></li></ul><h2 id="43-邮件发送"><a class="markdownIt-Anchor" href="#43-邮件发送"></a> 4.3 邮件发送</h2><ul><li><a href="https://blog.csdn.net/songjiaping/article/details/51496977" target="_blank" rel="noopener">jenkins构建后邮件发送</a></li><li><a href="https://www.cnblogs.com/lelexiong/p/9037807.html" target="_blank" rel="noopener">jenkins构建邮件自动发送，测试邮件发送成功，构建项目邮件发送不成功的问题</a></li><li><a href="https://www.cnblogs.com/t-ae/p/10186157.html" target="_blank" rel="noopener">jenkins构建任务后发送邮件</a></li><li><a href="https://blog.csdn.net/weixin_34199405/article/details/94286501" target="_blank" rel="noopener">jenkins发送邮件失败“No emails were triggered”</a></li></ul><p>本地复现使用的Jenkins自带的邮件提醒功能；华为实习过程中，自己编写脚本进行邮件提醒。</p><p>具体实现详见 博客：<code>Jenkins配置定时发送邮件功能</code></p><h1 id="关于报错"><a class="markdownIt-Anchor" href="#关于报错"></a> 关于报错</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">###强制回滚到某版本</span></span><br><span class="line">git reset --hard 36409abd22dcc9f9252152b34fa9e929f7c883ec</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">###解决：https://stackoverflow.com/questions/3411048/unexpected-operator-in-shell-programming/3411061</span></span><br><span class="line">./srCover.sh: 17: [: h: unexpected operator </span><br><span class="line">./srCover.sh: 21: [: h: unexpected operator</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 环境与工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python-全局变量-list</title>
      <link href="/2021/06/27/Python-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F-list/"/>
      <url>/2021/06/27/Python-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F-list/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-list"><a class="markdownIt-Anchor" href="#1-list"></a> 1 List</h1><p><strong>python中list作为全局变量无需global声明的原因</strong>：</p><blockquote><p><a href="https://www.cnblogs.com/yym2013/p/5915980.html" target="_blank" rel="noopener">https://www.cnblogs.com/yym2013/p/5915980.html</a></p></blockquote><p>python中list变量作为全局变量时，在函数中可以直接修改。</p><p>而普通变量则需要先在函数中global声明，否则会报错。</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">()</span>:</span></span><br><span class="line">　　<span class="keyword">global</span> a</span><br><span class="line">　　a = <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">b = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">()</span>:</span></span><br><span class="line">　　b[<span class="number">0</span>] = <span class="number">2</span></span><br></pre></td></tr></table></figure><p>在函数中直接修改list则是可以的。</p><p>原因是：</p><p>普通变量如果在函数中赋值</p><p><code>a = 2</code></p><p>会有歧义。因为它既可以是表示引用全局变量a，也可以是创建一个新的局部变量，所以在python中，默认它的行为是创建局部变量，除非显式声明global。</p><p>而对列表list变量进行赋值</p><p><code>b[0] = 2</code></p><p>则不会有歧义。它是“明确的”，因为如果把b当作是局部变量的话，它会报KeyError，所以它只能是引用全局的b,故不需要多此一举显式声明global。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
