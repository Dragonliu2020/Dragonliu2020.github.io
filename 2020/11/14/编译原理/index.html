<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>编译原理 | Dragon Liu</title><meta name="description" content="编译原理"><meta name="keywords" content><meta name="author" content="Dragon Liu"><meta name="copyright" content="Dragon Liu"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="http://q4wib37p7.bkt.clouddn.com/BlogFavicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="https://Dragonliu2018.github.io/2020/11/14/编译原理/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="编译原理"><meta name="twitter:description" content="编译原理"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/20161213181906073.png"><meta property="og:type" content="article"><meta property="og:title" content="编译原理"><meta property="og:url" content="https://Dragonliu2018.github.io/2020/11/14/编译原理/"><meta property="og:site_name" content="Dragon Liu"><meta property="og:description" content="编译原理"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/20161213181906073.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="prev" title="密码学" href="https://Dragonliu2018.github.io/2020/12/03/密码学复习/"><link rel="next" title="图像滤波整理" href="https://Dragonliu2018.github.io/2020/11/08/图像滤波整理/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  highlight_lang: 'true',
  highlight_shrink: 'true',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: '添加书签',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天'

  
}</script><link rel="alternate" href="/atom.xml" title="Dragon Liu" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#01-考点"><span class="toc-text">01 考点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#02-问题"><span class="toc-text">02 问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#03-课上安排"><span class="toc-text">03 课上安排</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Ch1-引论-amp-Ch9-运行时存储空间组织"><span class="toc-text">Ch1 引论 &amp; Ch9 运行时存储空间组织</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#0x01-目标代码与中间代码的区别和联系"><span class="toc-text">0x01 目标代码与中间代码的区别和联系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x02-存储分配策略"><span class="toc-text">0x02 存储分配策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#01-C语言"><span class="toc-text">01 C语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#02-DISPLAY表实现嵌套过程中非局部变量访问的思想"><span class="toc-text">02 DISPLAY表实现嵌套过程中非局部变量访问的思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#03-C语言与Pascal"><span class="toc-text">03 C语言与Pascal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#04-问题"><span class="toc-text">04 问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x03-可规约活前缀"><span class="toc-text">0x03  可规约活前缀</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x04-短语-直接短语-句柄"><span class="toc-text">0x04 短语+直接短语+句柄</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x05-编译的主要过程"><span class="toc-text">0x05 编译的主要过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x06-算符优先分析"><span class="toc-text">0x06 算符优先分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#01-算符优先分析同规范规约比较"><span class="toc-text">01 算符优先分析同规范规约比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#02-如何寻找“可规约串”，分析树与语法树是否一致"><span class="toc-text">02 如何寻找“可规约串”，分析树与语法树是否一致</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x07-编译各过程对符号表的操作"><span class="toc-text">0x07 编译各过程对符号表的操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x08-编译的前后端"><span class="toc-text">0x08 编译的前后端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x09-其他"><span class="toc-text">0x09 其他</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Ch2-高级语言及其语法描述-上下文无关文法"><span class="toc-text">Ch2 高级语言及其语法描述 上下文无关文法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#01-文法分类"><span class="toc-text">01 文法分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#02-试题"><span class="toc-text">02 试题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Ch3-词法分析-正规式到DFA"><span class="toc-text">Ch3 词法分析 正规式到DFA</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#01-正规式"><span class="toc-text">01 正规式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#02-有穷自动机-FA"><span class="toc-text">02 有穷自动机(FA)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#03-RE转换为DFA"><span class="toc-text">03 RE转换为DFA</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#04-FA转化为RE"><span class="toc-text">04 FA转化为RE</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#05-FA与正规文法转化"><span class="toc-text">05 FA与正规文法转化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Ch4-语法分析——自上而下分析-LL-1"><span class="toc-text">Ch4 语法分析——自上而下分析 LL(1)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#01-概念"><span class="toc-text">01 概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#02-解题"><span class="toc-text">02 解题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#03-LL-1-文法"><span class="toc-text">03 LL(1)文法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#04-消去二义性"><span class="toc-text">04 消去二义性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#05-消除左递归"><span class="toc-text">05 消除左递归</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#a-左递归"><span class="toc-text">a. 左递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#b-步骤"><span class="toc-text">b. 步骤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#06-提左因子"><span class="toc-text">06 提左因子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#07-FIRST集"><span class="toc-text">07 FIRST集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#08-FOLLOW集"><span class="toc-text">08 FOLLOW集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#09-SELECT集"><span class="toc-text">09 SELECT集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-预测分析表"><span class="toc-text">10 预测分析表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Ch5-语法分析——自下而上分析-LR-0-SLR-1"><span class="toc-text">Ch5 语法分析——自下而上分析 LR(0)+SLR(1)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#00-解题"><span class="toc-text">00 解题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#01-移入-归约分析"><span class="toc-text">01 移入-归约分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#02-LR分析法"><span class="toc-text">02 LR分析法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#a-LR-分析器的工作过程"><span class="toc-text">a. LR 分析器的工作过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#b-LR-0-项目"><span class="toc-text">b. LR(0) 项目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#c-增广文法"><span class="toc-text">c. 增广文法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#d-文法中的项目"><span class="toc-text">d. 文法中的项目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#e-LR-0-转换图转LR-0-分析表"><span class="toc-text">e. LR(0)转换图转LR(0)分析表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#f-冲突"><span class="toc-text">f. 冲突</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#g-SLR-1-消除冲突"><span class="toc-text">g. SLR(1)  消除冲突</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Ch6-属性文法和语法制导翻译-amp-Ch7-语义分析和中间代码生成"><span class="toc-text">Ch6 属性文法和语法制导翻译 &amp; Ch7 语义分析和中间代码生成</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#01-语法制导翻译"><span class="toc-text">01 语法制导翻译</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#02-中间代码生成"><span class="toc-text">02 中间代码生成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#a-S-gt-if-E-then-S1-P195"><span class="toc-text">a. S -&gt; if E then S1 P195</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#b-S-gt-if-E-then-S1-else-S2"><span class="toc-text">b. S -&gt; if E then S1 else S2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#c-S-gt-while-E-do-S1"><span class="toc-text">c. S -&gt; while E do S1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#d-S-gt-for-E1-E2-E3-S1"><span class="toc-text">d. S -&gt; for(E1; E2; E3) S1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#e-其他"><span class="toc-text">e. 其他</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Ch9-运行时存储空间组织"><span class="toc-text">Ch9 运行时存储空间组织</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Ch10-优化"><span class="toc-text">Ch10 优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#01-划分基本块"><span class="toc-text">01 划分基本块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#02-作出程序控制流图"><span class="toc-text">02 作出程序控制流图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#03-基本块优化"><span class="toc-text">03 基本块优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#04-循环优化"><span class="toc-text">04 循环优化</span></a></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/20161213181906073.png)"><div id="page-header"><span class="pull-left"> <a class="blog_title" id="site-name" href="/">Dragon Liu</a></span><div class="open toggle-menu pull-right"><div class="menu-icon-first"></div><div class="menu-icon-second"></div><div class="menu-icon-third"></div></div><div class="menu_mask"></div><span class="pull-right menus"><div class="mobile_author_icon"><img class="lozad avatar_img" src="https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/avatar.png" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item text-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">38</div></a></div></div><div class="mobile_data_item text-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">15</div></a></div></div><div class="mobile_data_item text-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">5</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/books/"><i class="fa-fw fa fa-book"></i><span> 读书</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-photo"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/theme/"><i class="fa-fw fa fa-superpowers"></i><span> 主题</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title"><div class="posttitle">编译原理</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-11-14<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2021-09-21</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/课程/">课程</a></span><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">8.6k</span><span class="post-meta__separator">|</span><span>阅读时长: 28 分钟</span><span class="post-meta__separator">|</span><span>阅读量: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="01-考点"><a href="#01-考点" class="headerlink" title="01 考点"></a>01 考点</h1><ol>
<li>简答题：Ch1-引论与Ch9-运行时存储空间组织，知识发散</li>
<li>给定语言，写出文法(上下文无关文法)</li>
<li>给定正规式，划到最小化的有限自动机</li>
<li>LL(1)</li>
<li>LR(0)、SLR(1)；<strong>LR(1)不考、算符优先分析不考</strong></li>
<li>语法制导翻译：会写翻译模式，if+while+for等会写</li>
<li>优化：基本块优化、循环优化</li>
</ol>
<h1 id="02-问题"><a href="#02-问题" class="headerlink" title="02 问题"></a>02 问题</h1><ol>
<li>卷一的题三</li>
<li>卷三的题二+题三+题四</li>
<li>改写无二义性</li>
<li>卷4题6</li>
<li>for翻译</li>
<li>符号表建立</li>
</ol>
<h1 id="03-课上安排"><a href="#03-课上安排" class="headerlink" title="03 课上安排"></a>03 课上安排</h1><ul>
<li>翻译</li>
<li>优化</li>
</ul>
<h1 id="Ch1-引论-amp-Ch9-运行时存储空间组织"><a href="#Ch1-引论-amp-Ch9-运行时存储空间组织" class="headerlink" title="Ch1 引论 &amp; Ch9 运行时存储空间组织"></a>Ch1 引论 &amp; Ch9 运行时存储空间组织</h1><h2 id="0x01-目标代码与中间代码的区别和联系"><a href="#0x01-目标代码与中间代码的区别和联系" class="headerlink" title="0x01 目标代码与中间代码的区别和联系"></a>0x01 目标代码与中间代码的区别和联系</h2><p>　　目标代码生成的任务是将中间代码(或经过优化处理后的中间代码)变换成特定机器上的绝对指令代码或可重新定位的指令代码或汇编指令代码。这种代码变换依赖于特定的硬件系统结构和机器指令含义。</p>
<h2 id="0x02-存储分配策略"><a href="#0x02-存储分配策略" class="headerlink" title="0x02 存储分配策略"></a>0x02 存储分配策略</h2><ul>
<li><strong>静态分配策略</strong>：在编译时对所有数据对象分配固定的存储单元，且运行时始终保持不变。</li>
<li><strong>栈式动态分配策略</strong>：在运行时把存储器作为一个栈进行管理，运行时，每当调用一个过程，他所需要的存储空间就动态地分配于栈顶，一旦退出，它所占空间就予以释放。</li>
<li><strong>堆式动态分配策略</strong>：在运行时把存储器组成堆结构，以便用户关于存储空间的申请与归还(回收)，凡申请者从堆中分给一块存储空间，凡释放者退回给堆。</li>
</ul>
<h3 id="01-C语言"><a href="#01-C语言" class="headerlink" title="01 C语言"></a>01 C语言</h3><p>　　C语言是这样的一种语言：没有分程序结构，过程定义不允许嵌套，但是允许过程的递归调用，允许过程含有可变数组。由于允许递归过程，在编译时刻无法预先确定哪些递归过程在运行时被激活，更难以确定他们的递归深度，而每次递归调用都要为该过程中的每个数据对象分配一个新的存储空间，因此编译程序不能采用静态分配策略，只能采用在程序运行时动态的进行分配(栈式分配)。栈式分配策略在运行时把存储器作为一个栈进行管理，运行时，每当调用一个过程，他所需要的存储空间就动态地分配于栈顶，一旦退出，它所占空间就予以释放。</p>
<p>　　另外，C语言允许用户动态的申请和释放存储空间，而且申请与释放之间不一定遵守先申请后释放或后申请先释放的原则，因此需要采用一种更加复杂的堆式动态分配策略。堆式动态分配策略在运行时把存储器组成堆结构，以便用户关于存储空间的申请与归还(回收)，凡申请者从堆中分给一块存储空间，凡释放者退回给堆。</p>
<h3 id="02-DISPLAY表实现嵌套过程中非局部变量访问的思想"><a href="#02-DISPLAY表实现嵌套过程中非局部变量访问的思想" class="headerlink" title="02 DISPLAY表实现嵌套过程中非局部变量访问的思想"></a>02 DISPLAY表实现嵌套过程中非局部变量访问的思想</h3><p>　　display表的作用是对嵌套过程语言实现对非局部变量的引用而设置的，它依次存放着包围它的外过程的最新活动记录的基地址SP值，由于，嵌套层次为i+1过程中的非局部变量可能在i,i-1…0层，所以，对非局部变量的引用是通过它的display表元素d[i],d[i-1],..,d[0]而获得包围它的外过程的最新活动记录的基地址SP值，再加上变量在该过程(第i层)的偏移量。如若非局部变量a是在第i层，那么引用a时，首先从当前栈顶过程的display表中元素d[i]中取出存放的第i层最新活动记录基地址SP值，然后加上a所在过程(第i层)的偏移量，就得到a的存放地址。</p>
<h3 id="03-C语言与Pascal"><a href="#03-C语言与Pascal" class="headerlink" title="03 C语言与Pascal"></a>03 C语言与Pascal</h3><p>　　C语言与Pascal语言都允许递归调用，因此应该采用栈式存储分配。由于C语言过程定义不允许嵌套定义，对非局部变量的访问非常简单，因此活动记录只需保持一条动态链，记录过程的调用关系；而Pascal过程定义允许嵌套定义，因此，对非局部变量的访问是一个相对概念，因此，其活动记录不仅要记录过程的调用关系，还必须记录过程的嵌套关系。</p>
<h3 id="04-问题"><a href="#04-问题" class="headerlink" title="04 问题"></a>04 问题</h3><ul>
<li><strong>问</strong>：假定一语言，在每个过程内部既可以引用局部于该过程的变量，也可以引用主过程中的全局变量，过程允许递归调用但不允许嵌套定义，请根据该语言的特点说明其运行时需要采用何种存储分配策略</li>
<li><strong>答</strong>：采用简单的栈式分配，但需要在每个过程的活动记录中增加一个指向主过程中变量的位置，以便对主过程中全局变量的访问。</li>
</ul>
<h2 id="0x03-可规约活前缀"><a href="#0x03-可规约活前缀" class="headerlink" title="0x03  可规约活前缀"></a>0x03  可规约活前缀</h2><ul>
<li><strong>前缀</strong>：字的前缀是指该字的任意首部。例如，字<code>abc</code>的前缀有空字、a、ab或abc。</li>
<li><strong>活前缀</strong>：规范句型的一个前缀，这种前缀不含句柄之后的任何符号。之所以称为活前缀，是因为在右边增添一些终结符号之后，就可以使其成为一个规范句型。</li>
<li><strong>可规约活前缀</strong>：含句柄的活前缀</li>
<li><strong>规范句型</strong>：在形式语言中，最右推导常被称为规范推导。由规范推导所得的句型称为规范句型。如果文法G是无二义的，那么规范推导(最右推导)的逆过程必是规范规约(最左规约)。</li>
</ul>
<h2 id="0x04-短语-直接短语-句柄"><a href="#0x04-短语-直接短语-句柄" class="headerlink" title="0x04 短语+直接短语+句柄"></a>0x04 短语+直接短语+句柄</h2><p><img alt data-src="https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/20161213181906072.png" class="lozad"></p>
<ul>
<li><strong>短语</strong>：一个句型的语法树中任一子树叶结点所组成的符号串都是该句型的短语</li>
<li><strong>直接短语</strong>：深度为2的子树叶结点所组成的符号串都是该句型的直接短语</li>
<li><p><strong>句柄</strong>：直接短语中的最左直接短语为该句型的句柄</p>
</li>
<li><p><strong>素短语</strong>：素短语是一个短语，它至少含有一个终结符，而且除他之外不含有其他素短语。</p>
</li>
<li><strong>最左素短语</strong>：最左边的素短语</li>
</ul>
<h2 id="0x05-编译的主要过程"><a href="#0x05-编译的主要过程" class="headerlink" title="0x05 编译的主要过程"></a>0x05 编译的主要过程</h2><p>编译程序的工作过程一般分为五个阶段：词法分析、语法分析、语义分析与中间代码产生、优化、目标代码生成。</p>
<ul>
<li><strong>词法分析</strong>：输入源程序，对构成源程序的字符串进行扫描和分解，识别一个个的单词(亦称单词符号或简称符号)。</li>
<li><strong>语法分析</strong>：对单词符号串进行语法分析(根据语法规则进行推导或规约)，识别出各类语法单位，最终判断输入串是否构成语法上正确的”程序”。</li>
<li><strong>语义分析与中间代码产生</strong>：对语法分析所识别出的各类语法范畴，分析其含义，并进行初步翻译(产生中间代码)。</li>
<li><strong>优化</strong>：对前端产生的中间代码进行加工变换，以期在最后阶段能产生更为高效(省时间和空间)的目标代码。</li>
<li><strong>目标代码生成</strong>：把中间代码(或经优化处理之后)变换成特定机器上的低级语言代码。</li>
</ul>
<h2 id="0x06-算符优先分析"><a href="#0x06-算符优先分析" class="headerlink" title="0x06 算符优先分析"></a>0x06 算符优先分析</h2><h3 id="01-算符优先分析同规范规约比较"><a href="#01-算符优先分析同规范规约比较" class="headerlink" title="01 算符优先分析同规范规约比较"></a>01 算符优先分析同规范规约比较</h3><p>　　算符优先分析因为在分析过程中跳过了单非终结符对应的规约步骤，因此规约速度比规范规约快，但由于忽略了非终结符在规约过程中的作用，因此可能导致把本来不成句子地输入串误认为是句子。</p>
<h3 id="02-如何寻找“可规约串”，分析树与语法树是否一致"><a href="#02-如何寻找“可规约串”，分析树与语法树是否一致" class="headerlink" title="02 如何寻找“可规约串”，分析树与语法树是否一致"></a>02 如何寻找“可规约串”，分析树与语法树是否一致</h3><p>　　通过算符之间的优先关系，找到最左素短语进行规约；算符优先分析在分析时忽略的产生式右边时单非终结符的产生式，并且在规约过程中采用“型近”方式进行规约，因此得到的分析树可能和语法树不一致。</p>
<h2 id="0x07-编译各过程对符号表的操作"><a href="#0x07-编译各过程对符号表的操作" class="headerlink" title="0x07 编译各过程对符号表的操作"></a>0x07 编译各过程对符号表的操作</h2><p>　　词法分析阶段需要将识别出来的单词符号及其类别填入符号表；语义分析阶段需要将单词符号的属性填入对应的单词，同时需要查阅符号表；目标代码生成阶段也需要查阅符号表。</p>
<h2 id="0x08-编译的前后端"><a href="#0x08-编译的前后端" class="headerlink" title="0x08 编译的前后端"></a>0x08 编译的前后端</h2><p>　　前端与源语言有关，包括词法分析、语法分析、语义分析机中间代码产生，有的代码优化工作也可包含在前端；后端与目标机有关，包括与目标机有关的代码优化和目标代码生成等，通常后端不依赖于源语言而仅仅依赖于中间语言。划分为前后端主要使得编译结构清晰，便于实现。</p>
<h2 id="0x09-其他"><a href="#0x09-其他" class="headerlink" title="0x09 其他"></a>0x09 其他</h2><ul>
<li>形式化的例子：上下文无关文法描述语法结构、正规文法描述词法结构、语义形式化-属性文法</li>
<li>上下文无关文法无法描述程序结构语言的语义问题</li>
<li></li>
</ul>
<h1 id="Ch2-高级语言及其语法描述-上下文无关文法"><a href="#Ch2-高级语言及其语法描述-上下文无关文法" class="headerlink" title="Ch2 高级语言及其语法描述 上下文无关文法"></a>Ch2 高级语言及其语法描述 上下文无关文法</h1><h2 id="01-文法分类"><a href="#01-文法分类" class="headerlink" title="01 文法分类"></a>01 文法分类</h2><ul>
<li><strong>0型文法</strong>：也称无限制文法或短语结构文法(PSG)。$\forall \alpha \rightarrow \beta \in P$，$\alpha$中至少包含一个非终结符。</li>
<li><strong>1型文法</strong>：也称上下文有关文法(CSG)。$\forall \alpha \rightarrow \beta \in P$，$|\boldsymbol{\alpha}| \leq|\boldsymbol{\beta}|$，$\alpha$中至少包含一个非终结符。产生式的一般形式：$\alpha<em>{1} A \alpha</em>{2} \rightarrow \alpha<em>{1} \beta \alpha</em>{2}(\beta \neq \varepsilon)$。不包含​ε-产生式。</li>
<li><strong>2型文法</strong>：也称上下文无关文法(CFG)。$\forall \alpha \rightarrow \beta \in P, \alpha \in V_{N}$。产生式的一般形式：$A \rightarrow \beta$。</li>
<li><strong>3型文法</strong>：也称正则文法(RG)。<ul>
<li>右线性文法：$A \rightarrow w B$ 或 $A \rightarrow w$</li>
<li>左线性文法：$A \rightarrow B w$ 或 $A \rightarrow w$</li>
</ul>
</li>
</ul>
<h2 id="02-试题"><a href="#02-试题" class="headerlink" title="02 试题"></a>02 试题</h2><ul>
<li><p>$L(G)={a^nb^m,n&gt;m&gt;0}$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">G(S): S -&gt; AB</span><br><span class="line">	  A -&gt; aA | a</span><br><span class="line">	  B -&gt; aBb | ab</span><br><span class="line">或</span><br><span class="line">G(S): S -&gt; aSB | aab</span><br><span class="line">	  B -&gt; b | ε</span><br></pre></td></tr></table></figure>
</li>
<li><p>非0开头的正偶数集</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">G(Z): Z -&gt; ABC | 2 | 4 | 6 | 8</span><br><span class="line">	  A -&gt; 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9</span><br><span class="line">	  B -&gt; BA | B0 | ε</span><br><span class="line">	  C -&gt; 0 | 2 | 4 | 6 | 8</span><br></pre></td></tr></table></figure>
</li>
<li><p>$L(G)={a^nb^nc^m|n为偶数，m为奇数}$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">G(S): S -&gt; AC</span><br><span class="line">	  A -&gt; aaAbb | ε</span><br><span class="line">	  C -&gt; ccC | c</span><br></pre></td></tr></table></figure>
</li>
<li><p>$L(G)={a^nb^nc^i|n&gt;=1，i&gt;=0}$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">G(S): S -&gt; AC</span><br><span class="line">	  A -&gt; aAb | ab</span><br><span class="line">	  C -&gt; cC | ε</span><br></pre></td></tr></table></figure>
</li>
<li><p>$L(G)={a^nb^na^mb^m|n,m&gt;=0}$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">G(S): S -&gt; AB</span><br><span class="line">	  A -&gt; aAb | ε</span><br><span class="line">	  B -&gt; aBb | ε</span><br></pre></td></tr></table></figure>
</li>
<li><p>$L(G)={1^n0^m1^m0^n|n,m&gt;=0}$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">G(S): S -&gt; A | B</span><br><span class="line">	  A -&gt; 0A1 | ε</span><br><span class="line">	  B -&gt; 1B0 | A</span><br></pre></td></tr></table></figure>
</li>
<li></li>
</ul>
<h1 id="Ch3-词法分析-正规式到DFA"><a href="#Ch3-词法分析-正规式到DFA" class="headerlink" title="Ch3 词法分析 正规式到DFA"></a>Ch3 词法分析 正规式到DFA</h1><h2 id="01-正规式"><a href="#01-正规式" class="headerlink" title="01 正规式"></a>01 正规式</h2><ul>
<li>{a.b}，至少两个连续的a：$(a|b)^<em>aa(a|b)^</em>$</li>
<li></li>
<li></li>
</ul>
<h2 id="02-有穷自动机-FA"><a href="#02-有穷自动机-FA" class="headerlink" title="02 有穷自动机(FA)"></a>02 有穷自动机(FA)</h2><ul>
<li><strong>最长字串匹配原则</strong>：但输入串的多个前缀与一个或多个模式匹配时，总是选择最长的前缀进行匹配。</li>
<li><strong>确定有限自动机(DFA)</strong>：$M=\left(S, \Sigma, \delta, s_{0}, F\right)$<ul>
<li>$S$：有穷状态集</li>
<li>$ \Sigma$：输入字母表，即输入符号集合。假设ε不是$ \Sigma$中的元素。</li>
<li>$\delta$：将$S \times \Sigma$映射到$S$的转换函数。$\forall s \in S, a \in \Sigma, \delta(s, a)$表示从状态$s$出发，沿着标记为$a$的边所能到达的状态</li>
<li>$s<em>{0}$：开始状态(或初始状态)，$\boldsymbol{s}</em>{0} \in S$</li>
<li>$F$：接受状态(或终止状态)集合，$F \subseteq S$</li>
</ul>
</li>
<li><strong>非确定有限自动机(NFA)</strong>：$M=\left(S, \Sigma, \delta, s_{0}, F\right)$<ul>
<li>$S$：有穷状态集</li>
<li>$ \Sigma$：输入字母表，即输入符号集合。假设ε不是$ \Sigma$中的元素。</li>
<li>$\delta$：将$S \times \Sigma$映射到$2^S$的转换函数。$\forall s \in S, a \in \Sigma, \delta(s, a)$表示从状态$s$出发，沿着标记为$a$的边所能到达的状态<strong>集合</strong></li>
<li>$s<em>{0}$：开始状态(或初始状态)，$\boldsymbol{s}</em>{0} \in S$</li>
<li>$F$：接受状态(或终止状态)集合，$F \subseteq S$</li>
</ul>
</li>
<li><strong>带有”ε-边”的NFA</strong>：<ul>
<li>$\delta$：将$S \times \Sigma\cup{\varepsilon}$映射到$2^S$的转换函数。$\forall s \in S, a \in \Sigma\cup{\varepsilon}, \delta(s, a)$表示从状态$s$出发，沿着标记为$a$的边所能到达的状态<strong>集合</strong></li>
</ul>
</li>
</ul>
<h2 id="03-RE转换为DFA"><a href="#03-RE转换为DFA" class="headerlink" title="03 RE转换为DFA"></a>03 RE转换为DFA</h2><ul>
<li><p><strong>RE -&gt; NFA</strong></p>
</li>
<li><p><strong>NFA -&gt; DFA(子集构造法)</strong>：画出转换表(值为集合)</p>
<p><img alt data-src="https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/Snipaste_2020-11-15_16-53-33.jpg" class="lozad"></p>
</li>
<li><p><strong>DFA化简</strong>：寻找一个状态数比M少的DFA M’，使得L(M)=L(M’)</p>
<ul>
<li>① 将DFA M的状态集Q分划成两个子集：终态集和非终态集；</li>
<li>② 对每个子集G，如果面对某个输入符号得到的后继状态不属于同一个子集，则将G进一步划分；<strong>(等价定义判断状态接受字符的能力)</strong></li>
<li>③ 重复②直到不再产生新划分；</li>
<li>④ 在每个子集中选一个状态作代表，消去其他状态，得到最少状态的等价DFA M’。</li>
</ul>
</li>
</ul>
<h2 id="04-FA转化为RE"><a href="#04-FA转化为RE" class="headerlink" title="04 FA转化为RE"></a>04 FA转化为RE</h2><ul>
<li><strong>FA -&gt; RE</strong><ul>
<li>引入新的开始状态和终止状态</li>
<li>消去状态</li>
</ul>
</li>
</ul>
<h2 id="05-FA与正规文法转化"><a href="#05-FA与正规文法转化" class="headerlink" title="05 FA与正规文法转化"></a>05 FA与正规文法转化</h2><ul>
<li><p><strong>FA -&gt; RG</strong></p>
<p><img alt data-src="https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/Snipaste_2020-11-15_19-13-21.jpg" class="lozad"></p>
</li>
<li><p><strong>RRG -&gt; FA</strong></p>
</li>
<li><p><strong>LRG -&gt; FA</strong></p>
</li>
</ul>
<h1 id="Ch4-语法分析——自上而下分析-LL-1"><a href="#Ch4-语法分析——自上而下分析-LL-1" class="headerlink" title="Ch4 语法分析——自上而下分析 LL(1)"></a>Ch4 语法分析——自上而下分析 LL(1)</h1><h2 id="01-概念"><a href="#01-概念" class="headerlink" title="01 概念"></a>01 概念</h2><ul>
<li><strong>问题</strong><ul>
<li>替换当前句型中的哪个非终结符</li>
<li>用该非终结符的哪个候选式<ul>
<li>多个时，遍历，回溯，效率低</li>
<li>预测分析式递归下降分析技术的一个特例，通过在输入中向前看固定个数(通常是1)符号来选择正确的A-产生式，不需要回溯</li>
<li>可以对某些文法构造出向前看k个输入符号的预测分析器，该类文法有时也称为LL(k)文法类</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="02-解题"><a href="#02-解题" class="headerlink" title="02 解题"></a>02 解题</h2><ul>
<li>改写LL(1)文法<ul>
<li>提取公共左因子</li>
<li>消去二义性 ？？卷三题四</li>
<li>消去左递归</li>
</ul>
</li>
<li>求解各非终结符的FIRST集和FOLLOW集</li>
<li>求解产生式的SELECT集，构造预测分析表</li>
</ul>
<h2 id="03-LL-1-文法"><a href="#03-LL-1-文法" class="headerlink" title="03 LL(1)文法"></a>03 LL(1)文法</h2><p>　　第一个“L”表示从左向右扫描输入，第二个“ L”表示产生最左推导，“1”表示在每一步中只需要向前看一个输入符号来决定语法分析动作。</p>
<ul>
<li><strong>S_文法(简单的确定性文法)</strong>：<ul>
<li>每个产生式的右部都以终结符开始</li>
<li>同一非终结符的各个候选式的首终结符都不同</li>
<li>不含ε产生式</li>
</ul>
</li>
<li><strong>q_文法</strong><ul>
<li>每个产生式的右部或为ε ，或以终结符开始</li>
<li>具有相同左部的产生式有不相交的可选集</li>
<li>不含右部以非终结符打头的产生式</li>
</ul>
</li>
<li><strong>LL(1)文法</strong>：G的任意两个具有相同左部的 产生式A → α | β 满足下面的条件<ul>
<li>不存在终结符a使得α 和β都能够推导出以a开头的串</li>
<li>α 和β至多有一个能推导出ε </li>
<li>如果$\beta \Rightarrow^{*} \varepsilon$，则$FIRST(\alpha) \cap F O L L O W(A)=\Phi$</li>
<li>如果$\alpha \Rightarrow^{*} \varepsilon$，则$FIRST(\beta) \cap F O L L O W(A)=\Phi$</li>
<li>同一非终结符的各个产生式的可选集互不相交</li>
</ul>
</li>
</ul>
<h2 id="04-消去二义性"><a href="#04-消去二义性" class="headerlink" title="04 消去二义性"></a>04 消去二义性</h2><ul>
<li>判断文法二义性<ul>
<li>二义性问题是不可判定的，即不存在一个算法，它能在有限步骤内，确切地判定一个文法是否为二义的</li>
<li>存在某个句子对应两棵不同的语法树(存在两个不同的最左/右推导)</li>
<li>形如<code>S -&gt; SS</code>、<code>S -&gt; iSeS | iS | i</code>、<code>S -&gt; S + S</code></li>
</ul>
</li>
<li>消去文法二义性<ul>
<li>定义规则：规定二义文法中符号的优先级和结合性，使仅产生一棵分析树</li>
<li><strong>重写文法</strong><ul>
<li>划分优先级和结合性：？？<a href="https://blog.csdn.net/sandalphon4869/article/details/103423292" target="_blank" rel="noopener">https://blog.csdn.net/sandalphon4869/article/details/103423292</a></li>
<li>引入一个新的非终结符，<strong>增加一个子结构并提高一级优先级</strong>（优先级的判断）；</li>
<li>递归非终结符在终结符左边，运算具有左结合性，否则具有右结合性</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="05-消除左递归"><a href="#05-消除左递归" class="headerlink" title="05 消除左递归"></a>05 消除左递归</h2><h3 id="a-左递归"><a href="#a-左递归" class="headerlink" title="a. 左递归"></a>a. 左递归</h3><ul>
<li>如果一个文法中有一个非终结符 A使得对某个串 α 存 在一个推导$A \Rightarrow^{+} A \alpha$，那么这个文法就是<strong>左递归</strong>的</li>
<li>一步推导是<strong>直接左递归</strong></li>
<li>经过两步或两步以上推导产生的左递归称为是<strong>间接左递归</strong> </li>
</ul>
<h3 id="b-步骤"><a href="#b-步骤" class="headerlink" title="b. 步骤"></a>b. 步骤</h3><ul>
<li><p>直接左递归消除</p>
<ul>
<li>$A \rightarrow A \alpha<em>{1}\left|A \alpha</em>{2}\right| \ldots\left|A \alpha<em>{n}\right| \beta</em>{1}\left|\beta<em>{2}\right| \ldots \mid \beta</em>{m} \left(\alpha<em>{i} \neq \varepsilon, \beta</em>{j} \right.$ 以 $A$ 开头 $)$</li>
<li>$A \rightarrow \beta<em>{1} A^{\prime}\left|\beta</em>{2} A^{\prime}\right| \ldots \mid \beta<em>{m} A^{\prime}$<br>$A^{\prime} \rightarrow \alpha</em>{1} A^{\prime}\left|\alpha<em>{2} A^{\prime}\right| \ldots\left|\alpha</em>{n} A^{\prime}\right| \varepsilon$</li>
<li><strong>代价</strong>：引进了一些非终结符和ε_​产生式</li>
</ul>
</li>
<li><p>间接左递归消除：代入后转化为直接左递归，再消除</p>
<p><img alt data-src="https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/Snipaste_2020-11-15_20-00000000000.jpg" class="lozad"></p>
</li>
</ul>
<h2 id="06-提左因子"><a href="#06-提左因子" class="headerlink" title="06 提左因子"></a>06 提左因子</h2><p>　　通过改写产生式来推迟决定，等读入了足够多的输入，获得足够信息后再做出正确的选择。</p>
<p><img alt data-src="https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/Snipaste_2020-11-15_20-52-44.jpg" class="lozad"></p>
<h2 id="07-FIRST集"><a href="#07-FIRST集" class="headerlink" title="07 FIRST集"></a>07 FIRST集</h2><ul>
<li><p><strong>串首终结符集</strong>：给定一个文法符号串α， α的串首终结符集FIRST(α)被定义为可以从α推导出的所有串首终结符构成的集合。</p>
</li>
<li><p><strong>性质</strong></p>
<ul>
<li>对于$\forall \alpha \in\left(V<em>{T} \cup V</em>{N}\right)^{+}, FIRST (\alpha)=\left{a \mid \alpha \Rightarrow^{<em>} a \beta, a \in V<em>{T}, \beta \in\left(V</em>{T} \cup V_{N}\right)^{</em>}\right}$</li>
<li>如果$\alpha \Rightarrow{ }^{*} \varepsilon$， 那么ε也在FIRST(α)中</li>
</ul>
</li>
<li><p><strong>计算文法符号X的FIRST(X)</strong></p>
<p><img alt data-src="https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/Snipaste_2020-11-15_210000.jpg" class="lozad"></p>
</li>
<li><p><strong>计算串X1X2 …Xn的FIRST 集合</strong></p>
<p><img alt data-src="https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/Snipaste_2020-11-15_21-42-24.jpg" class="lozad"></p>
</li>
</ul>
<h2 id="08-FOLLOW集"><a href="#08-FOLLOW集" class="headerlink" title="08 FOLLOW集"></a>08 FOLLOW集</h2><ul>
<li><p><strong>非终结符A的后继符号集</strong>：可能在某个句型中紧跟在A后边的终结符a的集合，记为$FOLLOW(A)=\left{a \mid S \Rightarrow^{<em>} \alpha A a \beta, a \in V<em>{T}, \quad \alpha, \beta \in\left(V</em>{T} \cup V_{N}\right)^{</em>}\right}$。如果 A是某个句型的的最右符号， 则将结束符“$”添加到FOLLOW(A)中。</p>
</li>
<li><p><strong>计算非终结符A的FOLLOW(A)</strong></p>
<p><img alt data-src="https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/Snipaste_2020-11-15_21-44-19.jpg" class="lozad"></p>
</li>
</ul>
<h2 id="09-SELECT集"><a href="#09-SELECT集" class="headerlink" title="09 SELECT集"></a>09 SELECT集</h2><ul>
<li><strong>产生式的可选集</strong>：产生式A→β的可选集是指可以选用该产生式进行推导时对应的输入符号的集合，记为SELECT( A→β )</li>
<li><strong>性质(S_文法与q_文法)</strong><ul>
<li>$\operatorname{SELECT}(A \rightarrow a \beta)={a}$</li>
<li>$\operatorname{SELECT}(A \rightarrow \varepsilon)=FOLLOW(A)$</li>
</ul>
</li>
<li><strong>性质(LL(1))</strong><ul>
<li>如果$\varepsilon \notin F I R S T(\alpha)$，那么$\operatorname{SELECT}(A \rightarrow \alpha)=\operatorname{FIRST}(\alpha)$</li>
<li>如果$\varepsilon \in F I R S T(\alpha)$，那么$\operatorname{SELECT}(A \rightarrow \alpha)=(\operatorname{FIRST}(\alpha)-{\varepsilon}) \cup FOLLOW(A)$</li>
</ul>
</li>
<li><strong>计算表达式文法各产生式的SELECT 集</strong><ul>
<li>若非终结符A打头，则SELECT(…) = FIRST(A)</li>
<li>若终结符a打头，则SELECT(…) = {a}</li>
<li>若为S -&gt; ε，则SELECT(…) = FOLLOW(S)</li>
</ul>
</li>
</ul>
<h2 id="10-预测分析表"><a href="#10-预测分析表" class="headerlink" title="10 预测分析表"></a>10 预测分析表</h2><p>根据SELECT集写出。</p>
<h1 id="Ch5-语法分析——自下而上分析-LR-0-SLR-1"><a href="#Ch5-语法分析——自下而上分析-LR-0-SLR-1" class="headerlink" title="Ch5 语法分析——自下而上分析 LR(0)+SLR(1)"></a>Ch5 语法分析——自下而上分析 LR(0)+SLR(1)</h1><h2 id="00-解题"><a href="#00-解题" class="headerlink" title="00 解题"></a>00 解题</h2><ul>
<li>判断何种规范规约文法<ul>
<li>拓广文法</li>
<li>构造识别活前缀的DFA<ul>
<li>无移进/规约冲突和规约/规约冲突，则为LR(0)</li>
<li>SLR分析表中不存在冲突，则为SLR(1)</li>
<li>SLR分析表中存在冲突，则为LR(1) (不考)</li>
</ul>
</li>
</ul>
</li>
<li>构造分析表：状态、ACTION、GOTO、终结符(含#)、非终结符(仅仅在线上的)、$s_i$(移进)、$r_j$(归约)、acc(接受)</li>
<li>输入串<em>*</em>的分析过程：步骤、状态栈(初始化为0)、符号栈(栈底为#)、当前字符、剩余字符串(以#结尾)、动作(移进、归约××、接受)</li>
</ul>
<h2 id="01-移入-归约分析"><a href="#01-移入-归约分析" class="headerlink" title="01 移入-归约分析"></a>01 移入-归约分析</h2><ul>
<li>采用最左归约方式（反向构造最右推导），每次归约的符号串称为“句柄”</li>
<li>栈内符号串 + 剩余输入 = “规范句型“</li>
<li><strong>工作过程</strong><ul>
<li>在对输入串的一次从左到右扫描过程中，语法分析器将零个或多个输入符号移入到栈的顶端，直到它可以对栈顶的一个文法符号串β进行归约为止</li>
<li>然后，它将β归约为某个产生式的左部</li>
<li>语法分析器不断地重复这个循环，直到它检测到一个语法错误，或者栈中包含了开始符号且输入缓冲区为空(当进入这样的格局时，语法分析器停止运行，并宣称成功完成了语法分析)为止</li>
</ul>
</li>
<li><strong>4种动作</strong><ul>
<li>移入：将下一个输入符号移到栈的顶端</li>
<li>归约：被归约的符号串的右端必然处于栈顶。语法 分析器在栈中确定这个串的左端，并决定用哪个非 终结符来替换这个串</li>
<li>接收：宣布语法分析过程成功完成</li>
<li>报错：发现一个语法错误，并调用错误恢复子例程</li>
</ul>
</li>
<li><strong>存在问题</strong>：错误地识别了句柄</li>
<li><strong>自底向上分析的关键问题</strong>：如何正确地识别句柄</li>
<li>句柄是逐步形成的，用“状态”表示句柄识别的进展程度；LR分析器基于这样一些状态来构造自动机进行句柄的识别<ul>
<li>移进状态</li>
<li>待约状态</li>
<li>归约状态</li>
</ul>
</li>
</ul>
<h2 id="02-LR分析法"><a href="#02-LR分析法" class="headerlink" title="02 LR分析法"></a>02 LR分析法</h2><p>　　LR文法(Knuth, 1963) 是最大的、可以构造出相应移入-归约语法分析器的文法类。L: 对输入进行从左到右的扫描；R: 反向构造出一个最右推导序列。</p>
<p>　　LR(k)分析需要向前查看k个输入符号的LR分析。k = 0 和 k = 1 这两种情况具有实践意义；当省略(k)时，表示k =1 。</p>
<h3 id="a-LR-分析器的工作过程"><a href="#a-LR-分析器的工作过程" class="headerlink" title="a. LR 分析器的工作过程"></a>a. LR 分析器的工作过程</h3><p><img alt data-src="https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/Snipaste_2020-11-15_22-53-50.jpg" class="lozad"></p>
<h3 id="b-LR-0-项目"><a href="#b-LR-0-项目" class="headerlink" title="b. LR(0) 项目"></a>b. LR(0) 项目</h3><ul>
<li><strong>定义</strong>：右部某位置标有圆点的产生式称为相应文法的一个LR(0) 项目(简称为项目)，$A \rightarrow \alpha<em>{1} \cdot \alpha</em>{2}$<ul>
<li>分类：移进项目、待约项目、归约项目</li>
<li>项目描述了句柄识别的状态</li>
<li>产生式$A→ε$ 只生成一个项目$A→ ·$</li>
</ul>
</li>
</ul>
<h3 id="c-增广文法"><a href="#c-增广文法" class="headerlink" title="c. 增广文法"></a>c. 增广文法</h3><p>　　如果G 是一个以S为开始符号的文法，则G的增广文法 G’ 就 是在G中加上新开始符号S’ 和产生式S’ → S而得到的文法。</p>
<p>　　引入这个新的开始产生式的目的是使得文法开始符号仅出现 在一个产生式的左边，从而使得分析器只有一个接受状态。</p>
<h3 id="d-文法中的项目"><a href="#d-文法中的项目" class="headerlink" title="d. 文法中的项目"></a>d. 文法中的项目</h3><ul>
<li><strong>初始项目</strong>：$S’ -&gt; \cdot S$ </li>
<li><strong>接收项目</strong>：$S’ -&gt; S \cdot$</li>
<li><strong>归约项目</strong>：圆点处于项目的末尾</li>
<li><strong>后继项目</strong><ul>
<li>同属于一个产生式的项目，但圆点的位置只相差一个符号， 则称后者是前者的后继项目</li>
<li>$A \rightarrow \alpha \cdot X \beta$ 的后继项目是 $A \rightarrow \alpha X \cdot \boldsymbol{\beta}$</li>
</ul>
</li>
<li>可以把等价的项目组成一个项目集( I ) ，称为项目集闭包 (Closure of Item Sets)，每个项目集闭包对应着自动机的一个状态</li>
<li>圆点后面有非终结符的存在等价项目</li>
</ul>
<h3 id="e-LR-0-转换图转LR-0-分析表"><a href="#e-LR-0-转换图转LR-0-分析表" class="headerlink" title="e. LR(0)转换图转LR(0)分析表"></a>e. LR(0)转换图转LR(0)分析表</h3><p><img alt data-src="https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/Snipaste_2020-11-15_23-25-39.jpg" class="lozad"></p>
<h3 id="f-冲突"><a href="#f-冲突" class="headerlink" title="f. 冲突"></a>f. 冲突</h3><ul>
<li><strong>移进/规约冲突</strong><ul>
<li>$E -&gt; T \cdot$</li>
<li>$T -&gt; T \cdot*F$</li>
</ul>
</li>
<li><strong>规约/规约冲突</strong><ul>
<li>$B -&gt; \cdot$</li>
<li>$T -&gt; \cdot$</li>
</ul>
</li>
<li>如果LR(0)分析表中没有语法分析动作冲 突，那么给定的文法就称为LR(0)文法</li>
<li>不是所有CFG都能用LR(0)方法进行分析，也就是说，CFG不总是LR(0)文法</li>
</ul>
<h3 id="g-SLR-1-消除冲突"><a href="#g-SLR-1-消除冲突" class="headerlink" title="g. SLR(1)  消除冲突"></a>g. SLR(1)  消除冲突</h3><p><img alt data-src="https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/Snipaste_2020-11-16_00-09-26.jpg" class="lozad"></p>
<p><img alt data-src="https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/Snipaste_2020-11-16_00-07-04.jpg" class="lozad"></p>
<h1 id="Ch6-属性文法和语法制导翻译-amp-Ch7-语义分析和中间代码生成"><a href="#Ch6-属性文法和语法制导翻译-amp-Ch7-语义分析和中间代码生成" class="headerlink" title="Ch6 属性文法和语法制导翻译 &amp; Ch7 语义分析和中间代码生成"></a>Ch6 属性文法和语法制导翻译 &amp; Ch7 语义分析和中间代码生成</h1><h2 id="01-语法制导翻译"><a href="#01-语法制导翻译" class="headerlink" title="01 语法制导翻译"></a>01 语法制导翻译</h2><ul>
<li><p><strong>定义</strong>：语法制导翻译使用CFG来引导对语言的翻译， 是一种面向文法的翻译技术。</p>
</li>
<li><p><strong>语法制导翻译</strong></p>
<ul>
<li>语法分析</li>
<li>语义翻译<ul>
<li>语义分析</li>
<li>中间代码生成</li>
</ul>
</li>
</ul>
</li>
<li><strong>基本思想</strong><ul>
<li>如何表示语义信息<ul>
<li>为CFG中的文法符号设置语义属性，用来表示语法成 分对应的语义信息</li>
</ul>
</li>
<li>如何计算语义属性<ul>
<li>文法符号的语义属性值是用与文法符号所在产生式 （语法规则）相关联的语义规则来计算的</li>
<li>对于给定的输入串x ，构建x的语法分析树，并利用 与 产生式（语法规则）相关联的语义规则 来计算分析树 中各结点对应的语义属性值</li>
</ul>
</li>
</ul>
</li>
<li><strong>语法制导定义(SDD)</strong><ul>
<li>SDD是对CFG的推广<ul>
<li>将每个文法符号和一个语义属性集合相关联</li>
<li>将每个产生式和一组语义规则相关联，这些规则用 于计算该产生式中各文法符号的属性值</li>
</ul>
</li>
<li>如果X是一个文法符号，a是X的一个属性，则用 X.a表示属性a在某个标号为X的分析树结点上的值</li>
<li><strong>综合属性</strong><ul>
<li>在分析树结点 N上的非终结符A的综合属性只能通 过 N的子结点或 N本身的属性值来定义</li>
<li>终结符可以具有综合属性。终结符的综合属性值是 由词法分析器提供的词法值，因此在SDD中没有计 算终结符属性值的语义规则</li>
</ul>
</li>
<li><strong>继承属性</strong><ul>
<li>在分析树结点 N上的非终结符A的继承属性只能通过 N的父结点、N的兄弟结点或 N本身的属性值来定义</li>
<li>终结符没有继承属性。终结符从词法分析器处获得的属性值被归为综合属性值</li>
</ul>
</li>
<li><strong>注释分析树</strong>： 每个节点都带有属性值的分析树</li>
<li><strong>属性文法</strong>：一个没有副作用的SDD有时也称为属性文法。属性文法的规则仅仅通过其它属性值和常量来 定义一个属性值。</li>
<li>SDD求值顺序<ul>
<li>语义规则建立了属性之间的依赖关系，在对语法 分析树节点的一个属性求值之前，必须首先求出 这个属性值所依赖的所有属性值</li>
<li><strong>依赖图</strong><ul>
<li>依赖图是一个描述了分析树中结点属性间依赖关系的有向图</li>
<li>分析树中每个标号为X的结点的每个属性a都对应着依赖图中的一个结点</li>
<li>如果属性X.a的值依赖于属性Y.b的值，则依赖图中有一条从Y.b的结点指向X.a的结点的有向边</li>
<li>如果图中没有环，那么至少存在一个拓扑排序</li>
</ul>
</li>
<li>属性值计算顺序<ul>
<li>可行的求值顺序是满足下列条件的结点序列$N_1, N_2, … , N_k$：如果依赖图中有一条从结点Ni到 Nj 的边($N_i→N_j$), 那么$i &lt; j$（即：在节点序列中，$N_i$ 排在$N_j$ 前面）</li>
<li>这样的排序将一个有向图变成了一个线性排序， 这个排序称为这个图的拓扑排序</li>
</ul>
</li>
<li>对于只具有综合属性的SDD ，可以按照任何自底向上的顺序计算它们的值</li>
<li>对于同时具有继承属性和综合属性的SDD，不能保证存在一个顺序来对各个节点上的属性进行求值</li>
</ul>
</li>
<li><strong>S-属性</strong><ul>
<li>仅仅使用综合属性的SDD称为S属性的SDD，或S-属性定义、 S-SDD</li>
<li>如果一个SDD是S属性的，可以按照语法分析树节点的任何自底向上顺序来计算它的各个属性值</li>
<li>S-属性定义可以在自底向上的语法分析过程中实现</li>
</ul>
</li>
<li><strong>L-属性</strong><ul>
<li>L-属性定义(也称为L属性的SDD或L-SDD)的 直观含义：在一个产生式所关联的各属性之间， 依赖图的边可以从左到右，但不能从右到左 (因此称为L属性的，L是Left的首字母)</li>
<li>一个SDD是L-属性定义，当且仅当它的每个属性要 么是一个综合属性，要么是满足如下条件的继承属 性：假设存在一个产生式$A \rightarrow X<em>{1} X</em>{2} \ldots X<em>{n}$，其右部符号$X</em>{i}(1 \leq i \leq n)$的继承属性仅依赖于下列属性：<ul>
<li>A的继承属性(不能是综合属性的原因：父节点的综合属性可以依赖子节点的属性(包括继承属性)，子节点的继承属性再依赖父节点的综合属性会造成循环依赖)</li>
<li>产生式中$X<em>i$左边的符号 $X_1, X_2, … , X</em>{i-1}$ 的属性</li>
<li>$X_i$本身的属性，但$X_i$ 的全部属性不能在依赖图中形成环路</li>
</ul>
</li>
<li>每个S-属性定义都是L-属性定义</li>
</ul>
</li>
</ul>
</li>
<li><strong>语法制导翻译方案(SDT)</strong><ul>
<li>SDT是在产生式右部嵌入了程序片段的CFG，这些程序片段称为语义动作。按照惯例，语义动作放在花括号内</li>
<li>基本文法可以使用LR分析技术，且SDD是S属性的；基本文法可以使用LL分析技术，且SDD是L属性的。</li>
<li><strong>将S-SDD转换为SDT</strong>：将每个语义动作都放在产生式的最后</li>
<li><strong>S-属性定义的SDT 实现</strong><ul>
<li>如果一个S-SDD的基本文法可以使用LR分析技术， 那么它的SDT可以在LR语法分析过程中实现</li>
<li>当归约发生时执行相应的语义动作</li>
<li>LR语法分析栈扩展：使用一个附加的域来存放综合属性值</li>
</ul>
</li>
<li><strong>将L-SDD转换为SDT</strong><ul>
<li>将计算某个非终结符号A的继承属性的动作插入到产生式右部中紧靠在A的本次出现之前的位置上</li>
<li>将计算一个产生式左部符号的综合属性的动作放置在这个产生式右部的最右端</li>
</ul>
</li>
<li><strong>L-属性定义的SDT 实现</strong><ul>
<li>如果一个L-SDD的基本文法可以使用LL分析技术， 那么它的SDT可以在LL或LR语法分析过程中实现</li>
</ul>
</li>
</ul>
</li>
<li><strong>SDD与SDT</strong><ul>
<li>SDD<ul>
<li>是关于语言翻译的高层次规格说明</li>
<li>隐蔽了许多具体实现细节，使用户不必显式地说明翻译发生的顺序</li>
</ul>
</li>
<li>SDT<ul>
<li>可以看作是对SDD的一种补充，是SDD的具体实施方案</li>
<li>显式地指明了语义规则的计算顺序，以便说明某些实现细节</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="02-中间代码生成"><a href="#02-中间代码生成" class="headerlink" title="02 中间代码生成"></a>02 中间代码生成</h2><ul>
<li><strong>声明语句的翻译</strong><ul>
<li>基本类型表达式</li>
<li>数组类型表达式</li>
</ul>
</li>
<li><strong>简单赋值语句的翻译</strong><ul>
<li><strong>主要任务</strong>：生成对表达式求值的三地址码</li>
</ul>
</li>
<li><strong>数组引用的翻译</strong>：不考</li>
<li><strong>控制语句的翻译</strong><ul>
<li>if </li>
<li>if-else</li>
<li>while</li>
<li>for</li>
</ul>
</li>
</ul>
<h3 id="a-S-gt-if-E-then-S1-P195"><a href="#a-S-gt-if-E-then-S1-P195" class="headerlink" title="a. S -&gt; if E then S1 P195"></a>a. S -&gt; if E then S1 P195</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">S -&gt; if E then M S1</span><br><span class="line">&#123;</span><br><span class="line">	backpatch(E.truelist, M.quad);</span><br><span class="line">	S.nextlist=merge(E.falselist, S1.nextlist);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">M -&gt; ε</span><br><span class="line">&#123; </span><br><span class="line">	M.quad = nextquad;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="b-S-gt-if-E-then-S1-else-S2"><a href="#b-S-gt-if-E-then-S1-else-S2" class="headerlink" title="b. S -&gt; if E then S1 else S2"></a>b. S -&gt; if E then S1 else S2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">S -&gt; if E then M1 S1 N else M2 S2</span><br><span class="line">&#123;</span><br><span class="line">	backpatch(E.truelist, M1.quad);</span><br><span class="line">	backpatch(E.falselist, M2.quad);</span><br><span class="line">	S.nextlist = merge( S1.nextlist, N.nextlist, S2.nextlist );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">N -&gt; ε</span><br><span class="line">&#123; </span><br><span class="line">	N.nextlist = makelist(nextquad);</span><br><span class="line">	gen(‘goto _’);//emit(&apos;j,-,-,-&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="c-S-gt-while-E-do-S1"><a href="#c-S-gt-while-E-do-S1" class="headerlink" title="c. S -&gt; while E do S1"></a>c. S -&gt; while E do S1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">S -&gt; while M1 E do M2 S1</span><br><span class="line">&#123;</span><br><span class="line">	backpatch( S1.nextlist, M1.quad );</span><br><span class="line">	backpatch( E.truelist, M2.quad );</span><br><span class="line">	S.nextlist = E.falselist;</span><br><span class="line">	gen(‘goto’ M1.quad);//emit(&apos;j,-,-,&apos;M1.quad)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="d-S-gt-for-E1-E2-E3-S1"><a href="#d-S-gt-for-E1-E2-E3-S1" class="headerlink" title="d. S -&gt; for(E1; E2; E3) S1"></a>d. S -&gt; for(E1; E2; E3) S1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="e-其他"><a href="#e-其他" class="headerlink" title="e. 其他"></a>e. 其他</h3><h1 id="Ch9-运行时存储空间组织"><a href="#Ch9-运行时存储空间组织" class="headerlink" title="Ch9 运行时存储空间组织"></a>Ch9 运行时存储空间组织</h1><ul>
<li><strong>运行存储分配策略</strong>：静态和动态分别对应 编译时刻和运行时刻<ul>
<li><strong>静态存储分配</strong>：对于那些在编译时刻就可以确定大小的数据对象，可以在编译时刻就为它们分配存储空间</li>
<li><strong>动态存储分配</strong>：反之，如果不能在编译时完全确定数据对象的大小，就要采用动态存储分配的策略。即在编译时仅产生各种必要的信息，而在运行时刻，再动态地分配数据对象的存储空间<ul>
<li>栈式存储分配</li>
<li>堆式存储分配</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Ch10-优化"><a href="#Ch10-优化" class="headerlink" title="Ch10 优化"></a>Ch10 优化</h1><h2 id="01-划分基本块"><a href="#01-划分基本块" class="headerlink" title="01 划分基本块"></a>01 划分基本块</h2><p>基本块是满足下列条件的最大的连续三地址指令序列：</p>
<ul>
<li>控制流只能从基本块的第一个指令进入该块。也就是说，没有跳转到基本块中间或末尾指令的转移指令</li>
<li>除了基本块的最后一个指令，控制流在离开基本块之前不会跳转或者停机</li>
<li>Halt？？</li>
</ul>
<p><img alt data-src="https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/Snipaste_2020-11-16_21-00-07.jpg" class="lozad"></p>
<h2 id="02-作出程序控制流图"><a href="#02-作出程序控制流图" class="headerlink" title="02 作出程序控制流图"></a>02 作出程序控制流图</h2><ul>
<li>流图的结点是一些基本块</li>
<li>从基本块B到基本块C之间有一条边当且仅当基本块C 的第一个指令可能紧跟在B的最后一条指令之后执行；此时称B是C的前驱， C是B的后继</li>
<li><strong>边的确定</strong><ul>
<li>有一个从B的结尾跳转到C的开头的条件或无条件跳转语句</li>
<li>按照原来的三地址语句序列中的顺序，C紧跟在之B 后，                                   </li>
</ul>
</li>
</ul>
<h2 id="03-基本块优化"><a href="#03-基本块优化" class="headerlink" title="03 基本块优化"></a>03 基本块优化</h2><ul>
<li><strong>DAG</strong>：很多重要的局部优化技术首先把一个基本块转换成为 一个无环有向图</li>
<li><strong>表示</strong>：基本块中的每个语句s都对应一个内部结点N<ul>
<li>结点N的标号是s中的运算符；同时还有一个定值变量表被关联到N ，表示s是 在此基本块内最晚对表中变量进行定值的语句</li>
<li>N的子结点是基本块中在s之前、最后一个对s所使用的运算分量进行定值的语 句对应的结点。如果s的某个运算分量在基本块内没有在s之前被定值，则这 个运算分量对应的子结点就是代表该运算分量初始值的叶结点(为区别起见， 叶节点的定值变量表中的变量加上下脚标0)</li>
<li>在为语句x=y+z构造结点N的时候，如果x已经在某结点M的定值变量表中，则 从M的定值变量表中删除变量x</li>
<li>对于形如x=y+z的三地址指令， 如果已经有一个结点表示y+z， 就不往DAG中增加新的结点， 而是给已经存在的结点附加 定值变量x</li>
</ul>
</li>
<li><strong>删除无用代码</strong><ul>
<li>从一个DAG上删除所有没有附加活跃变量（活跃变量是指其值可能会在以后被使用的变量）的根结点(即没有父结点的结点) 。重复应用这样的处理过程就可以从DAG 中消除所有对应于无用代码的结点</li>
</ul>
</li>
</ul>
<h2 id="04-循环优化"><a href="#04-循环优化" class="headerlink" title="04 循环优化"></a>04 循环优化</h2><ul>
<li><strong>代码外提</strong></li>
<li><strong>删除归纳变量</strong></li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Dragon Liu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://Dragonliu2018.github.io/2020/11/14/编译原理/">https://Dragonliu2018.github.io/2020/11/14/编译原理/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://Dragonliu2018.github.io">Dragon Liu</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/20161213181906073.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull-left"><a href="/2020/12/03/密码学复习/"><img class="prev_cover lozad" data-src="https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/Asymmetric_encryption_(colored).png" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>密码学</span></div></a></div><div class="next-post pull-right"><a href="/2020/11/08/图像滤波整理/"><img class="next_cover lozad" data-src="https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/1-19111613231a61.png" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>图像滤波整理</span></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = false == true ? true : false;
var verify = false == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'Pbjl2Wajl9och0xVbR5eqoH1-gzGzoHsz',
  appKey:'PgxFh1wV6pyMMllhxs7NJijb',
  placeholder:'Please leave your footprints',
  avatar:'monsterid',
  guest_info:guest_info,
  pageSize:'10',
  lang:'zh-cn',
  recordIP: true
});</script></div></div></div><footer><div id="footer"><div class="copyright">&copy;2019 - 2021 By Dragon Liu</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://dragonliu.tk">blog</a>!</div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><section class="rightside" id="rightside"><a id="to_comment" href="#post-comment"><i class="scroll_to_comment fa fa-comments"></i></a><i class="fa fa-book" id="readmode" title="阅读模式"> </i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换">繁</a><i class="nightshift fa fa-moon-o" id="nightshift" title="夜间模式"></i></section><div class=" " id="post_bottom"><div id="post_bottom_items"><a id="mobile_to_comment" href="#post-comment"><i class="mobile_scroll_to_comment fa fa-comments"></i></a><i class="fa fa-list" id="mobile_toc"></i><div id="toc_mobile"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#01-考点"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">01 考点</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#02-问题"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">02 问题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#03-课上安排"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">03 课上安排</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Ch1-引论-amp-Ch9-运行时存储空间组织"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">Ch1 引论 &amp; Ch9 运行时存储空间组织</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#0x01-目标代码与中间代码的区别和联系"><span class="toc_mobile_items-number">4.1.</span> <span class="toc_mobile_items-text">0x01 目标代码与中间代码的区别和联系</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#0x02-存储分配策略"><span class="toc_mobile_items-number">4.2.</span> <span class="toc_mobile_items-text">0x02 存储分配策略</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#01-C语言"><span class="toc_mobile_items-number">4.2.1.</span> <span class="toc_mobile_items-text">01 C语言</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#02-DISPLAY表实现嵌套过程中非局部变量访问的思想"><span class="toc_mobile_items-number">4.2.2.</span> <span class="toc_mobile_items-text">02 DISPLAY表实现嵌套过程中非局部变量访问的思想</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#03-C语言与Pascal"><span class="toc_mobile_items-number">4.2.3.</span> <span class="toc_mobile_items-text">03 C语言与Pascal</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#04-问题"><span class="toc_mobile_items-number">4.2.4.</span> <span class="toc_mobile_items-text">04 问题</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#0x03-可规约活前缀"><span class="toc_mobile_items-number">4.3.</span> <span class="toc_mobile_items-text">0x03  可规约活前缀</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#0x04-短语-直接短语-句柄"><span class="toc_mobile_items-number">4.4.</span> <span class="toc_mobile_items-text">0x04 短语+直接短语+句柄</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#0x05-编译的主要过程"><span class="toc_mobile_items-number">4.5.</span> <span class="toc_mobile_items-text">0x05 编译的主要过程</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#0x06-算符优先分析"><span class="toc_mobile_items-number">4.6.</span> <span class="toc_mobile_items-text">0x06 算符优先分析</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#01-算符优先分析同规范规约比较"><span class="toc_mobile_items-number">4.6.1.</span> <span class="toc_mobile_items-text">01 算符优先分析同规范规约比较</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#02-如何寻找“可规约串”，分析树与语法树是否一致"><span class="toc_mobile_items-number">4.6.2.</span> <span class="toc_mobile_items-text">02 如何寻找“可规约串”，分析树与语法树是否一致</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#0x07-编译各过程对符号表的操作"><span class="toc_mobile_items-number">4.7.</span> <span class="toc_mobile_items-text">0x07 编译各过程对符号表的操作</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#0x08-编译的前后端"><span class="toc_mobile_items-number">4.8.</span> <span class="toc_mobile_items-text">0x08 编译的前后端</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#0x09-其他"><span class="toc_mobile_items-number">4.9.</span> <span class="toc_mobile_items-text">0x09 其他</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Ch2-高级语言及其语法描述-上下文无关文法"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">Ch2 高级语言及其语法描述 上下文无关文法</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#01-文法分类"><span class="toc_mobile_items-number">5.1.</span> <span class="toc_mobile_items-text">01 文法分类</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#02-试题"><span class="toc_mobile_items-number">5.2.</span> <span class="toc_mobile_items-text">02 试题</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Ch3-词法分析-正规式到DFA"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text">Ch3 词法分析 正规式到DFA</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#01-正规式"><span class="toc_mobile_items-number">6.1.</span> <span class="toc_mobile_items-text">01 正规式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#02-有穷自动机-FA"><span class="toc_mobile_items-number">6.2.</span> <span class="toc_mobile_items-text">02 有穷自动机(FA)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#03-RE转换为DFA"><span class="toc_mobile_items-number">6.3.</span> <span class="toc_mobile_items-text">03 RE转换为DFA</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#04-FA转化为RE"><span class="toc_mobile_items-number">6.4.</span> <span class="toc_mobile_items-text">04 FA转化为RE</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#05-FA与正规文法转化"><span class="toc_mobile_items-number">6.5.</span> <span class="toc_mobile_items-text">05 FA与正规文法转化</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Ch4-语法分析——自上而下分析-LL-1"><span class="toc_mobile_items-number">7.</span> <span class="toc_mobile_items-text">Ch4 语法分析——自上而下分析 LL(1)</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#01-概念"><span class="toc_mobile_items-number">7.1.</span> <span class="toc_mobile_items-text">01 概念</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#02-解题"><span class="toc_mobile_items-number">7.2.</span> <span class="toc_mobile_items-text">02 解题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#03-LL-1-文法"><span class="toc_mobile_items-number">7.3.</span> <span class="toc_mobile_items-text">03 LL(1)文法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#04-消去二义性"><span class="toc_mobile_items-number">7.4.</span> <span class="toc_mobile_items-text">04 消去二义性</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#05-消除左递归"><span class="toc_mobile_items-number">7.5.</span> <span class="toc_mobile_items-text">05 消除左递归</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#a-左递归"><span class="toc_mobile_items-number">7.5.1.</span> <span class="toc_mobile_items-text">a. 左递归</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#b-步骤"><span class="toc_mobile_items-number">7.5.2.</span> <span class="toc_mobile_items-text">b. 步骤</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#06-提左因子"><span class="toc_mobile_items-number">7.6.</span> <span class="toc_mobile_items-text">06 提左因子</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#07-FIRST集"><span class="toc_mobile_items-number">7.7.</span> <span class="toc_mobile_items-text">07 FIRST集</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#08-FOLLOW集"><span class="toc_mobile_items-number">7.8.</span> <span class="toc_mobile_items-text">08 FOLLOW集</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#09-SELECT集"><span class="toc_mobile_items-number">7.9.</span> <span class="toc_mobile_items-text">09 SELECT集</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#10-预测分析表"><span class="toc_mobile_items-number">7.10.</span> <span class="toc_mobile_items-text">10 预测分析表</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Ch5-语法分析——自下而上分析-LR-0-SLR-1"><span class="toc_mobile_items-number">8.</span> <span class="toc_mobile_items-text">Ch5 语法分析——自下而上分析 LR(0)+SLR(1)</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#00-解题"><span class="toc_mobile_items-number">8.1.</span> <span class="toc_mobile_items-text">00 解题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#01-移入-归约分析"><span class="toc_mobile_items-number">8.2.</span> <span class="toc_mobile_items-text">01 移入-归约分析</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#02-LR分析法"><span class="toc_mobile_items-number">8.3.</span> <span class="toc_mobile_items-text">02 LR分析法</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#a-LR-分析器的工作过程"><span class="toc_mobile_items-number">8.3.1.</span> <span class="toc_mobile_items-text">a. LR 分析器的工作过程</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#b-LR-0-项目"><span class="toc_mobile_items-number">8.3.2.</span> <span class="toc_mobile_items-text">b. LR(0) 项目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#c-增广文法"><span class="toc_mobile_items-number">8.3.3.</span> <span class="toc_mobile_items-text">c. 增广文法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#d-文法中的项目"><span class="toc_mobile_items-number">8.3.4.</span> <span class="toc_mobile_items-text">d. 文法中的项目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#e-LR-0-转换图转LR-0-分析表"><span class="toc_mobile_items-number">8.3.5.</span> <span class="toc_mobile_items-text">e. LR(0)转换图转LR(0)分析表</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#f-冲突"><span class="toc_mobile_items-number">8.3.6.</span> <span class="toc_mobile_items-text">f. 冲突</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#g-SLR-1-消除冲突"><span class="toc_mobile_items-number">8.3.7.</span> <span class="toc_mobile_items-text">g. SLR(1)  消除冲突</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Ch6-属性文法和语法制导翻译-amp-Ch7-语义分析和中间代码生成"><span class="toc_mobile_items-number">9.</span> <span class="toc_mobile_items-text">Ch6 属性文法和语法制导翻译 &amp; Ch7 语义分析和中间代码生成</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#01-语法制导翻译"><span class="toc_mobile_items-number">9.1.</span> <span class="toc_mobile_items-text">01 语法制导翻译</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#02-中间代码生成"><span class="toc_mobile_items-number">9.2.</span> <span class="toc_mobile_items-text">02 中间代码生成</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#a-S-gt-if-E-then-S1-P195"><span class="toc_mobile_items-number">9.2.1.</span> <span class="toc_mobile_items-text">a. S -&gt; if E then S1 P195</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#b-S-gt-if-E-then-S1-else-S2"><span class="toc_mobile_items-number">9.2.2.</span> <span class="toc_mobile_items-text">b. S -&gt; if E then S1 else S2</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#c-S-gt-while-E-do-S1"><span class="toc_mobile_items-number">9.2.3.</span> <span class="toc_mobile_items-text">c. S -&gt; while E do S1</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#d-S-gt-for-E1-E2-E3-S1"><span class="toc_mobile_items-number">9.2.4.</span> <span class="toc_mobile_items-text">d. S -&gt; for(E1; E2; E3) S1</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#e-其他"><span class="toc_mobile_items-number">9.2.5.</span> <span class="toc_mobile_items-text">e. 其他</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Ch9-运行时存储空间组织"><span class="toc_mobile_items-number">10.</span> <span class="toc_mobile_items-text">Ch9 运行时存储空间组织</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Ch10-优化"><span class="toc_mobile_items-number">11.</span> <span class="toc_mobile_items-text">Ch10 优化</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#01-划分基本块"><span class="toc_mobile_items-number">11.1.</span> <span class="toc_mobile_items-text">01 划分基本块</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#02-作出程序控制流图"><span class="toc_mobile_items-number">11.2.</span> <span class="toc_mobile_items-text">02 作出程序控制流图</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#03-基本块优化"><span class="toc_mobile_items-number">11.3.</span> <span class="toc_mobile_items-text">03 基本块优化</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#04-循环优化"><span class="toc_mobile_items-number">11.4.</span> <span class="toc_mobile_items-text">04 循环优化</span></a></li></ol></li></ol></div></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script async src="/js/search/local-search.js"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script src="/js/nightshift.js"></script><script id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zindex="-1" data-click="false"></script><script color="0,0,255" opacity="0.7" zindex="-1" count="99" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/js/canvas-nest.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()

</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script>const observer = lozad(); // lazy loads elements with default selector as '.lozad'
observer.observe();</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script type="text/javascript" src="/js/dytitle.js"></script>
<script src="//code.tidio.co/tpwa8ucmrevvxpnhenh6elnstjmuuz5v.js" async></script>
<script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"superSample":2,"width":100,"height":100,"position":"left"},"mobile":{"show":false},"react":{"opacityDefault":0.9,"opacityOnHover":0.5},"log":false});</script></body></html>