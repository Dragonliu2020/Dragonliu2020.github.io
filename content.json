{"meta":{"title":"Dragon Liu","subtitle":null,"description":null,"author":"Dragon Liu","url":"https://dragonliu2022.github.io","root":"/"},"pages":[{"title":"看板","date":"2022-07-04T09:41:04.457Z","updated":"2022-07-04T09:41:04.457Z","comments":false,"path":"about/index.html","permalink":"https://dragonliu2022.github.io/about/index.html","excerpt":"","text":"联系方式：dragonliu2018@gmail.com 1 分类 目录名称 标签 C++ - Python - 03-排序 直接插入排序、希尔排序、冒泡排序、快速排序、简单选择排序、堆排序、归并排序、基数排序 04-查找 线性表查找、树结构查找、散列表查找 05-搜索 DFS、BFS、回溯法、二分 06-字符串 KMP、后缀数组、AC自动机、字典树 07-树 二叉树、多路查找树、堆、树状数组、线段树、字典树 08-图论 图的存储、最短路径、最小生成树、拓扑排序、关键路径、二分图、网络流 09-算法 贪心算法、分治算法、动态规划、背包、回溯算法、随机化算法、递归算法 10-数学 组合数学、数论、矩阵运算、概率分析、博弈论、位运算 11-技巧 前缀和、差分、双指针、打表 12-未分类 - 面试相关 面试"},{"title":"分类","date":"2022-01-20T08:24:01.513Z","updated":"2022-01-20T06:59:05.762Z","comments":false,"path":"categories/index.html","permalink":"https://dragonliu2022.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-09-13T08:58:45.000Z","updated":"2021-02-23T13:00:44.000Z","comments":true,"path":"link/index.html","permalink":"https://dragonliu2022.github.io/link/index.html","excerpt":"","text":""},{"title":"光影流年","date":"2019-09-13T08:56:36.000Z","updated":"2021-02-26T09:56:36.000Z","comments":true,"path":"gallery/index.html","permalink":"https://dragonliu2022.github.io/gallery/index.html","excerpt":"","text":"12"},{"title":"Repositories","date":"2022-01-20T06:59:05.762Z","updated":"2022-01-20T06:59:05.762Z","comments":false,"path":"repository/index.html","permalink":"https://dragonliu2022.github.io/repository/index.html","excerpt":"","text":""},{"title":"那些年，听过的音乐","date":"2022-01-24T13:08:47.234Z","updated":"2022-01-24T13:08:47.234Z","comments":true,"path":"music/index.html","permalink":"https://dragonliu2022.github.io/music/index.html","excerpt":"","text":"123&#123;% meting &quot;7429975963&quot; &quot;tencent&quot; &quot;playlist&quot; %&#125;&#123;% douban music 30121600 %&#125;"},{"title":"标签","date":"2022-01-20T06:59:05.763Z","updated":"2022-01-20T06:59:05.763Z","comments":false,"path":"tags/index.html","permalink":"https://dragonliu2022.github.io/tags/index.html","excerpt":"","text":""},{"title":"主题更新日志","date":"2019-09-13T08:58:45.000Z","updated":"2021-02-26T13:34:46.000Z","comments":true,"path":"theme/index.html","permalink":"https://dragonliu2022.github.io/theme/index.html","excerpt":"","text":"本站当前主题使用的是Hexo Butterfly TODO 博客相册页面 2021 年 02 月 2月23日： 添加菜单-主题 更改首页图片：点击查看 2月26日 解决博客加密文章本地测试通过，提交到GitHub后未通过问题，访问 https://dragonliu.tk 即可。参考：hexo-blog-encrypt 在 http 环境下无法使用的原因分析 文章加密部分使用 sweetalert 来美化错误提示。参考"}],"posts":[{"title":"Java中调用Python程序","slug":"Java中调用Python程序","date":"2022-05-29T14:28:07.000Z","updated":"2022-05-29T14:28:07.991Z","comments":true,"path":"2022/05/29/Java中调用Python程序/","link":"","permalink":"https://dragonliu2022.github.io/2022/05/29/Java中调用Python程序/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Python-列表-生成列表","slug":"Python-列表-生成列表","date":"2022-05-12T14:39:10.000Z","updated":"2022-05-12T16:59:20.484Z","comments":true,"path":"2022/05/12/Python-列表-生成列表/","link":"","permalink":"https://dragonliu2022.github.io/2022/05/12/Python-列表-生成列表/","excerpt":"","text":"1 问题 需求：生成1-10的列表；生成10个0的列表 2 解决 1234567891011121314# list方法init_list = list(range(1, 10+1)) # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]# []方法init_list = [i for i in range(1, 10+1)] # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]# 循环方法init_list = []for i in range(1, 10+1): init_list.append(i)print(init_list) # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]# 乘法init_list = [0] * 10 # [0, 0, 0, 0, 0, 0, 0, 0, 0, 0] X 参考 python------用多种方法生成1到100的列表并打印","categories":[{"name":"Python","slug":"Python","permalink":"https://dragonliu2022.github.io/categories/Python/"}],"tags":[]},{"title":"matplotlib画图出现中文乱码","slug":"matplotlib画图出现中文乱码","date":"2022-05-12T14:32:27.000Z","updated":"2022-05-12T14:35:01.118Z","comments":true,"path":"2022/05/12/matplotlib画图出现中文乱码/","link":"","permalink":"https://dragonliu2022.github.io/2022/05/12/matplotlib画图出现中文乱码/","excerpt":"","text":"1 问题描述 使用matplotlib画图，其中x和y轴标题中出现中文乱码。 2 解决 在代码前面加入： 123from pylab import *mpl.rcParams['font.sans-serif'] = ['SimHei']mpl.rcParams['axes.unicode_minus'] = False 3 参考 python中画图显示中文乱码","categories":[{"name":"环境与工具","slug":"环境与工具","permalink":"https://dragonliu2022.github.io/categories/环境与工具/"},{"name":"Python","slug":"Python","permalink":"https://dragonliu2022.github.io/categories/Python/"}],"tags":[]},{"title":"git报错之error: object file .git/objects/31/65329bb680e30595f242b7c4d8406ca63eeab0 is empty","slug":"git报错之error-object-file-git-objects-31-65329bb680e30595f242b7c4d8406ca63eeab0-is-empty","date":"2022-05-10T16:34:25.000Z","updated":"2022-05-12T14:29:06.771Z","comments":true,"path":"2022/05/11/git报错之error-object-file-git-objects-31-65329bb680e30595f242b7c4d8406ca63eeab0-is-empty/","link":"","permalink":"https://dragonliu2022.github.io/2022/05/11/git报错之error-object-file-git-objects-31-65329bb680e30595f242b7c4d8406ca63eeab0-is-empty/","excerpt":"","text":"1 问题 12error: object file .git/objects/31/65329bb680e30595f242b7c4d8406ca63eeab0 is emptyfatal: loose object 3165329bb680e30595f242b7c4d8406ca63eeab0 (stored in .git/objects/31/65329bb680e30595f242b7c4d8406ca63eeab0) is corrupt 2 解决 3 参考 git错误：对象文件为空（object-file-is-empty）解决方案 How can I fix the Git error “object file … is empty”? git status shows fatal: bad object HEAD","categories":[{"name":"环境与工具","slug":"环境与工具","permalink":"https://dragonliu2022.github.io/categories/环境与工具/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://dragonliu2022.github.io/tags/Git/"}]},{"title":"git报错之error: refs/heads/pa2 does not point to a valid object","slug":"git报错之error-refs-heads-pa2-does-not-point-to-a-valid-object","date":"2022-05-10T15:31:38.000Z","updated":"2022-05-12T14:35:27.373Z","comments":true,"path":"2022/05/10/git报错之error-refs-heads-pa2-does-not-point-to-a-valid-object/","link":"","permalink":"https://dragonliu2022.github.io/2022/05/10/git报错之error-refs-heads-pa2-does-not-point-to-a-valid-object/","excerpt":"","text":"1 问题引入 目前项目有两个分支：pa1和pa2。pa1分支没有更新到云端，需要更新；pa2分支出现问题。 目标：删除pa2分支，将pa1 push到云端。 2 解决 切换到pa1分支，git checkout pa1 提交本地pa2修改的代码，出现如下报错： 123$ git add .$ git commitfatal: could not parse HEAD 强制切换pa1分支： 1$ git checkout -f pa1 将pa1分支push到云端，出现报错： 执行下面的操作再进行push操作，成功执行 1rm .git/refs/heads/pa2 3 参考 How do I delete a local git branch when it can’t look up commit object in ‘refs/heads’? 解决git报错fatal: could not parse HEAD 【git操作】强制切换到本地某个分支","categories":[{"name":"环境与工具","slug":"环境与工具","permalink":"https://dragonliu2022.github.io/categories/环境与工具/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://dragonliu2022.github.io/tags/Git/"}]},{"title":"Python-os模块-文件(夹)操作","slug":"Python-os模块-文件-夹-操作","date":"2022-04-23T08:47:23.000Z","updated":"2022-04-24T14:31:58.911Z","comments":true,"path":"2022/04/23/Python-os模块-文件-夹-操作/","link":"","permalink":"https://dragonliu2022.github.io/2022/04/23/Python-os模块-文件-夹-操作/","excerpt":"","text":"1 判断文件(夹)是否存在 参考：Python判断文件是否存在的三种方法 os模块中的os.path.exists()方法用于检验文件是否存在。 判断文件(夹)是否存在： 123456import osos.path.exists(path)#Trueos.path.exists(path)#False 问题：如果文件夹和文件同路径+同名会出现bug。 只检查文件： 12import osos.path.isfile(\"test-data\") 2 创建目录 参考：python创建目录（文件夹） 1234567import osos.path.exists(path) # 判断一个目录是否存在os.makedirs(path) # 创建多级目录os.mkdir(path) # 创建单级目录 3 复制文件 参考：用Python复制文件的9个方法 这是运行任何系统命令的最常用方式。使用 system() 方法，你可以调用 subshell 中的任何命令。在内部，该方法将调用 C 语言的标准库函数。该方法返回该命令的退出状态。 对于 Windows 系统： 1234import osos.system('copy 1.txt.py 2.txt.py')os.system(f'copy &#123;source&#125; &#123;target&#125;') 对于 Liunx 系统： 123import osos.system('cp 1.txt.py 2.txt.py') 速度较慢，大量文件复制效果不佳。 4 路径拼接 os.path.join()函数用于路径拼接文件路径： 123456import osdir = \"xxx\"file_name = \"xxx\"path = os.path.join(dir, file_name) 5 删除文件(夹) 参考：Python中删除文件的几种方法 删除文件： 123import osos.remove(path) 注意：如果文件在之前被打开，会出现报错： 12 os.remove(file_path)PermissionError: [WinError 32] 另一个程序正在使用此文件，进程无法访问。: 'data3\\\\dataset\\\\test\\\\Benign\\\\4447.txt' 所以删除前要关闭文件： 1234file_path = os.path.join(type_dir, name)f = open(file_path, \"r\")f.close()os.remove(file_path) 删除目录：Python中的os.remove()方法用于删除文件路径。此方法无法删除目录。如果指定的路径是目录，则该方法将引发OSError。可以使用下面代码删除目录： 123import osos.rmdir(dir_path)","categories":[{"name":"Python","slug":"Python","permalink":"https://dragonliu2022.github.io/categories/Python/"}],"tags":[]},{"title":"pylab.show()或plt.show()报错","slug":"pylab-show-或plt-show-报错","date":"2022-04-22T12:04:21.000Z","updated":"2022-04-22T12:11:51.525Z","comments":true,"path":"2022/04/22/pylab-show-或plt-show-报错/","link":"","permalink":"https://dragonliu2022.github.io/2022/04/22/pylab-show-或plt-show-报错/","excerpt":"","text":"1 pylab.show()问题 最近使用实验室的机子进行模型训练，发生报错： 12XIO: fatal IO error 0 (Success) on X server \"localhost:13.0\" after 355 requests (355 known processed) with 2 events remaining. 定位代码： 1pylab.show() 原因：机子没有界面，导致显示失败。 解决：只需将图片保存，而非显示。 12# pylab.show()pylab.savefig('./data/net_pic/textcnn_100_0.001_300.jpg') 2 plt.show()问题 之前一个同学也遇到了类似的报错： 12UserWarning: Matplotlib is currently using agg, which is a non GUI backend, so cannot show the figure.plt.show() 定位代码： 1plt.show() 解决方法： 12# plt.show()plt.savefig('./data/net_pic/textcnn_100_0.001_300.jpg') X 参考 python matplotlib 画图保存图片简单例子","categories":[{"name":"环境与工具","slug":"环境与工具","permalink":"https://dragonliu2022.github.io/categories/环境与工具/"}],"tags":[]},{"title":"Pycharm远程开发","slug":"PyCharm远程开发","date":"2022-04-21T14:22:11.000Z","updated":"2022-04-24T15:18:34.516Z","comments":true,"path":"2022/04/21/PyCharm远程开发/","link":"","permalink":"https://dragonliu2022.github.io/2022/04/21/PyCharm远程开发/","excerpt":"","text":"1 引入 最近跑深度学习模型，自己的笔记本吃不消了，于是打算使用实验室的机子。为了提高开发效率，使用PyCharm进行远程开发。 2 查看远程环境 使用MobaXterm软件登陆实验室的机子，并将代码+数据集上传至指定位置；（其实这一步可以不做，在后面使用PyCharm进行同步） 查看机子的系统：Centos7 12345678910111213141516$ cat /etc/os-releaseNAME=\"CentOS Linux\"VERSION=\"7 (Core)\"ID=\"centos\"ID_LIKE=\"rhel fedora\"VERSION_ID=\"7\"PRETTY_NAME=\"CentOS Linux 7 (Core)\"ANSI_COLOR=\"0;31\"CPE_NAME=\"cpe:/o:centos:centos:7\"HOME_URL=\"https://www.centos.org/\"BUG_REPORT_URL=\"https://bugs.centos.org/\"CENTOS_MANTISBT_PROJECT=\"CentOS-7\"CENTOS_MANTISBT_PROJECT_VERSION=\"7\"REDHAT_SUPPORT_PRODUCT=\"centos\"REDHAT_SUPPORT_PRODUCT_VERSION=\"7\" 3 配置远程Python环境 发现机子是使用conda管理python的，查看系统中的所有环境： 12345(base) [ccyin@localhost Malware-Detection]$ conda info -e# conda environments:#base * /home/ccyin/miniconda3junxuan /home/ccyin/miniconda3/envs/junxuan 创建环境，名称为malware： 12conda create --name malware python=3.9# 指定Python版本是3.9（不用管是3.9.x，conda会为我们自动寻找3.9.x中的最新版本） 激活环境： 12(base) [ccyin@localhost Malware-Detection]$ source activate malware(malware) [ccyin@localhost Malware-Detection]$ 命令行前出现(malware)证明成功激活malware环境 查看python版本： 12(malware) [ccyin@localhost Malware-Detection]$ python --versionPython 3.9.12 安装一些库： 123pip install torchpip install torchvisionpip install d2l 查看已经安装的库： 1conda list 4 本地代码备份 后期本地与服务器的代码同步，以防万一，把本地代码整到GitHub上。 在项目主目录生成空版本库； 由于数据集占空间较大，不上传云端，所以新建.gitignore将一些文件夹进行忽略： 1234.idea__pycache__datamodel Github上新建仓库，然后将本地代码push上去。 5 配置PyCharm 将本地的Python Interperter更换为远端的，新建python解释器，选择SSH Interpreter，输入IP+用户名+密码： 查找conda虚拟环境malware中的解释器：（3 配置远程Python环境中已经创建好malware虚拟环境） 首先确定虚拟环境malware的目录：/home/ccyin/miniconda3/envs/malware 12345$ conda info -e# conda environments:#base /home/ccyin/miniconda3malware * /home/ccyin/miniconda3/envs/malware 然后点开bin，选择python（注意是python不是python3） 选择好解释器之后，就要确定项目在服务器上的同步路径，默认是在/tmp/下的文件夹中，现在修改为之前上传的目录： 12(malware) [ccyin@localhost Malware-Detection]$ pwd/home/ccyin/zhenlong/Malware-Detection 点击确定后，然后在Collectiong files...和Uploading xxx，应该是更新远端文件，因为数据集中有许多文件，所以比较慢；（这样看来，之前上传代码+数据集显得多此一举🥦） 更新完毕后，可以从右边“remote host”中看到服务器上的文件，而且标绿了，表示其为我们对应的同步路径： 要对该文件进行修改时，注意一定要先Download下来，不可直接双击点开。Remote Host里的文件，当你执行非打开操作的时候，所指代的都是服务器上的文件，比如你可以从这里选择下载，进行比对操作等。但是当你从Remote Host双击打开文件时，这时打开的就不是服务器上的，而是一个镜像文件。所以如果直接修改从Remote Host双击打开的文件，修改是无效的。一定要先下载下来，进行修改，然后再上传过去。（第7步设置自动同步，这样本地的修改会自动上传至远端，但是在远端修改或添加删除文件，不会影响本地） 确保工具栏中的Tools/Deployment/Automatic Upload前面有对勾（默认有），这样以来，在本地的修改会自动同步到服务器上，我不需要手动进行上传。 此外，如果运行python文件需要使用到命令行参数的时候，可以在Configurations中进行增加： 6 后台运行py脚本 训练脚本耗时长，使用pycharm直接运行脚本，可能会因为笔记本息屏、断网等因素而中断，所以考虑将脚本挂在后台运行。 使用MobaXterm登陆远程主机； 切换到项目目录并激活虚拟机环境； 后台运行脚本： 1234(malware) [ccyin@localhost Malware-Detection]$ nohup python -u train_textcnn.py &gt; textcnn.log 2&gt;&amp;1 &amp;[1] 46583(malware) [ccyin@localhost Malware-Detection]$ nohup python -u train_rnn.py &gt; rnn.log 2&gt;&amp;1 &amp;[2] 46823 检查下后台是否运行： 1234(malware) [ccyin@localhost Malware-Detection]$ ps aux|grep python...ccyin 46583 70.4 4.3 67868816 11451892 pts/13 Rl 14:20 1:47 python -u train_textcnn.pyccyin 46823 129 0.8 41704128 2243816 pts/13 Rl 14:23 0:09 python -u train_rnn.py 此时后台成功运行，笔记本断网、关机都不会影响脚本的运行。 7 取消后台运行 确定运行脚本的进程ID(6.3中已经给出ID)，也可以通过下面的命令获取： 1234(malware) [ccyin@localhost Malware-Detection]$ ps aux|grep python...ccyin 46583 70.4 4.3 67868816 11451892 pts/13 Rl 14:20 1:47 python -u train_textcnn.pyccyin 46823 129 0.8 41704128 2243816 pts/13 Rl 14:23 0:09 python -u train_rnn.py 杀掉进程： 12$ kill -9 46583$ kill -9 46823 X 参考 Git忽略文件.gitignore的使用 Conda使用指南 PyCharm远程开发的配置与流程 linux 下后台运行python脚本 nohup后台python3程序及关闭","categories":[{"name":"环境与工具","slug":"环境与工具","permalink":"https://dragonliu2022.github.io/categories/环境与工具/"}],"tags":[]},{"title":"MySQL-错误1153：max_allowed_packet","slug":"MySQL-错误1153：max_allowed_packet","date":"2022-04-20T06:53:01.000Z","updated":"2022-04-20T07:01:05.376Z","comments":true,"path":"2022/04/20/MySQL-错误1153：max_allowed_packet/","link":"","permalink":"https://dragonliu2022.github.io/2022/04/20/MySQL-错误1153：max_allowed_packet/","excerpt":"","text":"1 问题 编码过程中，有个字段使用TEXT无法存储，改用TEXT(65536) 后成功存储，但是导入mysql时报错： 1sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (1153, \"Got a packet bigger than 'max_allowed_packet' bytes\") 原因：TEXT(65536)为16M，超过了上限max_allowed_packet。 2 解决 修改max_allowed_packet值即可，在Mysql命令行运行： 12345mysql&gt; set global net_buffer_length=1000000; Query OK, 0 rows affected (0.00 sec)mysql&gt; set global max_allowed_packet=1000000000;Query OK, 0 rows affected (0.00 sec) 3 参考 MySQL Error 1153 - Got a packet bigger than ‘max_allowed_packet’ bytes","categories":[{"name":"Python","slug":"Python","permalink":"https://dragonliu2022.github.io/categories/Python/"},{"name":"数据库","slug":"数据库","permalink":"https://dragonliu2022.github.io/categories/数据库/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://dragonliu2022.github.io/tags/MySQL/"}]},{"title":"C++新标准","slug":"C++新标准","date":"2022-04-19T05:58:58.000Z","updated":"2022-04-19T06:02:00.154Z","comments":true,"path":"2022/04/19/C++新标准/","link":"","permalink":"https://dragonliu2022.github.io/2022/04/19/C++新标准/","excerpt":"","text":"《面向对象C++程序设计》皮德常 编著 清华大学出版社 2017 《C++ Primer Plus (第6版)中文版》Stephen Prata 著 张海龙 袁国忠 译 人民邮电出版社 2012 1 C++11 的新特性 核心特性：智能指针、右值引用、移动语义、完美转发、lambda 表达式（必答） 其它特性：auto、decltype、long long、函数返回类型自动推导、删除函数、列表初始化、nullptr、using 声明、限定作用域的枚举类型、const_iterator、override 声明、noexcept 声明、constexpr、范围 for 循环 2 智能指针 C++11 中引入了智能指针的概念，方便管理堆内存。 智能指针是利用了一种叫做 RAII（资源获取即初始化）的技术对普通的指针进行封装，这使得智能指针实质是一个对象，行为表现的却像一个指针。 智能指针的作用是防止忘记调用delete释放内存和程序异常的进入catch块忘记释放内存。另外指针的释放时机也是非常有考究的，多次释放同一个指针会造成程序崩溃，这些都可以通过智能指针来解决。 智能指针还有一个作用是把值语义转换成引用语义。 unique_ptr：实现的是专属所有权的语义，它是智能指针的默认选项。unique_ptr 是个只移型别，不能复制或共享。unique_ptr 小巧高效，大小等同于一个指针且支持右值引用，从而可实现快速插入和对 STL 集合的检索。 shared_ptr：采用引用计数的智能指针。如果你想要将一个裸指针分配给多个所有者，请使用该指针。直至所有 shared_ptr 所有者超出了范围或放弃所有权，才会删除裸指针。大小为两个裸指针：一个用于指向裸指针指向的对象，另一个用于指向包含引用计数的共享控制块。 weak_ptr ：结合 shared_ptr 使用的特例智能指针。 weak_ptr 提供对一个或多个 shared_ptr 实例拥有的对象的访问，但不参与引用计数。如果你想要观察某个对象但不需要其保持活动状态，请使用该实例。在某些情况下，用于断开 shared_ptr 实例间的循环引用。 https://www.cnblogs.com/wxquare/p/4759020.html 3 右值引用 左值和右值的概念 值引用的目的是为了延长用来初始化对象的生命周期。 https://zhuanlan.zhihu.com/p/54050093 4 移动语义 将内存的所有权从一个对象转移到另外一个对象，高效的移动用来替换效率低下的复制，对象的移动语义需要实现移动构造函数（move constructor）和移动赋值运算符（move assignment operator）。 5 完美转发 定义一个函数模板，该函数模板可以接收任意类型参数，然后将参数转发给其它目标函数，且保证目标函数接受的参数其类型与传递给模板函数的类型相同。 6 lambda 表达式 利用Lambda表达式，可以方便的定义和创建匿名函数。 https://www.cnblogs.com/DswCnblog/p/5629165.html","categories":[{"name":"C++","slug":"C","permalink":"https://dragonliu2022.github.io/categories/C/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://dragonliu2022.github.io/tags/面试/"}]},{"title":"C++编译与底层","slug":"C++编译与底层","date":"2022-04-19T05:58:45.000Z","updated":"2022-04-19T06:03:35.217Z","comments":true,"path":"2022/04/19/C++编译与底层/","link":"","permalink":"https://dragonliu2022.github.io/2022/04/19/C++编译与底层/","excerpt":"","text":"《面向对象C++程序设计》皮德常 编著 清华大学出版社 2017 《C++ Primer Plus (第6版)中文版》Stephen Prata 著 张海龙 袁国忠 译 人民邮电出版社 2012 1 栈区和堆区的区别 申请方式 栈区：由编译器自动分配释放，存放函数的参数值，局部变量值等； 堆区：一般由程序员分配释放（使用new/delete或malloc/free），若程序员不释放，程序结束时可能由OS回收。 操作方式 栈区：操作方式类似于数据结构中的栈； 堆区：不同于数据结构中的堆，分配方式类似于链表。 申请后系统的响应 栈区：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出； 堆区：操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。 申请大小的限制 栈区：在Windows下，栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。 堆区：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。 申请效率的比较 栈区：系统自动分配，速度较快。但程序员是无法控制的。 堆区：由new分配的内存，一般速度比较慢，而且容易产生内存碎片，不过用起来最方便. 堆和栈中的存储内容 栈区：在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。 堆区：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。 2 C语言程序从源代码到二进制行程序都经历了那些过程？ https://www.cnblogs.com/CarpenterLee/p/5994681.html 预处理(Preprocessing)：预处理用于将所有的#include头文件以及宏定义替换成其真正的内容，预处理之后得到的仍然是文本文件，但文件体积会大很多。gcc的预处理是预处理器cpp来完成的； 编译(Compilation)：将经过预处理之后的程序转换成特定汇编代码(assembly code)的过程；命令中-S让编译器在编译之后停止，不进行后续过程。 汇编(Assemble)：将上一步的汇编代码转换成机器码(machine code)，这一步产生的文件叫做目标文件，是二进制格式。gcc汇编过程通过as命令完成。 链接(Linking)：链接过程将多个目标文以及所需的库文件(.so等)链接成最终的可执行文件(executable file)。 3 C/C++的内存分配方式 3.1 C 栈(stack) 由编译器自动分配、翻译。存放函数的参数值和局部变量值。操作方式类似数据结构中的栈 堆(heap) 由程序员分配释放。程序员不释放，程序结束时有可能由OS释放。与数据结构中的堆不同，操作方式类似于链表 bss 存放未初始化的全局变量和静态变量 数据段data 存放初始化之后的全局变量、静态变量和常量 代码段text 程序代码主体，函数主体等。注意为二进制格式 3.2 C++ 栈 堆 全局/静态存储区 常量存储区 程序代码区 4 int 有几个字节？ C语言标准规定了每种数据类型的最小取值范围，例如int类型至少应为16位(2字节)，int类型数据具体的取值范围则由ABI规范规定。通常，int型在16位机器中为16位，在32位和64位机器中都为32位。(计组课本P42) ABI指应用二进制接口，规定了二进制程序两个模块之间或者二进制程序与操作系统之间的接口。 2 或 4 个字节，具体取决于编译器。千万不要直接答4个字节 5 内存对齐的原则 从0位置开始存储；变量存储的起始位置是该变量大小的整数倍；结构体总的大小是其最大元素的整数倍，不足的后面要补齐。 数据成员对齐规则：结构体的数据成员，第一个数据成员放在offset为0的地方，之后的每个数据成员存储的起始位置要从该成员大小的整数倍开始（比如int在32位机子上为4字节，所以要从4的整数倍地址开始存储）。 结构体作为成员：如果一个结构体里同时包含结构体成员，则结构体成员要从其内部最大元素大小的整数倍地址开始存储（如struct a里有struct b，b里有char,int,double等元素，那么b应该从8(即double类型的大小)的整数倍开始存储）。 结构体的总大小：即sizeof的结果。在按之前的对齐原则计算出来的大小的基础上，必须还得是其内部最大成员的整数倍，不足的要补齐（如struct里最大为double，现在计算得到的已经是11，则总大小为16）。 6 main 函数执行以前，还会执行什么代码？ 全局对象的构造函数会在 main 函数之前执行。 7 空类编译器会自动生成哪些函数 默认构造函数、析构函数、拷贝构造函数、赋值函数。","categories":[{"name":"C++","slug":"C","permalink":"https://dragonliu2022.github.io/categories/C/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://dragonliu2022.github.io/tags/面试/"}]},{"title":"C++STL","slug":"C++STL","date":"2022-04-19T05:58:31.000Z","updated":"2022-04-19T06:04:03.386Z","comments":true,"path":"2022/04/19/C++STL/","link":"","permalink":"https://dragonliu2022.github.io/2022/04/19/C++STL/","excerpt":"","text":"《面向对象C++程序设计》皮德常 编著 清华大学出版社 2017 《C++ Primer Plus (第6版)中文版》Stephen Prata 著 张海龙 袁国忠 译 人民邮电出版社 2012 1 C++容器类的底层实现 以下分别用K、T指代泛型参数。 C++ 特点 底层数据结构 T 变量名[数值]、array&lt;T,数值&gt; 固定大小数组。支持快速随机访问，不能添加和删除元素 普通数组 vector&lt;T&gt; 可变大小数组。支持快速随机访问，在尾部之外的位置插入或删除元素可能很慢 数组 list&lt;T&gt; 双向循环链表。只支持双向顺序访问，在任何位置进行插入删除操作都很快 链表 forward_list&lt;T&gt; 单向链表。只支持单向顺序访问，在任何位置进行插入删除操作都很快 链表 stack&lt;T&gt; 栈。后进先出容器 数组或链表 queue&lt;T&gt; 队列。先进先出容器 数组或链表 deque&lt;T&gt; 双端队列。支持首尾快速增删，也支持随机访问 底层数据结构为一个中央控制器和多个缓冲区 priority_queue&lt;T&gt; 优先级队列。队列中的元素具有优先级，优先级最高的元素位于队首，队首元素可以弹出队列 二叉大根堆 unordered_set&lt;T&gt; 集合。关键字无序且不可重复出现 哈希表 set&lt;T&gt; 集合。关键字有序且不可重复出现 红黑树 unordered_map&lt;K,T&gt; 关联数组。保存键值对，键值对无序且键不可重复出现 哈希表 map&lt;K,T&gt; 关联数组。保存键值对，键值对有序且键不可重复出现 红黑树 注意 stack、queue、priority_queue 均为容器适配器。stack 和 queue 底层一般用 list 或 deque 实现，不用 vector 的原因应该是容量大小有限制，扩容耗时。priority_queue 一般用 vector 作底层容器。 2 unordered_map 和 map 区别 map 内部实现了一个红黑树（红黑树是非严格平衡二叉搜索树，而 AVL 是严格平衡二叉搜索树），因此 map 内部的所有元素都是有序的，存取一个元素时间复杂度是 O(logn) unordered_map 内部实现了一个哈希表，其元素的排列顺序是无序的，取一个元素时间复杂度是 O(1) 3 红黑树 红黑树是一颗满足如下性质的二叉查找树： 每个结点或者为黑色或者为红色； 根结点为黑色； 每个叶节点为黑色； 如果一个结点为红色，那么他的两个子结点为黑色； 对于每个结点，从该节点到其所有子孙叶结点的路径中，所包含的黑色结点数量必须相同。 红黑树的每个结点的属性除了有一个key、3个指针(parent、lchild、rchild)以外，还有个color属性。 通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍。 4 vector 和 list 区别 5 vector 扩容原理 6 迭代器失效问题 7 使用 map 的使用不是基础数据类型需要重载什么运算符 8 list 和 map 的区别 9 二叉搜索树、平衡二叉树和红黑树的区别 https://zhuanlan.zhihu.com/p/258078863","categories":[{"name":"C++","slug":"C","permalink":"https://dragonliu2022.github.io/categories/C/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://dragonliu2022.github.io/tags/面试/"}]},{"title":"C++模板","slug":"C++模板","date":"2022-04-19T05:58:21.000Z","updated":"2022-04-19T06:00:54.287Z","comments":true,"path":"2022/04/19/C++模板/","link":"","permalink":"https://dragonliu2022.github.io/2022/04/19/C++模板/","excerpt":"","text":"《面向对象C++程序设计》皮德常 编著 清华大学出版社 2017 《C++ Primer Plus (第6版)中文版》Stephen Prata 著 张海龙 袁国忠 译 人民邮电出版社 2012 1 模版特化 模板特化分为全特化和偏特化，模板特化的目的就是对于某一种变量类型具有不同的实现，因此需要特化版本。 模板偏特化（Template Partitial Specialization）是模板特化的一种特殊情况，指显示指定部分模板参数而非全部模板参数，或者指定模板参数的部分特性而非全部特性，也称为模板部分特化。与模板偏特化相对的是模板全特化，指对所有的模板参数进行特化。模板全特化与模板偏特化共同组成模板特化。 模板偏特化主要分为两种，一种是指对部分模板参数进行全特化，另一种是对模板参数特性进行特化，包括将模板参数特化为指针、引用或是另外一个模板类。","categories":[{"name":"C++","slug":"C","permalink":"https://dragonliu2022.github.io/categories/C/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://dragonliu2022.github.io/tags/面试/"}]},{"title":"C++类","slug":"C++类","date":"2022-04-19T05:57:56.000Z","updated":"2022-04-19T06:00:34.134Z","comments":true,"path":"2022/04/19/C++类/","link":"","permalink":"https://dragonliu2022.github.io/2022/04/19/C++类/","excerpt":"","text":"《面向对象C++程序设计》皮德常 编著 清华大学出版社 2017 《C++ Primer Plus (第6版)中文版》Stephen Prata 著 张海龙 袁国忠 译 人民邮电出版社 2012 1 构造函数与析构函数 1.1 构造函数定义或作用 初始化类对象的数据成员。 即类的对象被创建的时候，编译系统对该对象分配内存空间，并自动调用构造函数，完成类成员的初始化。 构造函数的特点：以类名作为函数名，无返回类型。 常见的构造函数有三种写法： 无参构造函数 如果创建一个类，没有写任何构造函数，则系统会自动生成默认的无参构造函数，且此函数为空。 默认构造函数（default constructor）就是在没有显式提供初始化式时调用的构造函数。如果定义某个类的变量时没有提供初始化时就会使用默认构造函数。 一般构造函数 复制构造函数 复制构造函数，也称为拷贝构造函数。复制构造函数参数为类对象本身的引用，根据一个已存在的对象复制出一个新的对象，一般在函数中会将已存在对象的数据成员的值复制一份到新创建的对象中。 注意：若没有显示定义复制构造函数，则系统会默认创建一个复制构造函数，当类中有指针成员时，由系统默认创建的复制构造函数会存在“浅拷贝”的风险，因此必须显示定义复制构造函数。 浅拷贝指的是在对对象复制时，只对对象中的数据成员进行简单的赋值，若存在动态成员，就是增加一个指针，指向原来已经存在的内存。这样就造成两个指针指向了堆里的同一个空间。当这两个对象生命周期结束时，析构函数会被调用两次，同一个空间被两次free，造成野指针。 深拷贝就是对于对象中的动态成员，不是简单的赋值，而是重新分配空间。 C++的构造函数可以有多个，创建对象时编译器会根据传入的参数不同调用不同的构造函数。 1.2 析构函数定义或作用 C++析构函数概述 C++析构函数是一个特殊的成员函数，它的名字是类名的前面加一个～符号，作用与构造函数相反，当对象的生命期结束时，会自动执行析构函数。 C++执行析构函数的情况 如果在一个函数中定义了一个对象，当这个函数被调用结束时，对象应该释放，在对象释放前自动执行析构函数。 static局部对象在函数调用结束时对象并不释放，因此也不调用析构函数，只在main函数结束调用exit函数结束程序时，才调用static局部对象的析构函数。 如果定义了一个全局对象，则在程序的流程离开其作用域时，调用该全局对象的析构函数。 如果用new运算符动态地建立了一个对象，当用delete运算符释放该对象时，先调用该对象的析构函数。 C++析构函数详解 析构函数的作用并不是删除对象，而是在撤销对象占用的内存之前完成一些清理工作，使这部分内存可以被程序分配给新对象使用。 析构函数不返回任何值，没有函数类型，也没有函数参数，因此不能重载，一个类可以有多个构造函数，但只能有一个析构函数。 析构函数的作用并不仅限于释放资源方面，它还可以被用来执行程序员希望在最后一次使用对象之后所执行的任何操作。 如果没有定义析构函数，C++编译系统会自动生成一个析构函数，但它只是徒有析构函数的名称和形式，实际上什么都不执行，要想让析构函数执行，必须在定义的析构函数中指定。 1.3 C++类内静态成员的内存释放问题 C/C++中静态成员变量存放在全局内存的静态区域，因此，我们虽然delete掉了这个类，但是并不代表我们真的释放掉了类内静态成员的内存，这些静态成员的内存会在整个进程退出的时候由系统回收。 1.4 构造析构顺序 存在继承关系时，先执行父类的构造函数，再执行子类的构造函数；析构的时候恰好相反：先调用派生类的析构函数、然后调用基类的析构函数。 当一个类中含有对象成员时，在启动本类的构造函数之前，先分配对象空间，按对象成员的声明顺序执行他们各自的构造函数，再执行本类的构造函数。 对于非静态的局部对象，他们的析构函数的执行顺序与构造函数相反。 构造：父类-&gt;对象成员&gt;子类 1.5 析构函数能抛出异常吗? C++标准指明析构函数不能、也不应该抛出异常。 如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题。 通常异常发生时，c++的机制会调用已经构造对象的析构函数来释放资源，此时若析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃的问题。 1.6 调用拷贝构造函数的情况 用对象初始化同类的另一个对象 函数形参是对象，当进行参数传递时将调用copyconstruct 函数返回值是对象，函数执行结束时，将调用拷贝构造函数对无名临时对象初始化 2 多态与虚函数 2.1 多态性 多态性指&quot;一个接口，多种方法&quot;。C++支持两种多态性：编译时多态性，运行时多态性。 编译时多态性(静态多态)：通过重载函数和泛型编程实现 运行时多态性(动态多态)：通过虚函数实现 静态与动态的实质区别就是函数地址是早绑定还是晚绑定。 如果函数的调用，在编译器编译期间就可以确定函数的调用地址，并生产代码，是静态的，就是说地址是早绑定的。 而如果函数调用的地址不能在编译器期间确定，需要在运行时才确定，这就属于晚绑定。 2.2 动态绑定的概念 动态绑定是指在运行时（非编译期）将过程调用与相应代码链接起来的过程称为动态绑定。 C中，通过基类的引用或指针调用虚函数时，发生动态绑定。C中动态绑定是通过虚函数实现的，而虚函数是通过一张虚函数表实现的。这个表中记录了虚函数的地址，保证动态绑定时能够根据对象的实际类型调用正确的函数。编译器必须保证虚函数表的指针存在于对象实例中最前面的位置（这是为了保证正确取到虚函数的偏移量）。这意味着我们通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。 2.3 虚函数和纯虚函数 用 virtual 关键字修饰的成员函数就是虚函数，虚函数的作用就是实现多态性。纯虚函数是一种特殊的虚函数，在基类中不能对虚函数给出有意义的实现，而把它的实现留给派生类去做。只含有虚函数的类可以被实例化，含有纯虚函数的类不能被实例化。 注意： 只有类的成员函数才能声明为虚函数，虚函数仅适用于有继承关系的类对象。普通函数不能声明为虚函数。 静态成员函数不能是虚函数，因为静态成员函数不受限于某个对象。 内联函数（inline）不能是虚函数，因为内联函数不能在运行中动态确定位置。 构造函数不能是虚函数。 析构函数可以是虚函数，而且建议声明为虚函数。 2.4 C++类中定义虚函数和不定义在初始化的时候大小是不是一样？ 定义了虚函数的类要大一些，因为要建立虚函数表 2.5 构造函数能不能声明成虚函数？ 不能。 当创建一个派生类对象时，会先调用基类的构造函数，但是派生类已经覆盖了基类的构造函数，所以也就无法进一步执行，导致程序出错。 在创建对象时，首先要调用构造函数，然后构造函数是虚函数，就需要用虚函数指针去调用，但是，对象都还没构造，也就没有虚函数指针，造成了一个循环调用的问题。 2.6 基类的析构函数不是虚函数，会带来什么问题？ delete 指向派生类对象的基类指针时，只有基类的内存被释放，派生类的没有。这样就内存泄漏了。 2.7 构造函数和析构函数中调用虚函数吗？ 从语法上讲，调用完全没有问题。但是从效果上看，往往不能达到多态的效果。 Effective C的解释是：派生类对象的基类成分会在派生类自身成分被构造之前先构造妥当，派生类对象构造期间会首先进入基类的构造函数，在基类构造函数执行时继承类的成员变量尚未初始化，对象类型是基类类型，而不是派生类类型，虚函数会被编译器解析为基类，若使用运行时类型信息，也会把对象视为基类类型，构造期间调用虚函数，会调用自己的虚函数，此时虚函数和普通函数没有区别了，达不到多态的效果。 同样，进入基类析构函数时，对象也是基类类型。C中派生类在构造时会先调用基类的构造函数再调用派生类的构造函数，析构时则相反，先调用派生类的析构函数再调用基类的析构函数。一旦派生类析构函数运行，这个对象的派生类数据成员就被视为未定义的值，所以 C++ 就将它们视为不再存在。假设一个派生类的对象进行析构，首先调用了派生类的析构，然后再调用基类的析构时，遇到了一个虚函数，这个时候有两种选择： 编译器调用这个虚函数的基类版本，那么虚函数则失去了运行时调用正确版本的意义； 编译器调用这个虚函数的派生类版本，但是此时对象的派生类部分已经完成析构，“数据成员就被视为未定义的值”，这个函数调用会导致未知行为。 2.8 重载(overload)和重写(overried，有的书也叫做“覆盖”)的区别？ 重载：是指允许存在多个同名函数，而这些函数的参数列表不同 重写：是指派生类重新定义基类虚函数的方法。 2.9 虚函数表存放的内容以及在内存中的位置 每个对象里有虚(函数表)指针，指向虚函数表，虚函数表里存放了虚函数的地址。虚函数表是顺序存放虚函数地址的，不需要用到链表。 还有类的类型信息，在《深度探索C++对象模型》中有提到 C中**虚函数表位于只读数据段（.rodata），也就是C内存模型中的常量区；而虚函数则位于代码段（.text），也就是C++内存模型中的代码区。** 2.10 如果虚函数非常有效，我们是否可以把每个函数都声明为虚函数？ 不行，这是因为虚函数是有代价的： 由于每个虚函数的对象都必须维护一个虚函数表，因此在使用虚函数的时候会产生一个系统开销。如果仅是一个很小的类，且不想派生其他类，那么根本没必要使用虚函数。 虚函数效率低。因为虚函数需要一次间接的寻址，而一般的函数可以在编译时定位到函数的地址。虚函数(动态类型调用)是要根据某个指针定位到函数的地址。多增加了一个过程，效率肯定会低一些，但带来了运行时的多态。 3 继承 3.1 继承的概念 派生类可以具有基类的特性，共享基类的成员函数，使用基类的数据成员，还可以定义自己的数据成员和函数成员。从一个基类派生的称为单继承，从多个基类派生的称为多继承。 C++中，继承方式有 3 种： 公有继承：public、protected、private 权限均不变 私有继承：public、protected 权限变为 private 保护继承：public 变为 protected 实现的访问控制如下： public：自己、友元、派生类、外界均可访问 protected：自己、友元、派生类可以访问 private：自己、友元可以访问 3.2 多继承的优缺点 优点 **简单，清晰，更有利于复用。**不会因为基类一个小小的改变而大张旗鼓去改代码。 缺点 **二义性。**两个基类中有同名方法的时候，需要在子类的调用中指明此方法出自那个基类。 使用父类指针指向子类对象变得复杂。你不得不用到C++中提供的dynamic_cast来执行强制转换。至于dynamic_cast，也是个麻烦的家伙，它是在运行期间而非编译期间进行转换的（因为编译期间它不能确定到底要转向一个什么类型），因此除了会带来一些轻微的性能损失，它要求编译器允许RTTI（Runtime Type Information，运行时类型信息），也就是要求编译器保存所有类在运行时的信息。 使得子类的vtable变得不同寻常。单继承的vtable只是在父类vtable的表尾加上新的虚函数，子类对象的vtable中包含了有序的父类vtable。而对于多重继承，两个父类可能有完全不同的vtable，因此，子类的vtable中绝对不可能包含完整的有序的两个父类的vtable。子类的vtable中可能包含了两块不相连的父类vtable，因此每个父类都被迫追加了一个vtable，也就是，每个父类的对象都添加了一个指针。 孰优孰劣，自己把握。没有永远最好的，只有当前适合的。Java中摒弃了多重继承可能也是出于太过复杂，可能有不可料知的结果的原因。 不要随意使用多重继承。大多数的情况，用容器（也就是类的组合法）会更好些。 https://blog.csdn.net/woodforestbao/article/details/4500406","categories":[{"name":"C++","slug":"C","permalink":"https://dragonliu2022.github.io/categories/C/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://dragonliu2022.github.io/tags/面试/"}]},{"title":"C++基础","slug":"C++基础","date":"2022-04-19T05:57:29.000Z","updated":"2022-04-19T06:00:07.876Z","comments":true,"path":"2022/04/19/C++基础/","link":"","permalink":"https://dragonliu2022.github.io/2022/04/19/C++基础/","excerpt":"","text":"《面向对象C++程序设计》皮德常 编著 清华大学出版社 2017 《C++ Primer Plus (第6版)中文版》Stephen Prata 著 张海龙 袁国忠 译 人民邮电出版社 2012 1 c 和 c++ 的区别 C是一种结构化语言，重点在于算法和数据结构。C程序的设计首先考虑的是如何通过一个过程，对输入(或环境条件)进行运算处理得到输出(或实现过程(事务)控制)。 而对于C++，首先考虑的是如何构造一个对象模型，让这个模型能够契合与之对应的问题域，这样就可以通过获取对象的状态信息得到输出或实现过程(事务)控制。 C++中new和delete是对内存分配的运算符，取代了C中的malloc和free。 标准C++中的字符串类取代了标准C函数库头文件中的字符数组处理函数（C中没有字符串类型）。 C++中用来做控制态输入输出的iostream类库替代了标准C中的stdio函数库。 C++中的try/catch/throw异常处理机制取代了标准C中的setjmp()和longjmp()函数。 在C中，允许有相同的函数名，不过它们的参数类型不能完全相同，这样这些函数就可以相互区别开来。而这在C语言中是不允许的。也就是C可以重载，C语言不允许。 C语言中，允许变量定义语句在程序中的任何地方，只要在是使用它之前就可以；而C语言中，必须要在函数开头部分。而且C允许重复定义变量，C语言也是做不到这一点的 在C++中，除了值和指针之外，新增了引用。引用型变量是其他变量的一个别名，我们可以认为他们只是名字不相同，其他都是相同的。 C++相对与C增加了一些关键字，如：bool、using、dynamic_cast、namespace等等 2 new/delete、malloc/free 2.1 new/delete、malloc/free 区别 特征 new/delete malloc/free 分配内存的位置 自由存储区 堆 内存分配成功的返回值 完整类型指针 void* 内存分配失败的返回值 默认抛出异常 返回 NULL 分配内存的大小 由编译器根据类型计算得出 必须显式指定字节数 处理数组 有处理数组的 new 版本 new[] 需要用户计算数组的大小后进行内存分配 是否相互调用 可以，看具体的 operator new/delete 实现 不可调用 new 函数重载 允许 不允许 构造函数与析构函数 调用 不调用 2.2 C++有了malloc/free，为什么还需要new/delete? malloc/free是C++/C语言的标准库函数，new/delete是C++的运算符。他们都可用于申请动态内存和释放内存。 对于非内部数据类型的对象而言，只用malloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。 因此C++需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete。new/delete不是库函数，是运算符。 2.3 delete 与 delete []区别 delete 只会调用一次析构函数，而 delete[]会针对每一个成员都调用一次析构函数。 2.4 内存泄漏与定位 内存泄漏并非指的是内存在物理上的消失，而是分配某段内存后，失去了对该内存的控制，造成内存的浪费。比如 C++ new 之后没有 delete。 定位内存泄露： 在windows平台下通过CRT中的库函数进行检测； 在可能泄漏的调用前后生成块的快照，比较前后的状态，定位泄漏的位置 Linux下通过工具valgrind检测 3 结构体、联合体 3.1 结构体与联合有何区别 结构体和联合都是由多个不同的数据类型成员组成，但在任何同一时刻，联合中只存放了一个被选中的成员（所有成员共用一块地址空间），而结构体的所有成员都存在（不同成员的存放地址不同）。 对于联合的不同成员赋值，将会对其它成员重写，原来成员的值就不存在了。而对于结构体的不同成员赋值是互不影响的。 3.2 union的好处 节省内存空间 测大小端存储（大相反（低位存高位），小相同（低位存低位），叉八六（X86计算机)，必小端。） 123456789101112#include &lt;stdio.h&gt;typedef union un&#123; int i; char ch[2];&#125; un;int main()&#123; un u; u.ch[0] = 10; u.ch[1] = 1; printf(&quot;%d&quot;, (short)u.i); return 0;&#125; 解析： 10 相当于 0000 1010 低地址 1 相当于 0000 0001 高地址 如果是小端模式，低地址存放高位，高地址存放低位，那么该值按照正常顺序书写就是： 0000 0001 0000 1010，结果为266。 3.3 struct可以有构造、析构等成员函数吗？如果有，那么与class还有区别吗？ struct可以有构造函数、析构函数，之间也可以继承。 C++中的struct其实和class意义一样，唯一不同的就是struct里面默认的访问控制是public，class中默认的访问控制是private。 C中存在struct关键字的唯一意义就是为了让C程序员有个归属感，是为了让C编译器兼容以前用C开发的项目。 相同点 两者都拥有成员函数、公有和私有部分 任何可以使用class完成的工作，同样可以使用struct完成 不同点 两者中如果不对成员不指定公私有，struct默认是公有的，class则默认是私有的 class默认是private继承，而struct模式是public继承 class可以作为模板类型，struct不行 引申：C++和C的struct区别 C语言中：struct是用户自定义数据类型（UDT）；C中struct是抽象数据类型（ADT），支持成员函数的定义，（C中的struct能继承，能实现多态） C中struct是没有权限的设置的，且struct中只能是一些变量的集合体，可以封装数据却不可以隐藏数据，而且成员不可以是函数 C++中，struct增加了访问权限，且可以和类一样有成员函数，成员默认访问说明符为public（为了与C兼容） struct作为类的一种特例是用来自定义数据结构的。一个结构标记声明后，在C中必须在结构标记前加上struct，才能做结构类型名（除：typedef struct class{};）;C中结构体标记（结构体名）可以直接作为结构体类型名使用，此外结构体struct在C中被当作类的一种特例 4 C语言关键字及其对应的含义 数据类型关键字 A基本数据类型（5个） void：声明函数无返回值或无参数，声明无类型指针，显式丢弃运算结果 char：字符型类型数据，属于整型数据的一种 int：整型数据，通常为编译器指定的机器字长 float：单精度浮点型数据，属于浮点数据的一种 double：双精度浮点型数据，属于浮点数据的一种 B类型修饰关键字（4个） short：修饰int，短整型数据，可省略被修饰的int。 long：修饰int，长整形数据，可省略被修饰的int。 signed：修饰整型数据，有符号数据类型 unsigned：修饰整型数据，无符号数据类型 C复杂类型关键字（5个） struct：结构体声明 union：共用体声明 enum：枚举声明 typedef：声明类型别名 sizeof：得到特定类型或特定类型变量的大小 D存储级别关键字（6个） auto：指定为自动变量，由编译器自动分配及释放。通常在栈上分配 static：指定为静态变量，分配在静态变量区，修饰函数时，指定函数作用域为文件内部 register：指定为寄存器变量，建议编译器将变量存储到寄存器中使用，也可以修饰函数形参，建议编译器通过寄存器而不是堆栈传递参数 extern：指定对应变量为外部变量，即在另外的目标文件中定义，可以认为是约定由另外文件声明的对象的一个“引用“ const：与volatile合称“cv特性”，指定变量不可被当前线程/进程改变（但有可能被系统或其他线程/进程改变） volatile：与const合称“cv特性”，指定变量的值有可能会被系统或其他进程/线程改变，强制编译器每次从内存中取得该变量的值 流程控制关键字 A跳转结构（4个） return：用在函数体中，返回特定值（或者是void值，即不返回值） continue：结束当前循环，开始下一轮循环 break：跳出当前循环或switch结构 goto：无条件跳转语句 B分支结构（5个） if：条件语句 else：条件语句否定分支（与if连用） switch：开关语句（多重分支语句） case：开关语句中的分支标记 default：开关语句中的“其他”分治，可选。 C循环结构（3个）：for、do、while 5 变量存储类型 5.1 C语言支持的四种变量存储类型 auto：auto称为自动变量（局部变量） static ：static称为静态变量，根据变量的类型可以分为静态局部变量和静态全局变量。 静态局部变量：它与局部变量的区别在于，在函数退出时，这个变量始终存在，但不能被其它函数使用；当再次进入该函数时，将保存上次的结果。 静态全局变量：只在定义它的源文件中可见而在其它源文件中不可见的变量。它与全局变量的区别是：全局变量可以被其它源文件使用，而静态全局变量只能被所在的源文件使用。 extern：extern称为外部申明。为了使变量或者函数除了在定义它的源文件中可以使用外，还可以被其它文件使用。因此通知每一个程序模块文件，此时可用extern来说明。 register：register称为寄存器变量。它只能用于整型和字符型变量。定义符register说明的变量被存储在CPU的寄存器中，定义一个整型寄存器变量可写成: register int a; 对于以上四种数据的存储位置：register变量存在CPU的寄存器中；auto类型变量存在内存的栈；static型的局部变量和全局变量以及extern型变量（即全局变量），存在于内存的静态区。 5.2 static 的作用 隐藏：当同时编译多个文件时，所有未加 static 前缀的全局变量和函数都具有全局可见性，其它的源文件也能访问。如果加了 static，就会对其它源文件隐藏。利用这一特性可以在不同的文件中定义同名函数和同名变量，而不必担心命名冲突。static 可以用作函数和变量的前缀，对于函数来讲，static 的作用仅限于隐藏。 保持变量内容的持久：存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。如果作为 static 局部变量在函数内定义，它的生存期为整个源程序，但是其作用域仍与局部变量相同，只能在定义该变量的函数内使用该变量。退出该函数后，尽管该变量还继续存在，但不能使用它。 默认初始化为 0 在类中声明 static 变量或者函数时，初始化时使用作用域运算符来标明它所属类，因此，静态数据成员是类的成员，而不是对象的成员，这样就出现以下作用： 类的静态成员函数是属于整个类而非类的对象，所以它没有 this 指针，这就导致了它仅能访问类的静态数据和静态成员函数。 不能将静态成员函数定义为虚函数。 静态成员变量地址是指向其数据类型的指针，静态成员函数地址类型是一个“非成员函数指针”。 static 并没有增加程序的时空开销，相反它还缩短了派生类对基类静态成员的访问时间，节省了派生类的内存空间。 静态数据成员是静态存储的，所以必须对它进行初始化。（程序员手动初始化，否则编译时一般不会报错，但是在链接时会报错误） 静态成员为基类和派生类共享，但在派生类中重复定义了基类中的静态成员，不会引起错误。 注意，静态成员初始化与一般数据成员初始化不同: 初始化在类体外进行，而前面不加 static，以免与一般静态变量或对象相混淆； 初始化时不加该成员的访问权限控制符 private，public 等； 初始化时使用作用域运算符来标明它所属类； 所以我们得出静态数据成员初始化的格式：&lt;数据类型&gt;&lt;类名&gt;::&lt;静态数据成员名&gt;=&lt;值&gt; 5.3 请说出 const 与#define 相比，有何优点？ const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，并且在字符替换可能会产生意料不到的错误。 const还具有以下优点： 提高代码安全性。 提高代码的可读性和可维护性。 提高程序的效率。 当 const 和 non-const 成员函数具有本质上相同的实现的时候，使用 non-const 版本调用 const 版本可以避免重复代码。 5.4 C++中顶层 const 和底层 const 如果 const 右结合修饰的为类型或者*，那这个 const 就是一个底层 const，表示指针所指向的对象是个常量。 如果 const 右结合修饰的为标识符，那这个 const 就是一个顶层 const，表示指针本身是个常量。 5.5 const 关键字的使用 阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要(必须)对它进行初始化，因为以后就没有机会再去改变它了； 对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const； 在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值； 对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量，类的常对象只能访问类的常成员函数； 对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”。 const成员函数可以访问非const对象的非const数据成员、const数据成员，也可以访问const对象内的所有数据成员； 非const成员函数可以访问非const对象的非const数据成员、const数据成员，但不可以访问const对象的任意数据成员； 一个没有明确声明为const的成员函数被看作是将要修改对象中数据成员的函数，而且编译器不允许它为一个const对象所调用。因此const对象只能调用const成员函数。 const类型变量可以通过类型转换符const_cast将const类型转换为非const类型； const类型变量必须定义的时候进行初始化，因此也导致如果类的成员变量有const类型的变量，那么该变量必须在类的初始化列表中进行初始化； 对于函数值传递的情况，因为参数传递是通过复制实参创建一个临时变量传递进函数的，函数内只能改变临时变量，但无法改变实参。则这个时候无论加不加const对实参不会产生任何影响。但是在引用或指针传递函数调用中，因为传进去的是一个引用或指针，这样函数内部可以改变引用或指针所指向的变量，这时const 才是实实在在地保护了实参所指向的变量。因为在编译阶段编译器对调用函数的选择是根据实参进行的，所以，只有引用传递和指针传递可以用是否加const来重载。一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来。 5.6 volatile 关键字的使用 volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。 当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。 volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。多线程中被几个任务共享的变量需要定义为volatile类型。 volatile 指针和 const 修饰词类似，const 有常量指针和指针常量的说法，volatile 也有相应的概念 可以把一个非volatile int赋给volatile int，但是不能把非volatile对象赋给一个volatile对象。 除了基本类型外，对用户定义类型也可以用volatile类型进行修饰。 C++中一个有volatile标识符的类只能访问它接口的子集，一个由类的实现者控制的子集。用户只能用const_cast来获得对类型接口的完全访问。此外，volatile向const一样会从类传递到它的成员。 多线程下的volatile：有些变量是用volatile关键字声明的。当两个线程都要用到某一个变量且该变量的值会被改变时，应该用volatile声明，该关键字的作用是防止优化编译器把变量从内存装入CPU寄存器中。如果变量被装入寄存器，那么两个线程有可能一个使用内存中的变量，一个使用寄存器中的变量，这会造成程序的错误执行。volatile的意思是让编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的值。 5.7 一个参数可以既是const又是volatile吗？解释为什么 可以。一个例子就是只读的状态寄存器。它是volatile，因为他可能被意想不到地改变；她又是const，因为程序不应该试图去改变它。 尽管这并不很正常。一个例子就是当一个中断服务子程序修改一个指向一个buffer的指针时。 6 C 字符串和 C++字符串的区别 C 字符串是基本数据类型，即字符数组；C++字符串是类 string C 字符串函数是外部函数，字符串作为参数被传进来；C++字符串函数是字符串类内部定义的，用.来直接使用 C++字符串中对一些运算符进行了重载 7 引用和指针 7.1 引用与指针区别 初始化区别：引用必须被初始化，指针不必。 可修改区别：引用初始化以后不能被改变，指针可以改变所指的对象。 非空区别：不存在指向空值的引用，但是存在指向空值的指针。 合法性区别：在使用引用之前不需要测试他的合法性；相反，指针则应该总是被测试，防止其为空。 应用区别 ： 使用指针的情况 考虑到存在不指向任何对象的可能(在这种情况下，能够设置指针为空) 需要能够在不同时刻指向不同对象(在这种情况下，能够改变指针的指向) 使用引用的情况：总是指向一个对象并且一旦指向一个对象后就不会改变指向 7.2 在什么时候需要使用“常引用”？ 如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改变，就应使用常引用。 7.3 将“引用”作为函数返回值类型的优点和注意事项 好处：在内存中不产生被返回值的副本，提高效率 注意事项： 不能返回局部变量的引用。主要原因是局部变量会在函数返回后被销毁，因此被返回的引用就成为了&quot;无所指&quot;的引用，程序会进入未知状态。 不能返回函数内部 new 分配的内存的引用。原因是引用所指向的空间就无法释放，造成内存泄漏。 可以返回类成员的引用，但最好是 const。主要原因是如果其它对象可以获得该属性的非常量引用（或指针），那么对该属性的单纯赋值就会破坏业务规则的完整性。 流操作符和赋值操作符重载返回值申明为引用。 在另外的一些操作符中，却千万不能返回引用，例如四则运算符。 7.4 句柄和指针的区别与联系 句柄和指针其实是两个截然不同的概念。 Windows系统用句柄标记系统资源，隐藏系统的信息。只要知道有这个东西，然后去调用即可，他是一个32bit的uint。 指针则标记某个物理内存地址。 7.5 指针常量和常量指针 常量指针是一个指针，读成常量的指针，指向一个只读变量。如int const *p或const int *p 指针常量是一个不能给改变指向的指针。指针是个常量，不能中途改变指向，如int *const p 技巧：* 前面的是对被指向对象的修饰，* 后面的是对指针本身的修饰。 8 递归的优缺点 优点：代码简洁，容易理解 缺点：时间效率低，递归爆栈 9 C++四种类型转换：static_cast, dynamic_cast, const_cast, reinterpret_cast static_cast 用的最多，能用于多态向上转化，如果向下转能成功但是不安全。 dynamic_cast 用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回 NULL，对于引用抛异常。 const_cast 用于将 const 变量转为非 const reinterpret_cast 几乎什么都可以转，比如将 int 转指针，可能会出问题，尽量少用。 C 的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。 10 C++是不是类型安全的？ 不是。两个不同类型的指针之间可以强制转换 11 内联函数与宏定义的区别 所谓的内联函数就是那些完整地定义在类内部的函数成员。 C++ 宏定义将一个标识符定义为一个字符串，源程序中的该标识符均以指定的字符串来代替。 宏定义在预编译的时候就会进行宏替换；内联函数在编译阶段，在调用内联函数的地方进行替换，减少了函数的调用过程，但是使得编译文件变大。因此，内联函数适合简单函数，对于复杂函数，即使定义了内联，编译器可能也不会按照内联的方式进行编译。 内联函数相比宏定义更安全，内联函数可以检查参数，而宏定义只是简单的文本替换。因此推荐使用内联函数，而不是宏定义。 补充1 C笔记 exe已停止工作：1)漏&amp;；2)分母为0 定义整型，输入实型：自动截取小数部分，eg:2.5-&gt;2(赋值亦是)。 输出数据出错：格式字符与变量类型未对应；为赋初值。特别注意除号“/”和等号“==”。 数据范围与补码：-1全1，正负0全0，负数min为“1+全0”;溢出取低位，小数对应21,22,23…小数转二进制数: x/2取整数部分直到小数为0。 else就近结合。 || 和 &amp;&amp; 的短路特性。 数组a[]: scanf(&quot;%d&quot;, a)指对a[0]赋值。 字符串：scanf(&quot;%s&quot;, a)-&gt;遇’ ‘, ‘\\0’, ‘\\t’为截点(’\\n’跳出)开始不计；puts()=printf(&quot;%s&quot;, a)-&gt;遇’\\0’结束；gets()遇回车结束，前无截点。 x *= y+8 等价于 x = x + (y+8) C语言的函数体中，可以调用但不能定义其他函数。 puts()自动换行，putchar()不自动换行。 补充2 C++笔记 endl = ‘\\n’ + flush(刷新缓冲区) cin跳过空白字符，cin.get()读取包含空白字符的字符 浮点数和整型注意转化中的除号 递归调用次数可用二叉树解决 C++, 字符串拷贝用&quot;=&quot;, 字符串比较&quot;==&quot; 汉字占两个字符，故name[0]无法输出，&quot;cout&lt;&lt;name[0]&lt;&lt;name[1]&quot;输出一个汉字 cin对象遇’\\n’结束 nullptr能够避免在整数(0或NULL)和指针(nullptr)之间发生混淆 函数传参：数据较小，按值传递，但修改时用引用；数组用指针；结构体用指针或引用；对象用引用 缺省函数：声明函数(最先且一次)时为其参数指定默认值 sizeof(): 测字节(包含’\\0’)区分数组与指针strlen(): 不区分数组还是指针，读到’\\0’为止返回长度(\\t,\\n不停) 全局变量: int global -&gt; extern int global 声明到文件结尾局部变量: 从声明到函数结束静态变量: 函数退出保留值，下次调用 getline()读取换行符，但向数组存储时并不存储 初始化和赋值是不同概念 文本文件存储文件大小：char类型存储；二进制文件：&quot;01&quot;存储(内存大小) 引起缓存区刷新：缓存区满时(4K)；程序结束；flush语句；close语句；endl语句 解决：#ifdef ``` #endif 或 #pragma once 派生类的构造函数只能描述自己的成员和基类的初始化，不能去初始化基类的成员；基类的成员需要调用基类的构造函数初始化。 k = (a=1, b=2, a+b)逗号运算符 自身类的对象不能作为类的成员(存在无限初始化问题，构造成员变量-&gt;调用自身的构造函数)，而自身类对象的引用和指针可以。 虚函数：特殊的成员函数，用来实现运行时的多态；动态决议(运行时才绑定)；基类说明virtual后，子类可缺省virtual静态成员函数：静态决议(编译时就绑定)，属于整个class，并不针对某个类的实例，为所有对象所共用，作用域为全局；不能直接使用this指针；virtual不能是static 静态数据成员：class内声明：static int num; class外定义：int className::num(无static，默认0) 继承中的析构函数：基类的指针可指向派生类对象(多态性); *if delete []p;*就会调用该指针指向的派生类析构函数，而其自动调用基类的析构函数，整个派生类的对象被完全释放。若析构函数不被声明成虚函数，则编译器是是静态绑定，再删除基类指针时，只会调用基类的析构函数而不调用派生类的析构函数，这样一来派生类对象析构不完全。 两个指针指向同一数组，可以相减，结果是两个指针之间的元素数目。 函数模板：一个模板，专门用来生产函数的模板函数：是函数模板的实例化 注：类模板和模板类亦同 联编 ：程序自身彼此关联的过程，确定程序中的操作调用与执行该操作的代码之间的关系。 静态联编：联编工作出现在联编阶段，用对象名或者类名来限定要调用的函数； 动态联编：联编工作在程序运行时执行，在程序运行时才确定将要调用的函数。 虚基类子对象是由最远派生类的构造函数通过调用虚基类的构造函数进行初始化的；初始化列表列出对虚基类调用，如未列出则用虚基类构造函数；先虚后非虚。 虚基类：多条继承路径上有一个公共的基类，公共的基类会产生多个实例。virtual class是为了实例化一次基类存在的。eg: ios类是istream和ostream类的虚基类。 char = int + ‘0’ 指针数组：int *p[4]数组指针：int (*p)[4] Runtime Error: 除0操作；数组越界；栈溢出；未指定值的指针进行读写操作；已经释放空间的指针再次释放。 数组 ： int&amp;float&amp;double:初始化补零 char: 初始化补’\\0’ 对象：调用缺省构造函数 常对象不能被更新，因此通过常对象只能调用他的常成员函数。 临时对象是在遇到其后第一个分号(语句结束处)析构的。","categories":[{"name":"C++","slug":"C","permalink":"https://dragonliu2022.github.io/categories/C/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://dragonliu2022.github.io/tags/面试/"}]},{"title":"卫语句","slug":"卫语句","date":"2022-04-18T08:32:06.000Z","updated":"2022-04-18T14:52:33.148Z","comments":true,"path":"2022/04/18/卫语句/","link":"","permalink":"https://dragonliu2022.github.io/2022/04/18/卫语句/","excerpt":"","text":"转载：浅谈使用卫语句重构方法 1 卫语句定义 如果条件语句极其复杂，就应该将条件语句拆解开，然后逐个检查，并在条件为真时立刻从函数中返回，这样的单独检查通常被称之为“卫语句”(Guard Clauses)。 说人话就是：写方法时在合适的时候尽快return，少用else 2 按卫语句对函数进行重构应遵循 及时return，if中能return就return。(一旦满足条件return后你根本无需关注后面的代码) 能够return的就尽量少使用else。(用else太多，读者需要维护大量的栈在大脑中) 减少嵌套，一般嵌套超过4层读者就会产生阅读恐惧感。 3 示例 12345678910111213if（it == 活的）&#123; if（it == 人）&#123; if（it ！= 女人）&#123; return 不喜欢； &#125; else &#123; return 喜欢； &#125; &#125; else &#123; return 不喜欢； &#125;&#125; else &#123; return 不喜欢；&#125; 以上代码无非就是表达 我只喜欢活的女人 的意思，但是代码一层套一层明显妨碍了我在第一时间获取最核心信息的效率，使用卫语句来表达就是： 123456789if （it ！= 活的）&#123;return 不喜欢&#125;if（it！=人）&#123;return 不喜欢&#125;if（it！=女人）&#123;return 不喜欢&#125;if（it == 女人 &amp;&amp; it == 活的） &#123;return 喜欢&#125;return 不喜欢 这样看起来，代码就更明晰易懂。 有点逆向思维的意思。","categories":[{"name":"未分类","slug":"未分类","permalink":"https://dragonliu2022.github.io/categories/未分类/"}],"tags":[{"name":"重构","slug":"重构","permalink":"https://dragonliu2022.github.io/tags/重构/"}]},{"title":"git vs svn","slug":"git-vs-svn","date":"2022-04-18T08:28:44.000Z","updated":"2022-04-18T15:53:23.147Z","comments":true,"path":"2022/04/18/git-vs-svn/","link":"","permalink":"https://dragonliu2022.github.io/2022/04/18/git-vs-svn/","excerpt":"","text":"转载：SVN与Git比较的优缺点差异 1 集中式 vs 分布式 1.1 Subversion属于集中式的版本控制系统 集中式的版本控制系统都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。 Subversion的特点概括起来主要由以下几条： 每个版本库有唯一的URL（官方地址），每个用户都从这个地址获取代码和数据； 获取代码的更新，也只能连接到这个唯一的版本库，同步以取得最新数据； 提交必须有网络连接（非本地版本库）； 提交需要授权，如果没有写权限，提交会失败； 提交并非每次都能够成功。如果有其他人先于你提交，会提示“改动基于过时的版本，先更新再提交”… 诸如此类； 冲突解决是一个提交速度的竞赛：手快者，先提交，平安无事；手慢者，后提交，可能遇到麻烦的冲突解决。 好处：每个人都可以一定程度上看到项目中的其他人正在做些什么。而管理员也可以轻松掌控每个开发者的权限。 缺点： 中央服务器的单点故障。若是宕机一小时，那么在这一小时内，谁都无法提交更新、还原、对比等，也就无法协同工作。如果中央服务器的磁盘发生故障，并且没做过备份或者备份得不够及时的话，还会有丢失数据的风险。最坏的情况是彻底丢失整个项目的所有历史更改记录，被客户端提取出来的某些快照数据除外，但这样的话依然是个问题，你不能保证所有的数据都已经有人提取出来。 Subversion原理上只关心文件内容的具体差异。每次记录有哪些文件作了更新，以及都更新了哪些行的什么内容。 1.2 Git属于分布式的版本控制系统 Git记录版本历史只关心文件数据的整体是否发生变化。Git 不保存文件内容前后变化的差异数据。 实际上，Git 更像是把变化的文件作快照后，记录在一个微型的文件系统中。每次提交更新时，它会纵览一遍所有文件的指纹信息并对文件作一快照，然后保存一个指向这次快照的索引。为提高性能，若文件没有变化，Git 不会再次保存，而只对上次保存的快照作一连接。 在分布式版本控制系统中，客户端并不只提取最新版本的文件快照，而是把原始的代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。这类系统都可以指定和若干不同的远端代码仓库进行交互。籍此，你就可以在同一个项目中，分别和不同工作小组的人相互协作。你可以根据需要设定不同的协作流程。 另外，因为Git在本地磁盘上就保存着所有有关当前项目的历史更新，并且Git中的绝大多数操作都只需要访问本地文件和资源，不用连网，所以处理起来速度飞快。用SVN的话，没有网络或者断开VPN你就无法做任何事情。但用Git的话，就算你在飞机或者火车上，都可以非常愉快地频繁提交更新，等到了有网络的时候再上传到远程的镜像仓库。换作其他版本控制系统，这么做几乎不可能，抑或是非常麻烦。 Git具有以下特点： Git中每个克隆(clone)的版本库都是平等的。你可以从任何一个版本库的克隆来创建属于你自己的版本库，同时你的版本库也可以作为源提供给他人，只要你愿意。 Git的每一次提取操作，实际上都是一次对代码仓库的完整备份。 提交完全在本地完成，无须别人给你授权，你的版本库你作主，并且提交总是会成功。 甚至基于旧版本的改动也可以成功提交，提交会基于旧的版本创建一个新的分支。 Git的提交不会被打断，直到你的工作完全满意了，PUSH给他人或者他人PULL你的版本库，合并会发生在PULL和PUSH过程中，不能自动解决的冲突会提示您手工完成。 冲突解决不再像是SVN一样的提交竞赛，而是在需要的时候才进行合并和冲突解决。 Git 也可以模拟集中式的工作模式 Git版本库统一放在服务器中 可以为 Git 版本库进行授权：谁能创建版本库，谁能向版本库PUSH，谁能够读取（克隆）版本库 团队的成员先将服务器的版本库克隆到本地；并经常的从服务器的版本库拉（PULL）最新的更新； 团队的成员将自己的改动推（PUSH）到服务器的版本库中，当其他人和版本库同步（PULL）时，会自动获取改变 Git 的集中式工作模式非常灵活 你完全可以在脱离Git服务器所在网络的情况下，如移动办公／出差时，照常使用代码库 你只需要在能够接入Git服务器所在网络时，PULL和PUSH即可完成和服务器同步以及提交 Git提供 rebase 命令，可以让你的改动看起来是基于最新的代码实现的改动 Git 有更多的工作模式可以选择，远非 Subversion可比 2 版本库与工作区 Subversion的工作区和版本库是截然分开的，而Git的工作区和版本库是如影随形的。 2.1 SVN的版本库和工作区是分离的 Subversion 的工作区和版本库物理上分开：Subversion的版本库和工作区是存储在不同路径下，一般是在不同的主机中 Subversion的企业级部署中，版本库在服务器上，只能通过 https, http, svn 等协议访问，而不能直接被用户接触到。 Subversion的工作区是一份版本库在某个历史状态下的快照，如：版本库最新的数据检出到工作区。 Subversion的工作区中每一个目录下都包含一个名为 .svn 的控制目录（隐藏的目录），该目录的作用是： 标识工作区和版本库的对应关系。 包含一份该子目录下检出文件的原始拷贝。当文件改动的差异比较或者本地改动的回退时，可以直接参考原始拷贝而无须通过网络访问远程版本库。 Subversion 的 .svn 控制目录会引入很多麻烦： .svn 下的文件原始考本，会导致在目录下按照文件内容搜索时，多出一倍的搜索时间和搜索结果。 .svn 很容易在集成时，引入产品中，尤其是 Web 应用，将 .svn 目录带入Web服务器会导致安全隐患。因为一个不允许目录浏览的Web目录，可以通过 .svn/entries 文件查看到该目录下可能存在的文件。 2.2 Git 的版本库和工作区如影随形 Git 的版本库和工作区在同一个目录下，工作区的根目录有一个.git的子目录，这个名为 .git的目录就是版本库本身，它是Git 用来保存元数据和对象数据库的地方。该目录非常重要，每次克隆镜像仓库的时候，实际拷贝的就是这个目录里面的数据。所以千万要小心删除这个文件。 工作区中其他文件为工作区文件，可能是从 .git 中检出的，或者是要检入的，或者是运行产生的临时文件等。 版本库可以脱离工作区而存在，成为 bare（赤裸）版本库。可以用 –bare 参数来创建。但是工作区不能脱离版本库而存在，即工作区的根目录下必须有一个名为 .git 的版本库克隆文件。 Git 的版本库因为就在工作区中，能直接被用户接触到。 用户可以编辑 .git/config 文件，修改配置，增添新的源 用户可以编辑 .git/info/exclude 文件，创建本地忽略… Git 的工作区中只在工作区的根目录下有一个 .git 目录，此外再无任何控制目录。Git 工作区下唯一的 .git 目录是版本库，并非 .svn 的等价物，如果删除了 .git 目录，而又没有该版本库的其他镜像（克隆）的话，你破坏了整个历史，版本库也永远的失去了。 Git 在本地的 .git 版本库，提供了完全的改动历史。除了和其他人数据交换外，任何版本库相关的操作都在本地完成，更多的本地操作，避免了冗长的网络延迟，大大节省了时间。例如：查看 log，切换到任何历史版本等操作都无须连接网络。 Git如何保证安全：本地创建一个Git库，因为工作区和库是在同一个目录中，如果工作区删除了，或者所在的磁盘分区格式化了，数据不是全都没有了么？其实我们可以这样做： 在一个磁盘分区中创建版本库（最好是用 –bare 参数创建），然后在另外的磁盘分区中克隆一个新的作为工作区。在工作区的提交要不时的PUSH到另外分区的版本库，这样就实现了本地的数据镜像。你甚至可以在本地创建更多的版本库镜像，安全性要比Subversion的一个库加上一个工作区安全。 另一个办法：把你的版本库共享给他人，当他人克隆了你的版本库时，你就拥有了一个异地备份。 3 全局版本号和全球版本号 SVN的全局版本号和CVS的每个文件都独立维护一套版本号相比，是一个非常大的进步。在看似简单的全局版本号的背后，是Subversion提供对于事物处理的支持，每一个事物处理（即一次提交）都具有整个版本库全局唯一的版本号。 Git的版本号则更进一步，版本号是全球唯一的。Git 对于每一次提交，通过对文件的内容或目录的结构计算出一个SHA-1 哈希值，得到一个40位的十六进制字符串，Git将此字符串作为版本号。 3.1 SVN与Git版本号比较 所有保存在Git 数据库中的数据都是用此40位的哈希值作索引的，而不是靠文件名。 使用哈希值作版本号的好处就是对于一个分布式的版本控制系统，每个人每次提交后形成的版本号都不会出现重复。另一好处是保证数据的完整性，因为哈希值是根据内容或目录结构计算出来的，所以我们还可以据此来判断数据内容是否被篡改。 SVN 的版本号是连续的，可以预判下一个版本号，而 Git 的版本号则不是。 因为 subversion 是集中式版本控制，很容易实现版本号的连续性。 Git 是分布式的版本控制系统，而且 Git 采用 40 位长的哈希值作为版本号，每个人的提交都是各自独立完成的，没有先后之分（即使提交有先后之分，也由于PUSH/PULL的方向和时机而不同）。Git 的版本号虽然不连续，但是是有线索的，即每一个版本都有对应的父版本（一个或者两个），进而可以形成一个复杂的提交链 Git 的版本号简化：Git 可以使用从左面开始任意长度的字串作为简化版本号，只要该简化的版本号不产生歧义。一般采用7位的短版本号（只要不会出现重复的，你也可以使用更短的版本号）。 4 部分检出 Subversion可以将整个库检出到工作区，也可以将某个目录检出到工作区。对于要使用一个庞大、臃肿的版本库的用户来说，部分检出是非常方便和实际的。 但是Git只能全部检出，不支持按照目录进行的部分检出。 4.1 SVN的部分检出 在SVN中，从仓库checkout的一个工作树，每个子目录下都维护着自己的.svn目录，记录着该目录中文件的修改情况以及和服务器端仓库的对应关系。所以SVN可以checkout部分路径下的内容（部分检出），而不用checkout整个版本库或分支。 Subversion 有一条命令：svn export ，可以将 subversion 版本库的一个目录下所有内容导出到指定的目录下。Subversion 需要 svn export 命令是因为该命令可以导出一个干净的目录，即不包含 .svn 目录（包含配置文件和文件原始拷贝）。 4.2 Git的检出 Git 没有部分检出，这并不是说只有将整个库克隆下来才能查看文件。有很多 git 工具，提供直接浏览git库的功能，例如 gitweb, trac 的 git 版本库浏览, redmine 的 git 版本库浏览。 Git-submodule 可以实现版本库的模块化：Git 通过子模块处理这个问题。子模块允许你将一个Git 仓库当作另外一个Git仓库的子目录。这允许你克隆另外一个仓库到你的项目中并且保持你的提交相对独立。 Git 为什么没有实现 svn export 的功能？由于git的本地仓库信息完全维护在project根目录的.git目录下，（不像svn一样，每个子目录下都有单独的.svn目录）。所以，只要clone，checkout然后删除.git目录就可以了。 5 更新和提交 5.1 更新操作 在SVN中，因为只有一个中心仓库，所以所谓的远程更新，也就是svn update ,通过此命令来使工作区和版本库保持同步。 对于git来说，别人的改动是存在于远程仓库上的，所以git checkout命令尽管在某些功能上和svn中的update类似（例如取仓库特定版本的内容），但是在远程更新这一点上，还是不同的，不属于git checkout的功能涵盖范围。 Git使用git fetch和git pull来完成远程更新任务，fetch操作只是将远程数据库的object拷贝到本地，然后更新remotes head的refs，git pull 的操作则是在git fetch的基础上对当前分支外加merge操作。 大致上 git pull = git fetch + git merge 5.2 SVN中的commit命令 对于SVN来说，由于是中心式的仓库管理形式，所以并不存在特殊的远程提交的概念，所有的commit操作都可以认为是对远程仓库的更新动作。在工作区中对文件进行添加、修改、删除操作要同步到版本库，必须使用 commit命令。 add 命令，是将未标记为版本控制状态的文件标记为添加状态，并在下次提交时入库。 delete命令，是通过SVN来删除文件，并在下次提交后有效。 Subversion 有提交列表功能，即将某些文件加入一个修改列表，提交可以只提交处于该列表的文件。 5.3 Git中的暂存区域（stage） Git 管理项目时，文件在三个工作区域中流转：Git 的本地数据目录，工作目录以及暂存区域。暂存区域（stage）是介于 workcopy 和 版本库 HEAD 版本的一种中间状态。所谓的暂存区域只不过是个简单的文件，一般都放在git 目录中。有时候人们会把这个文件叫做索引文件，不过标准说法还是叫暂存区域。 要将一个文件纳入版本管理的范畴，首先是要用git add将文件纳入stage的监控范围，只有更新到stage中的内容才会在commit的时候被提交。另外，文件本身的改动并不会自动更新到stage中，每次的任何修改都必须重新更新到stage中去才会被提交。对于工作区直接删除的文件，需要用 git rm 命令进行标记，在下次提交时，在版本库中删除。 工作区的文件改动（新增文件，修改文件，删除文件），必须用 git add 或者 git rm 命令标识，使得改动进入 stage 提交只对加入 stage 的改动进行提交 如果一个文件改动加入 stage 后再次改动，则后续改动不改变 stage。即该文件的改动有两个状态，一个是标记到 stage 中并将在下次提交时入库的改动，另外的后续改动则不被提交，除非再次使用 git add 命令将改动加入到 stage 中。 Git的stag让你在提交的时候清楚的知道git将要提交哪些改动。除非提交的时候使用 -a 参数（不建议使用）。 我们可以从文件所处的位置来判断其状态：如果是git目录中保存着的特定版本文件，就属于已提交状态；如果作了修改并已放入暂存区域，就属于已暂存状态；如果自上次取出后，作了修改但还没有放到暂存区域，就是已修改状态，如果取出后未进行修改则是未修改状态。 在git中，因为有本地仓库和remote仓库之分，所以也就区别于commit 操作，存在额外的push命令，用于将本地仓库的数据更新到远程仓库中去。git push 可以选择需要提交的、更新的分支以及制定该分支在远程仓库上的名字。 6 分支和里程碑的实现 几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。在很多版本控制系统中，这是个昂贵的过程，常常需要创建一个源代码目录的完整副本，对大型项目来说会花费很长时间。 轻量级分支/里程碑的含义是，创建分支/里程碑的复杂度是O(1)O(1)O(1)，不会因为版本库的愈加庞大而变得缓慢。在CVS中，创建分支的复杂度是O(n)O(n)O(n)的，导致大的版本库的的分支创建非常缓慢。 CVS （代码版本控制软件）：百度百科 6.1 Subversion的分支/里程碑 Subversion轻量级分支和里程碑的实现是通过svn cp命令，即带历史的拷贝就是创建快速创建分支和里程碑的秘籍。Subversion的版本库有特殊的设计，当你复制一个目录，你不需要担心版本库会变得十分巨大—Subversion并不是拷贝所有的数据，相反，它只是建立了一个已存在目录树的入口。这种“廉价的拷贝”就是创建分支/里程碑是轻量级的原因。 由于Svn的分支和标签是来自目录拷贝，约定俗成是拷贝在 branches/和tags/目录下。所谓分支，tag等概念都只是仓库中不同路径上的一个对象或索引而已，和普通的路径并没有什么本质的区别，谁也不能阻止在一个提交中同时修改不同分支中的数据。 里程碑是对某个历史提交所起的一个别名，作为历史的标记，是不应该被更改的。svn的里程碑要建立到 tags/目录下，要求不要在tags/下的里程碑目录下进行提交。但是谁也阻止不了对未进行权限控制的里程碑的篡改。 6.2 Git 的轻量级分支和里程碑 Git中的分支实际上仅是一个包含所指对象校验和（40个字符长度SHA-1 哈希值）的文件，所以创建和销毁一个分支就变得非常廉价。说白了，新建一个分支就是向一个文件写入41个字节（版本号外加一个换行符）那么简单，自然速度就很快了。 Git的实现与项目复杂度无关，它永远可以在几毫秒的时间内完成分支的创建和切换。这和大多数版本控制系统形成了鲜明对比。 Git的分支是完全隔离的，而Subversion则没有。分支本来就应该是相对独立的命名空间，一个提交一般只能发生在一个分支中。在Git中，其内部的对象层级依赖关系或许和SVN类似，但是其工作树的视图表现形式和SVN完全不同。工作树永远是一个完整的分支，不同的分支由不同的head索引去构建，你不可能在工作树中同时获得多个分支的内容。 Git使用的标签有两种类型：轻量级的（lightweight）和含附注的（annotated）。 ① 轻量级标签就像是个不会变化的分支，实际上它就是个指向特定提交对象的引用。 ② 而含附注标签，实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，电子邮件地址和日期，以及标签说明，标签本身也允许使用GNU Privacy Guard (GPG) 来签署或验证。 Git的里程碑是只读的，Git完全遵守历史不可更改这一时空法则。用户不能向git的里程碑中提交，否则里程碑就不是标记，而成了一个分支。当然Git允许用户删除里程碑再重新创建指定到不同历史提交。 6.3 多分支间的切换 SVN中提供了一个功能switch，使用switch可以在同一个工作树上，在不同的分支中进行切换。 Git在分支中进行切换使用的命令是checkout。 7 分支与合并 Git 和 Svn 的分支实现机制完全的不同，这也直接导致了 SVN 在分支合并中困难重重。尽管在 SVN 1.5 之后，通过 svn:mergeinfo 属性引入了合并追踪机制，但是在特定情况下，合并仍会出现很多困难。 7.1 SVN的分支合并 当你在一个分支上工作数周或几个月之后，主干的修改也同时在进行着，两条线的开发会区别巨大，当你想合并分支回主干，可能因为太多冲突，已经无法轻易合并你的分支和主干的修改。 另一个问题，Subversion不会记录任何合并操作，当你提交本地修改，版本库并不能判断出你是通过svn merge还是手工修改得到这些文件。所以你必须手工记录这些信息（说明合并的特定版本号或是版本号的范围）。 要解决以上的问题只有通过有规律的将主干合并到分支来避免，制定这样一个政策：每周将上周的修改合并到分支，注意这样做时需要小心，你必须手工记录合并的过程，以避免重复的合并，你需要小心的撰写合并的日志信息，精确的描述合并包括的范围。这样做看起来有点像是胁迫。 SVN 的版本号是连续的版本号。每一次新的提交都会版本号+1 ，而无论这个提交是在哪个分支中进行的。SVN一个提交可以同时修改不同分支的不同文件，因为提交命令可以在 /trunk, /branches, /tags 的上一级目录执行。 SVN 的提交是单线索的，每一个提交（最原始的提交0除外）都只有一个父节点（版本号小一个的提交节点） SVN 的提交链只有一条，仅从版本号和提交说明，我们无法获得分支图 SVN 的分支图在某些工具（如乌龟SVN）可以提供，那是需要对提交内容进行检查，对目录拷贝动作视为分支，对 svn:mergeinfo 的改动视为合并，但这会由于目录管理的灵活性，导致千奇百怪的分支图表。 7.2 Git的分支合并 在 git 版本库中创建分支的成本几乎为零，所以，不必吝啬多创建几个分支。当第一次执行git-init时，系统就会创建一个名为”master”的分支。 而其它分支则通过手工创建。下面列举一些常见的分支策略。 ① 创建一个属于自己的个人工作分支，以避免对主分支 master 造成太多的干扰，也方便与他人交流协作。 ② 当进行高风险的工作时，创建一个试验性的分支，扔掉一个烂摊子总比收拾一个烂摊子好得多。 ③ 合并别人修改的时候，最好创建一个临时的分支用来合并，合并完成后再“fatch”到自己的分支。 Git分支相关的操作命令 8 撤消操作 8.1 提交的撤销 在Subversion中一旦完成向服务器的数据提交，你就没有办法再从客户端追回，只能在后续的提交中修正（回退或者修改）等。因为Subversion作为集中式的版本控制，不能允许个人对已提交的数据进行篡改。Subversion具有一个非常重要的特性就是它的信息从不丢失，即使当你删除了文件或目录，它也许从最新版本中消失了 ，但这个对象依然存在于历史的早期版本中。 Git则不同，Git是分布式版本控制系统，代码库是属于个人，允许任意修改。Git通过对提交建立数字摘要来保证提交的唯一性和不可更改性，通过版本库在多人之间的多份拷贝来保障数据的安全性。Git可以丢弃最新的一个或几个提交，使用 git reset –hard命令可以永远丢弃最新的一个或者几个提交。 8.2 提交说明的修改 提交后如果对提交说明不满意，如何实现对提交说明的修改： Git可以使用命令git commit –amend修改提交说明。 Git可以修改最后一次提交说明，并不是说不能修改历史版本的提交说明，只是修改最后一个版本提交说明拥有最简单的命令； Git修改提交说明，会改变提交的commit-id。即修改提交说明后，将产生一个新的提交； Git可以通过git reset –hard ，git commit –amend，git rebase onto 等命令来实现对历史提交的修改； 使用stg工具可以更为简单的修改历史提交的提交说明，包括提交内容； Subversion也可以修改提交说明，是通过修改提交的svn:log版本属性实现的： 不但可以修改最后一次提交的说明，并且可以修改历史提交的提交说明； Subversion修改提交说明是不可逆的操作，可能会造成说明被恶意修改； Subversion缺省关闭修改提交说明的功能。管理员在设置了提交说明更改的邮件通知后，才可以打开该功能。 8.3 修改和重构历史提交 Git可以修改和重构历史提交：使用Git本身的reset以及 rebase 命令可以修改或者重整/重构历史提交，非常灵活。使用强大的 stg 可以使得历史提交的重构更为简洁，如果您对 stg 或者 Hg/MQ 熟悉的话。 Subversion 修改历史提交，只能由管理员完成。 Subversion 是集中式版本控制系统，从客户端一旦完成提交，就没有办法从客户端撤销提交。但是管理员可以在服务器端完成提交的撤销和修改，但是操作过程和代价较大。 9 权限管理 Subversion通过对文件目录授权来实现权限管理，子目录默认继承父目录的权限。但是也有缺憾，即权限不能在分支中继承，不能对单个文件授权。例如为 /trunk及其子目录的授权，不能继承到分支或者标签中相应的目录下。 Git 的授权做不到Subversion那样精细。Git的授权模型只能实现非零即壹式的授权，要么拥有全部的写权限，要么没有写权限，要么拥有整个版本库的读权限，要么禁用。 从技术上将，Git可能永远也做不到类似SVN的路径授权（读授权）： 如果允许按照路径授权，则各个克隆的关系将不再是平等的关系，有的内容多，有的内容少，分布式的理念被破坏 如果只有部分路径可读，则克隆出来的提交和原始提交的提交ID可能不同。因为提交ID是和提交内容有关的，克隆中提交的部分内容被丢弃，势必提交的ID也要重新计算 允许全部代码可读，只允许部分代码可写，在版本控制的管理下，是没有多大实际意义的，而且导致了提交的逻辑上的不完整。 那么有什么办法来解决授权的问题？ 公司内部代码开放。即代码在公司内部，对项目组成员一视同仁的开放。 公司对代码库进行合理分解，对每个代码库分别授权。即某个代码库对团队成员完全开放，对其它团队完全封闭。 公司使用Subversion做集中式的版本控制，个人和/或团队使用 Git-svn。这样在无法改变公司版本控制策略时，程序员可以采用的变通之法。 Git服务器的部署实际上可以使用钩子对分支和路径进行写授权，即可以控制谁能够创建分支，能够写特定文件。 10 优缺点比较 10.1 SVN优缺点 优点： 管理方便，逻辑明确，符合一般人思维习惯。 易于管理，集中式服务器更能保证安全性。 代码一致性非常高。 适合开发人数不多的项目开发。 缺点： 服务器压力太大，数据库容量暴增。 如果不能连接到服务器上，基本上不可以工作，看上面第二步，如果服务器不能连接上，就不能提交，还原，对比等等。 不适合开源开发（开发人数非常非常多，但是Google app engine就是用svn的）。但是一般集中式管理的有非常明确的权限管理机制（例如分支访问限制），可以实现分层管理，从而很好的解决开发人数众多的问题。 10.2 Git优缺点 优点： 适合分布式开发，强调个体。 公共服务器压力和数据量都不会太大。 速度快、灵活。 任意两个开发者之间可以很容易的解决冲突。 离线工作。 缺点： 学习周期相对而言比较长。 不符合常规思维。 代码保密性差，一旦开发者把整个库克隆下来就可以完全公开所有代码和版本信息。","categories":[{"name":"环境与工具","slug":"环境与工具","permalink":"https://dragonliu2022.github.io/categories/环境与工具/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://dragonliu2022.github.io/tags/Git/"}]},{"title":"指针 vs 引用 vs 指针引用","slug":"指针-vs-引用-vs-指针引用","date":"2022-04-18T08:27:41.000Z","updated":"2022-04-18T11:40:19.443Z","comments":true,"path":"2022/04/18/指针-vs-引用-vs-指针引用/","link":"","permalink":"https://dragonliu2022.github.io/2022/04/18/指针-vs-引用-vs-指针引用/","excerpt":"","text":"1 引入 待补充","categories":[{"name":"C++","slug":"C","permalink":"https://dragonliu2022.github.io/categories/C/"}],"tags":[{"name":"待补充","slug":"待补充","permalink":"https://dragonliu2022.github.io/tags/待补充/"}]},{"title":"函数打桩","slug":"函数打桩","date":"2022-04-18T08:11:30.000Z","updated":"2022-04-18T15:58:48.152Z","comments":true,"path":"2022/04/18/函数打桩/","link":"","permalink":"https://dragonliu2022.github.io/2022/04/18/函数打桩/","excerpt":"","text":"转载：stub 1 定义 函数打桩，就是将一个函数用另一个函数实现(桩代码)进行替换，以达到在原有函数入口的位置执行新的实现。函数打桩类似于Windows系统中的钩子Hook，不过Hook针对的是事件，这里针对的是函数，或者说是函数的入口。在做C的Cunit单元测试时，遇到了这样的概念，在此梳理一下。 2 目的 函数打桩的目的一般是隔离、占位和控制，这里是参考其他博主的文章进行的大概分类，其实也不是很严格。 隔离就是将复杂的函数从程序中隔离，比如一个复杂的嵌套函数，如果只想要知道前几步的运行结果，则可以在调用下一层函数时替换一个简单的实现，甚至直接return。在进行流程的测试时比较常见。 占位就是对一些未实现的函数进行占位，多见于协同开发中，对于其他人完成的函数可以先使用空函数进行占位。 控制就是将原本的函数功能进行替换，控制流程。如在测试中，替换函数部分内容得到需要的结果，以进行单元测试。或者对一些系统函数进行替换，实现自己的功能。如常见的将内存分配的函数替换为自己重写的内存池分配等，这里就是一个函数Hook。 3 方法 3.1 编译时打桩 用宏定义#define，在预处理时进行字符串替换，将原函数定义成桩函数的形式。同时可以使用条件编译来控制编译选项。 3.2 链接时打桩 将桩函数定义到新的库文件中，并在原代码基础上增加条件编译选项，屏蔽原有的库，采用桩函数库。 3.3 运行时打桩 运行时打桩是对内存的应用，我们知道程序的函数是在代码段中存储，一个函数的操作对应一个栈帧的存储地址，如果在调用函数时，在一旦访问这个栈帧，我们就使它跳转到我们需要的桩函数去，那么也就实现了函数的打桩。这种方法要复杂一点，但是不需要对原有的代码进行修改，而是额外增加了打桩和还原的操作，在进行单元测试时也常用。 简单来说，就是读取到原函数指令的地址，并读取桩函数的地址，并使用jmp命令从原函数跳转到桩函数去，以实现打桩。 一个完整的打桩流程应该分为装载和卸载，因此需要做到的是记录原函数的函数指针，记录桩函数的函数指针，计算地址差值，调用jmp指令，完成桩函数的装载。使用完成后，再删除jmp指令，恢复原函数。此间由于操作系统对于进程的保护机制，可能存在对于进程内存的解锁和权限设置，将指定内存区域设定为可读可写可操作的权限。 3.3.1 数据结构 设定一个链表用于存储原函数、桩函数之间的对应关系，使用链表是为了动态分配同时记录多个函数。数据结构如下： 1234567struct stub &#123; struct stub *node; void *orig_f; //原函数的函数指针 void *stub_f; //桩函数的函数指针 unsigned int old_flg; //存储原有内存的权限 unsigned char assm[5]; //用于暂存原函数起始的5字节指令，用于被jmp指令(0xE9 + 4bytes地址)覆盖后恢复&#125;; 3.3.2 设置内存的保护属性 在Linux下，mprotect()函数可以用于更改指定内存区域的保护属性。原型为： 1234int mprotect(void *addr, size_t len, int prot);//addr为内存起始地址，必须是内存页的起始地址//len为内存区域长度,以字节为单位，必须是页大小的整数倍//prot为权限值，类似于Linux的权限值 同样，在Windows下，采用读取系统的页大小: 12#include &lt;unistd.h&gt;long pagesize = sysconf(_SC_PAGESIZE); 计算内存页的起始地址： 1234static inline void *pageof(const void* p)&#123; return (void *)((unsigned long)p &amp; ~(pagesize - 1));&#125; 3.3.3 安装桩函数 计算原函数与桩函数地址的偏移量，将原函数的入口5字节指令替换为jmp [offset]，同时缓存原本的5字节，用于后续的恢复。 jmp指令对应0xE9，后续为4字节的偏移量。 1234567891011121314151617181920212223242526272829int install_stub(void *orig_f, void *stub_f)&#123; //初始化stub数据结构 struct stub *pstub = calloc(1, sizeof(struct stub)); pstub-&gt;orig_f = orig_f; pstub-&gt;stub_f = stub_f; //设置内存保护属性 if (-1 == mprotect(pageof(orig_f), pagesize * 2, PROT_READ | PROT_WRITE | PROT_EXEC)) &#123; perror(\"mprotect to w+r+x faild\"); exit(errno); &#125; //缓存原函数orig_f头部的5字节指令 memcpy(pstub-&gt;assm, pstub-&gt;orig_f, sizeof(pstub-&gt;assm)); //将头部重写为jmp [offset] *((char*)pstub-&gt;orig_f) = 0xE9; offset = (unsigned int)((long)pstub-&gt;stub_f - ((long)pstub-&gt;orig_f + 5)); *((unsigned int*)((char*)pstub-&gt;orig_f + 1)) = offset; //如果有多线程同时操作，加锁 //lock()； //如果对多个函数打桩，维护struct stub 链表 //list_add(&amp;ptsub-&gt;node, &amp;head)； //unlock();&#125; 3.3.4 卸载桩函数 将原函数开始的5字节恢复，并释放stub结构 123456789101112131415int uninstall_stub(void *stub_f)&#123; //从桩函数链表中找到要释放的桩函数对应的数据结构 struct stub *pstub = NULL: pstub = find_pstub(stub_f); //设置内存保护属性 mprotect(pageof(pstub-&gt;orig_f), pagesize * 2, PROT_READ | PROT_WRITE | PROT_EXEC); //恢复原函数的初始5字节指令 memcpy(pstub-&gt;orig_f, pstub-&gt;assm, sizeof(pstub-&gt;assm)); //删除节点 del_node(pstub)；&#125; 上述代码只包含了关键代码，部分声明省略，并未对异常情况进行处理。 4 进程内存安全 这里的函数打桩利用jmp指令将原有的函数入口跳转到了我们指定的桩函数入口，自然会想到在非法情况下，也利用jmp将原本的函数跳转到指定的函数去。其实这也是一些病毒的做法，跳转到非法代码；或者一些软件破解的方法，将原本的验证机制跳转屏蔽。只不过我们打桩时是在同一进程内部进行了跳转，且是在获取源码到情况下进行的。而在破解和攻击时，一般只有可执行文件的二进制代码，此时可以通过反汇编得到程序的汇编指令，并找到需要修改的函数入口。在攻击时，也存在另外一个问题，就是跨进程的权限，在进程外对进程的内存进行修改。 操作系统对内存的保护，采取了虚拟地址空间（进程独立的虚拟内存），内存起点的随机偏移量（不能找到代码段段入口）等方式。而且mprotect()仅可以对同一进程的内存块进行修改。如果想要修改其他进程的内存块的保护属性，就要从两个方面下手，一是变成同一个进程，另一个则是对mprotect()动手脚。 当成同一个进程，可以使用代码注入，让我们的攻击代码从进程自身发出，则我们的代码就有了通过mprotect改变进程保护属性的权限。 而对mprotect()做手脚，即实现我们自己的mprotect()函数，让其模仿内核函数的行为，但是却拥有跨进程的能力。这就要编写一个类似于mprotect()函数功能的内核模块。 具体的操作暂时还没有深入了解，原理如上述所示。 5 Cunit的使用 CUnit是一个C语言的单元测试框架，以静态链接库的形式，连接到用户代码中。提供了语义丰富的断言和多种测试结果输出接口，可以方便地生成测试报告。可以结合 gcov/lcov等生成测试覆盖度报表。 5.1 结构 Cunit的结构基本如下图所示，分为三层，第一层是总的测试入口，第二层是测试包，第三层是测试用例。然后通过一系列的断言展示测试结果。 5.2 基本流程 编写待测函数对应的测试函数（如果必要，需要写suite的init/cleanup函数） 初始化Test Registry - CU_initialize_registry() 把测试包（Test Suites）加入到Test Registry - CU_add_suite() 把测试用例（Test Case）加入到测试包当中 - CU_add_test() 使用适当的接口来运行测试测试程序，例如 CU_console_run_tests() 清除Test Registry - CU_cleanup_registry() 6 参考 wangwencong-认识单元测试中的打桩 守望-库打桩机制-偷梁换柱 一种C语言”打桩”的源码实现 Covfefe-深入Linux | 如何在任意进程中修改内存保护（含PoC） 陈令祥-CUnit测试工具","categories":[{"name":"未分类","slug":"未分类","permalink":"https://dragonliu2022.github.io/categories/未分类/"}],"tags":[{"name":"待补充","slug":"待补充","permalink":"https://dragonliu2022.github.io/tags/待补充/"}]},{"title":"华为实习任务-codecheck","slug":"华为实习任务-codecheck","date":"2022-04-18T05:40:01.000Z","updated":"2022-04-18T16:50:22.812Z","comments":true,"path":"2022/04/18/华为实习任务-codecheck/","link":"","permalink":"https://dragonliu2022.github.io/2022/04/18/华为实习任务-codecheck/","excerpt":"","text":"1 引入 在华为实习的三个月(2021.9-2021.11)中有两个月(9&amp;11月)都在做codecheck的工作，重复性操作，&quot;毫无&quot;技术含量可言。 令我惊讶的是：2022年4月份在实习答辩时，我说做了codecheck的工作。一位老师说（具体咋说的忘了，大致意思是：你是实习生，才三个月，华为不会让你改代码的（指核心代码？），你不要吹过头了），当时我愣住了，哈哈哈哈🥦。 答辩结束后仔细想了下，应该这样说：“实习期间，部门正好有codecheck的任务，我在其中做了一部分工作（包括xxx），改完代码后有检视人员保障代码质量。” 值得肯定的是：面对老师的奇怪语气+奇怪问法，没有进行反驳，毕竟到时间了（答辩每人10min），而且老师也没有听的意思。 总而言之，答辩时表达要得体（本次实习答辩自己多多少少存在这方面的问题，可能真是吹的口吻，只是自己没察觉）；认真听取老师的意见，一些情况下没必要进行反驳。还有就是要努力🥦🥦🥦 华为c++语言编程规范 2 冗余代码 规则4.4.3 不用的代码段直接删除，不要注释掉 被注释掉的代码，无法被正常维护；当企图恢复使用这段代码时，极有可能引入易被忽略的缺陷。 正确的做法是，不需要的代码直接删除掉。若再需要时，考虑移植或重写这段代码。 这里说的注释掉代码，包括用 /* */和 //，还包括 #if 0， #ifdef NEVER_DEFINED 等等。 3 圈复杂度（Cyclomatic complexity） 详见 博客：圈复杂度 定义：软件源码某部分的圈复杂度就是这部分代码中线性无关路径的数量。百度百科 含huge_cyclomatic_complexity和huge_cca_cyclomatic_complexity两个指标；cyclomatic_complexity和cca_cyclomatic_complexity的计算差异： cca_cyclomatic_complexity：不管switch里面有多少个case，圈复杂度只加1 cyclomatic_complexity：switch里面有多少个case，圈复杂度就加多少 精髓：覆盖所有的可能情况最少使用的测试用例个数 ?: 三元运算符 +1 case +1 default +1 else +1 华为规则：圈复杂度改到15以下 4 超大目录 华为规则：超大目录门槛50 拆分标准：根据数据库表，PDMReader 5 降低文件重复率 问题：采用抽离函数的方式降DT重复率，但是cpp文件中重复代码过多且存在不同，所以会导致函数参数过多；抽离的函数中使用的if-else也会过多，导致圈复杂度上升； 解决：将抽离函数按照功能块再拆分 6 llvm(clang-tidy) llvm原生的，华为版本的 重新下库后需要执行： 12345mkdir cmake_buildcd cmake_buildcmake -DCMAKE_EXPORT_COMPILE_COMMANDS=1 -DCMAKE_TOOLCHAIN_FILE=../cmake/scripts/gcc_all_toolchain.cmake ..cp ./compile_commands.json ..cd .. 在01_RB下执行命令，工具路径替换成自己的： 1/usr1/dragon/llvm/tools/clang/tools/extra/clang-tidy/tool/run-clang-tidy.py -check=-*,modernize-use-nullptr,modernize-use-using,modernize-use-override -clang-tidy-binary='/usr1/dragon/llvm/build/bin/clang-tidy' -clang-apply-replacements-binary='/usr1/dragon/llvm/build/bin/clang-apply-replacements' -header-filter=./rating_charging/cppcode/tools/* -fix ./rating_charging/cppcode/tools 自动化修复： modernize-use-nullptr modernize-use-using：typedef-&gt;using modernize-use-override 7 c++类型风格转换 先去了解清楚C++11类型转换的语法 几种转换使用的场景 8 超大函数（huge method） 代码行大于阈值（阈值由产品CMC根据自身情况决策、定义）的函数 9 G.EXP.35-CPP 使用nullptr作为空指针常量 【级别】 要求 【描述】 C++11开始引入了nullptr关键字代表空指针，在此之前使用NULL宏来表示空指针常量，导致出现如下问题： 12345678#define NULL ((void*)0)char* str = NULL; // 编译错误: void* 不能自动转换为 char*void(C::*pmf)() = &amp;C::Func;if (pmf == NULL) &#123; // 编译错误: void* 不能自动转换为指向成员函数的指针 ...&#125; 如果把NULL被定义为0或0L。可以解决上面的问题。或者在需要空指针的地方直接使用0。 但这引入另一个问题，代码不清晰，特别是使用auto自动推导时更为突出： 1234auto result =Find(id);if (result == 0) &#123;// Find() 返回的是 指针 还是 整数? // do something&#125; 0字面上是int类型(0L是long)，所以NULL和0都不是指针类型。 当重载指针和整数类型的函数时，传递NULL或0都调用到整数类型重载的函数: 12345void F(int);void F(int*);F(0); // 调用 F(int)，而非 F(int*)F(NULL);// 调用 F(int)，而非 F(int*) 另外，sizeof(NULL) == sizeof(void*)并不一定总是成立的，直接使用0或0L，代码不清晰，且无法做到类型安全；使用NULL无法做到类型安全。这些都是潜在的风险。 nullptr的优势不仅仅是在字面上代表了空指针，使代码清晰，而且它不再是一个整数类型。 nullptr是std::nullptr_t类型，而std::nullptr_t可以隐式的转换为所有的原始指针类型，这使得nullptr可以表现成指向任意类型的空指针。 12345678void F(int);void F(int*);F(nullptr); // 调用 F(int*)auto result =Find(id);if (result ==nullptr) &#123; // Find() 返回的是 指针 // do something&#125; 10 G.EXP.03-CPP 使用using定义类型别名 **【级别】**建议 【描述】 类型的别名实际是对类型的封装。而通过封装，可以让代码更清晰，同时在很大程度上避免类型变化带来的散弹式修改。 在C++11之前，可以通过typedef定义类型的别名： 1typedef std::map&lt;uint32_t, std::vector&lt;int&gt;&gt; SomeType; 在C++11之后，提供using，实现声明别名(alias declarations): 1using SomeType = std::map&lt;uint32_t, std::vector&lt;int&gt;&gt;; 对比两者的格式，使用using更容易理解： 12typedef Type Alias; // Type 在前，还是 Alias 在前，不宜历届using Alias = Type; // 符合'赋值'的用法，容易理解，不易出错 如果觉得这点还不足以切换到using，我们接着看看模板别名(alias template)更简洁: 12345678910111213// 定义模板的别名，一行代码template&lt;class T&gt; // templateusing MyAllocatorVector = std::vector&lt;T,MyAllocator&lt;T&gt;&gt;;MyAllocatorVector&lt;int&gt; data;// 使用 using 定义的别名template&lt;class T&gt; // templateclass MyClass &#123; ... private: MyAllocatorVector&lt;int&gt; data_;// 模板类中使用 using 定义的别名&#125;; 而typedef不支持带模板参数的别名，只能”曲线救国”: 123456789101112131415// 通过模板包装 typedef，需要实现一个模板类template&lt;class T&gt;struct MyAllocatorVector &#123; typedef std::vector&lt;T,MyAllocator&lt;T&gt;&gt; type;&#125;;MyAllocatorVector&lt;int&gt;::type data; // 使用 typedef 定义的别名，多写 ::typetemplate&lt;class T&gt;class MyClass &#123; ... private: typename MyAllocatorVector&lt;int&gt;::type data_; // 模板类中使用，除了 ::type，还需要加上 typename&#125;; 实习中遇到的实例： 123456789101112131415161718// 数组typedef TChar NumArray[24];using NumArray = TChar[24];// 结构体c++中，定义变量无需加关键字structtypedef struct &#123; TUInt4 uiAVPcode; TUChar ucAVPflag_r : 5; ...&#125; AVPHEAD;struct AVPHEAD &#123; ...&#125; ;// 函数指针// typedef 返回类型(*新类型)(参数表)typedef RETCODE (*FnFmtFunc)(const TChar* cdrBuff, TUInt4 cdrLen) const;using FnFmtFunc = RETCODE (*)(const TChar* cdrBuff, TUInt4 cdrLen) const; 10 G.CLS.12-CPP 在重写虚函数时应明确指定override或final **【级别】**要求 【描述】 在重写虚函数时明确指定override或final，能保证该函数是重写了基类的虚函数，并且无需再添加virtual关键字。如果派生类函数与基类函数原型不一致，则产生编译错误。final还保证虚函数不会再被派生类重写。 virtual 表示一个新的虚函数 override 表示重写了基类中的虚函数，可以再被派生类重写 final 表示重写了基类中的虚函数，不能再被派生类重写 使用override或final关键字后，如果修改了基类虚函数原型，但忘记修改子类重写的虚函数，在编译期就可以发现。也可以避免有多个子类时，重写虚函数的修改遗漏。 【正例】 123456789101112131415161718class Base &#123;public: Base(); virtual ~Base(); virtual void Foo(); virtual void Foo(int var); void Bar();&#125;;class Derived(): public Base &#123;public: Derived(); ~Derived() override; // 符合：析构函数添加override void Foo(int var) final; // 符合：重写基类函数，且Derived的派生类不能再重写此函数 void Foo() override;// 符合：重写基类函数 void Foo() const override;// 编译失败: Derived::Foo 和 Base::Foo 原型不一致， void Bar() override;// 编译失败: Base::Bar 不是虚函数&#125;; 总结 基类首次定义虚函数，使用virtual关键字 子类重写基类虚函数（包括析构函数），使用override或final关键字（但不要两者一起使用），并且不使用virtual关键字 非虚函数，virtual、override和final都不使用 【实习实例】 1234567891011121314151617DECLARE_SERVICE_PLUGIN(CBypassMsgController);#define DECLARE_SERVICE_PLUGIN(CLASS_NAME) \\DECLARE_SERVICE_COMPONET(CLASS_NAME); \\protected: \\ virtual const TChar* MyName() const \\ &#123; return #CLASS_NAME; \\ &#125; \\ #define DECLARE_SERVICE_PLUGIN(CLASS_NAME) \\DECLARE_SERVICE_COMPONET(CLASS_NAME); \\protected: \\ virtual const TChar* MyName() const override \\ &#123; return #CLASS_NAME; \\ &#125; \\ 11 G.EXP.29-CPP 比较两个表达式，左侧倾向于变化，右侧倾向于不变 **【级别】**建议 【描述】 当变量与常量比较时，如果常量放左边，如 if (MAX == v) 不符合阅读习惯，而 if (MAX &gt; v) 更是难于理解。 应当按人的正常阅读、表达习惯，将常量放右边。写成如下方式： 【正例】 1234567if (value == MAX) &#123; ...&#125;if (value &lt; MAX) &#123; ...&#125; 也有特殊情况，如：if (MIN &lt; value &amp;&amp; value &lt; MAX) 用来描述区间时，前半段是常量在左的。 不用担心将 == 误写成 =，因为if (value = MAX) 会有编译告警，其他静态检查工具也会报错。让工具去解决笔误问题，代码要符合可读性第一。 【脚本误报】 1234567// 逻辑或if ('N' == cSIPChgSubsNoType || '\\0' == cSIPChgSubsNoType) if (cSIPChgSubsNoType == 'N' == cSIPChgSubsNoType || '\\0')// 逻辑并TBool bContinue = 0 &gt;= lSecUnpaid &amp;&amp; bSingle;TBool bContinue = lSecUnpaid &amp;&amp; bSingle &lt;= 0; 12 其他 G.FMT.02-CPP 使用空格进行缩进，每次缩进4个空格 G.CMT.03-CPP 文件头注释包含版权说明 G.CMT.02-CPP 代码注释置于对应代码的上方或右边 G.FMT.06-CPP 换行时将操作符留在行末，新行缩进一层或进行同类对齐 G.FMT.09-CPP 构造函数初始化列表放在同一行或按4空格缩进并排多行 G.FMT.13-CPP case/default语句相对于switch缩进一层","categories":[{"name":"未分类","slug":"未分类","permalink":"https://dragonliu2022.github.io/categories/未分类/"}],"tags":[{"name":"重构","slug":"重构","permalink":"https://dragonliu2022.github.io/tags/重构/"}]},{"title":"Clion项目配置教程","slug":"Clion项目配置教程","date":"2022-04-16T16:31:32.000Z","updated":"2022-04-16T17:08:48.772Z","comments":true,"path":"2022/04/17/Clion项目配置教程/","link":"","permalink":"https://dragonliu2022.github.io/2022/04/17/Clion项目配置教程/","excerpt":"","text":"1 下载clion，申请license 在clion官网下载安装包（在华为实习时是在IT工具库下载的）； 申请license，学生邮箱免费使用（公司里面需要审批申请license）； 2 第一次打开clion前修改缓存位置 打开下载目录bin文件夹下idea.properties文件； 放开如下注释，并修改idea.config.path和idea.system.path的取值（事先创建这两个目录）： 1234idea.config.path=目录1idea.system.path=目录2idea.plugins.path=$&#123;idea.config.path&#125;/pluginsidea.log.path=$&#123;idea.system.path&#125;/log 这一步是为了避免C盘存放JetBrains的工程缓存内容而被过度占用。 如果clion已经打开了，也可以修改此配置，只不过可能要重新配置一下clion的初始化步骤。 3 下载01_RB代码，用clion打开 打开部门主仓库； Fork自己的仓库； 安装git并配置，然后将自己的仓库拉到本地。 4 手动代理设置 点击文件(File)，选择设置(setting)，选择外观和行为——系统设置——HTTP代理 进行配置： 主机名：proxy.huawei.com 端口：8080 不为以下项使用代理：127.0.0.1, 10.*.100.*, *.huawei.com 5 安装插件 打开clion，点击文件(File)，选择设置(settings)，选择插件(plugins)； 安装以下插件：Chinese，（JetBrains Foundation，Huawei Jetbrains Marketplace，codecheck未找到） 重启IDE生效 6 配置远程工作模式 配置工具链：点击文件(File)，选择设置(setting)，选择构建、执行、部署——工具链，添加远程主机，配置远程主机信息。凭据需要点击后方齿轮进行配置。Make，C编译器，C++编译器会自动检测，不需要配置。 配置CMake： CMake 选项：-DCMAKE_TOOLCHAIN_FILE=../cmake/scripts/gcc_ut_toolchain.cmake .. 构建目录：cmake-build-debug（需要与自己项目中的目录对应） 构建选项：-- -j 32（多线程） 环境：CHG_HOME=xxx;LD_LIBRARY_PATH=xxx（需要和自己项目中的目录对应） 配置部署：点击文件，选择设置，选择部署，点击映射，配置部署路径：/usr1/dragon/01_RB（改成自己的，远程主机上的项目根目录） Debug配置：登陆到远程主机，将环境变量添加到~/.bashrc 1234export CHG_HOME=xxxexport LD_LIBRARY_PATH=xxxexport TZ=BEST-8export BILLING_HOME=xxx 7 clang-format的使用 将.clang-fromat文件放到要打开项目的根目录下，CLion会自动启用ClangFormat并应用设置； 在文件——设置——编辑器——代码样式勾选启用ClangFormat，然后状态栏会显示ClangFormat； 使用快捷键Ctrl+Alt+L，可以重新格式化选定代码，没有选定代码时，会格式化整个文件； 8 UT的配置 选择编辑配置--UTTest，进行配置并应用： 程序参数：nolog --gtest_filter=&quot;xxx&quot;（后面的–gtest_filter=&quot;…&quot;是根据CLion输出信息填写的，过滤掉无关报错） 环境变量：CHG_HOME=xxx;LD_LIBRARY_PATH=xxx;TZ=BEST-8;BILLING_HOME=xxx 单个执行配置，在当前界面点击编辑配置模板，选择Google Test，进行配置并应用： 目标：选择UTTest 程序参数：不用填 工作目录：\\usr1\\dragon\\01_RB\\test\\rating_charging\\cppcode\\90_uttest\\bin （需要改成自己的） 环境变量：CHG_HOME=xxx;LD_LIBRARY_PATH=xxx;TZ=BEST-8;BILLING_HOME=xxx（需要改成自己的） 9 编译 点击运行按钮，如果出现下面的报错： 12c++: internal compiler error... 编译内部错误有可能是后台内存不足导致的，点击左边的构建按钮，可能会编译成功。 如果后面再出现这种错误，就把构建选项中的数字改小一点：-- -j 32","categories":[{"name":"环境与工具","slug":"环境与工具","permalink":"https://dragonliu2022.github.io/categories/环境与工具/"}],"tags":[]},{"title":"Jenkins配置定时发送邮件功能","slug":"Jenkins配置定时发送邮件功能","date":"2022-04-16T15:48:10.000Z","updated":"2022-04-18T16:08:20.970Z","comments":true,"path":"2022/04/16/Jenkins配置定时发送邮件功能/","link":"","permalink":"https://dragonliu2022.github.io/2022/04/16/Jenkins配置定时发送邮件功能/","excerpt":"","text":"0 安装Jenkins 如何在 Ubuntu 20.04 上安装 Jenkins Jenkins 是最流行的，开源的，基于 Java 的自动化服务器，它允许你很容易地设置一个持续集成和持续发布的管道。 持续集成 (CI)是一个 DevOps 实践。当团队成员正常提交代码到版本控制仓库时，会运行自动化构建和测试。持续发布（CD）是一系列实践，当代码修改后，自动构建，测试，并且发布到生产环境中。 Jenkins 可以被作为一个独立应用安装，作为 Java servlet 容器（例如 Apache Tomcat）中的一个 servlet 安装，或者 以 Docker 容器的形式运行。 独立服务的形式安装 Jenkins： 1 发送邮件 1.1 设置参数 为了使得下面脚本成功执行，需要设置以下参数： Receiver 邮件接收邮箱 Copyer 邮件抄送邮箱 Subject 邮件主题 ReportLink 邮件链接 ReportFile 邮件报告文件（本次测试中未使用） 样例如下： 1.2 运行脚本 该脚本在01_RB工程中已存在，根据需求修改即可。路径：test/install/AutoInstallRB/icp/send_report_email.py 运行脚本： 1python3 send_report_email.py -u \"用户ID/codehub密码的Base64编码\" \"本人邮箱\" \"$Receiver\" \"$Copyer\" \"$ReportFile\" \"$Subject\" \"$ReportLink\" send_report_email.py脚本路径目录：E:\\04 Worker_work\\01 实习\\202109-华为C++后端实习\\hw-addlcov\\CBS-SW\\01_RB\\scripts 2 Jenkins 定时任务时间设置 2.1 定时任务的时间格式 定时任务的时间格式设定遵循的是cron的语法规则。具体的格式划分为5个字段：分别为 分钟、小时、日、月、星期、通过tab或者空格进行隔离区分 字段 * * * * * 含义 分钟 小时 日期 月份 星期 取值范围 0-59 0-23 1月30日 1月11日 0-7 实例 每隔15分钟执行一次 H/15 * * * * 每隔2小时执行一次 H H/2 * * * 每隔3天执行一次 H H H/3 * * 每隔3天执行一次（每月1-15号） H H 1-15/3 * * 每隔1、3、5执行一次 H H * * 1,3,5 规则 指定时间范围 a-b 指定时间间隔 / 指定变量取值 a,b,c 参数含义： *代表 匹配范围内所有值 M-N 匹配M~N范围内所有值 M-N/X 或者 */X 在指定M~N范围内或整个有效区间内每隔X构建一次 A,B,…,Z 匹配多个值 2.2 一些常用的时间规则 时间规则 规则内容 每天上午9点定时构建 H 9 * * * 每天上午11点和下午6点定时构建 H 11,18 * * * 每个小时的前30分钟内，每10分钟构建一次 H(0-29)/10 * * * * 周一到周五，9-16点，每2小时的第45分钟构建一次 45 9-16/2 * * 1-5 每个工作日从早上9点到下午5点这段时间内每间隔2小时之间的某刻。(或许在上午10:38, 下午12:38, 下午2:38 , 下午4:38) H H(9-16)/2 * * 1-5 每月（除了12月）从1号到15号这段时间内某刻 H H 1,15 1-11 * 2.3 样例","categories":[{"name":"环境与工具","slug":"环境与工具","permalink":"https://dragonliu2022.github.io/categories/环境与工具/"}],"tags":[]},{"title":"圈复杂度","slug":"圈复杂度","date":"2022-04-15T12:03:41.000Z","updated":"2022-04-18T16:10:02.076Z","comments":true,"path":"2022/04/15/圈复杂度/","link":"","permalink":"https://dragonliu2022.github.io/2022/04/15/圈复杂度/","excerpt":"","text":"转载：详解圈复杂度 1 圈复杂度概念 圈复杂度（Cyclomatic complexity，简写CC）也称为条件复杂度，是一种代码复杂度的衡量标准。由托马斯·J·麦凯布（Thomas J. McCabe, Sr.）于1976年提出，用来表示程序的复杂度，其符号为VG或是M。它可以用来衡量一个模块判定结构的复杂程度，数量上表现为独立现行路径条数，也可理解为覆盖所有的可能情况最少使用的测试用例数。圈复杂度大说明程序代码的判断逻辑复杂，可能质量低且难于测试和维护。程序的可能错误和高的圈复杂度有着很大关系。 2 圈复杂度计算方法 2.1 点边计算法 圈复杂度的计算方法很简单，计算公式为： V(G) = E - N + 2 其中，e表示控制流图中边的数量，n表示控制流图中节点的数量。 几个节点通过边连接。下面是典型的控制流程，如if-else，While，until和正常的流程顺序： 2.2 节点判定法 其实，圈复杂度的计算还有更直观的方法，因为圈复杂度所反映的是“判定条件”的数量，所以圈复杂度实际上就是等于判定节点的数量再加上1，也即控制流图的区域数，对应的计算公式为： V (G) = P + 1 其中P为判定节点数，判定节点举例： if语句 while语句 for语句 case语句 catch语句 and和or布尔操作 ?:三元运算符 对于多分支的CASE结构或IF-ELSEIF-ELSE结构，统计判定节点的个数时需要特别注意一点，要求必须统计全部实际的判定节点数，也即每个ELSEIF语句，以及每个CASE语句，都应该算为一个判定节点。 判定节点在模块的控制流图中很容易被识别出来，所以，针对程序的控制流图计算圈复杂度V(G)时，一般采用点边计算法，也即V(G)=e-n+2；而针对模块的控制流图时，可以直接使用统计判定节点数，这样更为简单。 3 圈复杂度计算练习 3.1 练习1： 12345678910111213141516void sort(int * A)&#123; int i=0; int n=4; int j = 0; while(i &lt; n-1) &#123; j = i +1 while(j &lt; n) &#123; if (A[i] &lt; A[j]) swap(A[i], A[j]); &#125; i = i + 1 &#125;&#125; 使用点边计算法绘出控制流图： 其圈复杂度为：V(G) = 9 - 7 + 2 = 4 3.2 练习2： 12345678910111213141516171819202122232425262728293031U32 find (string match)&#123; for(auto var : list) &#123; if(var == match &amp;&amp; from != INVALID_U32) return INVALID_U32; &#125; //match step1 if(session == getName() &amp;&amp; key == getKey()) &#123; for (auto&amp; kv : Map) &#123; if (kv.second == last &amp;&amp; match == kv.first) &#123; return last; &#125; &#125; &#125; //match step2 auto var = Map.find(match); if(var != Map.end()&amp;&amp; (from != var-&gt;second)) return var-&gt;second; //match step3 for(auto var: Map) &#123; if((var.first, match) &amp;&amp; from != var.second) &#123; return var.second; &#125; &#125; return INVALID_U32;&#125;; 其圈复杂度为：V(G) = 1(for) + 2(if) + 2(if) + 1(for) + 2(if) + 2(if) + 1(for) + 2(if) + 1= 14 4 圈复杂度的意义 在缺陷成为缺陷之前捕获它们。 4.1 圈复杂度与缺陷 一般来说圈复杂度大于10的方法存在很大的出错风险。圈复杂度和缺陷个数有高度的正相关：圈复杂度最高的模块和方法，其缺陷个数也可能最多。 4.2 圈复杂度与结构化测试 此外，它还为测试设计提供很好的参考。一个好的用例设计经验是：**创建数量与被测代码圈复杂度值相等的测试用例，**以此提升用例对代码的分支覆盖率。 4.3 圈复杂度与TDD TDD（测试驱动的开发，test-driven development)和低CC值之间存在着紧密联系。在编写测试时，开发人员会考虑代码的可测试性，倾向于编写简单的代码，因为复杂的代码难以测试。因此TDD的“代码、测试、代码、测试” 循环将导致频繁重构，驱使非复杂代码的开发。 4.4 圈复杂度与遗留代码 对于遗留代码的维护或重构，测量圈复杂度特别有价值。一般使用圈复杂度作为提升代码质量的切入点。 4.5 圈复杂度与CI 在持续集成环境中，可以基于时间变化维度来评估模块或函数的复杂度和增长值。如果CC值在不断增长，那么应该开展两项活动： 确保相关测试的有效性，减少故障风险。 评估重构必要性和具体方式，以降低出现代码维护问题的可能性。 4.6 圈复杂度和软件质量 圈复杂度 代码状况 可测性 维护成本 1-10 清晰、结构化 高 低 10-20 复杂 中 中 20-30 非常复杂 低 高 &gt;30 不可读 不可测 非常高 5 降低圈复杂度的方法 5.1 重新组织你的函数 5.1.1 技巧1 提炼函数 有一段代码可以被组织在一起并独立出来: 123456789101112void Example(int val)&#123; if( val &gt; MAX_VAL) &#123; val = MAX_VAL; &#125; for( int i = 0; i &lt; val; i++) &#123; doSomething(i); &#125;&#125; 将这段代码放进一个独立函数中，并让函数名称解释该函数的用途: 123456789101112131415161718192021int getValidVal(int val)&#123; if( val &gt; MAX_VAL) &#123; return MAX_VAL; &#125; return val;&#125;void doSomethings(int val)&#123; for( int i = 0; i &lt; val; i++) &#123; doSomething(i); &#125;&#125;void Example(int val)&#123; doSomethings(getValidVal(val));&#125; 最后还要重新审视函数内容是否在统一层次上。 5.1.2 技巧2 替换算法 把某个算法替换为另一个更清晰的算法： 123456789101112131415string foundPerson(const vector&lt;string&gt;&amp; peoples)&#123; for (auto&amp; people : peoples) &#123; if (people == \"Don\")&#123; return \"Don\"; &#125; if (people == \"John\")&#123; return \"John\"; &#125; if (people == \"Kent\")&#123; return \"Kent\"; &#125; &#125; return \"\";&#125; 将函数实现替换为另一个算法: 12345678910111213string foundPerson(const vector&lt;string&gt;&amp; people)&#123; std::map&lt;string,string&gt;candidates&#123; &#123; \"Don\", \"Don\"&#125;, &#123; \"John\", \"John\"&#125;, &#123; \"Kent\", \"Kent\"&#125;, &#125;; for (auto&amp; people : peoples) &#123; auto&amp; it = candidates.find(people); if(it != candidates.end()) return it-&gt;second; &#125;&#125; 所谓的表驱动。 5.2 简化条件表达式 5.2.1 技巧3 逆向表达 在代码中可能存在条件表达如下： 12345678if ((condition1() &amp;&amp; condition2()) || !condition1())&#123; return true;&#125;else&#123; return false;&#125; 应用逆向表达调换表达顺序后效果如下： 123456if(condition1() &amp;&amp; !condition2())&#123; return false;&#125;return true; 5.2.2 技巧4 分解条件 在代码中存在复杂的条件表达： 1234if(date.before (SUMMER_START) || date.after(SUMMER_END)) charge = quantity * _winterRate + _winterServiceCharge;else charge = quantity * _summerRate; 从if、then、else三个段落中分别提炼出独立函数： 1234if(notSummer(date)) charge = winterCharge(quantity);else charge = summerCharge (quantity); 5.2.3 技巧5 合并条件 一系列条件判断，都得到相同结果: 1234567double disabilityAmount() &#123; if (_seniority &lt; 2) return 0; if (_monthsDisabled &gt; 12) return 0; if (_isPartTime) return 0; // compute the disability amount ...... 将这些判断合并为一个条件式，并将这个条件式提炼成为一个独立函数: 12345double disabilityAmount() &#123; if (isNotEligableForDisability()) return 0; // compute the disability amount ...... 5.2.4 技巧6 移除控制标记 在代码逻辑中，有时候会使用bool类型作为逻辑控制标记： 12345678910111213141516void checkSecurity(vector&lt;string&gt;&amp; peoples) &#123; bool found = false; for (auto&amp; people : peoples) &#123; if (! found) &#123; if (people == \"Don\")&#123; sendAlert(); found = true; &#125; if (people == \"John\")&#123; sendAlert(); found = true; &#125; &#125; &#125;&#125; 使用break和return取代控制标记： 12345678910void checkSecurity(vector&lt;string&gt;&amp; peoples) &#123; for (auto&amp; people : peoples) &#123; if (people == \"Don\" || people == \"John\") &#123; sendAlert(); break; &#125; &#125;&#125; 5.2.5 技巧7 以多态取代条件式 条件式根据对象类型的不同而选择不同的行为： 123456789101112double getSpeed() &#123; switch (_type) &#123; case EUROPEAN: return getBaseSpeed(); case AFRICAN: return getBaseSpeed() - getLoadFactor() *_numberOfCoconuts; case NORWEGIAN_BLUE: return (_isNailed) ? 0 : getBaseSpeed(_voltage); &#125; throw new RuntimeException (\"Should be unreachable\");&#125; 将整个条件式的每个分支放进一个子类的重载方法中，然后将原始函数声明为抽象方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243class Bird&#123;public: virtual double getSpeed() = 0; protected: double getBaseSpeed();&#125;class EuropeanBird&#123;public: double getSpeed() &#123; return getBaseSpeed(); &#125;&#125;class AfricanBird&#123;public: double getSpeed() &#123; return getBaseSpeed() - getLoadFactor() *_numberOfCoconuts; &#125; private: double getLoadFactor(); double _numberOfCoconuts;&#125;class NorwegianBlueBird&#123;public: double getSpeed() &#123; return (_isNailed) ? 0 : getBaseSpeed(_voltage); &#125;; private: bool _isNailed;&#125; 5.3 简化函数调用 5.3.1 技巧8 读写分离 某个函数既返回对象状态值，又修改对象状态: 1234class Customer&#123; int getTotalOutstandingAndSetReadyForSummaries(int number);&#125; 建立两个不同的函数，其中一个负责查询，另一个负责修改: 12345class Customer&#123; int getTotalOutstanding(); void SetReadyForSummaries(int number);&#125; 5.3.2 技巧9 参数化方法 若干函数做了类似的工作，但在函数本体中却 包含了不同的值: 12345678910111213Dollars baseCharge() &#123; double result = Math.min(lastUsage(),100) * 0.03; if (lastUsage() &gt; 100) &#123; result += (Math.min (lastUsage(),200) - 100) * 0.05; &#125; if (lastUsage() &gt; 200) &#123; result += (lastUsage() - 200) * 0.07; &#125; return new Dollars (result);&#125; 建立单一函数，以参数表达那些不同的值： 123456789101112131415Dollars baseCharge() &#123; double result = usageInRange(0, 100) * 0.03; result += usageInRange (100,200) * 0.05; result += usageInRange (200, Integer.MAX_VALUE) * 0.07; return new Dollars (result);&#125;int usageInRange(int start, int end) &#123; if (lastUsage() &gt; start) return Math.min(lastUsage(),end) -start; return 0;&#125; 5.3.3 技巧10 以明确函数取代参数 函数实现完全取决于参数值而采取不同反应： 12345678void setValue (string name, int value) &#123; if (name == \"height\") _height = value; else if (name == \"width\") _width = value; Assert.shouldNeverReachHere();&#125; 针对该参数的每一个可能值，建立一个独立函数： 12345678void setHeight(int arg) &#123; _height = arg;&#125;void setWidth (int arg) &#123; _width = arg;&#125; 5.4 实战练习 还是以之前统计CC值的例子： 1234567891011121314151617181920212223242526272829303132U32 find (string match)&#123; for(auto var : List) &#123; if(var == match &amp;&amp; from != INVALID_U32) return INVALID_U32; &#125; //match step1 if(session == getName() &amp;&amp; key == getKey()) &#123; for (auto&amp; kv : Map) &#123; if (kv.second == last &amp;&amp; match == kv.first) &#123; return last; &#125; &#125; &#125; //match step2 auto var = Map.find(match); if(var != Map.end()&amp;&amp; (from != var-&gt;second)) return var-&gt;second; //match step3 for(auto var: Map) &#123; if((var.first, match) &amp;&amp; from != var.second) &#123; return var.second; &#125; &#125; return INVALID_U32; &#125;; 综合运用降低CC值的技巧后： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106namespace&#123; struct Matcher &#123; Matcher(string name, string key); U32 find(); private: bool except(); U32 matchStep1(); U32 matchStep2(); U32 matchStep3(); bool isTheSameMatch(); string match; U32 from; &#125;; Matcher::Matcher(string name, string key): match(name + key) &#123; from = GetFrom(); &#125; U32 Matcher::find() &#123; if (except()) return INVALID_U32; auto result = matchStep1(); if (result != INVALID_U32) return result; result = matchStep2(); if (result != INVALID_U32) return result; return matchStep3(); &#125; bool Matcher::except() &#123; for(auto var : List) &#123; if(var == match &amp;&amp; from != INVALID_U32) return true; &#125; return false; &#125; U32 Matcher::matchStep1() &#123; if(!isTheSameMatch()) &#123; return INVALID_U32; &#125; for (auto&amp; kv : Map) &#123; if ( last == kv.second &amp;&amp; match == kv.first) &#123; return last; &#125; &#125; return INVALID_U32; &#125; bool Matcher::isTheSameMatch() &#123; return match == getName() + getKey(); &#125; U32 Matcher::matchStep2() &#123; auto var = Map.find(match); if(var != Map.end()&amp;&amp; (from != var-&gt;second)) &#123; return var-&gt;second; &#125; return INVALID_U32; &#125; U32 Matcher::matchStep3() &#123; for(auto var: Map) &#123; if(keyMatch(var.first, match) &amp;&amp; from != var.second) &#123; return var.second; &#125; &#125; return INVALID_U32; &#125;&#125;U32 find (string match)&#123; Matcher matcher; return matcher.find(match);&#125; 该例子将匹配算法都封装到Matcher类中，并将原有逻辑通过提炼函数（技巧1）和合并条件（技巧6）将匹配逻辑抽象成能力查询、粘滞、精确匹配及模糊匹配四个步骤，这样将循环和条件分支封入小函数中，从而降低接口函数（findPno）的圈复杂度，函数职责也更加单一和清晰。整体圈复杂度从单个函数的14降到多个函数最高的5。 6 圈复杂度思辨 6.1 思辨1 高复杂度的代码是否可维护性差 在实际项目中为了调试方便，经常会把消息号对应的名称打印出来： 123456789101112131415161718192021222324string getMessageName(Message msg)&#123; switch(msg) &#123; case MSG_1: return \"MSG_1\"; case MSG_2: return \"MSG_2\"; case MSG_3: return \"MSG_3\"; case MSG_4: return \"MSG_4\"; case MSG_5: return \"MSG_5\"; case MSG_6: return \"MSG_6\"; case MSG_7: return \"MSG_7\"; case MSG_8: return \"MSG_8\"; default: return \"MSG_UNKNOWN\" &#125;&#125; 这段代码无论从可读性来说，还是从可维护性来说都是可以接收的。因此，当因为”高”复杂度就进行重构的话（例如：技巧2或技巧6），在降低圈复杂度的同时会带来不必要的逻辑复杂度。 当然，如果出现下面的情况的话，还是有必要进一步降低圈复杂度的： 消息数过多。 switch…case…多处重复。 对于消息过多的情况，可以考虑将消息进行分类，然后采用技巧1进行重构。对于出现多处重复的情况，可以通过技巧6将同样case的内容内聚到一个具体的类的方法中，然后通过多态的方式来使用。 6.2 思辨2 复杂度相同的代码是否是一致的 例如下面两个代码片段的圈复杂度都是6。 代码片段1： 123456789101112131415161718192021222324string getWeight(int i) &#123; if (i &lt;= 0) &#123; return \"no weight\"; &#125; if (i &lt; 10) &#123; return \"light\"; &#125; if (i &lt; 20) &#123; return \"medium\"; &#125; if (i &lt; 30) &#123; return \"heavy\"; &#125; if (i &lt; 40) &#123; return \"very heavy\"; &#125; return \"super heavy\"&#125; 代码片段2 123456789101112131415161718192021int sumOfNonPrimes(int limit) &#123; bool bAdd = false; int sum = 0; for (int i = 0; i &lt; limit; ++i) &#123; if (i &lt;= 2) continue; for (int j = 2; j &lt; i; ++j) &#123; if (i % j == 0) &#123; bAdd = false; break; &#125; bAdd = true; &#125; if (bAdd) sum += i; &#125; return sum;&#125; 但是它们的代码无论从可读性上来说，还是从可维护性来说，代码片段1应该都优于代码片段2，代码片段2的坏味道更加浓郁。因此，圈复杂度还需要具体情况具体分析，其只能作为重构的一个度量指标，作为决策的一个参考依据。 7 圈复杂度工具 圈复杂度的工具有很多，大致有三类： 类型 名称 说明 专用工具（单语言） OCLint C语言相关 GMetrics Java PyMetrics python JSComplexity js 通用工具（多语言） lizard 支持多种语言：C/C++ (works with C++14)、Java、C#、JavaScript、Objective C、Swift、Python、Ruby、PHP、Scala等。 sourcemonitor 免费、Windows平台。支持语言包括C、C++、C#、Java、VB、Delphi和HTML。 通用平台 sonarqube 一个用于代码质量管理的开源平台，支持20多种语言。通过插件机制可集成不同的测试工具，代码分析工具及持续集成工具 8 参考资料 循環複雜度- 维基百科，自由的百科全书 Learn Mccabe’s Cyclomatic Complexity with Example McCabe’s Cyclomatic Complexity and Why We Don’t Use It","categories":[{"name":"未分类","slug":"未分类","permalink":"https://dragonliu2022.github.io/categories/未分类/"}],"tags":[{"name":"待补充","slug":"待补充","permalink":"https://dragonliu2022.github.io/tags/待补充/"},{"name":"重构","slug":"重构","permalink":"https://dragonliu2022.github.io/tags/重构/"}]},{"title":"代码覆盖率","slug":"代码覆盖率","date":"2022-04-15T08:05:16.000Z","updated":"2022-04-18T16:11:05.206Z","comments":true,"path":"2022/04/15/代码覆盖率/","link":"","permalink":"https://dragonliu2022.github.io/2022/04/15/代码覆盖率/","excerpt":"","text":"1 介绍 代码覆盖率，是一种通过计算测试过程中被执行的源代码占全部源代码的比例，进而间接度量软件质量的方法。 全量覆盖率：基于全部代码的代码覆盖率 增量覆盖率：基于代码增量的代码覆盖率 按性质，它属于白盒测试的范畴，即主要依据源代码的内部结构来设计测试用例，通过设计不同的输入来测试软件的不同部分。 常见的编程语言，如C/C++，python和Java等，都有相应的代码覆盖率测试工具。 2 意义 提升开发者测试意识，可以基于此在程序中寻找没有被测试用例测试过的地方，创建新的测试用例来增加覆盖率，从而提高软件质量； 也为代码管理提供了新的手段，降低管理成本。 注意：代码覆盖率不是灵丹妙药，它只是告诉我们有哪些代码没有被测试用例“执行到”而已，高百分比的代码覆盖率不等于高质量的有效测试。 举例：假设代码覆盖率只在某一些模块代码覆盖率很高，但在一些关键模块并没有足够的测试用例覆盖，那样虽然代码覆盖率很高，但并不能说明产品质量就很高。 Martin Fowler 测试覆盖率 写到： 代码覆盖率是查找代码库中未测试部分的有用工具，然而它作为一个数字说明你的测试有多好用处不大。 3 分类 3.1 语句覆盖（statement coverage） 程序中的语句有多少被执行。它是最常用也是最简单的一种代码覆盖率度量方式，就是度量被测代码中每个可执行语句是否被执行到了。“可执行语句”，并不包括C++的头文件声明、代码注释和空行等。但是，单独一行的花括号｛｝ 常常也被统计进去。 3.2 行覆盖率 有多少行的源代码被测试过。感觉和语句覆盖一样。 3.3 判定覆盖率（decision coverage）or 分支覆盖 又称分支覆盖，所有边界覆盖，基本路径覆盖，判定路径覆盖，它度量程序中每一个判定的分支是否都被测试到了。所谓判定，是指一条判断语句的结果，而不考虑其中包含的子判断的结果和组合情况。 3.4 条件覆盖（condition coverage） 它报告每一个子表达式的结果的true 或false 是否测试到了。即构造测试用例时，要使得每个判定语句中每个逻辑条件的可能值至少满足一次（即每一个被“逻辑与”或“逻辑非”分开的布尔表达式真假值情况）。但是，需要注意的是，条件覆盖不是将判定中的每个条件表达式的结果进行排列组合，而是只要每个条件表达式的结果true和false测试到了就可以了。 3.5 修正条件判定覆盖（modified condition / decision coverage） 前面提到的条件覆盖比语句覆盖和判定覆盖都要严格，但是由于它只关注每个条件表达式的结果是否都被测试到，而不要求对每个条件表达式的解果进行排列组合，所以它也只能覆盖一部分的情况。如果真要做到全覆盖，随着子表达式的增加，不仅测试用例设计的难度会越来越大，而且用例的数量也会指数级增长。 修正条件判定覆盖，要求在一个程序中每一种输入输出至少得出现一次，在程序中的每一个条件必须产生所有可能的输出结果至少一次，并且每一个判定中的每一个条件必须能够独立影响一个判定的输出，即在其他条件不变的前提下仅改变这个条件的值，而使判定结果改变。显然，修正条件判定覆盖的定义有点抽象，接下来还是以前面的代码为例介绍。 修正条件判定覆盖要求在每个判定中，每个条件都独立地影响判定结果至少一次（所谓独立影响就是在其他条件不变的情况下，改变该条件可以改变判定结果）。例如，要想a对判定独立影响，则b或function的结果必须为true；要想b对判定独立影响，则a必须为true；同理，要想function对判定独立影响，a也必须为true。如果列出测试用例表，则不难发现满足以上条件的测试用例的数量并不需要很多！主要因为有些用例是重复的。 3.6 条件判定组合覆盖（condition decision coverage） 3.7 路径覆盖（path coverage） 3.8 多条件覆盖（multi-condition coverage） 3.9 方法覆盖率 程序中的方法/函数有多少被执行。 3.10 类覆盖率 程序中的类有多少被执行。 4 工作原理 代码覆盖率测量主要有以下三种方式： 4.1 Source code instrumentation - 源代码检测 将检测语句添加到源代码中，并使用正常的编译工具链编译代码以生成检测的程序集。这是我们常说的插桩，Gcov 是属于这一类的代码覆盖率工具。 4.2 Runtime instrumentation - 运行时收集 这种方法在代码执行时从运行时环境收集信息以确定覆盖率信息。以我的理解 JaCoCo 和 Coverage 这两个工具的原理属于这一类别。 4.3 Intermediate code instrumentation - 中间代码检测 通过添加新的字节码来检测编译后的类文件，并生成一个新的检测类。说实话，我 Google 了很多文章并找到确定的说明哪个工具是属于这一类的。机器码(machine code)和字节码(byte code)是什么？ 了解这些工具的基本原理，结合现有的测试用例，有助于正确的选择代码覆盖率工具。比如： 产品的源代码只有 E2E（端到端）测试用例，通常只能选择第一类工具，即通过插桩编译出的可执行文件，然后进行测试和结果收集。 产品的源代码有单元测试用例，通常选择第二类工具，即运行时收集。这类工具的执行效率高，易于做持续集成。 5 当前主流代码覆盖率工具 代码覆盖率的工具有很多，以下是我用过的不同编程语言的代码覆盖率工具。在选择工具时，力求去选择那些开源、流行（活跃）、好用的工具。 编程语言 代码覆盖率工具 C/C++ Gcov Java JaCoCo JavaScript Istanbul Python Coverage.py Golang cover 5.1 Gcov Gcov 工作流程图： 主要分三步： 在 GCC 编译的时加入特殊的编译选项-ftest-coverage，生成可执行文件和 .gcno； 运行（测试）生成的可执行文件，生成了 .gcda 数据文件；（.gcda的生成是因为程序在编译的时候引入了 -fprofile-arcs选项） 有了 .gcno 和 .gcda，通过源码生成 .gcov 文件，最后生成代码覆盖率报告。 用GCC编译的时候加上-fprofile-arcs -ftest-coverage选项，链接的时候也加上。 fprofile-arcs参数使gcc创建一个程序的流图，之后找到适合图的生成树。只有不在生成树中的弧被操纵（instrumented）：gcc添加了代码来清点这些弧执行的次数。当这段弧是一个块的唯一出口或入口时，操纵工具代码（instrumentation code)将会添加到块中，否则创建一个基础块来包含操纵工具代码。 gcov主要使用.gcno和.gcda两个文件： .gcno是由-ftest-coverage产生的，它包含了重建基本块图和相应的块的源码的行号的信息。 .gcda是由加了-fprofile-arcs编译参数的编译后的文件运行所产生的，它包含了弧跳变的次数和其他的概要信息（而gcda只能在程序运行完毕后才能产生的） 参考： 使用 Gcov 和 LCOV 度量 C/C++ 项目的代码覆盖率 源码分析 | 使用 gcov 和 lcov 测试 PostgreSQL 代码覆盖率 lcov收集覆盖率 实践部分详见 博客：C/C++项目的全量覆盖率和增量覆盖率 5.2 Jacoco Java代码覆盖率工具Jacoco上手指引 基于Jacoco的增量覆盖率实现与落地 滴滴开源Super-jacoco：java代码覆盖率收集平台 DevOps - Java增量代码覆盖率工具_zou90512的专栏-程序员宅基地_java增量覆盖率 onthefly动态插桩覆盖率统计 X 参考 什么是代码覆盖率？ 关于代码覆盖率(Code Coverage)","categories":[{"name":"未分类","slug":"未分类","permalink":"https://dragonliu2022.github.io/categories/未分类/"}],"tags":[{"name":"待补充","slug":"待补充","permalink":"https://dragonliu2022.github.io/tags/待补充/"}]},{"title":"2021年华为C++后端实习名词积累","slug":"2021年华为C++后端实习名词积累","date":"2022-04-15T06:55:14.000Z","updated":"2022-04-18T16:11:58.367Z","comments":true,"path":"2022/04/15/2021年华为C++后端实习名词积累/","link":"","permalink":"https://dragonliu2022.github.io/2022/04/15/2021年华为C++后端实习名词积累/","excerpt":"","text":"1 Perl语言 本次实习主要成果：基于SR的全量/增量覆盖率统计。 部门之前的该部分脚本是使用Perl语言编写的，晦涩难懂，没有维护人员。 菜鸟教程——Perl语言教程 2 UT &amp; IT &amp; ST 2.1 UT（Unit Test）：单元测试 2.2 IT（Integration Test）：集成测试 2.3 ST（System Test）：系统测试 3 DT（Develpor Test）：开发者测试 参考： 华为课程学习 开发者测试：你必须知道 7 件事 4 TDD（Test-Driven Development）：测试驱动开发 测试驱动开发，在开发功能代码之前，先编写单元测试用例代码，测试代码确定需要编写什么产品代码。 5 cleancode 详见博客《代码整洁之道 clean code》笔记 软件工程领域的大师级人物罗伯特·马丁(Robert C. Martin)所著的一本重量级经典图书《Clean Code》，中文译为代码整洁之道，书中提出代码质量与其整洁度成正比。 比如编程要遵守一些原则；命名、注释、函数。 参考：浅谈Clean Code 6 SR &amp; AR IR（Initial Requirement）：初始需求 SR（System Requirement）：系统需要 AR（Allocation Requirement）：配置需求 SA（System Analyst）：系统分析师， SE（System Engineer）：系统工程师 MDE（Module Design Engineer）：模块设计师，当SE把不同模块之间的接口大致画清晰后，模块内部的设计交给MDE来进行；敏捷之MDE认知 User Story：用户故事； 用户故事（一）：什么是用户故事？ 步骤： 需求经理：将用户需求（user story）转换成 客户能够接受的 初始需求 IR（Initial Requirement） SA：IR 拆分为 SR SE：SR 继续拆分 AR MDE：当SE把不同模块之间的接口大致画清晰后，模块内部的设计交给MDE来进行； 参考：我从华为身上学到的项目管理经验 – 需求篇 7 敏捷开发 敏捷开发是一种项目管理和软件开发的迭代方法，侧重于协作、客户反馈和快速发布。 敏捷开发以用户的需求进化为核心，采用迭代、循序渐进的方法进行软件开发，适用于竞争激烈，快速变化的市场。敏捷的客户协作观念，快速迭代能帮助团队以最小成本，最快速度满足客户真正的需求。 其特点：“个体与交互”胜过“过程与工具”、“可以工作的软件”胜过“面面俱到的文挡”、“客户协作”胜过“合同谈判”、“响应变化”胜过“遵循计划”。 敏捷开发迭代流程一般遵循以下五个步骤：需求分析（requirements analysis）、产品设计（design）、功能编码（coding）、功能测试（testing）、部署评估（deployment / evaluation）。流程图如下： 参考：四種軟體開發模式（瀑布、疊代、螺旋、敏捷），對比分析 8 持续集成 持续集成是一种软件开发实践，即团队开发成员经常集成他们的工作，通常每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。 实习部门使用Jenkins自动化部署， Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。 9 DevOps DevOps（Development和Operations的组合词）是一种重视“软件开发人员（Dev）”和“IT运维技术人员（Ops）”之间沟通合作的文化、运动或惯例。通过自动化“软件交付”和“架构变更”的流程，来使得构建、测试、发布软件能够更加地快捷、频繁和可靠。","categories":[{"name":"未分类","slug":"未分类","permalink":"https://dragonliu2022.github.io/categories/未分类/"}],"tags":[]},{"title":"git操作手册","slug":"git操作手册","date":"2022-04-13T02:17:22.000Z","updated":"2022-04-18T15:52:00.464Z","comments":true,"path":"2022/04/13/git操作手册/","link":"","permalink":"https://dragonliu2022.github.io/2022/04/13/git操作手册/","excerpt":"","text":"1 命令 show-log show-diff pull：大致上 git pull = git fetch + git merge commit push rebase：可以对某一段线性提交历史进行编辑、删除、复制、粘贴 git rebase命令 delete（rm） revert 新建本地分支 推到远程分支 切分支 cherry-pick 解冲突 .gitignore 2 举例 2.1 对方更新过代码，然后自己也需要上传新增文件 1234567891011121314151617# 拉下更新代码git pullgit pull origin master:master# 详细的。。。git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;# 新增文件···# 将所有新增文件添加到暂存区git add .# 将暂存区内容添加到本地仓库中git commit -m \"注释\"# 从将本地的分支版本上传到远程并合并git pushgit push origin master:master# 详细的。。。git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;git push &lt;远程主机名&gt; &lt;本地分支名&gt; # 如果本地分支名与远程分支名相同，则可以省略冒号 2.2 贡献自己的代码 commit-&gt;pull-&gt;push-&gt;MR 冲突：resolved-&gt;修改（edited）-&gt;完成（resolved） X 参考 菜鸟教程——git","categories":[{"name":"环境与工具","slug":"环境与工具","permalink":"https://dragonliu2022.github.io/categories/环境与工具/"}],"tags":[{"name":"待补充","slug":"待补充","permalink":"https://dragonliu2022.github.io/tags/待补充/"},{"name":"Git","slug":"Git","permalink":"https://dragonliu2022.github.io/tags/Git/"}]},{"title":"Python-yield用法详解","slug":"Python-yield用法详解","date":"2022-04-04T03:19:42.000Z","updated":"2022-04-18T11:28:22.655Z","comments":true,"path":"2022/04/04/Python-yield用法详解/","link":"","permalink":"https://dragonliu2022.github.io/2022/04/04/Python-yield用法详解/","excerpt":"","text":"1 前言 参考：python中yield的用法详解——最简单，最清晰的解释","categories":[{"name":"Python","slug":"Python","permalink":"https://dragonliu2022.github.io/categories/Python/"}],"tags":[{"name":"待补充","slug":"待补充","permalink":"https://dragonliu2022.github.io/tags/待补充/"}]},{"title":"Python-字符串-统计子串个数","slug":"Python-字符串-统计子串个数","date":"2022-04-04T03:11:56.000Z","updated":"2022-04-18T11:26:16.502Z","comments":true,"path":"2022/04/04/Python-字符串-统计子串个数/","link":"","permalink":"https://dragonliu2022.github.io/2022/04/04/Python-字符串-统计子串个数/","excerpt":"","text":"1 前言 参考：Python里统计一个字符串中子字符串的个数 母串str1 = 'ababa'，子串str2='aba'，统计子串有两种情况： 重复统计：被统计过的字符还可以参与统计，所以子串数量为3； 不重复统计：被统计过的字符不再参与统计，所以子串数量为2。 2 实现 2.1 重复统计 123456import res = \"abababa\"reg = re.compile(\"(?=aba)\")length = len(reg.findall(s))print(length) # 3 2.2 不重复统计 12s = \"abababa\"print(s.count('aba')) # 2","categories":[{"name":"Python","slug":"Python","permalink":"https://dragonliu2022.github.io/categories/Python/"}],"tags":[]},{"title":"Python-列表-将list中的值拼接成字符串","slug":"Python-列表-将list中的值拼接成字符串","date":"2022-04-04T02:50:45.000Z","updated":"2022-04-18T11:24:33.449Z","comments":true,"path":"2022/04/04/Python-列表-将list中的值拼接成字符串/","link":"","permalink":"https://dragonliu2022.github.io/2022/04/04/Python-列表-将list中的值拼接成字符串/","excerpt":"","text":"1 前言 在Python中，有时需要将list以字符串的形式输出。如list = ['a', 'b', 'c']，要求输出abc。 参考：python技巧——将list中的每个int元素转换成str 2 实现 2.1 元素是字符或字符串 1234test_list = [\"h\", \"e\", \"l\", \"l\", \"o\"]print(\"\".join(test_list)) # helloprint(\",\".join(test_list)) # h,e,l,l,o 2.2 元素中含有数字 2.2.1 新建list 12345test_list = [\"h\", \"e\", \"l\", \"l\", \"o\", 6]test_list_new = [str(x) for x in test_list]print(\"\".join(test_list_new)) # hello6print(\",\".join(test_list_new)) # h,e,l,l,o,6 2.2.2 lambda表达式 1234test_list = [\"h\", \"e\", \"l\", \"l\", \"o\", 6]test_list_new = map(lambda x: str(x), test_list)print(\"\".join(test_list_new)) # hello6","categories":[{"name":"Python","slug":"Python","permalink":"https://dragonliu2022.github.io/categories/Python/"}],"tags":[]},{"title":"Python-字符串-截取特定部分","slug":"Python-字符串-截取特定部分","date":"2022-04-03T06:34:17.000Z","updated":"2022-04-18T11:26:02.056Z","comments":true,"path":"2022/04/03/Python-字符串-截取特定部分/","link":"","permalink":"https://dragonliu2022.github.io/2022/04/03/Python-字符串-截取特定部分/","excerpt":"","text":"1 引入 截取字符串中特定部分的方法：可以使用 str[beginIndex:endPosition]，其中str为需要截取的字符串，beginIndex为需要截取的第一个字符的下标，endPosition为截取字符最后一个字符的下标。 该部分和 Python-字符串-分割字符串 有点类似。 参考：python如何截取字符串中特定部分 2 解决 2.1 切片 str[l,r]：字符串可以理解成一个下标从0开始的数组，这里表示[l,r)的部分；l不写默认0，r不写默认最后一个；l和r也可以是负数，表示截取方向从右到左。 123456test_str = \"hello.python\"print(test_str[1:4]) # ellprint(test_str[:4]) # hellprint(test_str[1:]) # ello.pythonprint(test_str[-3:-1]) # hoprint(test_str[-3:]) # hon 2.2 index+切片 先获取字符的下标位置，再通过以上的方法截取。 a.index(b, begin, end)：a为需要校验字符串，b为字符串，begin 为开始截取的字符的下标（默认为0），end结束字符下标（默认为字符长度），截取字符串[begin,end) 123456test_str = \"hello.python\"ch = '.'print(test_str.index(ch)) # 5print(test_str[:test_str.index(ch)]) # Helloprint(test_str[test_str.index(ch):]) # .python","categories":[{"name":"Python","slug":"Python","permalink":"https://dragonliu2022.github.io/categories/Python/"}],"tags":[]},{"title":"Python-列表-交集并集差集","slug":"Python-列表-交集并集差集","date":"2022-04-03T05:45:23.000Z","updated":"2022-04-18T11:24:39.110Z","comments":true,"path":"2022/04/03/Python-列表-交集并集差集/","link":"","permalink":"https://dragonliu2022.github.io/2022/04/03/Python-列表-交集并集差集/","excerpt":"","text":"1 list的集合运算 1.1 交集 方法1：朴素的遍历；如果列表出现重复元素，该方法会出现问题，重复元素可能会保留。 1234567891011# 无重复元素a = [2, 3, 4, 5]b = [2, 5, 8]tmp = [val for val in a if val in b]print(tmp) # [2, 5]# 有重复元素 a = [2, 2, 3, 4, 5]b = [2, 5, 8]tmp = [val for val in a if val in b]print(tmp) # [2, 2, 5] 方法2：转化为set操作，速度快；重复元素不会保留。 123456789# 无重复元素a = [2, 3, 4, 5]b = [2, 5, 8]print(list(set(a).intersection(set(b)))) # [2, 5]# 有重复元素a = [2, 2, 3, 4, 5]b = [2, 5, 8]print(list(set(a).intersection(set(b)))) # [2, 2, 5] 1.2 并集 方法1： 123a = [2, 3, 4, 5]b = [2, 5, 8]print(list(set(a+b))) # [2, 3, 4, 5, 8] 方法2： 123a = [2, 3, 4, 5]b = [2, 5, 8]print(list(set(a).union(set(b)))) # [2, 3, 4, 5, 8] 1.3 差集 方法1：朴素的遍历；如果列表出现重复元素，该方法会出现问题，重复元素可能会保留。 1234567891011# 无重复元素a = [2, 3, 4, 5]b = [2, 5, 8]tmp = [val for val in b if val not in a] # b中有而a中没有的print(tmp) # [8]# 有重复元素 a = [2, 3, 4, 5]b = [2, 5, 8, 8]tmp = [val for val in b if val not in a] # b中有而a中没有的print(tmp) # [8, 8] 方法2：转化为set操作，速度快；重复元素不会保留。 123456789# 无重复元素a = [2, 3, 4, 5]b = [2, 5, 8]print(list(set(b).difference(set(a)))) # [8]# 有重复元素 a = [2, 3, 4, 5]b = [2, 5, 8, 8]print(list(set(b).difference(set(a)))) # [8] 2 set的集合运算 1234567891011s = set([3, 5, 9, 10, 20, 40]) # 创建一个数值集合t = set([3, 5, 9, 1, 7, 29, 81]) # 创建一个数值集合# t 和 s的并集 ,等价于t.union(s)print(t | s) # &#123;1, 3, 5, 7, 40, 9, 10, 81, 20, 29&#125;# t 和 s的交集 ,等价于t.intersection(s)print(t &amp; s) # &#123;9, 3, 5&#125;# 求差集（项在t中，但不在s中） ,等价于t.difference(s)print(t - s) # &#123;81, 1, 29, 7&#125;# 对称差集（项在t或s中，但不会同时出现在二者中）,等价于t.symmetric_difference(s)print(t ^ s) # &#123;1, 7, 40, 10, 81, 20, 29&#125;","categories":[{"name":"Python","slug":"Python","permalink":"https://dragonliu2022.github.io/categories/Python/"}],"tags":[]},{"title":"Python-字符串-分割字符串","slug":"Python-字符串-分割字符串","date":"2022-04-03T05:13:34.000Z","updated":"2022-04-18T11:25:57.342Z","comments":true,"path":"2022/04/03/Python-字符串-分割字符串/","link":"","permalink":"https://dragonliu2022.github.io/2022/04/03/Python-字符串-分割字符串/","excerpt":"","text":"1 前言 工作过程中，会有分割字符串的需求，有可能是单个分隔符，也有可能是多个分隔符。 参考：python split使用多个分隔符分割字符串 2 实现 2.1 split() 参考：Python split()方法 缺点：python内建的split()函数只能使用单个分隔符，如果需要多个分隔符，需要使用下面的re.split()。 描述：通过指定分隔符对字符串进行切片，如果参数 num 有指定值，则分隔 num+1 个子字符串。 语法：str.split(str=&quot;&quot;, num=string.count(str)) 参数： str：分隔符，默认为所有的空字符，包括空格、换行(\\n)、制表符(\\t)等。 num：分割次数。默认为 -1, 即分隔所有。 返回值：返回分割后的字符串列表。 1234txt = \"phx what\\tphx\\nai\";print(txt.split()) # ['phx', 'what', 'phx', 'ai']print(txt.split(' ', 1)) # ['phx', 'what\\tphx\\nai']print(txt.split('phx')) # ['', ' what\\t', '\\nai'] 2.2 re.split() 优点：re模块的split()函数可以使用多个分隔符对句子进行分割，其中不同的分隔符要用 | 隔开。 1234import retxt = \"phx what\\tphx\\nai\";print(re.split(\" |\\t\", txt)) # ['phx', 'what', 'phx\\nai']","categories":[{"name":"Python","slug":"Python","permalink":"https://dragonliu2022.github.io/categories/Python/"}],"tags":[]},{"title":"Python-文件-csv文件读取","slug":"Python-文件-csv文件读取","date":"2022-04-03T02:09:58.000Z","updated":"2022-04-18T11:25:38.694Z","comments":true,"path":"2022/04/03/Python-文件-csv文件读取/","link":"","permalink":"https://dragonliu2022.github.io/2022/04/03/Python-文件-csv文件读取/","excerpt":"","text":"1 前言 最近在做毕设，数据集使用的天池竞赛的，csv数据格式的，下面整理下csv读取的几种方法。 主要参考：Python读取csv文件的几种方法 下面是测试文件test.csv 的内容（与下面的python代码同目录）： 123456file_id,label,api,tid,index1,5,LdrLoadDll,2488,01,5,LdrGetProcedureAddress,2488,11,5,LdrGetProcedureAddress,2488,21,5,LdrGetProcedureAddress,2488,31,5,LdrGetProcedureAddress,2488,4 2 读取操作 2.1 利用Python I/O读取文件 2.1.1 csv.reader() 123456789101112131415161718import csvdef read_csv(csv_path): data = [] with open(csv_path) as f: csv_reader = csv.reader(f) # 使用csv.reader读取f中的内容 header = next(csv_reader) # 读取第一行每一列的标题 print(header) # ['file_id', 'label', 'api', 'tid', 'index'] for row in csv_reader: # 将csv 文件中的数据保存到data中 data.append(row[1]) # 选择某一列加入到data数组中 print(data) # ['5', '5', '5', '5', '5'] f.close()if __name__ == \"__main__\": csv_path = \".\\\\test.csv\" read_csv(csv_path=csv_path) 2.1.2 csv.DictReader() 可以获取字段名，参考 csv.DictReader 读取字段名（headers） 12345678910111213141516import csvdef read_csv(csv_path): with open(csv_path, 'r') as f: reader = csv.DictReader(f) headers = reader.fieldnames # 字段名 print(headers) # ['file_id', 'label', 'api', 'tid', 'index'] column = [row['index'] for row in reader] # weight 同列的数据 print(column) # ['0', '1', '2', '3', '4'] f.close()if __name__ == \"__main__\": csv_path = \".\\\\test.csv\" read_csv(csv_path=csv_path) 2.1.3 open() 把csv文件当作文本文件，使用open()和split进行处理，但是存在明显缺点——如果字段中含有分隔符,，分割将会比较麻烦。 12345678910111213def read_csv(csv_path): with open(csv_path) as f: column = [] column_id = 0 for line in f.readlines(): column.append(line.rstrip(\"\\n\").split(',')[column_id]) print(column) # ['file_id', '1', '1', '1', '1', '1'] f.close()if __name__ == \"__main__\": csv_path = \".\\\\test.csv\" read_csv(csv_path=csv_path) 2.2 利用numpy读取 缺点：csv里面的值只能是数值型的，字符串类型会报错，读取的值是按照float存储的 解释：delimiter是分隔符，skiprows是跳过前n行，usecols是使用的列数，例子中读取的是3,4列。 123456789101112import numpy as npdef read_csv(csv_path): n = 1 data = np.loadtxt(open(csv_path, \"rb\"), delimiter=\",\", skiprows=n, usecols=[2, 3]) print(data)if __name__ == \"__main__\": csv_path = \".\\\\test.csv\" read_csv(csv_path=csv_path) 2.3 利用pandas读取 1234567891011121314import pandas as pddef read_csv(csv_path): data = pd.read_csv(csv_path, sep=',', header='infer', usecols=[2]) print(data) array = data.values[0::, 0::] # 读取全部行，全部列 print(array) # array是数组形式存储，顺序与data读取的数据顺序格式相同 print(array[0][0]) # LdrLoadDllif __name__ == \"__main__\": csv_path = \".\\\\test.csv\" read_csv(csv_path=csv_path) X 参考","categories":[{"name":"Python","slug":"Python","permalink":"https://dragonliu2022.github.io/categories/Python/"}],"tags":[]},{"title":"【开源代码学习--若依】恶意样本界面空白","slug":"【开源代码学习--若依】恶意样本界面空白","date":"2022-03-26T14:52:51.000Z","updated":"2022-04-18T16:18:47.096Z","comments":true,"path":"2022/03/26/【开源代码学习--若依】恶意样本界面空白/","link":"","permalink":"https://dragonliu2022.github.io/2022/03/26/【开源代码学习--若依】恶意样本界面空白/","excerpt":"","text":"1 问题 恶意样本界面空白，没有数据；恶意家族界面正常。 2 解决 测试后端正常，数据也传到了前端。 最后排错，确定bug代码块： 1234&lt;!-- 动态分析-》图对话框 --&gt;&lt;el-dialog :title=&quot;title&quot; :visible.sync=&quot;open_dynamic_graph&quot; width=&quot;1100px&quot; append-to-body&gt; &lt;el-image :src=&quot;require(&apos;@/assets/graphviz_images/&apos;+this.img_path)&quot; :fit=&quot;cover&quot;&gt;&lt;/el-image&gt;&lt;/el-dialog&gt; 原因：@/assets/graphviz_images/'+this.img_path 文件不存在。","categories":[{"name":"前端","slug":"前端","permalink":"https://dragonliu2022.github.io/categories/前端/"}],"tags":[{"name":"Element","slug":"Element","permalink":"https://dragonliu2022.github.io/tags/Element/"}]},{"title":"【开源代码学习--若依】vue+springboot文件下载","slug":"【开源代码学习--若依】vue-springboot文件下载","date":"2022-03-26T13:57:18.000Z","updated":"2022-04-18T10:01:39.080Z","comments":true,"path":"2022/03/26/【开源代码学习--若依】vue-springboot文件下载/","link":"","permalink":"https://dragonliu2022.github.io/2022/03/26/【开源代码学习--若依】vue-springboot文件下载/","excerpt":"","text":"1 引入 需要文件下载功能，如下图所示： 2 解决 2.1 手写(404，无法下载) 若依手册——上传下载 Java中将Map转String，String转Map vue+springboot文件下载 使用VUE和SPRING BOOT实现文件下载 2.2 使用官网提供的封装方法 参考：使用若依前后端分离下载需要授权的url文件 前端使用封装方法this.$download.resource(resource);： 12345678910111213141516171819202122// 表格中的下载按钮&lt;el-table-column label=&quot;下载报告&quot; align=&quot;center&quot; class-name=&quot;small-padding fixed-width&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;el-button size=&quot;mini&quot; type=&quot;text&quot; icon=&quot;el-icon-download&quot; @click=&quot;handleDownload(scope.row)&quot; v-hasPermi=&quot;[&apos;system:report:downLoad:test&apos;]&quot; &gt;下载&lt;/el-button&gt; &lt;/template&gt;&lt;/el-table-column&gt;// handleDownload(scope.row)函数实现/** 下载报告按钮操作 */handleDownload(row) &#123; this.reset(); const id = row.id || this.ids const resource = &quot;/profile/upload/&quot; + row.reportName; // 不再设立实体类 // 默认方法 this.$download.resource(resource);&#125;, 增加对xml文件的授权：修改MimeTypeUtils.java文件 1234567891011121314public static final String[] DEFAULT_ALLOWED_EXTENSION = &#123; // 图片 \"bmp\", \"gif\", \"jpg\", \"jpeg\", \"png\", // word excel powerpoint \"doc\", \"docx\", \"xls\", \"xlsx\", \"ppt\", \"pptx\", \"html\", \"htm\", \"txt\", // 压缩文件 \"rar\", \"zip\", \"gz\", \"bz2\", // 视频格式 \"mp4\", \"avi\", \"rmvb\", // pdf \"pdf\", // xml \"xml\",&#125;; 修改资源默认路径，资源默认路径是D:\\ruoyi\\uploadPath\\upload，修改文件RuoYi-Vue\\ruoyi-admin\\src\\main\\resources\\application.yml 12345678910111213141516# 项目相关配置ruoyi: # 名称 name: RuoYi # 版本 version: 3.8.1 # 版权年份 copyrightYear: 2022 # 实例演示开关 demoEnabled: true # 文件路径 示例（ Windows配置D:/ruoyi/uploadPath，Linux配置 /home/ruoyi/uploadPath） profile: E:/05 Code/RMDVS/uploadPath # 获取ip地址开关 addressEnabled: false # 验证码类型 math 数组计算 char 字符验证 captchaType: math 2.3 补充(修改日志默认路径) 日志默认路径：E:\\home\\ruoyi\\logs 修改文件：RuoYi-Vue\\ruoyi-admin\\src\\main\\resources\\logback.xml 123&lt;!-- 日志存放路径 --&gt;&lt;!-- &lt;property name=\"log.path\" value=\"/home/ruoyi/logs\" /&gt;--&gt;&lt;property name=\"log.path\" value=\"E:/05 Code/RMDVS/logs\" /&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://dragonliu2022.github.io/categories/前端/"},{"name":"Java","slug":"Java","permalink":"https://dragonliu2022.github.io/categories/Java/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://dragonliu2022.github.io/tags/Spring-Boot/"},{"name":"Vue","slug":"Vue","permalink":"https://dragonliu2022.github.io/tags/Vue/"}]},{"title":"【开源代码学习--若依】表格同列排序","slug":"【开源代码学习--若依】表格同列排序","date":"2022-03-26T13:39:06.000Z","updated":"2022-04-18T10:01:19.138Z","comments":true,"path":"2022/03/26/【开源代码学习--若依】表格同列排序/","link":"","permalink":"https://dragonliu2022.github.io/2022/03/26/【开源代码学习--若依】表格同列排序/","excerpt":"","text":"1 引入 在表格中，需要根据同一列中的内容进行排序。如下图所示： 2 解决 table标签： 1&lt;el-table v-loading=&quot;loading&quot; :data=&quot;familyList&quot; @selection-change=&quot;handleSelectionChange&quot; :default-sort=&quot;defaultSort&quot; @sort-change=&quot;handleSortChange&quot;&gt; table-column标签： 1&lt;el-table-column label=&quot;家族中样本平均得分&quot; align=&quot;center&quot; prop=&quot;averageScore&quot; sortable=&quot;custom&quot; :sort-orders=&quot;[&apos;descending&apos;, &apos;ascending&apos;]&quot; /&gt; 涉及参数及函数： 123456789// 默认排序defaultSort: &#123;prop: 'id', order: 'ascending'&#125;,/** 排序触发事件 */handleSortChange(column, prop, order) &#123; this.queryParams.orderByColumn = column.prop; this.queryParams.isAsc = column.order; this.getList();&#125;,","categories":[{"name":"前端","slug":"前端","permalink":"https://dragonliu2022.github.io/categories/前端/"}],"tags":[{"name":"Element","slug":"Element","permalink":"https://dragonliu2022.github.io/tags/Element/"}]},{"title":"【开源代码学习--若依】表格中跳转外部链接","slug":"【开源代码学习--若依】表格中跳转外部链接","date":"2022-03-26T13:22:14.000Z","updated":"2022-04-18T10:01:11.821Z","comments":true,"path":"2022/03/26/【开源代码学习--若依】表格中跳转外部链接/","link":"","permalink":"https://dragonliu2022.github.io/2022/03/26/【开源代码学习--若依】表格中跳转外部链接/","excerpt":"","text":"1 引入 现在的需求：表格中需要加入跳转外部链接，链接是后端传入。 2 解决 参考：在elementui中的table加入可跳转的链接 12345678&lt;el-table-column label=&quot;VirusTotal链接&quot; align=&quot;center&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;a :href=&quot;scope.row.permalink&quot; target=&quot;_blank&quot; class=&quot;buttonText&quot; style=&quot;color: dodgerblue&quot;&gt;跳 转&lt;/a&gt; &lt;/template&gt;&lt;/el-table-column&gt; 解释： scope.row.permalink：表示表格当前行的permalink属性或参数 style=&quot;color: dodgerblue&quot;：设置字体颜色，颜色表链接","categories":[{"name":"前端","slug":"前端","permalink":"https://dragonliu2022.github.io/categories/前端/"}],"tags":[{"name":"Element","slug":"Element","permalink":"https://dragonliu2022.github.io/tags/Element/"}]},{"title":"【开源代码学习--若依】表格设置列宽","slug":"【开源代码学习--若依】表格设置列宽","date":"2022-03-26T13:05:58.000Z","updated":"2022-04-18T10:01:03.075Z","comments":true,"path":"2022/03/26/【开源代码学习--若依】表格设置列宽/","link":"","permalink":"https://dragonliu2022.github.io/2022/03/26/【开源代码学习--若依】表格设置列宽/","excerpt":"","text":"1 引入 官方文档——表格 表格中每列的文字长度不同，有些差距较大，所以需要修改表格的某一列宽度。 2 解决 2.1宽度自适应（效果不好） ElementUI 实现el-table 列宽自适应 2.2 设置width属性 1&lt;el-table-column label=&quot;危害得分&quot; align=&quot;center&quot; prop=&quot;hazardScore&quot; width=&quot;140px&quot;/&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://dragonliu2022.github.io/categories/前端/"}],"tags":[{"name":"Element","slug":"Element","permalink":"https://dragonliu2022.github.io/tags/Element/"}]},{"title":"【开源代码学习--若依】表格分页问题","slug":"【开源代码学习--若依】表格分页问题","date":"2022-03-26T12:01:43.000Z","updated":"2022-04-18T10:00:54.870Z","comments":true,"path":"2022/03/26/【开源代码学习--若依】表格分页问题/","link":"","permalink":"https://dragonliu2022.github.io/2022/03/26/【开源代码学习--若依】表格分页问题/","excerpt":"","text":"1 问题引入 Vue官方文档 表格实现了分页，但是点击页码后会将所有数据显示或不刷新页面，观察后台，并没有调用操作。 原因：回调函数出了问题，没有正确传参。 2 分页实现 参考：若依管理系统源码分析-分页的实现以及post请求时的分页 2.1 前端调用 123456789101112131415161718192021// 一般在查询参数中定义分页变量queryParams: &#123; pageNum: 1, pageSize: 10&#125;, // 页面添加分页组件，传入分页变量&lt;pagination v-show=&quot;total&gt;0&quot; :total=&quot;total&quot; :page.sync=&quot;queryParams.pageNum&quot; :limit.sync=&quot;queryParams.pageSize&quot; @pagination=&quot;getList&quot;/&gt; // 调用后台方法，传入参数 获取结果listUser(this.queryParams).then(response =&gt; &#123; this.userList = response.rows; this.total = response.total; &#125;); 2.2 后台逻辑实现 12345678@PostMapping(\"/list\")@ResponseBodypublic TableDataInfo list(User user)&#123; startPage(); // 此方法配合前端完成自动分页 List&lt;User&gt; list = userService.selectUserList(user); return getDataTable(list);&#125; 3 解决 回调函数进行参数传递：@pagination=&quot;handleDynamic(dynamicRow) 12345678910111213&lt;el-table v-loading=&quot;dynamicLoading&quot; :data=&quot;dynamicList&quot; @selection-change=&quot;handleSelectionChange&quot; v-fit-columns&gt; &lt;el-table-column label=&quot;行为类别&quot; align=&quot;center&quot; prop=&quot;category&quot; width=&quot;140px&quot;/&gt; &lt;el-table-column label=&quot;危害等级&quot; align=&quot;center&quot; prop=&quot;hazardLevel&quot; width=&quot;140px&quot;/&gt; &lt;el-table-column label=&quot;危害得分&quot; align=&quot;center&quot; prop=&quot;hazardScore&quot; width=&quot;140px&quot;/&gt; &lt;el-table-column label=&quot;类目行为代表&quot; align=&quot;center&quot; prop=&quot;represent&quot; /&gt;&lt;/el-table&gt;&lt;pagination v-show=&quot;dynamicTotal&gt;0&quot; :total=&quot;dynamicTotal&quot; :page.sync=&quot;queryDynamicParams.pageNum&quot; :limit.sync=&quot;queryDynamicParams.pageSize&quot; @pagination=&quot;handleDynamic(dynamicRow)&quot;/&gt; 其中：v-loading 作用为加载动画。 4 其他问题(未解决) 正常情况下，表格页面展示会默认从第一页开始。但是实践过程中会从上次表格页数展示，即使是不同的表格。 X 参考 官方文档——表格","categories":[{"name":"前端","slug":"前端","permalink":"https://dragonliu2022.github.io/categories/前端/"}],"tags":[{"name":"Element","slug":"Element","permalink":"https://dragonliu2022.github.io/tags/Element/"}]},{"title":"【开源代码学习--若依】Element显示图片","slug":"【开源代码学习--若依】Element显示图片","date":"2022-03-26T11:47:40.000Z","updated":"2022-04-18T10:00:46.347Z","comments":true,"path":"2022/03/26/【开源代码学习--若依】Element显示图片/","link":"","permalink":"https://dragonliu2022.github.io/2022/03/26/【开源代码学习--若依】Element显示图片/","excerpt":"","text":"1 引用项目内部的图片 1&lt;el-image :src=&quot;require(&apos;@/assets/graphviz_images/&apos;+this.img_path)&quot; :fit=&quot;cover&quot;&gt;&lt;/el-image&gt; 2 参考 官方文档——Image 图片 element ui 或者 element-admin 模板 img 标签 图片不能正常显示或者资源不能正常加载问题 element-ui Image组件中的隐藏功能el-image-viewer组件的使用","categories":[{"name":"前端","slug":"前端","permalink":"https://dragonliu2022.github.io/categories/前端/"}],"tags":[{"name":"Element","slug":"Element","permalink":"https://dragonliu2022.github.io/tags/Element/"}]},{"title":"【开源代码学习--若依】Element中的Icon图标","slug":"【开源代码学习--若依】Element中的Icon图标","date":"2022-03-26T11:20:46.000Z","updated":"2022-04-18T10:00:09.269Z","comments":true,"path":"2022/03/26/【开源代码学习--若依】Element中的Icon图标/","link":"","permalink":"https://dragonliu2022.github.io/2022/03/26/【开源代码学习--若依】Element中的Icon图标/","excerpt":"","text":"1 Element简介 Element，一套为开发者、设计师和产品经理准备的基于 Vue 2.0 的桌面端组件库。 官方文档 2 Icon 图标 Icon 图标提供了一套常用的图标集合。 直接通过设置类名为 el-icon-iconName 来使用即可。例如： 1234&lt;i class=&quot;el-icon-edit&quot;&gt;&lt;/i&gt;&lt;i class=&quot;el-icon-share&quot;&gt;&lt;/i&gt;&lt;i class=&quot;el-icon-delete&quot;&gt;&lt;/i&gt;&lt;el-button type=&quot;primary&quot; icon=&quot;el-icon-search&quot;&gt;搜索&lt;/el-button&gt; 官方文档——Icon 图标","categories":[{"name":"前端","slug":"前端","permalink":"https://dragonliu2022.github.io/categories/前端/"}],"tags":[{"name":"Element","slug":"Element","permalink":"https://dragonliu2022.github.io/tags/Element/"}]},{"title":"Python-Mysql-sqlalchemy中的聚合函数","slug":"Python-Mysql-sqlalchemy中的聚合函数","date":"2022-03-26T04:10:12.000Z","updated":"2022-04-18T11:27:41.114Z","comments":true,"path":"2022/03/26/Python-Mysql-sqlalchemy中的聚合函数/","link":"","permalink":"https://dragonliu2022.github.io/2022/03/26/Python-Mysql-sqlalchemy中的聚合函数/","excerpt":"","text":"1 引入 参考：SQL聚合函数 SQL聚合函数，包括：AVG()，COUNT()，MIN()，MAX()和SUM()。 SQL聚合函数计算一组值并返回单个值。 例如，平均函数(AVG)采用值列表并返回平均值。 2 实验 2.1 构建数据表 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from sqlalchemy.ext.declarative import declarative_basefrom sqlalchemy import create_engine, Column, Integer, Stringfrom sqlalchemy.orm import sessionmakerHOST = '127.0.0.1'PORT = 3306USERNAME = 'xxx' # mysql用户名PASSWORD = 'xxx' # mysql密码DB = 'xxx' # 数据库名称# f代表可以使用&#123;&#125;引用变量DB_URI = f'mysql+pymysql://&#123;USERNAME&#125;:&#123;PASSWORD&#125;@&#123;HOST&#125;:&#123;PORT&#125;/&#123;DB&#125;'# 创建引擎engine = create_engine(DB_URI)# 创建SQLORM基类，注意这里要加参数，参数为上一步创建的引擎Base = declarative_base(engine)# 构建session对象session = sessionmaker(engine)()# 创建实体表Personclass Person(Base): __tablename__ = 'person' # 表名 id = Column(Integer, primary_key=True, autoincrement=True) name = Column(String(100)) age = Column(Integer)# 将模型映射到数据库中# 即如果数据库中没有student表则创建映射表studentBase.metadata.create_all()# 增：批量def insert_batch(obj_list): session.add_all(obj_list) session.commit()# 删除TestTable表def del_table(): Person.__table__.drop()if __name__ == \"__main__\": obj_list = [Person(name=\"dragon\", age=22), Person(name=\"pig\", age=23), Person(name=\"SY\", age=19), Person(name=\"cat\", age=7), Person(name=\"toy\", age=8), Person(name=\"sen\", age=23), Person(name=\"tor\", age=10), ] insert_batch(obj_list) # del_table() 数据表如下图所示： 下面的聚合函数，需要导入func： 1from sqlalchemy import func 2.2 AVG() - 返回集合中的平均值 参考：SQLAlchemy（二)：SQLAlchemy对数据的增删改查操作、属性常用数据类型详解 1age_avg = session.query(func.avg(Person.age)).scalar() # 16.0000 注意：这里的age虽然是int类型的，但是最后的平均值是“准确”的小数。 2.3 COUNT() - 返回集合中的项目数 参考：SQLAlchemy —— query 返回查询结果的对象的数目，下面的例子是找到了toy和tor两个对象： 1u = session.query(Person).filter(Person.name.like('to%')).count() # 2 需要单独计算某一类对象的数量，可以用 func() 和 group_by() 配合查询： 12u = session.query(Person.name, func.count(Person.name)).group_by(Person.name).all()print(u) # [('dragon', 1), ('pig', 1), ('SY', 1), ('cat', 1), ('toy', 1), ('sen', 1), ('tor', 1)] 返回查询得到的的数值，我们使用 scalar() 方法： 1u = session.query(func.count(Person.age)).scalar() # 7 2.4 MIN() - 返回集合的最小值 参考：SQLAlchemy（二)：SQLAlchemy对数据的增删改查操作、属性常用数据类型详解 1age_min = session.query(func.min(Person.age)).scalar() # 7 2.5 MAX() - 返回集合的最大值 参考：SQLAlchemy（二)：SQLAlchemy对数据的增删改查操作、属性常用数据类型详解 1age_max = session.query(func.max(Person.age)).scalar() # 23 2.6 SUM() - 返回所有值的总和 参考：sqlalchemy对数据进行求和 12age_sum = session.query(func.sum(Person.age)).scalar() # 112age_sum = session.query(func.sum(Person.age)).filter(Person.name.like(\"to%\")).scalar() # 18 X 参考","categories":[{"name":"Python","slug":"Python","permalink":"https://dragonliu2022.github.io/categories/Python/"},{"name":"数据库","slug":"数据库","permalink":"https://dragonliu2022.github.io/categories/数据库/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://dragonliu2022.github.io/tags/MySQL/"}]},{"title":"MySQL-错误1366：字段编码报错","slug":"MySQL-错误1366：字段编码报错","date":"2022-03-26T03:32:44.000Z","updated":"2022-04-18T11:29:11.791Z","comments":true,"path":"2022/03/26/MySQL-错误1366：字段编码报错/","link":"","permalink":"https://dragonliu2022.github.io/2022/03/26/MySQL-错误1366：字段编码报错/","excerpt":"","text":"1 引入 在做毕设时，操作mysql时出现了这样的一个报错： 1sqlalchemy.exc.DataError: (pymysql.err.DataError) (1366, \"Incorrect string value: '\\\\xF2\\\\x88\\\\xBF\\\\xB6E ...' for column 'property' at row 1\") 原因：UTF-8编码有可能是两个、三个、四个字节。Emoji表情或者某些特殊字符是4个字节，而Mysql的utf8编码最多3个字节，所以数据插不进去。 2 解决 2.1 问题复现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from sqlalchemy.ext.declarative import declarative_basefrom sqlalchemy import *from sqlalchemy.orm import sessionmakerHOST = '127.0.0.1'PORT = 3306USERNAME = 'xxx'PASSWORD = 'xxx'DB = 'xxx'# f代表可以使用&#123;&#125;引用变量DB_URI = f'mysql+pymysql://&#123;USERNAME&#125;:&#123;PASSWORD&#125;@&#123;HOST&#125;:&#123;PORT&#125;/&#123;DB&#125;'# 创建引擎engine = create_engine(DB_URI)# 创建SQLORM基类，注意这里要加参数，参数为上一步创建的引擎Base = declarative_base(engine)# 构建session对象session = sessionmaker(engine)()# 创建实体表Encodeclass Encode(Base): __tablename__ = \"string_encode\" id = Column(Integer, primary_key=True) property = Column(TEXT)# 将模型映射到数据库中# 即如果数据库中没有student表则创建映射表studentBase.metadata.create_all()# 增：一个def insert(obj): session.add(obj) # 添加到session session.commit()# 删除Encode表def del_table(): Encode.__table__.drop()if __name__ == \"__main__\": property = \"📦 🚀 森罗万象\" insert(Encode(property=property)) # del_table() 出现报错： 1234sqlalchemy.exc.DataError: (pymysql.err.DataError) (1366, \"Incorrect string value: '\\\\xF0\\\\x9F\\\\x93\\\\xA6 \\\\xF0...' for column 'property' at row 1\")[SQL: INSERT INTO string_encode (property) VALUES (%(property)s)][parameters: &#123;'property': '📦 🚀 森罗万象'&#125;](Background on this error at: https://sqlalche.me/e/14/9h9h) 2.2 尝试解决 2.2.1 Sqlalchemy 设置表编码及引擎 参考：Sqlalchemy 设置表编码及引擎 设置引擎编码方式为utf8： 1234DB_URI = f'mysql+pymysql://&#123;USERNAME&#125;:&#123;PASSWORD&#125;@&#123;HOST&#125;:&#123;PORT&#125;/&#123;DB&#125;?charset=utf8'# 默认是utf8，所以上述代码无需修改DB_URI = f'mysql+pymysql://&#123;USERNAME&#125;:&#123;PASSWORD&#125;@&#123;HOST&#125;:&#123;PORT&#125;/&#123;DB&#125;' 设置数据库表编码方式为utf8mb4： 1234567class Encode(Base): __tablename__ = \"string_encode\" id = Column(Integer, primary_key=True) property = Column(TEXT) __table_args__ = &#123; \"mysql_charset\": \"utf8mb4\" &#125; 删除原来的表，再次生成表结构就可以正常插入了： 缺点：需要重新构建表，所以旧表存在大量数据就会比较麻烦；在这种情况下可以使用下面的方法。 2.2.2 修改表的字符集为utf8mb4 参考：mysql之（1366，“Incorrect string value:’\\xF0\\x9F\\x98\\x82…’ for column ‘content’ at row 1”)20 navicat右击需要修改的数据表，点击设计表； 选择要修改的字段property，将字符集修改为utf8mb4，然后保存： 现在就可以正常插入了： 缺点：这种方法仅仅改变了当前表的字符集，如果以后项目迁移，重新生成表的情况，相同的问题将会再次出现。 X 参考 Mysql错误1366的解决办法：Incorrect string value: ‘\\xF0\\x9F…’ for column ‘XXX’ at row 1 pymysql.err.DataError: (1366, “Incorrect string value: ‘\\xF0\\x9F\\x92\\xA1 \\xE4…‘ for column ‘d","categories":[{"name":"Python","slug":"Python","permalink":"https://dragonliu2022.github.io/categories/Python/"},{"name":"数据库","slug":"数据库","permalink":"https://dragonliu2022.github.io/categories/数据库/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://dragonliu2022.github.io/tags/MySQL/"}]},{"title":"MySQL-错误1406：超长字符串","slug":"MySQL-错误1406：超长字符串","date":"2022-03-25T15:52:12.000Z","updated":"2022-04-20T06:44:12.191Z","comments":true,"path":"2022/03/25/MySQL-错误1406：超长字符串/","link":"","permalink":"https://dragonliu2022.github.io/2022/03/25/MySQL-错误1406：超长字符串/","excerpt":"","text":"1 引入 在做毕设时，操作mysql时出现了这样的一个报错： 1sqlalchemy.exc.DataError: (pymysql.err.DataError) (1406, \"Data too long for column 'actions' at row 1\") 这里显示字段的长度不够存放数据，也就是解决mysql超长字符串存储问题。 2 解决 2.1 问题复现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from sqlalchemy.ext.declarative import declarative_basefrom sqlalchemy import *from sqlalchemy.orm import sessionmakerHOST = '127.0.0.1'PORT = 3306USERNAME = 'xxx'PASSWORD = 'xxx'DB = 'xxx'# f代表可以使用&#123;&#125;引用变量DB_URI = f'mysql+pymysql://&#123;USERNAME&#125;:&#123;PASSWORD&#125;@&#123;HOST&#125;:&#123;PORT&#125;/&#123;DB&#125;'# 创建引擎engine = create_engine(DB_URI)# 创建SQLORM基类，注意这里要加参数，参数为上一步创建的引擎Base = declarative_base(engine)# 构建session对象session = sessionmaker(engine)()# 创建实体表Lengthclass Length(Base): __tablename__ = \"string_length\" id = Column(Integer, primary_key=True) actions = Column(String(10)) # 修改此处debug# 将模型映射到数据库中# 即如果数据库中没有student表则创建映射表studentBase.metadata.create_all()# 增：一个def insert(obj): session.add(obj) # 添加到session session.commit()# 删除Data表def del_table(): Length.__table__.drop()if __name__ == \"__main__\": actions = '' for i in range(10): # 修改长度进行测试 actions += \"SY\" insert(Length(actions=actions)) del_table() 出现报错： 1234sqlalchemy.exc.DataError: (pymysql.err.DataError) (1406, \"Data too long for column 'actions' at row 1\")[SQL: INSERT INTO string_length (actions) VALUES (%(actions)s)][parameters: &#123;'actions': 'SYSYSYSYSYSYSYSYSYSY'&#125;](Background on this error at: https://sqlalche.me/e/14/9h9h) 2.2 尝试解决 修改String的长度参数，可以解决： 1actions = Column(String(21842)) 注意：VARCHAR(0-65535 bytes)，这里测试String的长度参数最大是21842，具体意思与大小还不清楚。 修改长度后就发生了之前的报错： 1234actions = ''for i in range(21842): actions += \"SY\"insert(Length(actions=actions)) 修改字段类型为TEXT可以解决上述问题： 123actions = Column(TEXT) # 64K TEXTactions = Column(TEXT(65536)) # 16M MEDIUMTEXTactions = Column(TEXT(16777216)) # 32M LONGTEXT 现在字符串最大长度可以到32M，可以cover大部分情况。 X 参考 mysql报错：“DataError: (pymysql.err.DataError) (1406, &quot;Data too long for column ‘pwd’ at row 1” pymysql.err.DataError: (1406, “Data too long for column ‘字段名’ at row 1”) pymysql.err.DataError: (1406, “Data too long for column ‘url’ at row 1”)","categories":[{"name":"Python","slug":"Python","permalink":"https://dragonliu2022.github.io/categories/Python/"},{"name":"数据库","slug":"数据库","permalink":"https://dragonliu2022.github.io/categories/数据库/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://dragonliu2022.github.io/tags/MySQL/"}]},{"title":"MySQL-数据类型以及sqlalchemy中的对应","slug":"MySQL-数据类型以及sqlalchemy中的对应","date":"2022-03-25T13:17:46.000Z","updated":"2022-04-18T11:29:20.418Z","comments":true,"path":"2022/03/25/MySQL-数据类型以及sqlalchemy中的对应/","link":"","permalink":"https://dragonliu2022.github.io/2022/03/25/MySQL-数据类型以及sqlalchemy中的对应/","excerpt":"","text":"1 MySQL数据类型 参考：MySQL 数据类型 MySQL 支持多种类型，大致可以分为三类：数值、日期/时间和字符串(字符)类型。 1.1 数值类型 类型 大小 范围（有符号） 范围（无符号） 用途 TINYINT 1 Bytes (-128，127) (0，255) 小整数值 SMALLINT 2 Bytes (-32768，32767) (0，65 535) 大整数值 MEDIUMINT 3 Bytes (-8388608，8388607) (0，16 777 215) 大整数值 INT或INTEGER 4 Bytes (-2 147 483 648，2 147 483 647) (0，4 294 967 295) 大整数值 BIGINT 8 Bytes (-9,223,372,036,854,775,808，9 223 372 036 854 775 807) (0，18 446 744 073 709 551 615) 极大整数值 FLOAT 4 Bytes - - 单精度浮点数值 DOUBLE 8 Bytes - - 双精度浮点数值 DECIMAL或DEC 对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2 依赖于M和D的值 依赖于M和D的值 小数值 1.2 日期和时间类型 每个时间类型有一个有效值范围和一个&quot;零&quot;值，当指定不合法的MySQL不能表示的值时使用&quot;零&quot;值。 类型 大小 ( bytes) 范围 格式 用途 DATE 3 1000-01-01/9999-12-31 YYYY-MM-DD 日期值 TIME 3 ‘-838:59:59’/‘838:59:59’ HH:MM:SS 时间值或持续时间 YEAR 1 1901/2155 YYYY 年份值 DATETIME 8 1000-01-01 00:00:00/9999-12-31 23:59:59 YYYY-MM-DD HH:MM:SS 混合日期和时间值 TIMESTAMP 4 1970-01-01 00:00:00/2038结束时间是第 2147483647 秒，北京时间 2038-1-19 11:14:07，格林尼治时间 2038年1月19日 凌晨 03:14:07 YYYYMMDD HHMMSS 混合日期和时间值，时间戳 1.3 字符串类型 类型 大小 用途 CHAR 0-255 bytes 定长字符串 VARCHAR 0-65535 bytes 变长字符串 TINYBLOB 0-255 bytes 不超过 255 个字符的二进制字符串 TINYTEXT 0-255 bytes 短文本字符串 BLOB 0-65 535 bytes 二进制形式的长文本数据 TEXT 0-65 535 bytes 长文本数据 MEDIUMBLOB 0-16 777 215 bytes 二进制形式的中等长度文本数据 MEDIUMTEXT 0-16 777 215 bytes 中等长度文本数据 LONGBLOB 0-4 294 967 295 bytes 二进制形式的极大文本数据 LONGTEXT 0-4 294 967 295 bytes 极大文本数据 char(n) 和 varchar(n) 中括号中 n 代表字符的个数，并不代表字节个数，比如 CHAR(30) 就可以存储 30 个字符。 CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。 BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。 BLOB 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。它们区别在于可容纳存储范围不同。 有 4 种 TEXT 类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。对应的这 4 种 BLOB 类型，可存储的最大长度不同，可根据实际情况选择。 2 MySQL、sqlalchemy与Python数据类型对应 Mysql类型 sqlalchemy类型 python类型 说明 TINYINT(1B) Boolean bool 布尔值 SMALLINT(2B) SmallInteger int 取值范围较小，一般为16位 MEDIUMINT(3B) INT或INTEGER(4B) Integer int 普通整数，一般32位 BIGINT(8B) BigInteger int/long 不限精度的整数 FLOAT(4B) Float float 浮点数 DOUBLE(8B) DECIMAL或DEC Numeric decimal.Decimal 定点数 DATE(3B) Date datetime.date 日期 TIME(3B) Time date.time 时间 YEAR(1B) DATETIME(8B) DateTime datetime.datetime 日期和时间 TIMESTAMP(4B) CHAR VARCHAR String str 变长字符串，而且String后面需要长度参数，否则报错 TINYBLOB TINYTEXT BLOB LargeBinary str 二进制文件，64K=65535bytes TEXT Text str 变长字符串，64K=65535bytes(255bytes) MEDIUMBLOB LargeBinary(65536) str 二进制，16M=16777215bytes MEDIUMTEXT Text(65536) str 变长字符串，16M=16777215bytes LONGBLOB LargeBinary(16777216) str 二进制，32M=4294967295bytes LONGTEXT Text(16777216) str 变长字符串，32M=4294967295bytes ENUM Enum str 一组字符串 3 代码实战 3.1 建立MySQL表 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from sqlalchemy.ext.declarative import declarative_basefrom sqlalchemy import *from sqlalchemy.orm import sessionmakerHOST = '127.0.0.1'PORT = 3306USERNAME = 'xxx' # mysql的用户名PASSWORD = 'xxx' # mysql的密码DB = 'xxx' # 数据库名称# f代表可以使用&#123;&#125;引用变量DB_URI = f'mysql+pymysql://&#123;USERNAME&#125;:&#123;PASSWORD&#125;@&#123;HOST&#125;:&#123;PORT&#125;/&#123;DB&#125;'# 创建引擎engine = create_engine(DB_URI)# 创建SQLORM基类，注意这里要加参数，参数为上一步创建的引擎Base = declarative_base(engine)# 构建session对象session = sessionmaker(engine)()# 创建实体表Dataclass Data(Base): __tablename__ = \"data_type\" id = Column(Integer, primary_key=True) booleanData = Column(Boolean(0)) # TINYINT(1B) smallInteger = Column(SmallInteger) # SMALLINT(2B) integer = Column(Integer) # INT或INTEGER(4B) bigInteger = Column(BigInteger) # BIGINT(8B) floatData = Column(Float) # FLOAT(4B) numericData = Column(Numeric) # DECIMAL或DEC dateData = Column(Date) # DATE(3B) timeData = Column(Time) # TIME(3B) dateTime = Column(DateTime) # DATETIME(8B) stringData = Column(String(250)) # VARCHAR textData = Column(Text) mediumText = Column(Text(65536)) longText = Column(Text(16777216)) largeBinary = Column(LargeBinary) mediumBlob = Column(LargeBinary(65536)) longBlob = Column(LargeBinary(16777216)) enumData = Column(Enum('father', 'mother'))# 将模型映射到数据库中# 即如果数据库中没有student表则创建映射表studentBase.metadata.create_all()# 删除Data表def del_table(): Data.__table__.drop()if __name__ == \"__main__\": print(\"test data type\") # del_table() 3.2 MySQL表结构 1234567891011121314151617181920212223mysql&gt; DESC data_type;+--------------+-------------------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+--------------+-------------------------+------+-----+---------+----------------+| id | int | NO | PRI | NULL | auto_increment || booleanData | tinyint(1) | YES | | NULL | || smallInteger | smallint | YES | | NULL | || integer | int | YES | | NULL | || bigInteger | bigint | YES | | NULL | || floatData | float | YES | | NULL | || numericData | decimal(10,0) | YES | | NULL | || dateData | date | YES | | NULL | || timeData | time | YES | | NULL | || dateTime | datetime | YES | | NULL | || stringData | varchar(250) | YES | | NULL | || textData | text | YES | | NULL | || mediumText | mediumtext | YES | | NULL | || longText | longtext | YES | | NULL | || largeBinary | blob | YES | | NULL | || mediumBlob | mediumblob | YES | | NULL | || longBlob | longblob | YES | | NULL | || enumData | enum('father','mother') | YES | | NULL | |+--------------+-------------------------+------+-----+---------+----------------+ X 参考 Flask SQLAlchemy 数据类型和数据库的对应关系","categories":[{"name":"Python","slug":"Python","permalink":"https://dragonliu2022.github.io/categories/Python/"},{"name":"数据库","slug":"数据库","permalink":"https://dragonliu2022.github.io/categories/数据库/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://dragonliu2022.github.io/tags/MySQL/"}]},{"title":"修复TortoiseGit文件夹和文件状态图标不显示问题","slug":"修复TortoiseGit文件夹和文件状态图标不显示问题","date":"2022-03-25T10:58:15.000Z","updated":"2022-04-18T09:59:53.109Z","comments":true,"path":"2022/03/25/修复TortoiseGit文件夹和文件状态图标不显示问题/","link":"","permalink":"https://dragonliu2022.github.io/2022/03/25/修复TortoiseGit文件夹和文件状态图标不显示问题/","excerpt":"","text":"1 引入 今天打开git仓库项目，突然发现文件夹和文件状态图标不再显示。 2 解决(修改注册表Overlay的值) 参考：【随记】修复TortoiseGit文件夹和文件状态图标不显示问题 按Win+R键打开运行对话框，输入 regedit ，打开注册表； 在注册表中找到 HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\ShellIconOverlayIdentifiers 修改tortoise相关的名称（如在名称前加一个空格前缀）使其置于开始位置： 重启电脑，图标正常显示： X 参考 TortoiseGit 显示文件状态图标 解决TortoiseGit文件夹和文件状态图标不显示问题","categories":[{"name":"环境与工具","slug":"环境与工具","permalink":"https://dragonliu2022.github.io/categories/环境与工具/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://dragonliu2022.github.io/tags/Git/"}]},{"title":"借助gitbook与Gitee Pages服务搭建静态网站","slug":"借助gitbook与Gitee-Pages服务搭建静态网站","date":"2022-03-25T09:03:12.000Z","updated":"2022-04-18T09:59:39.372Z","comments":true,"path":"2022/03/25/借助gitbook与Gitee-Pages服务搭建静态网站/","link":"","permalink":"https://dragonliu2022.github.io/2022/03/25/借助gitbook与Gitee-Pages服务搭建静态网站/","excerpt":"","text":"1 引入 在做PA助教，需要将讲义重新部署下，静态网站。讲义仓库在Gitee，所以使用 gitbook + Gitee Pages 实现该需求。本文将以自己的Algorithm仓库进行演示： 2 实现 主要参考：使用 Gitbook 打造你的电子书 2.1 本地安装gitbook 2.1.1 安装gitbook 环境要求： NodeJS（推荐使用v4.0.0及以上版本） Windows，Linux，Unix 或 Mac OS X Windows下在cmd中输入： 1npm install gitbook-cli -g 执行下面的命令，查看 GitBook 版本，以验证安装成功： 1gitbook -V 2.1.2 GitBook 项目结构 GitBook使用简单的目录结构。在 SUMMARY （即 SUMMARY.md 文件）中列出的所有 Markdown / Asciidoc 文件将被转换为 HTML。 一个基本的 GitBook 电子书结构通常如下： 12345678910.├── book.json├── README.md├── SUMMARY.md├── chapter-1/| ├── README.md| └── something.md└── chapter-2/ ├── README.md └── something.md GitBook 特殊文件的功能： 文件 描述 book.json 配置数据、包括插件配置(可选) README.md 电子书的前言或每个文件夹的简介(必选) SUMMARY.md 电子书目录(可选) GLOSSARY.md 词汇/注释术语列表(可选) 2.1.3 创建book.json与SUMMARY.md 参考：Gitbook根据目录生成Summary.md book.json 文件需要自己创建，SUMMARY.md文件可以使用插件(gitbook-plugin-summary)自动生成。 安装插件： 1npm i gitbook-plugin-summary --save 在Algorithm项目根目录创建 book.json 文件，并输入： 12345&#123; \"plugins\": [ \"summary\" ]&#125; 2.1.4 目录顺序 关于数字序号的顺序：Ch10、Ch11、Ch1、Ch2、Ch3、Ch4… 所以需要修改序号：Ch1、Ch2、Ch3、Ch4、…、Ch10、Ch11 2.1.5 数学公式 使用mathjax，但是不支持行内公式，效果不好，后续再看怎么解决这一块。 参考： gitbook使用mathjax gitbook采坑笔记（一：Mathjax） 2.1.6 构建与启动服务 使用下面的命令，会在项目的目录下生成一个 _book 目录，里面的内容为静态站点的资源文件： 1gitbook build 使用下列命令会运行一个 web 服务, 通过 http://localhost:4000/ 可以预览书籍： 1gitbook serve 至此，Algorithm仓库对应的静态网站已经部署成功。 2.2 实现在线访问 在Gitee上打开Algorithm仓库，点击服务标签，选择Gitee Pages图标。 注意：Gitee Pages服务需要实名认证，审核需要数个工作日。 部署目录需要是_book 现在访问 http://dragon-liu.gitee.io/algorithm 即可。","categories":[{"name":"环境与工具","slug":"环境与工具","permalink":"https://dragonliu2022.github.io/categories/环境与工具/"}],"tags":[]},{"title":"Python-解决循环引用问题","slug":"Python-解决循环引用问题","date":"2022-03-09T08:11:23.000Z","updated":"2022-04-18T11:24:08.002Z","comments":true,"path":"2022/03/09/Python-解决循环引用问题/","link":"","permalink":"https://dragonliu2022.github.io/2022/03/09/Python-解决循环引用问题/","excerpt":"","text":"1 引入 当项目中的模块过多，或功能划分不够清晰时会出现循环引用的问题。最近在做毕设，涉及后台管理系统时出现循环引用的问题。 主要copy于：python解决循环引用问题 2 示例 moduleA.py： 1234567891011from moduleB import bdef a(): print('aaaaaaaa') b()def c(): print('cccc')if __name__ == '__main__': a() moduleB.py： 12345from moduleA import cdef b(): print('bbbbbbbbbb') c() 运行moduleA.py出现以下报错： 1ImportError: cannot import name 'b' from partially initialized module 'moduleB' (most likely due to a circular import) 导入其实是要将 被导入模块所有的代码都执行一遍，遇到函数和类的定义会作申明。回到循环引用中，首先导入B，进入B中，发现B中又导入了A又回到A中，但是A又导入B这就形成了循环引用。 3 解决 3.1 直接导入模块名，通过模块调用其中的函数 moduleA.py： 1234567891011import moduleBdef a(): print 'aaaaaaaa' moduleB.b()def c(): print 'cccccc'if __name__ == '__main__': a() moduleB.py： 123456import moduleAdef b(): print 'bbbbbbbbbb' moduleA.c() 3.2 使用延迟导入(lazy import) 在需要用的函数内部导入，或是在底部导入。 moduleA.py： 123456789101112# 不变from moduleB import bdef a(): print('aaaaaaaa') b()def c(): print('cccc')if __name__ == '__main__': a() moduleB.py： 12345678910111213# 方法1def b(): print('bbbbbbbbbb') c()from moduleA import c# 方法2def b(): from moduleA import c print('bbbbbbbbbb') c() 3.3 重新设计代码结构，将代码和并或者分离 将公共功能的代码分离成单独模块，或者将一些具有关系的代码合并成一个模块。 本次毕设便采用了这个方法：将一些公共功能的代码分离，config.py(数据库配置)、entity.py(实体类) config.py： 12345678910111213141516171819#!/usr/bin/python3from sqlalchemy.ext.declarative import declarative_basefrom sqlalchemy import create_engine, Column, Integer, String, TEXTfrom sqlalchemy.orm import sessionmakerHOST = '127.0.0.1'PORT = 3306USERNAME = 'xxx' # mysql数据库用户名PASSWORD = 'xxx' # 密码DB = 'xxx' # 数据库名称# f代表可以使用&#123;&#125;引用变量DB_URI = f'mysql+pymysql://&#123;USERNAME&#125;:&#123;PASSWORD&#125;@&#123;HOST&#125;:&#123;PORT&#125;/&#123;DB&#125;'# 创建引擎engine = create_engine(DB_URI)# 创建SQLORM基类，注意这里要加参数，参数为上一步创建的引擎Base = declarative_base(engine)# 构建session对象session = sessionmaker(engine)() entity.py： 123456789101112131415161718192021222324from config import *# 创建Report表class Report(Base): __tablename__ = 'report' # 表名 id = Column(Integer, primary_key=True, autoincrement=True) report_name = Column(String(100)) report_size = Column(String(100)) source_info = Column(String(100)) operation = Column(String(100)) tag = Column(String(100)) hazard_level = Column(String(100)) malware_static_info = Column(TEXT()) malware_dynamic_info = Column(TEXT()) upload_time = Column(String(100))# 创建MidFid表class MidFid(Base): __tablename__ = 'malware_mid_fid' # 表名 id = Column(Integer, primary_key=True, autoincrement=True) mid = Column(Integer()) # 样本id fid = Column(Integer()) # 家族id X 参考","categories":[{"name":"Python","slug":"Python","permalink":"https://dragonliu2022.github.io/categories/Python/"}],"tags":[]},{"title":"Python-列表-遍历","slug":"Python-列表-遍历","date":"2022-03-08T07:03:09.000Z","updated":"2022-04-18T11:24:22.213Z","comments":true,"path":"2022/03/08/Python-列表-遍历/","link":"","permalink":"https://dragonliu2022.github.io/2022/03/08/Python-列表-遍历/","excerpt":"","text":"1 前言 最近在使用python操作mysql，涉及列表操作比较多，整理一下列表遍历。 主要copy于python3 遍历列表list 四种方法 2 方法 2.1 in 123456789101112item_list = ['a', 'b', 'c', 'd', 'a']for item in item_list: print(item_list.index(item), item)'''0 a1 b2 c3 d0 a''' 注意：按顺序输出值；如果列表中有重复值，下标会返回第一个值的下标，如上面的第二个a，但是这种bug只需要添加一个计数变量就解决了。 2.2 enumerate() enumerate(sequence, [start=0])，返回枚举对象(元组) 参数： sequence：一个序列、迭代器或其他支持迭代对象。 start：下标起始位置。 用法实例： 1234567891011121314151617181920212223item_list = ['a', 'b', 'c', 'd', 'a']for item in enumerate(item_list): print(item)'''(0, 'a')(1, 'b')(2, 'c')(3, 'd')(4, 'a')'''for index, val in enumerate(item_list): print(index, val)'''0 a1 b2 c3 d4 a''' 注意：按顺序输出值；下标会返回对应值的下标，解决了2.1的问题。 2.3 iter()迭代器 iter(object, [sentinel])函数用来生成迭代器，返回迭代对象。 参数： object：支持迭代的集合对象。 sentinel：如果传递了第二个参数，则参数 object 必须是一个可调用的对象（如，函数），此时，iter 创建了一个迭代器对象，每次调用这个迭代器对象的__next__()方法时，都会调用 object。 用法实例： 123456789101112item_list = ['a', 'b', 'c', 'd', 'a']for item in iter(item_list): print(item)'''abcda''' 注意：按顺序输出。 2.4 range()函数 range(start, end, [step]) 函数返回类型是ndarray，可用list()返回一个整数列表，一般用在 for 循环中。 参数： start：计数从 start 开始，默认是从 0 开始，例如range(5)等价于range(0,5)； end：计数到 end 结束，但不包括 end。例如：range(0, 5)是 [0, 1, 2, 3, 4] 没有 5 step：步长，默认为1。例如：range(0, 5) 等价于 range(0, 5, 1) 用法实例： 123456789101112item_list = ['a', 'b', 'c', 'd', 'a']for i in range(len(item_list)): print(item_list[i])'''abcda''' 注意：按顺序输出。 2.5 倒序遍历 2.5.1 reversed函数 123456789101112item_list = ['a', 'b', 'c', 'd', 'a']for item in reversed(item_list): print(item)'''adcba''' 2.5.2 range()函数 123456789101112item_list = ['a', 'b', 'c', 'd', 'a']for i in range(len(item_list)-1, -1, -1): print(item_list[i])'''adcba''' 2.5.3 切片 123456789101112item_list = ['a', 'b', 'c', 'd', 'a']for item in item_list[::-1]: print(item)'''adcba''' X 参考 Python 列表(List) 的三种遍历(序号和值)方法 python列表遍历（包括倒序遍历的三种方法）","categories":[{"name":"Python","slug":"Python","permalink":"https://dragonliu2022.github.io/categories/Python/"}],"tags":[]},{"title":"Python-列表-排序","slug":"Python-列表-排序","date":"2022-03-08T07:02:59.000Z","updated":"2022-04-18T11:24:45.479Z","comments":true,"path":"2022/03/08/Python-列表-排序/","link":"","permalink":"https://dragonliu2022.github.io/2022/03/08/Python-列表-排序/","excerpt":"","text":"1 前言 最近在使用python操作mysql，涉及列表操作比较多，整理一下列表排序。 主要copy于 菜鸟教程——Python List sort()方法 2 sort()方法 sort() 函数用于对原列表进行排序，如果指定参数，则使用比较函数指定的比较函数。 sort()方法语法： 1list.sort(cmp=None, key=None, reverse=False) 参数： cmp – 可选参数, 如果指定了该参数会使用该参数的方法进行排序。 key – 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。 reverse – 排序规则，reverse = True 降序， reverse = False 升序（默认）。 返回值： 该方法没有返回值，但是会对列表的对象进行排序。 以下实例展示了 sort() 函数的使用方法： 12345item_list = ['a', 'b', 'c', 'd', 'a']print(item_list) # ['a', 'b', 'c', 'd', 'a']item_list.sort()print(item_list) # ['a', 'a', 'b', 'c', 'd'] 关于key参数的使用： 12345678910111213# 获取列表的第二个元素def takeSecond(elem): return elem[1]# 列表random = [(2, 2), (3, 4), (4, 1), (1, 3)]# 指定第二个元素排序random.sort(key=takeSecond)# 输出类别print(random) # [(4, 1), (2, 2), (1, 3), (3, 4)] X 参考","categories":[{"name":"Python","slug":"Python","permalink":"https://dragonliu2022.github.io/categories/Python/"}],"tags":[]},{"title":"Python-列表-去重","slug":"Python-列表-去重","date":"2022-03-06T12:37:31.000Z","updated":"2022-04-18T11:24:52.079Z","comments":true,"path":"2022/03/06/Python-列表-去重/","link":"","permalink":"https://dragonliu2022.github.io/2022/03/06/Python-列表-去重/","excerpt":"","text":"1 前言 最近在使用python操作mysql，涉及列表操作比较多，整理一下列表去重。 主要copy于Python 列表去重的4种方式及性能对比 2 辅助数组 新建一个数组，遍历原数组，如果值不在新数组里便加入到新数组中： 12345678item_list = ['a', 'b', 'c', 'd', 'a']unique = []for item in item_list: if item not in unique: unique.append(item)print(unique) # ['a', 'b', 'c', 'd'] 上面使用了数组作为存储对象，实际上如果我们改成集合存储去重后的结果，性能会快不少： 12345678item_list = ['a', 'b', 'c', 'd', 'a']unique = set()for item in item_list: if item not in unique: unique.add(item)print(unique) # &#123;'b', 'a', 'd', 'c'&#125; 因为集合和数组的内在数据结构完全不同，集合使用了哈希表，因此速度会比列表快许多，但缺点在于无序。 3 数组-&gt;集合-&gt;数组 直接对数组进行集合转化，然后再转回数组： 12345item_list = ['a', 'b', 'c', 'd', 'a']unique = list(set(item_list))print(unique) # ['d', 'a', 'b', 'c'] 注意：这种去重方式是最快的，但正如前面所说，集合是无序的，将数组转为集合后再转为列表，就失去了原有列表的顺序。 4 保留原有数组顺序的去重（dict.fromkeys()） Python3.6+使用dict.fromkeys()函数，可以保留原有数组的顺序并去重： 12345item_list = ['a', 'b', 'c', 'd', 'a']unique = list(dict.fromkeys(item_list))print(unique) # ['a', 'b', 'c', 'd'] 当然，它会比单纯用集合进行去重的方式耗时稍微久一点；dict.fromkeys()仅在Python3.6及以上才支持。 在Python3.6以下，其实也存在fromkeys函数，只不过它由collections提供： 12345from collections import OrderedDictitem_list = ['a', 'b', 'c', 'd', 'a']unique = list(OrderedDict.fromkeys(item_list))print(unique) # ['a', 'b', 'c', 'd'] 比 Python3.6 的内置dict.fromkeys()慢一些，这是因为OrderedDict是用纯Python实现的。 X 参考","categories":[{"name":"Python","slug":"Python","permalink":"https://dragonliu2022.github.io/categories/Python/"}],"tags":[]},{"title":"【开源代码学习--若依】代码自动生成","slug":"【开源代码学习--若依】代码自动生成","date":"2022-03-04T03:18:51.000Z","updated":"2022-04-18T16:22:26.065Z","comments":true,"path":"2022/03/04/【开源代码学习--若依】代码自动生成/","link":"","permalink":"https://dragonliu2022.github.io/2022/03/04/【开源代码学习--若依】代码自动生成/","excerpt":"","text":"1 创建数据表 2 使用若依进行代码生成 3 打通前后端 3.1 controller MalwareDynamicController.java： 1234567891011/** * 根据mid查询malware_dynamic列表 */@PreAuthorize(\"@ss.hasPermi('system:dynamic:listmid')\")@GetMapping(value = \"/list/&#123;mid&#125;\")public TableDataInfo listByMid(MalwareDynamic malwareDynamic, @PathVariable(\"mid\") Long mid)&#123; startPage(); List&lt;MalwareDynamic&gt; list = malwareDynamicService.selectMalwareDynamicListByMid(malwareDynamic, mid); return getDataTable(list);&#125; 3.2 service IMalwareDynamicService.java： 1234567/** * 查询malware_dynamic列表 * * @param malwareDynamic malware_dynamic * @return malware_dynamic集合 */public List&lt;MalwareDynamic&gt; selectMalwareDynamicListByMid(MalwareDynamic malwareDynamic, Long mid); MalwareDynamicServiceImpl.java： 1234567891011/** * 根据mid查询malware_dynamic列表 * * @param malwareDynamic malware_dynamic * @return malware_dynamic */@Overridepublic List&lt;MalwareDynamic&gt; selectMalwareDynamicListByMid(MalwareDynamic malwareDynamic, Long mid);&#123; return malwareDynamicMapper.selectMalwareDynamicListByMid(malwareDynamic, mid);&#125; 3.3 mapper MalwareDynamicMapper.java: 1234567/** * 查询malware_dynamic列表 * * @param behavior behavior * @return behavior集合 */public List&lt;Behavior&gt; selectBehaviorList(Behavior behavior); 3.4 MalwareDynamicMapper.xml MalwareDynamicMapper.xml: 12 3.5 index.vue 3.6 report.js 123srcu/exec/exec.c: In function ‘exec_wrapper’:srcu/exec/exec.c:238:3: error: ‘strcat’ accessing 81 or more bytes at offsets 264 and 184 may overlap 1 byte at offset 264 [-Werror=restrict] strcat(decoding.asm_buf, decoding.assembly); 4 无效 有时候出现接口404，此时需要关闭IDEA，然后重新打开后端项目","categories":[{"name":"Java","slug":"Java","permalink":"https://dragonliu2022.github.io/categories/Java/"}],"tags":[{"name":"待补充","slug":"待补充","permalink":"https://dragonliu2022.github.io/tags/待补充/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://dragonliu2022.github.io/tags/Spring-Boot/"}]},{"title":"Python-Mysql-通过SQLAlchemy操作","slug":"Python-Mysql-通过SQLAlchemy操作","date":"2022-03-01T07:01:57.000Z","updated":"2022-04-18T11:27:32.615Z","comments":true,"path":"2022/03/01/Python-Mysql-通过SQLAlchemy操作/","link":"","permalink":"https://dragonliu2022.github.io/2022/03/01/Python-Mysql-通过SQLAlchemy操作/","excerpt":"","text":"1 简介 Windows下安装Mysql参考：博客——Windows下安装MySQL SQLAlchemy是用Python编程语言开发的一个开源项目。它提供了SQL工具包和ORM（对象关系映射）工具，使用MIT许可证发行。 2 安装 12pip3 install sqlalchemypip3 install pymysql 本文使用MySQL作为数据库，使用pymysql作为驱动，因此需要安装pymysql。 3 简单使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156from sqlalchemy.ext.declarative import declarative_basefrom sqlalchemy import create_engine, Column, Integer, String, TEXTfrom sqlalchemy.orm import sessionmakerfrom sqlalchemy import or_HOST = '127.0.0.1'PORT = 3306USERNAME = 'xxx' # mysql用户名PASSWORD = 'xxx' # mysql密码DB = 'xxx' # 数据库名称# f代表可以使用&#123;&#125;引用变量DB_URI = f'mysql+pymysql://&#123;USERNAME&#125;:&#123;PASSWORD&#125;@&#123;HOST&#125;:&#123;PORT&#125;/&#123;DB&#125;'# 创建引擎engine = create_engine(DB_URI)# 创建SQLORM基类，注意这里要加参数，参数为上一步创建的引擎Base = declarative_base(engine)# 构建session对象session = sessionmaker(engine)()# 创建实体表Personclass Person(Base): __tablename__ = 'person' # 表名 id = Column(Integer, primary_key=True, autoincrement=True) name = Column(String(100)) value = Column(TEXT())# 将模型映射到数据库中# 即如果数据库中没有student表则创建映射表studentBase.metadata.create_all()# 增：一个def insert(obj): session.add(obj) # 添加到session session.commit()# 增：批量def insert_batch(obj_list): session.add_all(obj_list) session.commit()# 删def delete(): session.query(Person).filter(Person.name == 'Pig').delete() session.commit()# 改def update(): # 将查找到的对象全部修改 session.query(Person).filter(Person.name == 'dragon').update(&#123;'value': 'waiting'&#125;) session.commit()# 查：所有数据def select_all(): item_list = session.query(Person).all() for item in item_list: print(item.name, item.value) # 若没有此句，后面执行删除表时会卡住 session.commit()# 查：指定列查询def select_in_cols(): item_list = session.query(Person.name).all() print(item_list) # 若没有此句，后面执行删除表时会卡住 session.commit()# 查：获取返回数据的第一行def select_first_row(): item = session.query(Person.name).first() print(item) session.commit()# 查：使用filter()方法过滤def select_filter(): item_list = session.query(Person.name).filter(Person.value != \"love\").all() print(item_list) session.commit()# 查：使用order_by()进行排序def select_order(): # 默认正序 item_list = session.query(Person.name, Person.value).order_by(Person.name).all() print(item_list) # desc()倒序 item_list = session.query(Person.name, Person.value).order_by(Person.name.desc()).all() print(item_list) session.commit()# 查：多条件查询def select_multi_condition(): # 多条件查询条件以,分隔默认为and item_list = session.query(Person.name).filter(Person.name != \"dragon\", Person.value != \"love\").all() print(item_list) # 使用or_连接多个条件 item_list = session.query(Person.name).filter(or_(Person.name != \"dragon\", Person.value != \"love\")).all() print(item_list) session.commit()# 查：模糊查询def select_like(): item_list = session.query(Person.name).filter(Person.name.like('%ag%')).all() print(item_list) session.commit()# 查：是否包含传递参数列表类元素def select_in(): item_list = session.query(Person.name).filter(Person.name.in_([\"SY\", \"dragon\"])).all() print(item_list) session.commit()# 查：计算个数def select_count(): num = session.query(Person).count() print(num) session.commit()# 删除TestTable表def del_table(): Person.__table__.drop()if __name__ == \"__main__\": insert(Person(name=\"SY\", value=\"afascinatinggril\")) obj_list = [Person(name=\"dragon\", value=\"aunreasoningboy\"), Person(name=\"pig\", value=\"aquerulousboy\"), ] insert_batch(obj_list) delete() update() select_all() select_in_cols() select_first_row() select_filter() select_order() select_multi_condition() select_like() select_in() select_count() del_table() 注意： 增删改查除了查询不设计修改操作，其他增删改都需要使用commit()方法提交事务 执行查询操作后，不执行session.commit()，直接执行删除表操作会卡住 X 参考 sqlalchemy的基本用法 如何在SQLAlchemy中删除表？","categories":[{"name":"Python","slug":"Python","permalink":"https://dragonliu2022.github.io/categories/Python/"},{"name":"数据库","slug":"数据库","permalink":"https://dragonliu2022.github.io/categories/数据库/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://dragonliu2022.github.io/tags/MySQL/"}]},{"title":"Python-字符串-字典与字符串互转","slug":"Python-字符串-字典与字符串互转","date":"2022-02-28T14:15:59.000Z","updated":"2022-04-18T11:26:22.925Z","comments":true,"path":"2022/02/28/Python-字符串-字典与字符串互转/","link":"","permalink":"https://dragonliu2022.github.io/2022/02/28/Python-字符串-字典与字符串互转/","excerpt":"","text":"1 字符串转为字典 如果要将字符串转为字典，则可以使用 eval，但是原来双引号会变为单引号。 123456789dict_str = \"\"\"&#123; \"key_a\": 1, \"key_b\": 2,&#125;\"\"\"dict_new = eval(dict_str)print(type(dict_new)) # &lt;class 'dict'&gt;print(dict_new) # &#123;'key_a': 1, 'key_b': 2&#125; 2 字典转字符串 将字典转为字符串的方式，可以使用 str，但是原来双引号会变为单引号。 1234567dict_test = &#123; \"key_a\": 1, \"key_b\": 2,&#125;dict_str = str(dict_test)print(type(dict_str)) # &lt;class 'str'&gt;print(dict_str) # &#123;'key_a': 1, 'key_b': 2&#125; 使用 json.dumps，就可以保住双引号；如果不用考虑双引号，则使用 str，毕竟比 json.dumps 快了一个数量级。 123456789import jsondict_test = &#123; \"key_a\": 1, \"key_b\": 2,&#125;dict_str = json.dumps(dict_test)print(type(dict_str)) # &lt;class 'str'&gt;print(dict_str) # &#123;\"key_a\": 1, \"key_b\": 2&#125; X 参考 python字典转字符串","categories":[{"name":"Python","slug":"Python","permalink":"https://dragonliu2022.github.io/categories/Python/"}],"tags":[]},{"title":"Python-os模块-获取文件信息","slug":"Python-os模块-获取文件信息","date":"2022-02-28T13:44:44.000Z","updated":"2022-04-18T11:27:57.722Z","comments":true,"path":"2022/02/28/Python-os模块-获取文件信息/","link":"","permalink":"https://dragonliu2022.github.io/2022/02/28/Python-os模块-获取文件信息/","excerpt":"","text":"1 获取文件大小，创建时间，访问时间，修改时间 12345678910111213141516171819202122232425262728293031323334353637383940414243import timeimport os'''把时间戳转化为时间: 1479264792 to 2016-11-16 10:53:12'''def TimeStampToTime(timestamp): timeStruct = time.localtime(timestamp) return time.strftime('%Y-%m-%d %H:%M:%S',timeStruct)'''获取文件的大小,结果保留两位小数，单位为MB'''def get_FileSize(filePath): filePath = filePath.encode('utf-8') fsize = os.path.getsize(filePath) print(fsize, \"B\") print(fsize/float(1024), \"KB\") print(fsize/float(1024*1024), \"MB\") fsize = fsize/float(1024*1024) return round(fsize, 2)'''获取文件的访问时间'''def get_FileAccessTime(filePath): filePath = filePath.encode('utf-8') t = os.path.getatime(filePath) return TimeStampToTime(t)'''获取文件的创建时间'''def get_FileCreateTime(filePath): filePath = filePath.encode('utf-8') t = os.path.getctime(filePath) return TimeStampToTime(t)'''获取文件的修改时间'''def get_FileModifyTime(filePath): filePath = filePath.encode('utf-8') t = os.path.getmtime(filePath) return TimeStampToTime(t)if __name__ == \"__main__\": file_path = \"test1.py\" print(get_FileSize(file_path)) print(get_FileAccessTime(file_path)) print(get_FileCreateTime(file_path)) print(get_FileModifyTime(file_path)) X 参考 python 获取文件大小，创建时间和访问时间","categories":[{"name":"Python","slug":"Python","permalink":"https://dragonliu2022.github.io/categories/Python/"}],"tags":[]},{"title":"Python-time模块-获取当前时间","slug":"Python-time模块-获取当前时间","date":"2022-02-28T13:01:50.000Z","updated":"2022-04-18T11:28:10.136Z","comments":true,"path":"2022/02/28/Python-time模块-获取当前时间/","link":"","permalink":"https://dragonliu2022.github.io/2022/02/28/Python-time模块-获取当前时间/","excerpt":"","text":"1 time.time() 返回当前时间戳，值为按秒计算的浮点数 表示从1970年1月1日0点0分开始，到当前时间，一共经历了多少秒 12345import timetest_time = time.time()print(type(test_time)) # &lt;class 'float'&gt;print(test_time) # 1646054545.0786133 2 time.localtime() 格式化时间戳为本地的时间，年月日，时分秒等信息 若未输入参数，默认当前时间 1234567891011121314import timetest_time = time.localtime()print(type(test_time)) # &lt;class 'time.struct_time'&gt;print(test_time) # time.struct_time(tm_year=2022, tm_mon=2, tm_mday=28, tm_hour=21, tm_min=29, tm_sec=32, tm_wday=0, tm_yday=59, tm_isdst=0)print(test_time.tm_year) # 年：2022print(test_time.tm_mon) # 月：2print(test_time.tm_mday) # 日：28print(test_time.tm_hour) # 时：21print(test_time.tm_min) # 分：29print(test_time.tm_sec) # 秒：32t2 = time.time()print(time.localtime(t2)) # time.struct_time(tm_year=2022, tm_mon=2, tm_mday=28, tm_hour=21, tm_min=32, tm_sec=44, tm_wday=0, tm_yday=59, tm_isdst=0) 3 time.asctime() 格式化时间 若未输入参数，默认当前时间 1234567891011import timet1 = time.asctime()print(type(t1)) # &lt;class 'str'&gt;print(t1) # Mon Feb 28 21:37:53 2022t2 = time.localtime(time.time())print(time.asctime(t2)) # Mon Feb 28 21:37:53 2022t3 = time.asctime(time.localtime())print(t3) # Mon Feb 28 21:37:53 2022 4 time.strftime() 格式化时间 123456789import timet1 = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime())print(type(t1)) # &lt;class 'str'&gt;print(t1) # 2022-02-28 21:39:55t2 = time.strftime('%a %b %d %H:%M:%S %Y', time.localtime())print(type(t2)) # &lt;class 'str'&gt;print(t2) # Mon Feb 28 21:39:55 2022 X 参考 Python获取当前时间（time模块）","categories":[{"name":"Python","slug":"Python","permalink":"https://dragonliu2022.github.io/categories/Python/"}],"tags":[]},{"title":"Windows下安装Redis","slug":"Windows下安装Redis","date":"2022-02-15T08:13:23.000Z","updated":"2022-04-18T09:56:28.667Z","comments":true,"path":"2022/02/15/Windows下安装Redis/","link":"","permalink":"https://dragonliu2022.github.io/2022/02/15/Windows下安装Redis/","excerpt":"","text":"1 引入 最近在Windows上运行若依系统，需要配置Redis，但是这台笔记本上还没安装，整理下。 Redis官网：http://www.redis.cn/ 主要copy于 Windows中Redis的下载安装与修改密码并启动 2 下载安装包 Github下载安装包：Redis Installer 选择 zip 和 msi 下载都可以，测试使用的 msi。 3 安装Redis 双击下载好的安装文件Redis-x64-3.0.504.msi打开安装程序 安装时注意将路径加到PATH中： 其他的，如端口等默认选项即可： 4 测试 启动服务端：在上述安装过程中已经自启动Redis了，如果没启动，则在Redis安装目录打开命令行并执行：redis-server.exe redis.windows.conf 启动客户端： 12345# 这里的123456是上面自己设置的密码D:\\developer\\database\\redis\\soft&gt;redis-cli.exe -h 127.0.0.1 -p 6379 -a 123456127.0.0.1:6379&gt; pingPONG127.0.0.1:6379&gt; 5 Redis管理软件（Redis Desktop Manager） 从0.9.3.817版本后就开始收费了。当然，源码始终是开源的，需要自行编译，有已经编译好的版本： 新版的RedisDesktopManager下载 Github-AnotherRedisDesktopManager （实验中使用的软件） 新建连接，默认即可： 运行完若依系统后，已经有了数据：","categories":[{"name":"环境与工具","slug":"环境与工具","permalink":"https://dragonliu2022.github.io/categories/环境与工具/"},{"name":"数据库","slug":"数据库","permalink":"https://dragonliu2022.github.io/categories/数据库/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://dragonliu2022.github.io/tags/Redis/"}]},{"title":"Windows下安装MySQL","slug":"Windows下安装MySQL","date":"2022-02-15T06:02:40.000Z","updated":"2022-04-18T09:56:12.513Z","comments":true,"path":"2022/02/15/Windows下安装MySQL/","link":"","permalink":"https://dragonliu2022.github.io/2022/02/15/Windows下安装MySQL/","excerpt":"","text":"1 引入 最近在Windows上运行若依系统，需要配置MySQL，但是这台笔记本上还没安装，整理下。 主要copy于 windows10上安装mysql（详细步骤) 2 下载安装包 官网下载：MySQL Installer 下载速度较慢，使用迅雷下载提速。 3 安装Mysql 双击下载好的mysql安装文件mysql-installer-community-8.0.28.0.msi打开安装程序，打开后需要稍等一下 选择安装类型（根据个人需要）：此处我只需要server，所以选择Custom Select Products：（注意这个地方把软件安装目录和数据目录换成非C盘，因为毕设后期数据量可能比较大） 点击“Execute”（执行）开始安装，安装过程中会显示安装的Progress（进度），等待安装完成后Status会显示Complete，mysql图标前会出现一个绿色的勾，然后点击“Next”按钮进入产品配置界面： Type and Networking：默认即可 Authentication Method：安装目的是学习使用，所以使用下面的选项即可： 设置密码等默认操作即可，其中mysql server的名称默认是MySQL80，默认开机自启动。 4 配置mysql环境变量（非必要） 说明：给mysql配置环境变量后我们就可以在cmd里运行mysql（开启、停止等操作） 选中系统变量中的path，在path值开头处输入mysql安装目录下的bin文件夹所在路径（默认是C:\\Program Files\\MySQL\\MySQL Server x.x，但是此处我做了修改），保存退出； 测试是否配置成功：打开cmd，输入 123456789101112131415C:\\Users\\Dragon Liu&gt;mysql -u root -pEnter password: ****Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 10Server version: 8.0.28 MySQL Community Server - GPLCopyright (c) 2000, 2022, Oracle and/or its affiliates.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.mysql&gt; 测试成功。 因为上面安装时默认开机自启动，所以这里mysql已经启动了，如果没启动可以管理员运行cmd，然后输入： 1234C:\\Windows\\system32&gt;net start MySQL80请求的服务已经启动。请键入 NET HELPMSG 2182 以获得更多的帮助。 5 MySQL管理软件（Navicat for MySQL） 安装正版Navicat for MySQL：破解版 打开Navicat for MySQL 新建一个连接，填写连接信息：","categories":[{"name":"环境与工具","slug":"环境与工具","permalink":"https://dragonliu2022.github.io/categories/环境与工具/"},{"name":"数据库","slug":"数据库","permalink":"https://dragonliu2022.github.io/categories/数据库/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://dragonliu2022.github.io/tags/MySQL/"}]},{"title":"【开源代码学习--若依】Windows下运行若依","slug":"【开源代码学习--若依】Windows下运行若依","date":"2022-02-15T03:30:43.000Z","updated":"2022-04-18T11:31:58.089Z","comments":true,"path":"2022/02/15/【开源代码学习--若依】Windows下运行若依/","link":"","permalink":"https://dragonliu2022.github.io/2022/02/15/【开源代码学习--若依】Windows下运行若依/","excerpt":"","text":"1 引入 最近在为毕设选取后台管理框架，开始打算用自己熟悉的Flask，或者Django，毕竟后边恶意样本的检测和可视化编程主语言会是python，这样一来使用python系的框架会做到无缝衔接。 Flask redash：redash-Github、redash-Gitee、redash-介绍、官网 Flask-Admin-Dashboard：Github Django+Vue Medusa：Github、文档 Vue+Django整合 但是考虑到这些框架网上参考资料、视频教程较少，上手时间可能较长。所以最后决定使用若依前后端分离版本。 简介：基于SpringBoot、Spring Security、Jwt、Vue的前后端分离的后台管理系统，还有前后端不分离版本、cloud版本 官网：官网、源码、文档 环境要求： JDK 1.8+ (推荐1.8版本) Mysql (业务数据库) 5.7+ (推荐5.7版本) Redis (缓存数据库) 3.0+ Maven 3.0+ Node 12+ 开发工具： IDEA：Spring Boot、Vue Navicat：mysql Another Redis Manager Desktop：Redis 主要参考教程：B站——楠哥教你学java 使用开源项目的步骤： 下载并运行 看懂业务流程 进行二次开发 2 查看自己的环境 打开cmd查看自己的环境，不满足上述 环境要求 的做出整改： 12345678910111213141516171819202122# 查看java版本E:\\&gt;java -versionjava version \"1.8.0_301\"Java(TM) SE Runtime Environment (build 1.8.0_301-b09)Java HotSpot(TM) 64-Bit Server VM (build 25.301-b09, mixed mode)# 查看maven版本E:\\&gt;mvn -v'mvn' 不是内部或外部命令，也不是可运行的程序或批处理文件。# 查看Node版本E:\\&gt;node -vv12.5.0# Redis版本D:\\developer\\database\\redis\\soft&gt;redis-server.exe -vRedis server v=3.0.504 sha=00000000:0 malloc=jemalloc-3.6.0 bits=64 build=a4f7a6e86f2d60b3# Mysql版本查看E:\\&gt;mysql --versionmysql Ver 8.0.28 for Win64 on x86_64 (MySQL Community Server - GPL) 3 下载并打开 IDEA从git链接导入项目，IDEA 打开总项目Spring Boot——RuoYi-Vue和前端项目Vue——ruo-ui。 下载源码之后ruoyi-ui是前端项目模块，ruoyi-admin是后端主模块，其他的是后端用到的其他模块。 sql目录下会有两个sql文件，这两个sql文件就是数据文件，需要导入Mysql数据库。 4 配置Mysql 安装MySQL：参考博客 Windows下安装MySQL 打开Navicat，新建数据库：（切记在新建数据库时要将字符集设置为utf8不然在执行向数据库插入一些数据含有中文时会报错） 新建数据库完成后在数据库上右击-运行sql文件，这里使用的是Navicat连接工具。然后选中上面的sql目录下的ry_20210908.sql，点击开始，然后再执行sql目录下的quartz.sql； 初始化数据库完成之后，会在数据库下生成一些表，并在表中生成一些数据： 在工程中配置数据库： 5 配置Redis 安装Redis：参考博客 Windows下安装Redis 在工程中配置数据库，若没修改Redis默认配置，无需改动下面的代码： 6 运行后端 找到启动程序，右键运行即可： 等待一段时间，Console中输出： 123456789101112131415...16:35:40.364 [restartedMain] INFO o.a.c.h.Http11NioProtocol - [log,173] - Starting ProtocolHandler [\"http-nio-8080\"]16:35:40.534 [restartedMain] INFO c.r.RuoYiApplication - [logStarted,61] - Started RuoYiApplication in 6.585 seconds (JVM running for 7.614)(♥◠‿◠)ﾉﾞ 若依启动成功 ლ(´ڡ`ლ)ﾞ .-------. ____ __ | _ _ \\ \\ \\ / / | ( ' ) | \\ _. / ' |(_ o _) / _( )_ .' | (_,_).' __ ___(_ o _)' | |\\ \\ | || |(_,_)' | | \\ `' /| `-' / | | \\ / \\ / ''-' `'-' `-..-' 16:35:41.546 [Quartz Scheduler [RuoyiScheduler]] INFO o.q.c.QuartzScheduler - [start,547] - Scheduler RuoyiScheduler_$_LAPTOP-NE344QFT1644914139051 started.16:36:15.811 [http-nio-8080-exec-1] INFO o.a.c.c.C.[.[.[/] - [log,173] - Initializing Spring DispatcherServlet 'dispatcherServlet' 打开浏览器，输入http://localhost:8080/： 1欢迎使用RuoYi后台管理框架，当前版本：v3.8.1，请通过前端地址访问。 至此，后端运行成功。 7 运行前端 在IDEA中打开 Terminal 标签，并输入 npm install --registry=https://registry.npm.taobao.org 安装依赖： 等待依赖安装完成，启动服务： 1234567891011121314151617E:\\05 Code\\RMDVS\\RuoYi-Vue\\ruoyi-ui&gt;npm run dev&gt; ruoyi@3.8.1 dev E:\\05 Code\\RMDVS\\RuoYi-Vue\\ruoyi-ui&gt; vue-cli-service serve INFO Starting development server...98% after emitting CopyPlugin DONE Compiled successfully in 20312ms 18:05:56 App running at: - Local: http://localhost:80/ - Network: http://192.168.1.7:80/ Note that the development build is not optimized. To create a production build, run npm run build. 启动成功后，会自动跳转到浏览器 http://localhost:80/，然后能出现验证码则是请求后台成功。 登陆成功，至此前端启动成功。 至此，若依系统前后端全部启动成功！！ X 参考 若依前后端分离版手把手教你本地搭建环境并运行项目","categories":[{"name":"Java","slug":"Java","permalink":"https://dragonliu2022.github.io/categories/Java/"}],"tags":[]},{"title":"git clone失败整理","slug":"git-clone失败整理","date":"2022-02-14T11:15:00.000Z","updated":"2022-04-18T16:25:59.926Z","comments":true,"path":"2022/02/14/git-clone失败整理/","link":"","permalink":"https://dragonliu2022.github.io/2022/02/14/git-clone失败整理/","excerpt":"","text":"1 errno 10054 翻墙了，但是仍然出现下面的报错： 12Cloning into 'redash'...fatal: unable to access 'https://github.com/getredash/redash.git/': OpenSSL SSL_read: Connection was reset, errno 10054 可能是因为代码库太大，调高 git buffer size 即可： 12345678# 方法1 全局修改git config --global http.postBuffer 524288000# 方法2 只针对当前仓库git initgit config http.postBuffer 524288000git remote add origin &lt;REPO URL&gt;git pull origin master 重开cmd，倘若还不成功，重复几次即可。 stackoverflow问答 2 443：Timed out 12Cloning into 'redash'...fatal: unable to access 'https://github.com/getredash/redash.git/': Failed to connect to github.com port 443: Timed out 翻墙是一种方法，其他待整理 3 OpenSSL SSL_connect: SSL_ERROR_SYSCALL 12Cloning into 'addlcov'...fatal: unable to access 'https://github.com/Dragonliu2018/addlcov.git/': OpenSSL SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443 又试了一次，成功下载。","categories":[{"name":"环境与工具","slug":"环境与工具","permalink":"https://dragonliu2022.github.io/categories/环境与工具/"}],"tags":[{"name":"待补充","slug":"待补充","permalink":"https://dragonliu2022.github.io/tags/待补充/"},{"name":"Git","slug":"Git","permalink":"https://dragonliu2022.github.io/tags/Git/"}]},{"title":"Python-取整","slug":"Python-取整","date":"2022-02-11T08:25:36.000Z","updated":"2022-04-18T11:24:58.087Z","comments":true,"path":"2022/02/11/Python-取整/","link":"","permalink":"https://dragonliu2022.github.io/2022/02/11/Python-取整/","excerpt":"","text":"1 向下取整——int() 1234f1 = 1.23print(int(f1)) # 1f2 = 1.73print(int(f2)) # 1 2 向上取整——ceil() 123456import mathf1 = 1.23print(math.ceil(f1)) # 2f2 = 1.73print(math.ceil(f2)) # 2 3 四舍五入——round() 1234f1 = 1.23print(round(f1)) # 1f2 = 1.73print(round(f2)) # 2 4 分别取整数和小数部分 12f1 = 1.23print(math.modf(f1)) # (0.22999999999999998, 1.0) 至于小数部分不准确：涉及浮点数在计算机中的表示。在计算机中是无法精确的表示小数的，至少目前的计算机做不到这一点。Python 和 C 一样, 采用 IEEE 754 规范来存储浮点数。 X 参考 python中取整数的四种方法","categories":[{"name":"Python","slug":"Python","permalink":"https://dragonliu2022.github.io/categories/Python/"}],"tags":[]},{"title":"Python-类-使用简易教程","slug":"Python-类-使用简易教程","date":"2022-02-11T06:07:06.000Z","updated":"2022-04-18T16:27:18.343Z","comments":true,"path":"2022/02/11/Python-类-使用简易教程/","link":"","permalink":"https://dragonliu2022.github.io/2022/02/11/Python-类-使用简易教程/","excerpt":"","text":"1 模板 1234567891011121314151617class Action(object): # 类属性 is_fail = False def __init__(self, sid, fid): self.id = sid # 唯一标志信息 self.fid = fid # 父进程唯一标志信息 def get_id(self): return self.id def get_fid(self): return self.fidtest_action = Action(sid=sid, fid=fid)print(test_action.get_id())print(Action.is_fail) 更多参考：菜鸟教程","categories":[{"name":"Python","slug":"Python","permalink":"https://dragonliu2022.github.io/categories/Python/"}],"tags":[{"name":"待补充","slug":"待补充","permalink":"https://dragonliu2022.github.io/tags/待补充/"}]},{"title":"Python-多线程&多进程-编程教程","slug":"Python-多线程&多进程-编程","date":"2022-02-11T06:05:20.000Z","updated":"2022-04-18T11:23:50.088Z","comments":true,"path":"2022/02/11/Python-多线程&多进程-编程/","link":"","permalink":"https://dragonliu2022.github.io/2022/02/11/Python-多线程&多进程-编程/","excerpt":"","text":"1 引言 最近在做恶意样本行为可视化，样本数量2w+，执行时间&gt;24h，所以需要多任务处理来提高效率。 参考：Python多进程和多线程（跑满CPU） 任务可以理解为进程（process），如打开一个word就是启动一个word进程。在一个word进程之中不只是进行打字输入，还需要拼写检查、打印等子任务，我们可以把进程中的这些子任务称为线程（thread）。 同时执行多个任务通常各个任务之间并不是没有关联的，而是需要相互通信和协调，有时，任务1必须暂停等待任务2完成后才能继续执行，有时，任务3和任务4又不能同时执行，所以，多进程和多线程的程序的复杂度要远远高于我们前面写的单进程单线程的程序。 2 多任务实现的3种方式 2.1 多进程模式 启动多个进程，每个进程虽然只有一个线程，但多个进程可以一块执行多个任务。多个CPU核心可以一起做多个任务。 进程执行带有参数的任务： 参数名 说明 args 以元祖的方式给任务传递参数, 顺序要正确 kwrags 以字典的方式给执行任务传递参数, key 跟参数名要一致 12345678910111213141516171819202122232425import multiprocessingimport timeimport osimport mathdef func(data): print(data, '进程PID', os.getpid()) print(data, '进程父进程编号', os.getppid()) for i in data: time.sleep(0.5)def test_multiprocess(): data_list = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10] core = 4 # 4进程并行 mod = math.ceil(len(data_list) / core) # 向上取整 group_data = [data_list[i:i + mod] for i in range(0, len(data_list), mod)] for data in group_data: # process = multiprocessing.Process(target=func, args=(5,)) process = multiprocessing.Process(target=func, kwargs=&#123;'data': data&#125;) process.start()if __name__ == '__main__': test_multiprocess() 2.2 多线程模式 启动一个进程，在一个进程内启动多个线程，这样，多个线程也可以一块执行多个任务。单个CPU核心可以同时做多个任务。 菜鸟教程——多线程 2.3 多进程+多线程模式 启动多个进程，每个进程再启动多个线程，这样同时执行的任务就更多了，当然这种模型更复杂，实际很少采用。 3 进程线程对比 3.1 关系对比 线程是依附在进程里边的, 没有进程就没有线程 一个进程默认提供一条线程, 进程可以创建多个线程 3.2 区别对比 进程创建的开销要比线程的开销要大 进程是操作系统资源分配的基本单位, 线程是cpu 调度的基本单位 线程不能独立执行, 必须依存进程 3.3 优缺点对比 进程优缺点: 优点：可以用多核 缺点：资源开销大 线程优缺点 优点: 资源开销小 缺点：不能使用多核 X 参考 在Python中优雅地用多进程 python多进程多线程,多个程序同时运行","categories":[{"name":"Python","slug":"Python","permalink":"https://dragonliu2022.github.io/categories/Python/"}],"tags":[]},{"title":"Pycharm(IntelliJ系列)的Low Memory问题","slug":"Pycharm-IntelliJ-的Low-Memory问题","date":"2022-02-11T03:22:48.000Z","updated":"2022-04-18T09:55:38.448Z","comments":true,"path":"2022/02/11/Pycharm-IntelliJ-的Low-Memory问题/","link":"","permalink":"https://dragonliu2022.github.io/2022/02/11/Pycharm-IntelliJ-的Low-Memory问题/","excerpt":"","text":"1 问题引入 最近在跑恶意样本可视化的脚本，Pycharm出现： 12Low MemoryThe IDE is running low on memory and this might affect performance. Please consider increasing available heap. 原因是IDE内存不足（之前给pycharm设定了2048M，跑大项目会出现上述问题）。 主要copy于 idea 的Low Memory问题 2 解决方法 下面的方法适用于IntelliJ系列产品，如Pycharm、idea等。 2.1 直接配置 选择上图里的 Configure，修改堆大小： 重启IDE生效。 2.2 通过help配置修改 菜单 Help -&gt; 选择 Edit Custom VM Options，会打开 pycharm64.exe.vmoptions文件，修改配置即可。 此时发现Change Memory Settings中已经发生了变化： 最后重启IDE生效。","categories":[{"name":"环境与工具","slug":"环境与工具","permalink":"https://dragonliu2022.github.io/categories/环境与工具/"}],"tags":[]},{"title":"Python-集合-操作教程","slug":"Python-集合-操作教程","date":"2022-02-10T09:22:22.000Z","updated":"2022-04-18T11:23:58.703Z","comments":true,"path":"2022/02/10/Python-集合-操作教程/","link":"","permalink":"https://dragonliu2022.github.io/2022/02/10/Python-集合-操作教程/","excerpt":"","text":"1 引言 集合（set）是一个无序的不重复元素序列。 主要copy于菜鸟教程 2 使用 2.1 创建 可以使用大括号 { } 或者 set() 函数创建集合： 1234567891011121314set1 = &#123;1, 2, 3&#125;print(set1) # &#123;1, 2, 3&#125;set2 = &#123;'pear', 'apple'&#125;print(set2) # &#123;'apple', 'pear'&#125;set3 = set(\"apple\")print(set3) # &#123;'l', 'p', 'e', 'a'&#125;set4 = set(&#123;'pear', 'apple'&#125;)print(set4) # &#123;'apple', 'pear'&#125;set5 = set(('pear', 'apple'))print(set5) # &#123;'pear', 'apple'&#125; 注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。 2.2 集合运算 1234567891011121314&gt;&gt;&gt; # 下面展示两个集合间的运算....&gt;&gt;&gt; a = set('abracadabra')&gt;&gt;&gt; b = set('alacazam')&gt;&gt;&gt; a &#123;'a', 'r', 'b', 'c', 'd'&#125;&gt;&gt;&gt; a - b # 集合a中包含而集合b中不包含的元素&#123;'r', 'd', 'b'&#125;&gt;&gt;&gt; a | b # 集合a或b中包含的所有元素&#123;'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'&#125;&gt;&gt;&gt; a &amp; b # 集合a和b中都包含了的元素&#123;'a', 'c'&#125;&gt;&gt;&gt; a ^ b # 不同时包含于a和b的元素&#123;'r', 'd', 'b', 'm', 'z', 'l'&#125; 2.3 基本操作 12345678910111213141516171819202122232425262728293031323334353637383940test_set = &#123;1, 2&#125;# 添加元素——add(x)##将元素 x 添加到集合 s 中，如果元素已存在，则不进行任何操作。test_set.add(2) # &#123;1, 2&#125;test_set.add(3) # &#123;1, 2, 3&#125;# 添加元素——update(x)##参数是列表，元组，字典等，int会报错##x 可以有多个，用逗号分开。test_set.update(4) # TypeError: 'int' object is not iterabletest_set.update(&#123;4, 5&#125;) # &#123;1, 2, 3, 4, 5&#125;test_set.update([4, 5], [5, 6]) # &#123;1, 2, 3, 4, 5, 6&#125;test_set.update((6, 7)) # &#123;1, 2, 3, 4, 5, 6, 7&#125;# 移除元素——remove(x)##将元素 x 从集合 s 中移除，如果元素不存在，则会发生错误。test_set.remove(8) # KeyError: 8test_set.remove(7) # &#123;1, 2, 3, 4, 5, 6&#125;# 移除元素——discard(x)##移除集合中的元素，且如果元素不存在，不会发生错误test_set.discard(7) # 不报错 &#123;1, 2, 3, 4, 5, 6&#125;test_set.discard(6) # &#123;1, 2, 3, 4, 5&#125;# 移除元素——pop()##随机删除集合中的一个元素##对集合进行无序的排列，然后将这个无序排列集合的左面第一个元素进行删除。test_set.pop() # &#123;2, 3, 4, 5&#125;# 计算元素个数——lenlen(test_set) # 4# 判断元素是否存在于集合中——inprint(2 in test_set) # Trueprint(1 in test_set) # Falseprint(1 not in test_set) # True# 清空集合——cleartest_set.clear()print(test_set) # set()","categories":[{"name":"Python","slug":"Python","permalink":"https://dragonliu2022.github.io/categories/Python/"}],"tags":[]},{"title":"Windows下安装与使用neo4j","slug":"Windows下安装与使用neo4j","date":"2022-02-10T03:17:06.000Z","updated":"2022-04-18T09:59:20.659Z","comments":true,"path":"2022/02/10/Windows下安装与使用neo4j/","link":"","permalink":"https://dragonliu2022.github.io/2022/02/10/Windows下安装与使用neo4j/","excerpt":"","text":"1 引言 最近在实现恶意样本行为可视化，使用 python模块graphviz使用教程 可以达到既定要求；但是图数据库neo4j理论上也是个不错的选择，所以整理下。 思路：安装Neo4j数据库，python语言使用py2neo库进行使用。 2 安装Neo4j 主要copy于 图数据库neo4j的安装与基本使用(一) 2.1 安装JDK Neo4j是基于Java的图形数据库，运行Neo4j需要启动JVM进程，因此必须安装JAVA SE的JDK。从Oracle官方网站下载 Java SE JDK，当前的版本是JDK8。java版本的高低决定了Neo4j的版本 2.2 安装Neo4j 官网下载最新版本Neo4j Neo4j应用程序有如下主要的目录结构： 1234bin目录：用于存储Neo4j的可执行程序；conf目录：用于控制Neo4j启动的配置文件；data目录：用于存储核心数据库文件；plugins目录：用于存储Neo4j的插件； 2.3 配置环境变量 创建主目录环境变量NEO4J_HOME，并把主目录设置为变量值。 2.4 启动neo4j 2.4.1 通过控制台启动Neo4j程序 打开cmd，切换到Neo4j主目录下的bin目录，运行下面命令即可： 1neo4j.bat console 用户名和密码默认为neo4j，首次登陆需要修改密码(Neo4j) java与neo4j版本不对应的报错： 123456789警告: ERROR! Neo4j cannot be started using java version 1.8.0_301警告: * Please use Oracle(R) Java(TM) 11, OpenJDK(TM) 11 to run Neo4j Server.* Please see https://neo4j.com/docs/ for Neo4j installation instructions.Invoke-Neo4j : This instance of Java is not supported所在位置 D:\\developer\\neo4j\\neo4j-community-4.4.3\\bin\\neo4j.ps1:21 字符: 7+ Exit (Invoke-Neo4j -Verbose:$Arguments.Verbose -CommandArgs $Argument ...+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : NotSpecified: (:) [Write-Error], WriteErrorException + FullyQualifiedErrorId : Microsoft.PowerShell.Commands.WriteErrorException,Invoke-Neo4j 当时我测试的版本(JDK8+Neo4j4.4.4)出现上面的报错，该换JDK8+Neo4j3.5.30后成功运行。 2.4.2 把Neo4j安装为服务（Windows Services） 请查阅 图数据库neo4j的安装与基本使用(一) 3 python使用 python通过调用py2neo 库实现对数据库的操作。 py2neo官网 py2neo——Neo4j&amp;python的配合使用 用Python中的py2neo库调用neo4j，搭建简单关联图谱 3.1 连接数据库 安装py2neo库：pip install py2neo 1234567from py2neo import Graphtest_graph = Graph( \"http://localhost:7474\", username=\"neo4j\", password=\"Neo4j\" #修改后的密码) 测试时出现报错： 1ValueError: The following settings are not supported: &#123;'username': 'neo4j'&#125; 因为py2neo版本问题，需要做出以下修改： 123from py2neo import Graphtest_graph = Graph(\"http://localhost:7474\", auth=(\"neo4j\", \"Neo4j\")) 详见 关于使用Py2neo连接Neo4j图数据库出现“ValueError: The following settings are not supported”报错的解决方案 3.2 基本操作 参考：py2neo在已有节点上批量创建关系 12345678910111213141516171819202122232425262728from py2neo import Graph, Node, Relationship, Subgraphtest_graph = Graph(\"http://localhost:7474\", auth=(\"neo4j\", \"Neo4j\"))# 删除数据库中以往的图，确保在一个空白的环境中进行操作test_graph.delete_all()# 创建顶点node_list = []node_list.append(Node(\"Teacher\", name=\"Alice\")) # label(type) name(显示值)node_list.append(Node(\"Student\", name=\"Bob\"))node_list.append(Node(\"Student\", name=\"Dragon\"))node_list.append(Node(\"Student\", name=\"Pig\"))##subgraph加快导入速度nodes = Subgraph(node_list)test_graph.create(nodes)# 创建边edge_list = []##找到对应节点node1 = test_graph.nodes.match(name=\"Alice\").first()node2 = test_graph.nodes.match(name=\"Bob\").first()edge_list.append(Relationship(node1, \"teach\", node2))node1 = test_graph.nodes.match(name=\"Alice\").first()node2 = test_graph.nodes.match(name=\"Dragon\").first()edge_list.append(Relationship(node1, \"teach\", node2))edges = Subgraph(relationships=edge_list)test_graph.create(edges) 效果图如下： 4 拓展——SPADE 当时参加A-ST竞赛时使用过，本次测试没进行。 Github-Spade X 参考","categories":[{"name":"环境与工具","slug":"环境与工具","permalink":"https://dragonliu2022.github.io/categories/环境与工具/"},{"name":"数据库","slug":"数据库","permalink":"https://dragonliu2022.github.io/categories/数据库/"}],"tags":[{"name":"neo4j","slug":"neo4j","permalink":"https://dragonliu2022.github.io/tags/neo4j/"}]},{"title":"Python-列表-分组","slug":"Python-列表-分组","date":"2022-02-10T02:20:19.000Z","updated":"2022-04-18T11:24:28.471Z","comments":true,"path":"2022/02/10/Python-列表-分组/","link":"","permalink":"https://dragonliu2022.github.io/2022/02/10/Python-列表-分组/","excerpt":"","text":"1 前言 最近在整python多线程，需要对文件列表进行分组，下面整理下有关list分组的内容。 2 分块 1234num = 3data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]group_data = [data[i:i + num] for i in range(0, len(data), num)]print(group_data) # [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10]] 3 groupby分组 123456789101112131415161718192021from itertools import groupbyuser_list = [ &#123;\"uid\": 1, \"sex\": \"男\", \"age\": 10&#125;, &#123;\"uid\": 3, \"sex\": \"男\", \"age\": 20&#125;, &#123;\"uid\": 4, \"sex\": \"女\", \"age\": 20&#125;, &#123;\"uid\": 4, \"sex\": \"女\", \"age\": 31&#125;, &#123;\"uid\": 2, \"sex\": \"男\", \"age\": 10&#125;]# 多字段排序user_sort = sorted(user_list, key=lambda x: (x[\"sex\"], x[\"age\"]))# 多字段分组user_group = groupby(user_sort, key=lambda x: (x[\"sex\"], x[\"age\"]))for key, group in user_group: print(key, list(group))\"\"\"('女', 20) [&#123;'uid': 4, 'sex': '女', 'age': 20&#125;]('女', 31) [&#123;'uid': 4, 'sex': '女', 'age': 31&#125;]('男', 10) [&#123;'uid': 1, 'sex': '男', 'age': 10&#125;, &#123;'uid': 2, 'sex': '男', 'age': 10&#125;]('男', 20) [&#123;'uid': 3, 'sex': '男', 'age': 20&#125;]\"\"\" 注意分组之前应先使用分组字段排好序。 X 参考 python list按规定的范围分组 Python list列表groupby分组用法","categories":[{"name":"Python","slug":"Python","permalink":"https://dragonliu2022.github.io/categories/Python/"}],"tags":[]},{"title":"Python-字典-判断dict或list中是否含有某个元素或key","slug":"Python-字典-判断dict或list中是否含有某个元素或key","date":"2022-02-09T14:49:35.000Z","updated":"2022-04-18T11:25:45.036Z","comments":true,"path":"2022/02/09/Python-字典-判断dict或list中是否含有某个元素或key/","link":"","permalink":"https://dragonliu2022.github.io/2022/02/09/Python-字典-判断dict或list中是否含有某个元素或key/","excerpt":"","text":"1 自带函数has_key() 在python的字典的属性方法里面有一个has_key()方法，这个方法使用起来非常简单。 Python 3.x不再支持 has_key() 函数，而被__contains__()所替代。 123d = &#123;'name': &#123;&#125;, 'age': &#123;&#125;, 'sex': &#123;&#125;&#125;# print(d.has_key('name'))print(d.__contains__('name')) # True 2 in 方法 123456789# 字典是否含有keyd = &#123;'name': &#123;&#125;, 'age': &#123;&#125;, 'sex': &#123;&#125;&#125;print(\"name\" in d.keys()) # Trueprint(\"name\" not in d.keys()) # False# 列表是否含有valuel = ['name', 'age', 'sex']print(\"name\" in l) # Trueprint(\"name\" not in l) # False X 参考 判断python字典或者列表中是否包含某个元素或者key","categories":[{"name":"Python","slug":"Python","permalink":"https://dragonliu2022.github.io/categories/Python/"}],"tags":[]},{"title":"Python-字符串-去除首尾的指定字符","slug":"Python-字符串-去除首尾的指定字符","date":"2022-02-09T14:43:17.000Z","updated":"2022-04-18T11:26:07.271Z","comments":true,"path":"2022/02/09/Python-字符串-去除首尾的指定字符/","link":"","permalink":"https://dragonliu2022.github.io/2022/02/09/Python-字符串-去除首尾的指定字符/","excerpt":"","text":"1 前言 最近在用到防止字符串转义函数——repr，但是他生成的字符串首尾会自动加上单引号，详见博客，可以使用strip函数进行去除。 2 实践 123456789101112131415# strip不传参数默认去掉空格test_str = ' string '# 去掉首尾空格print(test_str.strip()) # string# 去掉首空格print(test_str.lstrip()) # string # 去掉尾空格print(test_str.rstrip()) # string# 指定字符str1 = \"123\\tabc\"str2 = repr(str1)print(str1) # 123 abcprint(str2) # '123\\tabc'print(str2.strip(\"\\'\")) # 123\\tabc","categories":[{"name":"Python","slug":"Python","permalink":"https://dragonliu2022.github.io/categories/Python/"}],"tags":[]},{"title":"Python-文件-表格读写","slug":"Python-文件-表格读写","date":"2022-02-09T10:45:09.000Z","updated":"2022-04-18T11:25:10.483Z","comments":true,"path":"2022/02/09/Python-文件-表格读写/","link":"","permalink":"https://dragonliu2022.github.io/2022/02/09/Python-文件-表格读写/","excerpt":"","text":"1 问题引入 今天实现恶意样本标签提取，用到了表格处理，下面进行整理。 python操作excel主要用到xlrd和xlwt这两个库，即xlrd是读excel，xlwt是写excel的库。这两个库使用pip进行安装。 2 Python写excel——xlwt 12345678910111213141516171819202122import xlwt# 导出表格def export_excel(output_file): fields = ['姓名', '年龄'] # 设置自己需要的Excel表头 book = xlwt.Workbook(encoding='utf-8') # 获取excel对象 sheet = book.add_sheet('人员信息表') # 设置excel的sheet名称 for col, field in enumerate(fields): # 写入excel表头 sheet.write(0, col, field) info_list = [['Dragon', 18], ['Pig', 21], ['Cat', 22]] row = 1 for name, age in info_list: # 根据数据写入excel，col-单元格行标，field-单元格列标 sheet.write(row, 0, name) sheet.write(row, 1, age) row += 1 book.save(output_file)if __name__ == '__main__': output_file = \"output.xls\" export_excel(output_file) 表格信息如下： 3 Python读excel——xlrd 整体思路为，打开文件，选定表格，读取行列内容，读取表格内数据 详细代码如下： 12345678910111213141516171819202122232425262728293031import xlrd# 导入表格def read_excel(input_file): # 打开文件 wb = xlrd.open_workbook(filename=input_file) # 获取所有表格名字 print(wb.sheet_names()) # ['人员信息表'] # 通过索引获取表格 sheet1 = wb.sheet_by_index(0) # 通过名字获取表格 sheet2 = wb.sheet_by_name('人员信息表') print(sheet1, sheet2) # Sheet 0:&lt;人员信息表&gt; Sheet 0:&lt;人员信息表&gt; print(sheet1.name, sheet1.nrows, sheet1.ncols) # 人员信息表 4 2 # 获取第1行内容（编号从0开始） rows = sheet1.row_values(1) # 获取第1列内容（编号从0开始） cols = sheet1.col_values(1) print(rows) # ['Dragon', 18.0] print(cols) # ['年龄', 18.0, 21.0, 22.0] # 获取表格里的内容，三种方式 print(sheet1.cell(1, 0).value) # Dragon print(sheet1.cell_value(1, 0)) # Dragon print(sheet1.row(1)[0].value) # Dragonif __name__ == '__main__': input_file = \"output.xls\" read_excel(input_file) 4 xls和xlsx的异同 文件核心结构不同： xls核心结构是复合文档类型的； xlsx 的核心结构是 XML 类型的结构，并且基于XML进行压缩（占用空间更小），所以也可以看做zip文件，将一个“.xlsx”文件的后缀改为ZIP后，用解压软件解压，可以看到里面有一个xml文件和文件的主要内容。 版本不同： xls是excel2003及以前版本所生成的文件格式 xlsx是excel2007及以后版本所生成的文件格式 （excel 2007之后版本可以打开上述两种格式，但是excel2013只能打开xls格式） 进一步的详细解释参见：excel后缀.xls和.xlsx有什么区别 X 参考 python如何处理表格？ python实现——处理Excel表格（超详细）","categories":[{"name":"Python","slug":"Python","permalink":"https://dragonliu2022.github.io/categories/Python/"}],"tags":[]},{"title":"Python-字符串-统计词频","slug":"Python-字符串-统计词频","date":"2022-02-09T10:44:46.000Z","updated":"2022-04-18T11:26:10.284Z","comments":true,"path":"2022/02/09/Python-字符串-统计词频/","link":"","permalink":"https://dragonliu2022.github.io/2022/02/09/Python-字符串-统计词频/","excerpt":"","text":"1 问题引入 最近在做恶意样本的标签信息提取、投票表决方式确定样本的最终最终标签信息，恰好用到了词频统计，或者说查找数组中出现次数最多的元素。 2 词频统计 1234567891011121314151617txt = '''in a job interview or in a situation'''# 分解并提取英文文章的单词for s in ',.\\n ': txt = txt.replace(s, ' ')txt = txt.lower() # 将字母变成小写，排除原文大小写差异对词频统计的干扰word_list = txt.split()print(word_list) # ['in', 'a', 'job', 'interview', 'or', 'in', 'a', 'situation']# 对每个单词进行计数count = dict()for i in word_list: count[i] = count.get(i, 0) + 1print(count) # &#123;'in': 2, 'a': 2, 'job': 1, 'interview': 1, 'or': 1, 'situation': 1&#125;# 对单词的统计值从高到低进行排序sorted_word = sorted(count.items(), key=lambda item: item[1], reverse=True)print(sorted_word) # [('in', 2), ('a', 2), ('job', 1), ('interview', 1), ('or', 1), ('situation', 1)] 2 查找数组(list)中出现次数最多的元素 2.1 np.argmax(np.bincount()) 12345import numpy as nparray = [0, 1, 2, 2, 3, 4, 4, 4, 5, 6]print(np.bincount(array)) # [1 1 2 1 3 1 1]print(np.argmax(np.bincount(array))) # 4 np.argmax：就是返回数组中最大值对应的下标， np.bincount：首先找到数组最大值max，然后返回0～max的各个数字出现的次数，只能处理不含负数的集合 2.2 Counter().most_common 12345from collections import Counterarray = [0, 1, 2, 2, 3, 4, 4, 4, 5, 6, 'aswd']print(Counter(array)) # Counter(&#123;4: 3, 2: 2, 0: 1, 1: 1, 3: 1, 5: 1, 6: 1, 'aswd': 1&#125;)print(Counter(array).most_common(1)[0][0]) # 4 Counter用来对数组中元素出现次数进行统计，然后通过most_common函数找到出现次数最多的元素。这种方法对于数组就没有过多限制，甚至是各种类型元素混合的数组也可以。数组只能是array，不能是ndarray。 2.3 自己实现 12345678910appear_times = &#123;&#125;for label in [1, 1, 2, 3, 4, 5, 5, 5]: if label in appear_times: appear_times[label] += 1 else: appear_times[label] = 1most_common = max(appear_times, key=lambda x: appear_times[x])print(appear_times) # &#123;1: 2, 2: 1, 3: 1, 4: 1, 5: 3&#125;print(most_common) # 5 用max求最大值默认情况返回value值（出现次数）最大的key值（元素），而不是value值。 X 参考 python之统计文本中出现最多的单词 python统计数组中出现次数最多的元素","categories":[{"name":"Python","slug":"Python","permalink":"https://dragonliu2022.github.io/categories/Python/"}],"tags":[]},{"title":"Python-文件-解析xml文件","slug":"Python-文件-解析xml文件","date":"2022-02-09T10:44:20.000Z","updated":"2022-04-18T11:25:30.181Z","comments":true,"path":"2022/02/09/Python-文件-解析xml文件/","link":"","permalink":"https://dragonliu2022.github.io/2022/02/09/Python-文件-解析xml文件/","excerpt":"","text":"1 问题引入 最近在做恶意样本行为可视化，样本的行为是xml文件形式给出，需要使用python对其解析。本次实验使用了dom进行的解析。 XML 指可扩展标记语言（eXtensible Markup Language），标准通用标记语言的子集，是一种用于标记电子文件使其具有结构性的标记语言。 XML 被设计用来传输和存储数据。 XML 是一套定义语义标记的规则，这些标记将文档分成许多部件并对这些部件加以标识。 它也是元标记语言，即定义了用于定义其他与特定领域有关的、语义的、结构化的标记语言的句法语言。 常见的 XML 编程接口有 DOM 和 SAX，这两种接口处理 XML 文件的方式不同，当然使用场合也不同。 Python 有三种方法解析 XML，SAX，DOM，以及 ElementTree 主要参考：菜鸟教程——Python3 XML 解析 2 SAX 待补充 3 DOM 文件对象模型（Document Object Model，简称DOM），是W3C组织推荐的处理可扩展置标语言的标准编程接口。 一个 DOM 的解析器在解析一个 XML 文档时，一次性读取整个文档，把文档中所有元素保存在内存中的一个树结构里，之后你可以利用DOM 提供的不同的函数来读取或修改文档的内容和结构，也可以把修改过的内容写入xml文件。 xml文件 movies.xml 如下： 123456789101112131415161718&lt;collection shelf=\"New Arrivals\"&gt;&lt;movie title=\"Enemy Behind\"&gt; &lt;type&gt;War, Thriller&lt;/type&gt; &lt;format&gt;DVD&lt;/format&gt; &lt;year&gt;2003&lt;/year&gt; &lt;rating&gt;PG&lt;/rating&gt; &lt;stars&gt;10&lt;/stars&gt; &lt;description&gt;Talk about a US-Japan war&lt;/description&gt;&lt;/movie&gt;&lt;movie title=\"Transformers\"&gt; &lt;type&gt;Anime, Science Fiction&lt;/type&gt; &lt;format&gt;DVD&lt;/format&gt; &lt;year&gt;1989&lt;/year&gt; &lt;rating&gt;R&lt;/rating&gt; &lt;stars&gt;8&lt;/stars&gt; &lt;description&gt;A schientific fiction&lt;/description&gt;&lt;/movie&gt;&lt;/collection&gt; Python 中用 xml.dom.minidom 来解析 xml 文件，实例如下： 1234567891011121314151617181920212223242526#!/usr/bin/python3import xml.dom.minidom# 使用minidom解析器打开 XML 文档DOMTree = xml.dom.minidom.parse(\"movies.xml\")collection = DOMTree.documentElementif collection.hasAttribute(\"shelf\"): print (\"Root element : %s\" % collection.getAttribute(\"shelf\"))# 在集合中获取所有电影movies = collection.getElementsByTagName(\"movie\")# 打印每部电影的详细信息for movie in movies: print (\"*****Movie*****\") if movie.hasAttribute(\"title\"): print (\"Title: %s\" % movie.getAttribute(\"title\")) type = movie.getElementsByTagName('type')[0] print (\"Type: %s\" % type.childNodes[0].data) format = movie.getElementsByTagName('format')[0] print (\"Format: %s\" % format.childNodes[0].data) rating = movie.getElementsByTagName('rating')[0] print (\"Rating: %s\" % rating.childNodes[0].data) description = movie.getElementsByTagName('description')[0] print (\"Description: %s\" % description.childNodes[0].data) 输出如下： 1234567891011121314Root element : New Arrivals*****Movie*****Title: Enemy BehindType: War, ThrillerFormat: DVDRating: PGDescription: Talk about a US-Japan war*****Movie*****Title: TransformersType: Anime, Science FictionFormat: DVDRating: RDescription: A schientific fiction*****Movie***** 完整的 DOM API 文档请查阅Python DOM APIs。 4 ElementTree 待补充 X 参考","categories":[{"name":"Python","slug":"Python","permalink":"https://dragonliu2022.github.io/categories/Python/"}],"tags":[]},{"title":"Python-time模块-测量程序运行时间","slug":"Python-time模块-测量程序运行时间","date":"2022-02-09T08:48:03.000Z","updated":"2022-04-18T11:28:03.878Z","comments":true,"path":"2022/02/09/Python-time模块-测量程序运行时间/","link":"","permalink":"https://dragonliu2022.github.io/2022/02/09/Python-time模块-测量程序运行时间/","excerpt":"","text":"1 问题引入 最近做到恶意样本可视化，跑脚本需要测量程序运行时间，下面是几种测量方法： 2 datetime.datetime.now() 1234567import datetimestarttime = datetime.datetime.now()#long running#do something otherendtime = datetime.datetime.now()print((endtime - starttime).seconds) # 秒 datetime.datetime.now()获取的是当前日期，在程序执行结束之后，这个方式获得的时间值为程序执行的时间。 3 time.time() 1234567import timestart = time.time()#long running#do something otherend = time.time()print(end - start) # 秒 time.time()获取自纪元以来的当前时间（以秒为单位）。如果系统时钟提供它们，则可能存在秒的分数。所以这个地方返回的是一个浮点型类型。这里获取的也是程序的执行时间。 4 time.clock() 或 time.perf_counter() 12345678910# start = time.clock()start = time.perf_counter()#long running#do something otheri = 0while i &lt; 1e8: i += 1# end = time.clock()end = time.perf_counter()print(end - start) #秒 time.clock()返回程序开始或第一次被调用clock()以来的CPU时间。 这具有与系统记录一样多的精度。返回的也是一个浮点类型。这里获得的是CPU的执行时间。 python3.8+ 不支持 clock 了，替换成 time.perf_counter() 就可以了 注意：程序执行时间=cpu时间 + io时间 + 休眠或者等待时间 X 参考 几种Python执行时间的计算方法","categories":[{"name":"Python","slug":"Python","permalink":"https://dragonliu2022.github.io/categories/Python/"}],"tags":[]},{"title":"Python-os模块-遍历文件夹下的所有文件","slug":"Python-os模块-遍历文件夹下的所有文件","date":"2022-02-09T08:47:44.000Z","updated":"2022-04-18T11:27:50.543Z","comments":true,"path":"2022/02/09/Python-os模块-遍历文件夹下的所有文件/","link":"","permalink":"https://dragonliu2022.github.io/2022/02/09/Python-os模块-遍历文件夹下的所有文件/","excerpt":"","text":"1 问题引入 最近在实现恶意脚本的可视化，需要实现提取文件夹下的所有文件名，实现脚本自动化。 2 文件夹下只有文件 当目标文件夹中只有文件时，使用os模块的listdir()方法即可：该方法可以返回目标路径下的文件和文件夹的名字列表，参数就是目标路径。 1234import osfile_names = os.listdir(r'test')print(file_names) # ['1.txt', '2.txt', '3.txt'] 3 文件夹下有文件和文件夹 当目标文件中既有文件又有文件夹时，我们使用listdir()方法就只能获得第一层子文件或文件夹了，而子文件夹中的内容便获取不到了。 这时候我们需要用到os.walk()方法：传入目标路径即可。该方法可以递归的找出目标路径下的所有文件。 12345678910111213141516import osfile_names = os.listdir(r'test')print(file_names) # ['1.txt', '2.txt', '3.txt', 'sub-dir']for filepath, dirnames, filenames in os.walk(r'test'): for filename in filenames: print(filename)\"\"\"1.txt2.txt3.txt4.txt5.txt6.txt\"\"\" os.walk()方法可以生成三元组，也就是我们代码中的filepath，dirnames，filenames。我们将他们分别打印出来可以看到：其中filepath就是目标路径下所有文件的路径，dirnames是我们目标路径的所有目录名称，filenames则是各个路径下的文件名称列表： 123456789101112131415161718for filepath, dirnames, filenames in os.walk(r'test'): print(filepath)\"\"\"testtest\\sub-dir\"\"\"for filepath, dirnames, filenames in os.walk(r'test'): print(dirnames)\"\"\"['sub-dir'][]\"\"\"for filepath, dirnames, filenames in os.walk(r'test'): print(filenames)\"\"\"['1.txt', '2.txt', '3.txt']['4.txt', '5.txt', '6.txt']\"\"\" 4 拓展—获得目标路径下的所有文件的绝对路径 遍历目标路径下的各个文件，用os.path.join()方法将文件路径和文件名拼接在一起，就是各个文件的绝对路径了： 1234567891011for filepath, dirnames, filenames in os.walk(r'test'): for filename in filenames: print(os.path.join(filepath, filename))\"\"\"test\\1.txttest\\2.txttest\\3.txttest\\sub-dir\\4.txttest\\sub-dir\\5.txttest\\sub-dir\\6.txt\"\"\" X 参考 python遍历文件夹下的所有文件","categories":[{"name":"Python","slug":"Python","permalink":"https://dragonliu2022.github.io/categories/Python/"}],"tags":[]},{"title":"Python-字符串-防止转义","slug":"Python-字符串-防止转义","date":"2022-02-09T07:31:55.000Z","updated":"2022-04-18T11:25:51.613Z","comments":true,"path":"2022/02/09/Python-字符串-防止转义/","link":"","permalink":"https://dragonliu2022.github.io/2022/02/09/Python-字符串-防止转义/","excerpt":"","text":"1 问题引入 最近在做xml解析、可视化时遇到一个问题：将字符串（文件路径）中的转义字符不进行转义123\\tabc，正常print会将\\t看作转义字符tab，需求是使字符串按原样输出。下面是不同场景下的解决方法： 2 字符串常量 如果是字符串常量，则在字符串前加r 即可： 1234print(\"123\\tabc\")# 123 abcprint(r\"123\\tabc\") # test_str = r\"123\\tabc\"# 123\\tabc 3 字符串变量 如果字符串是变量，使用 repr() 方法： 123456str1 = \"123\\tabc\"str2 = repr(str1)print(str1) # 123 abcprint(str2) # '123\\tabc'print(str2.strip(\"\\'\")) # 123\\tabc 注意：字符串使用 repr 函数后输出是会在字符串前后自动加上单引号（见print第二行），print第三行是去掉了字符串首尾的单引号。关于strip函数，详见博客。 4 文件读取 123file1 = open(\"test.txt\", \"r\") # 123\\tabcprint(file1.read()) # 123\\tabc 文本文件读取测试发现字符串未发生转义。 拓展阅读：关于python中open函数读取和写入windows记事本的换行问题研究 X 参考 python中防止字符串转义 python如何实现对变量的禁止转义操作","categories":[{"name":"Python","slug":"Python","permalink":"https://dragonliu2022.github.io/categories/Python/"}],"tags":[]},{"title":"Python-graphviz模块-使用教程","slug":"Python-graphviz模块-使用教程","date":"2022-02-03T03:11:14.000Z","updated":"2022-04-18T11:26:36.880Z","comments":true,"path":"2022/02/03/Python-graphviz模块-使用教程/","link":"","permalink":"https://dragonliu2022.github.io/2022/02/03/Python-graphviz模块-使用教程/","excerpt":"","text":"1 情景引入 前几个月师姐给了个任务——恶意样本行为可视化，输入为xml文件，一个文件代表一个恶意样本。请教学姐学长同学等，加上观看效果图，得出实现思路：python解析xml文件，使用python模块graphviz进行可视化；之后使用图数据库neo4j进行对比。 之后发现neo4j创建多个图数据库比较麻烦，但是按照行为分类等都比较直观，所以做辅助作用应该不错。 下面对graphviz进行整理。 2 Graphviz Graphviz 是一个自动排版的作图软件，可以生成 png pdf 等格式。 Graphviz官网 Graphviz 画图的一些总结 3 python graphviz python graphviz则是graphviz的python实现。我们可以通过python graphviz实现轻松完成各种流程图的绘制。 python graphviz官方文档 [python] python模块graphviz使用入门 3.1 安装 安装python graphviz木块（本机使用的是python3.9）: 1pip install graphviz 除了python安装外，本机还需要安装Graphviz(下载页面)，并确保包含dot可执行文件的目录在系统路径上。安装过程中需要添加PATH： 否则出现下面的报错：(重启Pycharm生效) 1graphviz.backend.execute.ExecutableNotFound: failed to execute WindowsPath('dot'), make sure the Graphviz executables are on your systems' PATH graphviz.backend.ExecutableNotFound: failed to execute [‘dot’, ‘-Tpng’, ‘-O’, ‘t est.gv’]问题解决方法 解决报错：添加环境变量 3.2 使用 该graphviz模块提供了两个类：Graph和 Digraph。它们分别以DOT语言为无向图和有向图创建图描述。它们具有相同的 API。示例如下： 1234567891011121314151617181920212223from graphviz import Digraphdot = Digraph(comment='恶意样本行为可视化', format='jpg')# 初始化端点dot.node(name='n1', label='端点A', color=\"#008000\", fontcolor=\"#000000\", style=\"filled\", shape=\"rectangle\", fontname=\"Microsoft YaHei\")dot.node(name='n2', label='端点B', color=\"#FFD700\", fontcolor=\"#000000\", style=\"filled\", shape=\"circle\", fontname=\"Microsoft YaHei\")dot.node(name='n3', label='端点C', color=\"#0000FF\", fontcolor=\"#FFFFFF\", style=\"filled\", shape=\"oval\", fontname=\"Microsoft YaHei\")# 布局 L-左 R-右 T-上 B-下dot.attr(rankdir='LR') # 自左向右# dot.attr(rankdir='RL')# dot.attr(rankdir='TB') # 默认# dot.attr(rankdir='BT')# 初始化边dot.edge('n1', 'n2', label=\"边1\", color=\"#000000\", fontcolor=\"#000000\", style=\"\", fontname=\"Microsoft YaHei\")dot.edge('n1', 'n3', label=\"边2\", color=\"#FF0000\", fontcolor=\"#FF0000\", style=\"dashed\", fontname=\"Microsoft YaHei\")# 保存文件，view=False时将不自动打开文件# dot.render(\"test_graphviz.gv\", format='jpg', view=True)# 不保存文件，仅仅自动打开u = dot.unflatten(stagger=1)u.view() 显示如下： 3.3 中文乱码 如果出现中文乱码，多半是因为没有设置fontname为支持中文显示的字体，只需要在node或者edge中添加fontname=&quot;Microsoft YaHei&quot;，即可正常显示。 参考 3.4 端点、边、字体颜色 在node或者edge中添加color=&quot;#000000&quot;, fontcolor=&quot;#000000&quot;即可，具体颜色可以参考： 官网颜色 维基百科——X11名称编码 3.5 端点的形状 在node中添加shape=&quot;xxx&quot;即可，具体需要什么形状可以在官网中查找。 3.6 Rank GraphViz DOT有向图 (四)node节点布局控制之rank,group,subgraph 3.7 排版 如上面的示例，使用dot.attr(rankdir='xx')来确定排版，作用范围为使用该行代码之后，下一个dot.attr(rankdir='xx')代码之前。 3.8 name参数中不能有英文冒号 123dot.node(name='n1', label='n1')dot.node(name='n2:3', label='n2:3')dot.edge('n1', 'n2:3') dot.node(name=&quot;xxx&quot;) 如果name参数含有英文逗号，则会报错，导致画图错误： 1Warning: node n2, port 3 unrecognized 常见的思路是使用python将name参数改成中文冒号，label参数是原来的英文冒号，达到正确显示的目的。 123string = \"http://gsstudio.info/panel\"label = repr(string)name = repr(string.replace(\":\", \"：\")) repr函数是防止字符串转义的，详细见博客——python中防止字符串转义。 3.9 报错：graphviz.backend.execute.CalledProcessError 报错信息： 123subprocess.CalledProcessError: Command '[WindowsPath('dot'), '-Kdot', '-Tjpg', '-O', '57630-0.xml.gv']' returned non-zero exit status 3221225477....graphviz.backend.execute.CalledProcessError: Command '[WindowsPath('dot'), '-Kdot', '-Tjpg', '-O', '57630-0.xml.gv']' returned non-zero exit status 3221225477. [stderr: b'dot: graph is too large for cairo-renderer bitmaps. Scaling by 0.876568 to fit\\r\\n'] 现象： .gv文件可以正常生成，图片文件.jpg无法生成。 定位报错语句： 123dot = Digraph(comment='恶意样本行为可视化', format='jpg')...dot.render(output_dir + \"\\\\\" + file_name + \".gv\", format='jpg') 原因： 生成的graph太大，dot无法导出，换成pdf或svg就可以了，png和jpg都不行。 最后选择pdf格式，因为导出的文件小。 123dot = Digraph(comment='恶意样本行为可视化', format='pdf')...dot.render(output_dir + \"\\\\\" + file_name + \".gv\", format='pdf') X 参考","categories":[{"name":"环境与工具","slug":"环境与工具","permalink":"https://dragonliu2022.github.io/categories/环境与工具/"},{"name":"Python","slug":"Python","permalink":"https://dragonliu2022.github.io/categories/Python/"}],"tags":[]},{"title":"Python-jupyter-使用教程","slug":"Python-jupyter-使用教程","date":"2022-01-17T01:44:22.000Z","updated":"2022-04-18T11:26:54.770Z","comments":true,"path":"2022/01/17/Python-jupyter-使用教程/","link":"","permalink":"https://dragonliu2022.github.io/2022/01/17/Python-jupyter-使用教程/","excerpt":"","text":"1 安装 打开cmd，使用pip进行安装： 1pip install jupyterlab 2 使用 cmd输入： 1jupyter-lab 在浏览器输入：http://localhost:8888/","categories":[{"name":"环境与工具","slug":"环境与工具","permalink":"https://dragonliu2022.github.io/categories/环境与工具/"},{"name":"Python","slug":"Python","permalink":"https://dragonliu2022.github.io/categories/Python/"}],"tags":[{"name":"待补充","slug":"待补充","permalink":"https://dragonliu2022.github.io/tags/待补充/"}]},{"title":"Python-matplotlib-使用简易教程","slug":"Python-matplotlib-使用简易教程","date":"2022-01-17T01:44:22.000Z","updated":"2022-05-12T14:38:32.469Z","comments":true,"path":"2022/01/17/Python-matplotlib-使用简易教程/","link":"","permalink":"https://dragonliu2022.github.io/2022/01/17/Python-matplotlib-使用简易教程/","excerpt":"","text":"1 基础知识 官方文档 画板figure，画纸Sublpot画质，可多图绘画 画纸上最上方是标题title，用来给图形起名字 坐标轴Axis，横轴叫x坐标轴label，纵轴叫y坐标轴ylabel 图例Legend 代表图形里的内容 网格Grid，图形中的虚线，True显示网格 点 Markers：表示点的形状。 2 绘图步骤 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#导入matplotlib的pyplot模块import matplotlib.pyplot as plt#1 基础绘图#第1步：定义x和y坐标轴上的点 x坐标轴上点的数值x=[1, 2, 3, 4]#y坐标轴上点的数值y=[1, 4, 9, 16]#第2步：使用plot绘制线条第1个参数是x的坐标值，第2个参数是y的坐标值plt.plot(x,y)#第3步：显示图形plt.show()#2 定义绘图属性'''color：线条颜色，值r表示红色（red）marker：点的形状，值o表示点为圆圈标记（circle marker）linestyle：线条的形状，值dashed表示用虚线连接各点'''plt.plot(x, y, color='r',marker='o',linestyle='dashed')#plt.plot(x, y, 'ro')'''axis：坐标轴范围语法为axis[xmin, xmax, ymin, ymax]，也就是axis[x轴最小值, x轴最大值, y轴最小值, y轴最大值]'''plt.axis([0, 6, 0, 20])plt.show()#3 给图片提阿甲注释和标题等#第1步：定义x和y坐标轴上的点 x坐标轴上点的数值x=[1, 2, 3, 4]#y坐标轴上点的数值y=[1, 4, 9, 16]#第2步：使用plot绘制线条 第1个参数是x的坐标值，第2个参数是y的坐标值# 折线图plt.plot(x,y)# 柱形图# plt.barh(x,y)#添加文本 #x轴文本plt.xlabel('x坐标轴')#y轴文本plt.ylabel('y坐标轴')#标题plt.title('标题')#添加注释 参数名xy：箭头注释中箭头所在位置，参数名xytext：注释文本所在位置，#arrowprops在xy和xytext之间绘制箭头, shrink表示注释点与注释文本之间的图标距离plt.annotate('我是注释', xy=(2,5), xytext=(2, 10), arrowprops=dict(facecolor='black', shrink=0.01), )#第3步：显示图形plt.show() 3 多图绘制 123456789101112131415161718192021222324252627282930313233343536373839404142434445# 柱形图fig, axs = plt.subplots(nrows=2, ncols=2, figsize=(20, 12), dpi=100)axs[0][0].set_title('HeatLoadLight')axs[0][0].set_xlabel('DateTime')axs[0][0].set_ylabel('LoadValue')axs[0][0].bar(range(12), list, fc='g')axs[0][1].set_title('HeatLoadHeavy')axs[0][1].set_xlabel('DateTime')axs[0][1].set_ylabel('LoadValue')axs[0][1].bar(range(12), list, fc='g')axs[1][0].set_title('CoolLoadLight')axs[1][0].set_xlabel('DateTime')axs[1][0].set_ylabel('LoadValue')axs[1][0].bar(range(12), list, fc='g')axs[1][1].set_title('CoolLoadHeavy')axs[1][1].set_xlabel('DateTime')axs[1][1].set_ylabel('LoadValue')axs[1][1].bar(range(12), list, fc='g')fig.autofmt_xdate()plt.show()# 折线图fig, axs = plt.subplots(nrows=1, ncols=2, figsize=(20, 6), dpi=100)axs[0].set_title('xxx')axs[0].set_xlabel('Hour')axs[0].set_ylabel('Value')axs[0].plot(range(168), Q_trans_light, c='red', label='Light')axs[0].plot(range(168), Q_trans_heavy, c='blue', label='Heavy')axs[0].legend(loc='best')axs[1].set_title(\"xxx\")axs[1].set_xlabel('Hour')axs[1].set_ylabel('Value')axs[1].plot(range(168), Q_trans_light, c='red', label='Light')axs[1].plot(range(168), Q_trans_heavy, c='blue', label='Heavy')axs[1].legend(loc='best')fig.autofmt_xdate()plt.show() X 参考 菜鸟教程——Matplotlib 柱形图","categories":[{"name":"环境与工具","slug":"环境与工具","permalink":"https://dragonliu2022.github.io/categories/环境与工具/"},{"name":"Python","slug":"Python","permalink":"https://dragonliu2022.github.io/categories/Python/"}],"tags":[]},{"title":"Python-文件-读取整理","slug":"Python-文件-读取整理","date":"2022-01-17T01:44:22.000Z","updated":"2022-04-18T11:25:23.459Z","comments":true,"path":"2022/01/17/Python-文件-读取整理/","link":"","permalink":"https://dragonliu2022.github.io/2022/01/17/Python-文件-读取整理/","excerpt":"","text":"1 按行读取文本文件 1234file_path = 'xxx'with open(file_path) as f: for line in f.readlines(): print(line) open详解","categories":[{"name":"Python","slug":"Python","permalink":"https://dragonliu2022.github.io/categories/Python/"}],"tags":[{"name":"待补充","slug":"待补充","permalink":"https://dragonliu2022.github.io/tags/待补充/"}]},{"title":"C++项目的全量覆盖率和增量覆盖率","slug":"C++项目的全量覆盖率和增量覆盖率","date":"2021-09-27T15:14:54.000Z","updated":"2022-04-18T16:55:46.589Z","comments":true,"path":"2021/09/27/C++项目的全量覆盖率和增量覆盖率/","link":"","permalink":"https://dragonliu2022.github.io/2021/09/27/C++项目的全量覆盖率和增量覆盖率/","excerpt":"","text":"1 引入 需求：生成C/C++项目的全量/增量覆盖率报告 方案：gcov+lcov+addlcov gcov：是Linux下GCC自带的一个C/C++代码覆盖率分析工具,因此只要安装了gcc，就不需要再次安装了。 lcov：生成全量覆盖率报告。gcov能够生成代码覆盖信息，但是不够直观，因此需要借助lcov直观展示覆盖率，主要特点有： 基于Html输出，并生成一棵完整的HTML树 输出包括概述、覆盖率百分比、图表，能快速浏览覆盖率数据 支持大项目，提供三个级别的视图：目录视图、文件视图、源码视图 addlcov：生成全量覆盖率报告。 2 准备 文件目录： 12345C++_project Version_A hello_world.cpp Version_B hello_world.cpp Version_A/hello_world.cpp： 1234567#include&lt;stdio.h&gt;int main()&#123; printf(\"hello world\"); return 0; &#125; Version_B/hello_world.cpp： 1234567891011121314151617#include&lt;stdio.h&gt;void func()&#123; if (true) &#123; printf(\"func true\"); &#125; else &#123; printf(\"func false\"); &#125;&#125; int main()&#123; printf(\"hello world\"); func(); return 0; &#125; 3 安装 gcov：安装gcc和g++即可； lcov： 12345git clone https://github.com/Dragonliu2018/lcov.gitcd ./lcov# 安装perl，否则可能出现报错apt-get install perlmake install 在./bin 目录下生成了可执行文件 lcov addlcov： 1git clone https://github.com/Dragonliu2018/addlcov.git 将addlcov脚本放到项目文件夹直接使用即可。 4 全量覆盖率报告 4.1 lcov常用的参数 -d 项目路径，即.gcda .gcno所在的路径 -a 合并（归并）多个lcov生成的info文件 -c 捕获，也即收集代码运行后所产生的统计计数信息 --external 捕获其它目录产生的统计计数文件 -i/--initial 初始化所有的覆盖率信息，作为基准数据 -o 生成处理后的文件 -r/--remove 移除不需要关注的覆盖率信息文件 -z 重置所有执行程序所产生的统计信息为0 4.2 生成步骤 以Version_A/hello_world.cpp为例： g++ -fprofile-arcs -ftest-coverage hello_world.cpp -o hello_world 生成hello_world 和 hello_world.gcno 编译时候加两个参数：-fprofile-arcs -ftest-coverage, 此时会生成： hello_world.gcno ./hello_world 生成 hello_world.gcda gcov hello_world.cpp 生成 hello_world.cpp.gcov，是代码覆盖信息，但看起来并不直观 123456789101112-: 0:Source:hello_world.cpp-: 0:Graph:hello_world.gcno-: 0:Data:hello_world.gcda-: 0:Runs:1-: 0:Programs:1-: 1:#include&lt;stdio.h&gt;-: 2:1: 3:int main()-: 4:&#123;1: 5: printf(\"hello world\");1: 6: return 0;-: 7:&#125; lcov -d . -t 'hello world' -o 'hello_world.info' -b . -c (注意：如果提示lcov命令找不到，则使用lcov的绝对路径) 1/drives/e/lcov/bin/lcov -d . -t 'hello world' -o 'hello_world.info' -b . -c 借助lcov对hello_world.cpp.gcov进行改造，可以看见生成了hello_world.info： 123456789101112TN:hello_worldSF:/drives/e/10 temp/C++_project/Version_A/hello_world.cppFN:3,mainFNDA:1,mainDA:3,1DA:5,1DA:6,1FNF:1FNH:1LF:3LH:3end_of_record genhtml -o result hello_world.info (注意：如果提示genhtml命令找不到，则使用genhtml的绝对路径) 1234567891011$ /drives/e/lcov/bin/genhtml -o result hello_world.infoReading data file hello_world.infoFound 1 entries.Found common filename prefix \"/drives/e/10 temp/C++_project\"Writing .css and .png files.Generating output.Processing file Version_A/hello_world.cppWriting directory view page.Overall coverage rate: lines......: 100.0% (3 of 3 lines) functions..: 100.0% (1 of 1 function) 生成了result文件夹，借助web服务器，结果直观 用浏览器打开index.html： 5 增量覆盖率报告 以Version_A 和 Version_B 为例： 5.1 使用diff命令生成文件差异列表 1diff -r -N -x \".git\" -x \"*.gcov\" -u &lt;old_src_path&gt; &lt;new_src_path&gt; &gt; diff.txt 其中&lt;old_src_path&gt;是Version_A 版本代码路径、&lt;new_src_path&gt;是Version_B 版本代码路径，生成的diff.txt中包含的就是Version_B 相比Version_A的增量代码 所以执行命令： 1diff -r -N -x \"*.gc*\" -x \"*.exe\" -x \"result\" -u ./Version_A ./Version_B &gt; diff.txt diff.txt中的内容： 1234567891011121314151617181920--- ./Version_A/hello_world.cpp+++ ./Version_B/hello_world.cpp@@ -1,7 +1,17 @@ #include&lt;stdio.h&gt; +void func()+&#123;+ if (true) &#123;+ printf(&quot;func true&quot;);+ &#125; else &#123;+ printf(&quot;func false&quot;);+ &#125;+&#125;+ int main() &#123; printf(&quot;hello world&quot;);+ func(); return 0; &#125; 5.2 使用addlcov生成增量代码覆盖率文件 1addlcov --diff &lt;full_cov_file&gt; diff.txt -o &lt;add_cov_file&gt; --strip &lt;depth&gt; --path &lt;new_src_path&gt; 其中&lt;full_cov_file&gt;为之前统计的Version_B版本上的全量覆盖率；&lt;add_cov_file&gt;为输出的增量覆盖率info文件；&lt;depth&gt;是要截取的代码深度；&lt;new_src_path&gt;是Version_B版本源码 这里的&lt;depth&gt;再做一下解释：源码路径一般比较长，假设我们源码路径是a/b/c/d/e，这里的depth取值3则后续生成报告的根目录就是d了，前面三级就被屏蔽掉了。 所以执行命令： 12345cur_version_dir=\"/drives/e/10 temp/C++_project/Version_B\"depth=$(echo $&#123;cur_version_dir&#125; | sed -e 's/\\/*$//g' | awk -F\"/\" '&#123;print NF&#125;')./addlcov --diff ./Version_B/hello_world.info diff.txt -o addhello_world.info --strip $&#123;depth&#125; --path ./Version_B 出现报错：(单文件出现下述问题，多文件无问题) 123456789BReading tracefile ./Version_B/hello_world.infoReading diff diff.txtRemoving /drives/e/10 temp/C++_project/Version_B/hello_world.cpp1 entry converted, 0 entries left unchanged.Writing data to addhello_world.infoSummary coverage rate: lines......: no data found functions..: no data found branches...: no data found 解决：--path后面的&lt;new_src_path&gt;路径要使用绝对路径 1234567891011$ ./addlcov --diff ./Version_B/hello_world.info diff.txt -o addhello_world.info --strip $&#123;depth&#125; --path \"/drives/e/10 temp/C++_project/Version_B\"Reading tracefile ./Version_B/hello_world.infoReading diff diff.txtConverting /drives/e/10 temp/C++_project/Version_B/hello_world.cpp1 entry converted, 0 entries left unchanged.Writing data to addhello_world.infoSummary coverage rate: lines......: 100.0% (4 of 4 lines) functions..: 100.0% (2 of 2 functions) branches...: no data found 5.3 使用genhtml生成html格式的覆盖率报告 1genhtml -o &lt;report_dir&gt; &lt;add_cov_file&gt; 其中&lt;report_dir&gt;是想要生成的报告路径名称，&lt;add_cov_file&gt;是通过上一步生成的覆盖率文件 所以执行指令： 1genhtml -o addresult addhello_world.info X 参考 代码覆盖工具(gcov、lcov)的使用 关于代码覆盖lcov的使用 使用gcov生成增量覆盖率报告","categories":[{"name":"C++","slug":"C","permalink":"https://dragonliu2022.github.io/categories/C/"}],"tags":[]},{"title":"C++单元测试","slug":"C++单元测试","date":"2021-09-27T01:44:22.000Z","updated":"2022-04-18T09:54:33.007Z","comments":true,"path":"2021/09/27/C++单元测试/","link":"","permalink":"https://dragonliu2022.github.io/2021/09/27/C++单元测试/","excerpt":"","text":"0 情景导入 在实习时，用到了C++中的单元测试，整理一下。分别在Windows和子系统（Ubuntu）中安装配置。 1 安装googletest 1.1 环境配置 下载gtest：git clone https://github.com/google/googletest.git 安装cmake： CMake 是一个开源的跨平台的自动化构建系统，主要用于 C++ 的工程构建、测试以及打包等自动化操作。它能根据开发者编写的 CMakeLists.txt 规则文件，在不同的平台输出所需要的工程文件，然后开发者可以按照常见的构建方式使用生成的工程文件编译最终的程序。 CMake 是 Cross platform Make 的缩写，虽然名字中含有“make”，但是 CMake 和 Linux 上常见的 make 系统有所区别，是更上一层的构建系统。 Windows：首先打开 CMake 官方网站，在下载页面选择 Windows win64-x64 Installer 下载并安装 Ubuntu：apt-get install cmake windows配置clion编译环境：Window10上CLion极简配置教程 1.2 编译gtest库 使用clion打开googletest代码目录，选择gtest项目编译生成： 显示下面的信息表明编译成功（显示Error running，不用管他），生成的libgtestd.a即为gtest的库文件，项目中引用这个库文件就能使用gtest了。 2 使用googletest 2.1 引入库 新建测试项目cliontest，将libgtestd.a文件拷贝到该代码根路径的lib路径下，在CMakeList.txt中加上以下内容： 123456# 添加上库文件的路径，注意相对路径link_directories(lib/)# 添加可执行文件add_executable(cliontest main.cpp)# 链接gtest库文件target_link_libraries(cliontest libgtestd.a) 2.2 引入头文件 拷贝googletest/include下的gtest目录到项目下的include目录下，然后在CMakeList.txt中添加上对应的调用： 123include_directories( include/) 然后在代码中添加头文件gtest/gtest.h就可以使用了。 2.3 测试 修改main.cpp并运行： 12345678910111213141516171819202122#include \"gtest/gtest.h\" int add(int a, int b) &#123; return a + b;&#125; TEST(add, zero) &#123; EXPECT_EQ(0, add(0, 0));&#125; TEST(add, positive_number) &#123; EXPECT_EQ(3, add(1, 2));&#125; TEST(add, negative_number) &#123; EXPECT_EQ(-3, add(-1, -2));&#125; int main() &#123; ::testing::InitGoogleTest(); return RUN_ALL_TESTS();&#125; 3 gtest的使用教程 参考文档：Googletest Primer，google官方出品。 https://www.dyxmq.cn/program/usage-of-googletest.html 4 参考 CMake 安装指南","categories":[{"name":"C++","slug":"C","permalink":"https://dragonliu2022.github.io/categories/C/"}],"tags":[]},{"title":"基于SR的全量/增量覆盖率统计","slug":"基于SR的全量增量覆盖率统计","date":"2021-09-27T01:44:22.000Z","updated":"2022-04-18T11:34:08.060Z","comments":true,"path":"2021/09/27/基于SR的全量增量覆盖率统计/","link":"","permalink":"https://dragonliu2022.github.io/2021/09/27/基于SR的全量增量覆盖率统计/","excerpt":"","text":"1 情景导入 2021.09.26华为实习任务复现，要求实现基于SR的全量/增量覆盖率统计。 源代码：https://gitee.com/dragon-liu/RB_01 2 部门现状 当前的代码覆盖率只能基于整个代码库进行统计，无法便捷跟踪每个需求引起的覆盖率变化，版本管理成本很高。 方案：基于SR的全量/增量覆盖率统计 其次，脚本使用Perl语言编写，晦涩难懂，没有维护人员。 编程语言：Shell + Python 3 解决方案 通过git跟踪不同需求引入的代码变更 基于变更代码生成差异文件：强行cherry-pick 无冲突，直接做全量/增量分析，结果是准确的 有冲突需，自己获取差异代码行，结果是近似的 根据SR获取commit id列表 以最后一笔提交为标准 倒序遍历commit id，找出每次提交的代码行（倒序的原因：一般的，越新的commit对当前代码库影响越大） 利用lcov以及addlcov生成对应需求的全量/增量覆盖率报告 通过genhtml工具和python工程库生成html报告 借助Jenkins定时运行脚本与发送邮件 4 Jenkins使用 4.1 Ubuntu20安装Jenkins 如何在 Ubuntu 20.04 上安装 Jenkins Ubuntu环境下Jenkins安装、卸载、配置 4.2 配置构建任务 Jenkins配置git仓库 Jenkins 之插件 Publish HTML reports 的使用 4.3 邮件发送 jenkins构建后邮件发送 jenkins构建邮件自动发送，测试邮件发送成功，构建项目邮件发送不成功的问题 jenkins构建任务后发送邮件 jenkins发送邮件失败“No emails were triggered” 本地复现使用的Jenkins自带的邮件提醒功能；华为实习过程中，自己编写脚本进行邮件提醒。 具体实现详见 博客：Jenkins配置定时发送邮件功能 关于报错 12###强制回滚到某版本git reset --hard 36409abd22dcc9f9252152b34fa9e929f7c883ec 123###解决：https://stackoverflow.com/questions/3411048/unexpected-operator-in-shell-programming/3411061./srCover.sh: 17: [: h: unexpected operator ./srCover.sh: 21: [: h: unexpected operator","categories":[{"name":"C++","slug":"C","permalink":"https://dragonliu2022.github.io/categories/C/"},{"name":"环境与工具","slug":"环境与工具","permalink":"https://dragonliu2022.github.io/categories/环境与工具/"}],"tags":[]},{"title":"Python-全局变量-list","slug":"Python-全局变量-list","date":"2021-06-27T01:44:22.000Z","updated":"2022-04-18T11:25:05.076Z","comments":true,"path":"2021/06/27/Python-全局变量-list/","link":"","permalink":"https://dragonliu2022.github.io/2021/06/27/Python-全局变量-list/","excerpt":"","text":"1 List python中list作为全局变量无需global声明的原因： https://www.cnblogs.com/yym2013/p/5915980.html python中list变量作为全局变量时，在函数中可以直接修改。 而普通变量则需要先在函数中global声明，否则会报错。 例如： 12345678a = 1def fun(): global a a = 2 b = [1,2]def fun(): b[0] = 2 在函数中直接修改list则是可以的。 原因是： 普通变量如果在函数中赋值 a = 2 会有歧义。因为它既可以是表示引用全局变量a，也可以是创建一个新的局部变量，所以在python中，默认它的行为是创建局部变量，除非显式声明global。 而对列表list变量进行赋值 b[0] = 2 则不会有歧义。它是“明确的”，因为如果把b当作是局部变量的话，它会报KeyError，所以它只能是引用全局的b,故不需要多此一举显式声明global。","categories":[{"name":"Python","slug":"Python","permalink":"https://dragonliu2022.github.io/categories/Python/"}],"tags":[]}],"categories":[{"name":"Python","slug":"Python","permalink":"https://dragonliu2022.github.io/categories/Python/"},{"name":"环境与工具","slug":"环境与工具","permalink":"https://dragonliu2022.github.io/categories/环境与工具/"},{"name":"数据库","slug":"数据库","permalink":"https://dragonliu2022.github.io/categories/数据库/"},{"name":"C++","slug":"C","permalink":"https://dragonliu2022.github.io/categories/C/"},{"name":"未分类","slug":"未分类","permalink":"https://dragonliu2022.github.io/categories/未分类/"},{"name":"前端","slug":"前端","permalink":"https://dragonliu2022.github.io/categories/前端/"},{"name":"Java","slug":"Java","permalink":"https://dragonliu2022.github.io/categories/Java/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://dragonliu2022.github.io/tags/Git/"},{"name":"MySQL","slug":"MySQL","permalink":"https://dragonliu2022.github.io/tags/MySQL/"},{"name":"面试","slug":"面试","permalink":"https://dragonliu2022.github.io/tags/面试/"},{"name":"重构","slug":"重构","permalink":"https://dragonliu2022.github.io/tags/重构/"},{"name":"待补充","slug":"待补充","permalink":"https://dragonliu2022.github.io/tags/待补充/"},{"name":"Element","slug":"Element","permalink":"https://dragonliu2022.github.io/tags/Element/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://dragonliu2022.github.io/tags/Spring-Boot/"},{"name":"Vue","slug":"Vue","permalink":"https://dragonliu2022.github.io/tags/Vue/"},{"name":"Redis","slug":"Redis","permalink":"https://dragonliu2022.github.io/tags/Redis/"},{"name":"neo4j","slug":"neo4j","permalink":"https://dragonliu2022.github.io/tags/neo4j/"}]}