{"meta":{"title":"Dragon Liu","subtitle":null,"description":null,"author":"Dragon Liu","url":"https://Dragonliu2018.github.io","root":"/"},"pages":[{"title":"看板","date":"2022-02-12T03:15:29.536Z","updated":"2022-02-12T03:15:29.536Z","comments":false,"path":"about/index.html","permalink":"https://Dragonliu2018.github.io/about/index.html","excerpt":"","text":"1 分工 1.0 图床 使用Github+jsdelivr+PicGo或SM.MS+PicGo 本地文件夹：E:\\01 Blog_work\\Images 图片命名为id.png，id从1开始递增 文章引用： 1&lt;img src=\"xxx\" width = \"300\" height = \"300\" alt=\"图片名称\" align=center id=xx /&gt; 1.1 Hexo Blog 负责一些生活和黑科技板块 目录名称 简介 手机端 标签 来源 安全 热点标签是热点事件或技术复现 - Web、Crypto、Pwn、Misc、热点 CSDN、阮一峰、安全客、 开发 热点标签是热点事件或技术复现 - C++、C、python、Java、热点 - 环境与工具 环境搭建和工具使用等内容 - Hexo - 折腾 暂时未进行分类的内容 - 区块链、CV - 阅读 阅读App读书与做笔记，读完一本书进行书评 阅读、备忘录-摘抄 书评、摘抄、诗词 阅读APP、豆瓣、有画说艺、其他 音乐 - - - Apple Music、QQ、网易云、豆瓣 旅行 - 相册-相簿 - - 影视 - 备忘录-影视 电影、纪录片、电视剧 豆瓣 百科 杂七杂八，后期可能以其中的tag分类 - 科普、文化、历史、时评、财经 - 英语 该部分待定 - - - 1.2 Github &amp; Gitee 负责一些成模块的板块，同步更新到Github及Gitee 板块名称 简介 本地 Github Gitee 年终总结 该部分比较隐私，只在电脑本地 - - - 面经（Interview） 整理面经部分，一些热点面试问题 E:\\04 Worker_work\\01 实习\\面经\\Interview 跳转 跳转 算法（Algorithm） 根据每天leetcode进行整理算法 E:\\08 Algorithm\\Algorithm 跳转 跳转 CTF 一些比赛的WP，复现一些题目 E:\\02 Competition\\01 CTF\\CTF 跳转 跳转 漏洞（Vulnerability） 漏洞复现与发现 E:\\06 Scientific_research\\01漏洞\\Vulnerability 跳转 跳转 论文 待整理 - - - 其他项目 E:\\05 Code或Hexo Blog-项目 - - 1.3 Notion 负责一些零散的板块 项目开发记录 党务工作 毕业设计 2 windows使用技巧 滴答清单：记录近期任务 截图：Snipaste 录屏：FastStone Capture 粘贴增强：Ditto 文件搜索、快速启动程序：火萤酱（火柴） PDF：阅读——Foxit PDF Reader；编辑——PDFelement MarkDown编写：Typoa 翻译：网易有道词典 Python开发：Pycharm 通用语言开发：VSCode Git：TortoiseGit 文件(夹)差异比较：Beyond Compare 虚拟机：VMware 科学上网：Clash 浏览器：Chrome 拓展管理：扩展管理器（Extension Manager） 广告拦截：AdGuard 广告拦截器、uBlock Origin、过滤广告 為 Youtube™ 运行用户脚本：Tampermonkey 冻结标签页：The Great Suspender Original 音乐播放器：Listen 1 油管弹幕：Bulletchat for YouTube 内存使用量、CPU温度等：鲁大师 思维导图：XMind 远程登录：xshell，文件传输——xftp Linux子系统：wsl2+docker系统定制+Terminus+zsh+oh-my-zsh 文字识别：天若ocr文字识别 论文写作：VSCode + Latex + SumatraPDF(小屏幕时使用) 链接 3 iphone使用技巧 1.1 电池健康 开启最佳化电池充电模式 不必要时避免使用快充 注意手机温度和环境温度 随手充电（40%~80%） 1.2 本机技巧类 1.2.1 辅助功能 触控-》轻点背面：两下截屏，三下开手电筒 1.2.2 相册 隐藏照片 截屏类图片单列（可以方便删除） 1.2.3 备忘录 输入数字时，长按123拖拽对应数字，不需要切换输入法 双击文字选中一个单词，三击选中一句话 三指向左边划（或摇晃iphone）：撤销当前操作； 三指向右边划（或摇晃iphone）：恢复之前操作； 三指向中间靠拢：拷贝选中内容 三指向对角线分散：粘贴 1.2.4 控制中心 听歌识曲：添加识曲功能：（针对欧美，一些中文小众或xx平台热曲识别不了，可以识别后台歌曲） 低电量模式 1.2.5 隐私保护 设置-》隐私-》跟踪-》关掉 设置-》隐私-》定位服务-》系统服务-》根据情况勾选（状态栏图标勾选） 设置-》隐私-》分析与改进关掉 设置-》隐私-》Apple广告关掉 设置-》隐私-》记录APP活动打开 1.2.6 云备份 设置-》Apple ID账户-》iCloud-》iCloud云备份-》通过蜂窝网络备份关闭（没找到） 设置-》蜂窝网络-》iCloud云备份关闭（没找到） 1.2.7 后台APP刷新 无线局域网或关闭 1.2.x 其他 双指选定文件 1.3 软件类 1.3.1 widgy 小组件，导入下面已经设计好的 1.4 科学上网 1.4.1 申请美区Apple ID https://www.youtube.com/watch?v=qQP1DAgiVn4 1.4.2 vpn软件 夏时国际"},{"title":"光影流年","date":"2019-09-13T08:56:36.000Z","updated":"2021-02-26T09:56:36.000Z","comments":true,"path":"gallery/index.html","permalink":"https://Dragonliu2018.github.io/gallery/index.html","excerpt":"","text":"12"},{"title":"分类","date":"2022-01-20T08:24:01.513Z","updated":"2022-01-20T06:59:05.762Z","comments":false,"path":"categories/index.html","permalink":"https://Dragonliu2018.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-09-13T08:58:45.000Z","updated":"2021-02-23T13:00:44.000Z","comments":true,"path":"link/index.html","permalink":"https://Dragonliu2018.github.io/link/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-01-20T06:59:05.763Z","updated":"2022-01-20T06:59:05.763Z","comments":false,"path":"tags/index.html","permalink":"https://Dragonliu2018.github.io/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-01-20T06:59:05.762Z","updated":"2022-01-20T06:59:05.762Z","comments":false,"path":"repository/index.html","permalink":"https://Dragonliu2018.github.io/repository/index.html","excerpt":"","text":""},{"title":"那些年，听过的音乐","date":"2022-01-24T13:08:47.234Z","updated":"2022-01-24T13:08:47.234Z","comments":true,"path":"music/index.html","permalink":"https://Dragonliu2018.github.io/music/index.html","excerpt":"","text":"123&#123;% meting &quot;7429975963&quot; &quot;tencent&quot; &quot;playlist&quot; %&#125;&#123;% douban music 30121600 %&#125;"},{"title":"主题更新日志","date":"2019-09-13T08:58:45.000Z","updated":"2021-02-26T13:34:46.000Z","comments":true,"path":"theme/index.html","permalink":"https://Dragonliu2018.github.io/theme/index.html","excerpt":"","text":"本站当前主题使用的是Hexo Butterfly TODO 博客相册页面 2021 年 02 月 2月23日： 添加菜单-主题 更改首页图片：点击查看 2月26日 解决博客加密文章本地测试通过，提交到GitHub后未通过问题，访问 https://dragonliu.tk 即可。参考：hexo-blog-encrypt 在 http 环境下无法使用的原因分析 文章加密部分使用 sweetalert 来美化错误提示。参考"}],"posts":[{"title":"《能人》书籍","slug":"《能人》书籍","date":"2022-02-12T05:25:48.000Z","updated":"2022-02-12T06:37:13.313Z","comments":true,"path":"2022/02/12/《能人》书籍/","link":"","permalink":"https://Dragonliu2018.github.io/2022/02/12/《能人》书籍/","excerpt":"","text":"1 简介 天津是个码头，码头上的人争强好胜，自然是谁有本事佩服谁。这种心理衍及社会各行各业，都是钦佩能人。所谓能人是真有本事的人，技高一筹的人，身怀绝技的人。 大回、酒婆、甄一口、管万斤、李铁柱、卓乃丽……这些人中既有显耀上层，更有市井小民，既能空手拿贼，又能平地抠饼，性格又辣又热，又爽又嘎，行事出人意表却又坚持着自己的道义，令人称奇叫绝，钦佩不已。 冯骥才执笔50年白金纪念版经典小说集《能人》，从清末民初到改革开放，有奇人异事，也有生活纪实，或幽默诙谐，或讽刺批判，或感怀过往，或温馨治愈，全面呈现天津卫近百位奇人异士的生活风貌和传奇人生，被读者誉为一幅“天津卫的清明上河图”。 2 作者 冯骥才，浙江宁波慈溪人，1942年2月9日生于天津，作家、画家。 早年在天津从事绘画工作，后专职文学创作和民间文化研究。 百度百科 维基百科 3 摘抄 人生中有许多问题是永远也解不开的方程式。 *** 有人说，从一个人身边的书，可以找到通往他心底最绝妙的缝隙。 *** 在人们的闲话里，大概没有一个完美的人，总是更坏一些，而不是更好一些。弱者会在闲话里畏首畏尾，最后被搞得神经衰弱。 —— 引自 在两个问号之间 你家院里有棵小树，树干光溜溜，早瞧惯了，可是有一天它忽然变得七扭八弯，愈看愈别扭。但日子一久，你就看顺眼了，仿佛它本来就应该是这样子。如果某一天，它忽然重新变直，你又会觉得说不出多么不舒服。它单调、乏味、简易，像根棍子！其实，它不过恢复最初的模样，你何以又别扭起来？ 人们总是按照自己的思维方式去解释世界，尽力把一切事物都和自己的理解力拉平。 这时，人们有种奇妙的感觉，觉得那伞下好像有长长一大块空间，空空的，世界上任什么东西也填补不上。 —— 引自 高女人和她的矮丈夫 这女子在杭州上大学，念中文，喜欢文学的女子都很看重人的心意。而真正的爱慕，往往是从对方身上感触到自己人生理想的准则开始的。还有比关水龙头再小的事吗？但对于这念文科的女子，它就像一束细细的光照亮一个世界。有了这样的来自心灵的因由，胡子就不会是任何障碍了。 —— 引自 胡子 有时这小天地的佼佼者，也会有君主、国王那样的自我富足感。 —— 引自 金色的眼镜腿儿 一 个人总会由于自己的某种缺陷或不足而羡慕别人。脸黑的羨慕脸白的；记性差的羡慕记性好的；牙齿糟烂的，羡慕别人的一口好牙；手笨的，羡慕人家心灵手巧；老年人羡慕青年人精力有余。 活人的悲剧比舞台上的悲剧，更能满足一个人的好奇心。 —— 引自 陌客 世界上，无论好事坏事、大事小事总得过去。新鲜的玩意儿刚到手如获至宝，看惯了也就习以为常。 —— 引自 匈牙利脚踏车 每个人都有自己童年和少年时代的朋友，好像朝日曙照、云霞、露珠一样，总是属于那一段时光里同时出现的，互相为伴，汇成片灿烂缤纷的景象，过后就纷纷散失了。 那时，世道狂乱，人人失去常恋，宁肯无知，宁愿心很，还有许多出奇的妄想，恨不得从身旁发现出希特勒。 我第一次感受到，一个人把话存在心里，他才是充实的。 —— 引自 在早春的日子里 我接过油毡时，你并没有客气或感谢地笑一笑。你用你黑黑的眼睛专注地望我一眼，这眼好深。你不是用眼，是用心灵望我。那时谁还会用全部心灵望一个陌生人，像人望大自然那样，无戒备的，感受的。后来我发现你也用这样的目光望一切。可是当你望我时，世界忽然变得一尘不染。 男人对女人就该有保护意识。女人乐不乐意接受是另一码事。要不怎么证实自己的性别，还称什么男子汉 你们只想叫我坐稳，把你们碰到的一个个难题提给我。我高兴用我的机智把这些问号打碎，还有些问号你们明知道我也没辙，却喜欢看我拿笑话把它扭得变形，不再像问号，好玩。 —— 引自 船歌 4 自评 从《俗世奇人》过来的。 书籍前半部分收录《俗世奇人》的文章，后半部分内容是新中国的事，风格也发生了变化，不再是“奇人”、“能人”，更多的是讽刺现实。 其中《船歌》第一次读直接略过了，后来整理博客、翻阅书评时，才又读了一遍，感觉唯美浪漫。只能说书籍后半部分需要静下心来仔细品味，不能像读《俗世奇人》那般。 5 他评 书名能人二字指得是书里的前13个短篇，都是民国年间天津卫的奇闻轶事。码头文化滋养之下，天津人性格有股子英雄主义情结，不畏强权不畏财富，做事讲究个狠字，不论是戏曲、武行、生意或是官场，能耐大过天。不过在沧海横流的世道，生死转瞬间，也应了那句话“能人都死在了能耐之下”。感叹作者笔力了的，急促紧凑地叙事，一把薅住人物特点，再寥寥几笔故事冲突和张力陡然凝聚，读着真过瘾。后半部分就是小人物众生相，《我这个笨蛋》中为换个大房子而走后门时，反复吃暗亏的窝囊小职员，《在两个问号之间》里斥责插队政策是下乡知青与农民不睦婚姻的黑手，背后的精神世界鸿沟无法弥合。还有《金色眼镜腿》《匈牙利脚踏车》《两医生》呈现知识分子在官僚和腐败体系下内心的价值观冲撞，一种愤恨情绪宣发。整体文本是老派的，规矩雅致，没有无聊的炫技。 —— 引自 豆瓣 大脸 这本书的策划方向错了，或者说故意错，往《俗世奇人》的方向上靠。收录了几篇《奇人》里的故事，但后面的故事跟“奇人”“能人”都没关系了。反倒是婚姻、情感故事居多，往这个方向策划，没准儿更好。《看一眼》《船歌》《在早春的日子》这几篇更喜欢，很浪漫。 —— 引自 豆瓣 鹿原 读《能人》有感 318分钟，读完了今年的第一本电子书。事实上，这也是今年第一本兴趣使然读完的书。 读这本书的前半程，就像初冬时节，在喧嚣的天津码头揣兜儿晃荡，路过酒肆，穿过大集，看那各路能人轮番登场，热闹非凡。泥人张，酒婆，管万金，冯五爷…任你在天津的地界儿忘记时间，比起什么生活的真谛，人生的意义，这浓烈的烟火气就是舒坦。 后半程的故事一样精彩生动，后劲儿更足，更深刻。读完总要让你回过味儿再想一想，琢磨琢磨。读完《两个问号之间》，连续好几天做饭的时候，我都在纠结要怎么给卓乃丽写封信，看完《今天接着昨天》，觉着又感动，又刺痛。最后一篇《老夫老妻》读的我紧张又着急，又不舍得往后面翻。 书里的小故事个个儿精彩万分，读这本书的感觉就像有一壶热腾腾的烧酒，却不敢贪杯。茶余饭后看看书，读读故事，兴致盎然，尽是风景。 —— 引自 豆瓣 小胡同学 6 拓展 是否被拍成影视作品？（无）","categories":[{"name":"阅读","slug":"阅读","permalink":"https://Dragonliu2018.github.io/categories/阅读/"}],"tags":[{"name":"书评","slug":"书评","permalink":"https://Dragonliu2018.github.io/tags/书评/"}]},{"title":"Python取整","slug":"Python取整","date":"2022-02-11T08:25:36.000Z","updated":"2022-02-11T15:59:12.010Z","comments":true,"path":"2022/02/11/Python取整/","link":"","permalink":"https://Dragonliu2018.github.io/2022/02/11/Python取整/","excerpt":"","text":"1 向下取整——int() 1234f1 = 1.23print(int(f1)) # 1f2 = 1.73print(int(f2)) # 1 2 向上取整——ceil() 123456import mathf1 = 1.23print(math.ceil(f1)) # 2f2 = 1.73print(math.ceil(f2)) # 2 3 四舍五入——round() 1234f1 = 1.23print(round(f1)) # 1f2 = 1.73print(round(f2)) # 2 4 分别取整数和小数部分 12f1 = 1.23print(math.modf(f1)) # (0.22999999999999998, 1.0) 至于小数部分不准确：涉及浮点数在计算机中的表示。在计算机中是无法精确的表示小数的，至少目前的计算机做不到这一点。Python 和 C 一样, 采用 IEEE 754 规范来存储浮点数。 X 参考 python中取整数的四种方法","categories":[{"name":"开发","slug":"开发","permalink":"https://Dragonliu2018.github.io/categories/开发/"}],"tags":[{"name":"python","slug":"python","permalink":"https://Dragonliu2018.github.io/tags/python/"}]},{"title":"Python中的类(class)","slug":"Python中的类-class","date":"2022-02-11T06:07:06.000Z","updated":"2022-02-11T14:16:18.654Z","comments":true,"path":"2022/02/11/Python中的类-class/","link":"","permalink":"https://Dragonliu2018.github.io/2022/02/11/Python中的类-class/","excerpt":"","text":"1 模板 1234567891011121314151617class Action(object): # 类属性 is_fail = False def __init__(self, sid, fid): self.id = sid # 唯一标志信息 self.fid = fid # 父进程唯一标志信息 def get_id(self): return self.id def get_fid(self): return self.fidtest_action = Action(sid=sid, fid=fid)print(test_action.get_id())print(Action.is_fail) 更多参考：菜鸟教程","categories":[{"name":"开发","slug":"开发","permalink":"https://Dragonliu2018.github.io/categories/开发/"}],"tags":[{"name":"python","slug":"python","permalink":"https://Dragonliu2018.github.io/tags/python/"}]},{"title":"Python多线程、多进程编程","slug":"Python多线程、多进程编程","date":"2022-02-11T06:05:20.000Z","updated":"2022-02-11T08:26:19.112Z","comments":true,"path":"2022/02/11/Python多线程、多进程编程/","link":"","permalink":"https://Dragonliu2018.github.io/2022/02/11/Python多线程、多进程编程/","excerpt":"","text":"1 引言 最近在做恶意样本行为可视化，样本数量2w+，执行时间&gt;24h，所以需要多任务处理来提高效率。 参考：Python多进程和多线程（跑满CPU） 任务可以理解为进程（process），如打开一个word就是启动一个word进程。在一个word进程之中不只是进行打字输入，还需要拼写检查、打印等子任务，我们可以把进程中的这些子任务称为线程（thread）。 同时执行多个任务通常各个任务之间并不是没有关联的，而是需要相互通信和协调，有时，任务1必须暂停等待任务2完成后才能继续执行，有时，任务3和任务4又不能同时执行，所以，多进程和多线程的程序的复杂度要远远高于我们前面写的单进程单线程的程序。 2 多任务实现的3种方式 2.1 多进程模式 启动多个进程，每个进程虽然只有一个线程，但多个进程可以一块执行多个任务。多个CPU核心可以一起做多个任务。 进程执行带有参数的任务： 参数名 说明 args 以元祖的方式给任务传递参数, 顺序要正确 kwrags 以字典的方式给执行任务传递参数, key 跟参数名要一致 12345678910111213141516171819202122232425import multiprocessingimport timeimport osimport mathdef func(data): print(data, '进程PID', os.getpid()) print(data, '进程父进程编号', os.getppid()) for i in data: time.sleep(0.5)def test_multiprocess(): data_list = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10] core = 4 # 4进程并行 mod = math.ceil(len(data_list) / 4) # 向上取整 group_data = [data_list[i:i + mod] for i in range(0, len(data_list), mod)] for data in group_data: # process = multiprocessing.Process(target=func, args=(5,)) process = multiprocessing.Process(target=func, kwargs=&#123;'data': data&#125;) process.start()if __name__ == '__main__': test_multiprocess() 2.2 多线程模式 启动一个进程，在一个进程内启动多个线程，这样，多个线程也可以一块执行多个任务。单个CPU核心可以同时做多个任务。 菜鸟教程——多线程 2.3 多进程+多线程模式 启动多个进程，每个进程再启动多个线程，这样同时执行的任务就更多了，当然这种模型更复杂，实际很少采用。 3 进程线程对比 3.1 关系对比 线程是依附在进程里边的, 没有进程就没有线程 一个进程默认提供一条线程, 进程可以创建多个线程 3.2 区别对比 进程创建的开销要比线程的开销要大 进程是操作系统资源分配的基本单位, 线程是cpu 调度的基本单位 线程不能独立执行, 必须依存进程 3.3 优缺点对比 进程优缺点: 优点：可以用多核 缺点：资源开销大 线程优缺点 优点: 资源开销小 缺点：不能使用多核 X 参考 在Python中优雅地用多进程 python多进程多线程,多个程序同时运行","categories":[{"name":"开发","slug":"开发","permalink":"https://Dragonliu2018.github.io/categories/开发/"}],"tags":[{"name":"python","slug":"python","permalink":"https://Dragonliu2018.github.io/tags/python/"}]},{"title":"Pycharm(IntelliJ系列)的Low Memory问题","slug":"Pycharm-IntelliJ-的Low-Memory问题","date":"2022-02-11T03:22:48.000Z","updated":"2022-02-11T03:39:29.635Z","comments":true,"path":"2022/02/11/Pycharm-IntelliJ-的Low-Memory问题/","link":"","permalink":"https://Dragonliu2018.github.io/2022/02/11/Pycharm-IntelliJ-的Low-Memory问题/","excerpt":"","text":"1 问题引入 最近在跑恶意样本可视化的脚本，Pycharm出现： 12Low MemoryThe IDE is running low on memory and this might affect performance. Please consider increasing available heap. 原因是IDE内存不足（之前给pycharm设定了2048M，跑大项目会出现上述问题）。 主要copy于 idea 的Low Memory问题 2 解决方法 下面的方法适用于IntelliJ系列产品，如Pycharm、idea等。 2.1 直接配置 选择上图里的 Configure，修改堆大小： 重启IDE生效。 2.2 通过help配置修改 菜单 Help -&gt; 选择 Edit Custom VM Options，会打开 pycharm64.exe.vmoptions文件，修改配置即可。 此时发现Change Memory Settings中已经发生了变化： 最后重启IDE生效。","categories":[{"name":"环境与工具","slug":"环境与工具","permalink":"https://Dragonliu2018.github.io/categories/环境与工具/"}],"tags":[{"name":"python","slug":"python","permalink":"https://Dragonliu2018.github.io/tags/python/"}]},{"title":"Python集合(set)操作","slug":"Python集合-set-操作","date":"2022-02-10T09:22:22.000Z","updated":"2022-02-10T10:24:27.248Z","comments":true,"path":"2022/02/10/Python集合-set-操作/","link":"","permalink":"https://Dragonliu2018.github.io/2022/02/10/Python集合-set-操作/","excerpt":"","text":"1 引言 集合（set）是一个无序的不重复元素序列。 主要copy于菜鸟教程 2 使用 2.1 创建 可以使用大括号 { } 或者 set() 函数创建集合： 1234567891011121314set1 = &#123;1, 2, 3&#125;print(set1) # &#123;1, 2, 3&#125;set2 = &#123;'pear', 'apple'&#125;print(set2) # &#123;'apple', 'pear'&#125;set3 = set(\"apple\")print(set3) # &#123;'l', 'p', 'e', 'a'&#125;set4 = set(&#123;'pear', 'apple'&#125;)print(set4) # &#123;'apple', 'pear'&#125;set5 = set(('pear', 'apple'))print(set5) # &#123;'pear', 'apple'&#125; 注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。 2.2 集合运算 1234567891011121314&gt;&gt;&gt; # 下面展示两个集合间的运算....&gt;&gt;&gt; a = set('abracadabra')&gt;&gt;&gt; b = set('alacazam')&gt;&gt;&gt; a &#123;'a', 'r', 'b', 'c', 'd'&#125;&gt;&gt;&gt; a - b # 集合a中包含而集合b中不包含的元素&#123;'r', 'd', 'b'&#125;&gt;&gt;&gt; a | b # 集合a或b中包含的所有元素&#123;'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'&#125;&gt;&gt;&gt; a &amp; b # 集合a和b中都包含了的元素&#123;'a', 'c'&#125;&gt;&gt;&gt; a ^ b # 不同时包含于a和b的元素&#123;'r', 'd', 'b', 'm', 'z', 'l'&#125; 2.3 基本操作 12345678910111213141516171819202122232425262728293031323334353637383940test_set = &#123;1, 2&#125;# 添加元素——add(x)##将元素 x 添加到集合 s 中，如果元素已存在，则不进行任何操作。test_set.add(2) # &#123;1, 2&#125;test_set.add(3) # &#123;1, 2, 3&#125;# 添加元素——update(x)##参数是列表，元组，字典等，int会报错##x 可以有多个，用逗号分开。test_set.update(4) # TypeError: 'int' object is not iterabletest_set.update(&#123;4, 5&#125;) # &#123;1, 2, 3, 4, 5&#125;test_set.update([4, 5], [5, 6]) # &#123;1, 2, 3, 4, 5, 6&#125;test_set.update((6, 7)) # &#123;1, 2, 3, 4, 5, 6, 7&#125;# 移除元素——remove(x)##将元素 x 从集合 s 中移除，如果元素不存在，则会发生错误。test_set.remove(8) # KeyError: 8test_set.remove(7) # &#123;1, 2, 3, 4, 5, 6&#125;# 移除元素——discard(x)##移除集合中的元素，且如果元素不存在，不会发生错误test_set.discard(7) # 不报错 &#123;1, 2, 3, 4, 5, 6&#125;test_set.discard(6) # &#123;1, 2, 3, 4, 5&#125;# 移除元素——pop()##随机删除集合中的一个元素##对集合进行无序的排列，然后将这个无序排列集合的左面第一个元素进行删除。test_set.pop() # &#123;2, 3, 4, 5&#125;# 计算元素个数——lenlen(test_set) # 4# 判断元素是否存在于集合中——inprint(2 in test_set) # Trueprint(1 in test_set) # Falseprint(1 not in test_set) # True# 清空集合——cleartest_set.clear()print(test_set) # set()","categories":[{"name":"开发","slug":"开发","permalink":"https://Dragonliu2018.github.io/categories/开发/"}],"tags":[{"name":"python","slug":"python","permalink":"https://Dragonliu2018.github.io/tags/python/"}]},{"title":"Windows下安装与使用neo4j","slug":"Windows下安装与使用neo4j","date":"2022-02-10T03:17:06.000Z","updated":"2022-02-11T14:06:51.560Z","comments":true,"path":"2022/02/10/Windows下安装与使用neo4j/","link":"","permalink":"https://Dragonliu2018.github.io/2022/02/10/Windows下安装与使用neo4j/","excerpt":"","text":"1 引言 最近在实现恶意样本行为可视化，使用 python模块graphviz使用教程 可以达到既定要求；但是图数据库neo4j理论上也是个不错的选择，所以整理下。 思路：安装Neo4j数据库，python语言使用py2neo库进行使用。 2 安装Neo4j 主要copy于 图数据库neo4j的安装与基本使用(一) 2.1 安装JDK Neo4j是基于Java的图形数据库，运行Neo4j需要启动JVM进程，因此必须安装JAVA SE的JDK。从Oracle官方网站下载 Java SE JDK，当前的版本是JDK8。java版本的高低决定了Neo4j的版本 2.2 安装Neo4j 官网下载最新版本Neo4j Neo4j应用程序有如下主要的目录结构： 1234bin目录：用于存储Neo4j的可执行程序；conf目录：用于控制Neo4j启动的配置文件；data目录：用于存储核心数据库文件；plugins目录：用于存储Neo4j的插件； 2.3 配置环境变量 创建主目录环境变量NEO4J_HOME，并把主目录设置为变量值。 2.4 启动neo4j 2.4.1 通过控制台启动Neo4j程序 打开cmd，切换到Neo4j主目录下的bin目录，运行下面命令即可： 1neo4j.bat console 用户名和密码默认为neo4j，首次登陆需要修改密码(Neo4j) java与neo4j版本不对应的报错： 123456789警告: ERROR! Neo4j cannot be started using java version 1.8.0_301警告: * Please use Oracle(R) Java(TM) 11, OpenJDK(TM) 11 to run Neo4j Server.* Please see https://neo4j.com/docs/ for Neo4j installation instructions.Invoke-Neo4j : This instance of Java is not supported所在位置 D:\\developer\\neo4j\\neo4j-community-4.4.3\\bin\\neo4j.ps1:21 字符: 7+ Exit (Invoke-Neo4j -Verbose:$Arguments.Verbose -CommandArgs $Argument ...+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : NotSpecified: (:) [Write-Error], WriteErrorException + FullyQualifiedErrorId : Microsoft.PowerShell.Commands.WriteErrorException,Invoke-Neo4j 当时我测试的版本(JDK8+Neo4j4.4.4)出现上面的报错，该换JDK8+Neo4j3.5.30后成功运行。 2.4.2 把Neo4j安装为服务（Windows Services） 请查阅 图数据库neo4j的安装与基本使用(一) 3 python使用 python通过调用py2neo 库实现对数据库的操作。 py2neo官网 py2neo——Neo4j&amp;python的配合使用 用Python中的py2neo库调用neo4j，搭建简单关联图谱 3.1 连接数据库 安装py2neo库：pip install py2neo 1234567from py2neo import Graphtest_graph = Graph( \"http://localhost:7474\", username=\"neo4j\", password=\"Neo4j\" #修改后的密码) 测试时出现报错： 1ValueError: The following settings are not supported: &#123;'username': 'neo4j'&#125; 因为py2neo版本问题，需要做出以下修改： 123from py2neo import Graphtest_graph = Graph(\"http://localhost:7474\", auth=(\"neo4j\", \"Neo4j\")) 详见 关于使用Py2neo连接Neo4j图数据库出现“ValueError: The following settings are not supported”报错的解决方案 3.2 基本操作 参考：py2neo在已有节点上批量创建关系 12345678910111213141516171819202122232425262728from py2neo import Graph, Node, Relationship, Subgraphtest_graph = Graph(\"http://localhost:7474\", auth=(\"neo4j\", \"Neo4j\"))# 删除数据库中以往的图，确保在一个空白的环境中进行操作test_graph.delete_all()# 创建顶点node_list = []node_list.append(Node(\"Teacher\", name=\"Alice\")) # label(type) name(显示值)node_list.append(Node(\"Student\", name=\"Bob\"))node_list.append(Node(\"Student\", name=\"Dragon\"))node_list.append(Node(\"Student\", name=\"Pig\"))##subgraph加快导入速度nodes = Subgraph(node_list)test_graph.create(nodes)# 创建边edge_list = []##找到对应节点node1 = test_graph.nodes.match(name=\"Alice\").first()node2 = test_graph.nodes.match(name=\"Bob\").first()edge_list.append(Relationship(node1, \"teach\", node2))node1 = test_graph.nodes.match(name=\"Alice\").first()node2 = test_graph.nodes.match(name=\"Dragon\").first()edge_list.append(Relationship(node1, \"teach\", node2))edges = Subgraph(relationships=edge_list)test_graph.create(edges) 效果图如下： 4 拓展——SPADE 当时参加A-ST竞赛时使用过，本次测试没进行。 Github-Spade X 参考","categories":[{"name":"环境与工具","slug":"环境与工具","permalink":"https://Dragonliu2018.github.io/categories/环境与工具/"}],"tags":[]},{"title":"python list分组","slug":"python-list分组","date":"2022-02-10T02:20:19.000Z","updated":"2022-02-10T02:54:04.495Z","comments":true,"path":"2022/02/10/python-list分组/","link":"","permalink":"https://Dragonliu2018.github.io/2022/02/10/python-list分组/","excerpt":"","text":"1 前言 最近在整python多线程，需要对文件列表进行分组，下面整理下有关list分组的内容。 2 分块 1234num = 3data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]group_data = [data[i:i + num] for i in range(0, len(data), num)]print(group_data) # [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10]] 3 groupby分组 123456789101112131415161718192021from itertools import groupbyuser_list = [ &#123;\"uid\": 1, \"sex\": \"男\", \"age\": 10&#125;, &#123;\"uid\": 3, \"sex\": \"男\", \"age\": 20&#125;, &#123;\"uid\": 4, \"sex\": \"女\", \"age\": 20&#125;, &#123;\"uid\": 4, \"sex\": \"女\", \"age\": 31&#125;, &#123;\"uid\": 2, \"sex\": \"男\", \"age\": 10&#125;]# 多字段排序user_sort = sorted(user_list, key=lambda x: (x[\"sex\"], x[\"age\"]))# 多字段分组user_group = groupby(user_sort, key=lambda x: (x[\"sex\"], x[\"age\"]))for key, group in user_group: print(key, list(group))\"\"\"('女', 20) [&#123;'uid': 4, 'sex': '女', 'age': 20&#125;]('女', 31) [&#123;'uid': 4, 'sex': '女', 'age': 31&#125;]('男', 10) [&#123;'uid': 1, 'sex': '男', 'age': 10&#125;, &#123;'uid': 2, 'sex': '男', 'age': 10&#125;]('男', 20) [&#123;'uid': 3, 'sex': '男', 'age': 20&#125;]\"\"\" 注意分组之前应先使用分组字段排好序。 X 参考 python list按规定的范围分组 Python list列表groupby分组用法","categories":[{"name":"开发","slug":"开发","permalink":"https://Dragonliu2018.github.io/categories/开发/"}],"tags":[{"name":"python","slug":"python","permalink":"https://Dragonliu2018.github.io/tags/python/"}]},{"title":"判断python dict或list 中是否含有某个元素或key","slug":"判断python-dict或list-中是否含有某个元素或key","date":"2022-02-09T14:49:35.000Z","updated":"2022-02-09T15:01:12.322Z","comments":true,"path":"2022/02/09/判断python-dict或list-中是否含有某个元素或key/","link":"","permalink":"https://Dragonliu2018.github.io/2022/02/09/判断python-dict或list-中是否含有某个元素或key/","excerpt":"","text":"1 自带函数has_key() 在python的字典的属性方法里面有一个has_key()方法，这个方法使用起来非常简单。 Python 3.x不再支持 has_key() 函数，而被__contains__()所替代。 123d = &#123;'name': &#123;&#125;, 'age': &#123;&#125;, 'sex': &#123;&#125;&#125;# print(d.has_key('name'))print(d.__contains__('name')) # True 2 in 方法 123456789# 字典是否含有keyd = &#123;'name': &#123;&#125;, 'age': &#123;&#125;, 'sex': &#123;&#125;&#125;print(\"name\" in d.keys()) # Trueprint(\"name\" not in d.keys()) # False# 列表是否含有valuel = ['name', 'age', 'sex']print(\"name\" in l) # Trueprint(\"name\" not in l) # False X 参考 判断python字典或者列表中是否包含某个元素或者key","categories":[{"name":"开发","slug":"开发","permalink":"https://Dragonliu2018.github.io/categories/开发/"}],"tags":[{"name":"python","slug":"python","permalink":"https://Dragonliu2018.github.io/tags/python/"}]},{"title":"python去除字符串首尾的指定字符","slug":"python去除字符串首尾的空格","date":"2022-02-09T14:43:17.000Z","updated":"2022-02-10T05:52:25.304Z","comments":true,"path":"2022/02/09/python去除字符串首尾的空格/","link":"","permalink":"https://Dragonliu2018.github.io/2022/02/09/python去除字符串首尾的空格/","excerpt":"","text":"1 前言 最近在用到防止字符串转义函数——repr，但是他生成的字符串首尾会自动加上单引号，详见博客，可以使用strip函数进行去除。 2 实践 123456789101112131415# strip不传参数默认去掉空格test_str = ' string '# 去掉首尾空格print(test_str.strip()) # string# 去掉首空格print(test_str.lstrip()) # string # 去掉尾空格print(test_str.rstrip()) # string# 指定字符str1 = \"123\\tabc\"str2 = repr(str1)print(str1) # 123 abcprint(str2) # '123\\tabc'print(str2.strip(\"\\'\")) # 123\\tabc","categories":[{"name":"开发","slug":"开发","permalink":"https://Dragonliu2018.github.io/categories/开发/"}],"tags":[{"name":"python","slug":"python","permalink":"https://Dragonliu2018.github.io/tags/python/"}]},{"title":"python处理表格","slug":"python处理表格","date":"2022-02-09T10:45:09.000Z","updated":"2022-02-09T13:39:03.805Z","comments":true,"path":"2022/02/09/python处理表格/","link":"","permalink":"https://Dragonliu2018.github.io/2022/02/09/python处理表格/","excerpt":"","text":"1 问题引入 今天实现恶意样本标签提取，用到了表格处理，下面进行整理。 python操作excel主要用到xlrd和xlwt这两个库，即xlrd是读excel，xlwt是写excel的库。这两个库使用pip进行安装。 2 Python写excel——xlwt 12345678910111213141516171819202122import xlwt# 导出表格def export_excel(output_file): fields = ['姓名', '年龄'] # 设置自己需要的Excel表头 book = xlwt.Workbook(encoding='utf-8') # 获取excel对象 sheet = book.add_sheet('人员信息表') # 设置excel的sheet名称 for col, field in enumerate(fields): # 写入excel表头 sheet.write(0, col, field) info_list = [['Dragon', 18], ['Pig', 21], ['Cat', 22]] row = 1 for name, age in info_list: # 根据数据写入excel，col-单元格行标，field-单元格列标 sheet.write(row, 0, name) sheet.write(row, 1, age) row += 1 book.save(output_file)if __name__ == '__main__': output_file = \"output.xls\" export_excel(output_file) 表格信息如下： 3 Python读excel——xlrd 整体思路为，打开文件，选定表格，读取行列内容，读取表格内数据 详细代码如下： 12345678910111213141516171819202122232425262728293031import xlrd# 导入表格def read_excel(input_file): # 打开文件 wb = xlrd.open_workbook(filename=input_file) # 获取所有表格名字 print(wb.sheet_names()) # ['人员信息表'] # 通过索引获取表格 sheet1 = wb.sheet_by_index(0) # 通过名字获取表格 sheet2 = wb.sheet_by_name('人员信息表') print(sheet1, sheet2) # Sheet 0:&lt;人员信息表&gt; Sheet 0:&lt;人员信息表&gt; print(sheet1.name, sheet1.nrows, sheet1.ncols) # 人员信息表 4 2 # 获取第1行内容（编号从0开始） rows = sheet1.row_values(1) # 获取第1列内容（编号从0开始） cols = sheet1.col_values(1) print(rows) # ['Dragon', 18.0] print(cols) # ['年龄', 18.0, 21.0, 22.0] # 获取表格里的内容，三种方式 print(sheet1.cell(1, 0).value) # Dragon print(sheet1.cell_value(1, 0)) # Dragon print(sheet1.row(1)[0].value) # Dragonif __name__ == '__main__': input_file = \"output.xls\" read_excel(input_file) 4 xls和xlsx的异同 文件核心结构不同： xls核心结构是复合文档类型的； xlsx 的核心结构是 XML 类型的结构，并且基于XML进行压缩（占用空间更小），所以也可以看做zip文件，将一个“.xlsx”文件的后缀改为ZIP后，用解压软件解压，可以看到里面有一个xml文件和文件的主要内容。 版本不同： xls是excel2003及以前版本所生成的文件格式 xlsx是excel2007及以后版本所生成的文件格式 （excel 2007之后版本可以打开上述两种格式，但是excel2013只能打开xls格式） 进一步的详细解释参见：excel后缀.xls和.xlsx有什么区别 X 参考 python如何处理表格？ python实现——处理Excel表格（超详细）","categories":[{"name":"开发","slug":"开发","permalink":"https://Dragonliu2018.github.io/categories/开发/"}],"tags":[{"name":"python","slug":"python","permalink":"https://Dragonliu2018.github.io/tags/python/"}]},{"title":"python统计词频","slug":"python统计词频","date":"2022-02-09T10:44:46.000Z","updated":"2022-02-09T14:28:23.191Z","comments":true,"path":"2022/02/09/python统计词频/","link":"","permalink":"https://Dragonliu2018.github.io/2022/02/09/python统计词频/","excerpt":"","text":"1 问题引入 最近在做恶意样本的标签信息提取、投票表决方式确定样本的最终最终标签信息，恰好用到了词频统计，或者说查找数组中出现次数最多的元素。 2 词频统计 1234567891011121314151617txt = '''in a job interview or in a situation'''# 分解并提取英文文章的单词for s in ',.\\n ': txt = txt.replace(s, ' ')txt = txt.lower() # 将字母变成小写，排除原文大小写差异对词频统计的干扰word_list = txt.split()print(word_list) # ['in', 'a', 'job', 'interview', 'or', 'in', 'a', 'situation']# 对每个单词进行计数count = dict()for i in word_list: count[i] = count.get(i, 0) + 1print(count) # &#123;'in': 2, 'a': 2, 'job': 1, 'interview': 1, 'or': 1, 'situation': 1&#125;# 对单词的统计值从高到低进行排序sorted_word = sorted(count.items(), key=lambda item: item[1], reverse=True)print(sorted_word) # [('in', 2), ('a', 2), ('job', 1), ('interview', 1), ('or', 1), ('situation', 1)] 2 查找数组(list)中出现次数最多的元素 2.1 np.argmax(np.bincount()) 12345import numpy as nparray = [0, 1, 2, 2, 3, 4, 4, 4, 5, 6]print(np.bincount(array)) # [1 1 2 1 3 1 1]print(np.argmax(np.bincount(array))) # 4 np.argmax：就是返回数组中最大值对应的下标， np.bincount：首先找到数组最大值max，然后返回0～max的各个数字出现的次数，只能处理不含负数的集合 2.2 Counter().most_common 12345from collections import Counterarray = [0, 1, 2, 2, 3, 4, 4, 4, 5, 6, 'aswd']print(Counter(array)) # Counter(&#123;4: 3, 2: 2, 0: 1, 1: 1, 3: 1, 5: 1, 6: 1, 'aswd': 1&#125;)print(Counter(array).most_common(1)[0][0]) # 4 Counter用来对数组中元素出现次数进行统计，然后通过most_common函数找到出现次数最多的元素。这种方法对于数组就没有过多限制，甚至是各种类型元素混合的数组也可以。数组只能是array，不能是ndarray。 2.3 自己实现 12345678910appear_times = &#123;&#125;for label in [1, 1, 2, 3, 4, 5, 5, 5]: if label in appear_times: appear_times[label] += 1 else: appear_times[label] = 1most_common = max(appear_times, key=lambda x: appear_times[x])print(appear_times) # &#123;1: 2, 2: 1, 3: 1, 4: 1, 5: 3&#125;print(most_common) # 5 用max求最大值默认情况返回value值（出现次数）最大的key值（元素），而不是value值。 X 参考 python之统计文本中出现最多的单词 python统计数组中出现次数最多的元素","categories":[{"name":"开发","slug":"开发","permalink":"https://Dragonliu2018.github.io/categories/开发/"}],"tags":[{"name":"python","slug":"python","permalink":"https://Dragonliu2018.github.io/tags/python/"}]},{"title":"python解析xml文件","slug":"python解析xml文件","date":"2022-02-09T10:44:20.000Z","updated":"2022-02-09T11:17:05.862Z","comments":true,"path":"2022/02/09/python解析xml文件/","link":"","permalink":"https://Dragonliu2018.github.io/2022/02/09/python解析xml文件/","excerpt":"","text":"1 问题引入 最近在做恶意样本行为可视化，样本的行为是xml文件形式给出，需要使用python对其解析。本次实验使用了dom进行的解析。 XML 指可扩展标记语言（eXtensible Markup Language），标准通用标记语言的子集，是一种用于标记电子文件使其具有结构性的标记语言。 XML 被设计用来传输和存储数据。 XML 是一套定义语义标记的规则，这些标记将文档分成许多部件并对这些部件加以标识。 它也是元标记语言，即定义了用于定义其他与特定领域有关的、语义的、结构化的标记语言的句法语言。 常见的 XML 编程接口有 DOM 和 SAX，这两种接口处理 XML 文件的方式不同，当然使用场合也不同。 Python 有三种方法解析 XML，SAX，DOM，以及 ElementTree 主要参考：菜鸟教程——Python3 XML 解析 2 SAX 待补充 3 DOM 文件对象模型（Document Object Model，简称DOM），是W3C组织推荐的处理可扩展置标语言的标准编程接口。 一个 DOM 的解析器在解析一个 XML 文档时，一次性读取整个文档，把文档中所有元素保存在内存中的一个树结构里，之后你可以利用DOM 提供的不同的函数来读取或修改文档的内容和结构，也可以把修改过的内容写入xml文件。 xml文件 movies.xml 如下： 123456789101112131415161718&lt;collection shelf=\"New Arrivals\"&gt;&lt;movie title=\"Enemy Behind\"&gt; &lt;type&gt;War, Thriller&lt;/type&gt; &lt;format&gt;DVD&lt;/format&gt; &lt;year&gt;2003&lt;/year&gt; &lt;rating&gt;PG&lt;/rating&gt; &lt;stars&gt;10&lt;/stars&gt; &lt;description&gt;Talk about a US-Japan war&lt;/description&gt;&lt;/movie&gt;&lt;movie title=\"Transformers\"&gt; &lt;type&gt;Anime, Science Fiction&lt;/type&gt; &lt;format&gt;DVD&lt;/format&gt; &lt;year&gt;1989&lt;/year&gt; &lt;rating&gt;R&lt;/rating&gt; &lt;stars&gt;8&lt;/stars&gt; &lt;description&gt;A schientific fiction&lt;/description&gt;&lt;/movie&gt;&lt;/collection&gt; Python 中用 xml.dom.minidom 来解析 xml 文件，实例如下： 1234567891011121314151617181920212223242526#!/usr/bin/python3import xml.dom.minidom# 使用minidom解析器打开 XML 文档DOMTree = xml.dom.minidom.parse(\"movies.xml\")collection = DOMTree.documentElementif collection.hasAttribute(\"shelf\"): print (\"Root element : %s\" % collection.getAttribute(\"shelf\"))# 在集合中获取所有电影movies = collection.getElementsByTagName(\"movie\")# 打印每部电影的详细信息for movie in movies: print (\"*****Movie*****\") if movie.hasAttribute(\"title\"): print (\"Title: %s\" % movie.getAttribute(\"title\")) type = movie.getElementsByTagName('type')[0] print (\"Type: %s\" % type.childNodes[0].data) format = movie.getElementsByTagName('format')[0] print (\"Format: %s\" % format.childNodes[0].data) rating = movie.getElementsByTagName('rating')[0] print (\"Rating: %s\" % rating.childNodes[0].data) description = movie.getElementsByTagName('description')[0] print (\"Description: %s\" % description.childNodes[0].data) 输出如下： 1234567891011121314Root element : New Arrivals*****Movie*****Title: Enemy BehindType: War, ThrillerFormat: DVDRating: PGDescription: Talk about a US-Japan war*****Movie*****Title: TransformersType: Anime, Science FictionFormat: DVDRating: RDescription: A schientific fiction*****Movie***** 完整的 DOM API 文档请查阅Python DOM APIs。 4 ElementTree 待补充 X 参考","categories":[{"name":"开发","slug":"开发","permalink":"https://Dragonliu2018.github.io/categories/开发/"}],"tags":[{"name":"python","slug":"python","permalink":"https://Dragonliu2018.github.io/tags/python/"}]},{"title":"python测量程序运行时间","slug":"python测量程序运行时间","date":"2022-02-09T08:48:03.000Z","updated":"2022-02-09T09:33:39.101Z","comments":true,"path":"2022/02/09/python测量程序运行时间/","link":"","permalink":"https://Dragonliu2018.github.io/2022/02/09/python测量程序运行时间/","excerpt":"","text":"1 问题引入 最近做到恶意样本可视化，跑脚本需要测量程序运行时间，下面是几种测量方法： 2 datetime.datetime.now() 1234567import datetimestarttime = datetime.datetime.now()#long running#do something otherendtime = datetime.datetime.now()print((endtime - starttime).seconds) # 秒 datetime.datetime.now()获取的是当前日期，在程序执行结束之后，这个方式获得的时间值为程序执行的时间。 3 time.time() 1234567import timestart = time.time()#long running#do something otherend = time.time()print(end - start) # 秒 time.time()获取自纪元以来的当前时间（以秒为单位）。如果系统时钟提供它们，则可能存在秒的分数。所以这个地方返回的是一个浮点型类型。这里获取的也是程序的执行时间。 4 time.clock() 或 time.perf_counter() 12345678910# start = time.clock()start = time.perf_counter()#long running#do something otheri = 0while i &lt; 1e8: i += 1# end = time.clock()end = time.perf_counter()print(end - start) #秒 time.clock()返回程序开始或第一次被调用clock()以来的CPU时间。 这具有与系统记录一样多的精度。返回的也是一个浮点类型。这里获得的是CPU的执行时间。 python3.8+ 不支持 clock 了，替换成 time.perf_counter() 就可以了 注意：程序执行时间=cpu时间 + io时间 + 休眠或者等待时间 X 参考 几种Python执行时间的计算方法","categories":[{"name":"开发","slug":"开发","permalink":"https://Dragonliu2018.github.io/categories/开发/"}],"tags":[{"name":"python","slug":"python","permalink":"https://Dragonliu2018.github.io/tags/python/"}]},{"title":"python遍历文件夹下的所有文件","slug":"python遍历文件夹下的所有文件","date":"2022-02-09T08:47:44.000Z","updated":"2022-02-09T09:19:43.597Z","comments":true,"path":"2022/02/09/python遍历文件夹下的所有文件/","link":"","permalink":"https://Dragonliu2018.github.io/2022/02/09/python遍历文件夹下的所有文件/","excerpt":"","text":"1 问题引入 最近在实现恶意脚本的可视化，需要实现提取文件夹下的所有文件名，实现脚本自动化。 2 文件夹下只有文件 当目标文件夹中只有文件时，使用os模块的listdir()方法即可：该方法可以返回目标路径下的文件和文件夹的名字列表，参数就是目标路径。 1234import osfile_names = os.listdir(r'test')print(file_names) # ['1.txt', '2.txt', '3.txt'] 3 文件夹下有文件和文件夹 当目标文件中既有文件又有文件夹时，我们使用listdir()方法就只能获得第一层子文件或文件夹了，而子文件夹中的内容便获取不到了。 这时候我们需要用到os.walk()方法：传入目标路径即可。该方法可以递归的找出目标路径下的所有文件。 12345678910111213141516import osfile_names = os.listdir(r'test')print(file_names) # ['1.txt', '2.txt', '3.txt', 'sub-dir']for filepath, dirnames, filenames in os.walk(r'test'): for filename in filenames: print(filename)\"\"\"1.txt2.txt3.txt4.txt5.txt6.txt\"\"\" os.walk()方法可以生成三元组，也就是我们代码中的filepath，dirnames，filenames。我们将他们分别打印出来可以看到：其中filepath就是目标路径下所有文件的路径，dirnames是我们目标路径的所有目录名称，filenames则是各个路径下的文件名称列表： 123456789101112131415161718for filepath, dirnames, filenames in os.walk(r'test'): print(filepath)\"\"\"testtest\\sub-dir\"\"\"for filepath, dirnames, filenames in os.walk(r'test'): print(dirnames)\"\"\"['sub-dir'][]\"\"\"for filepath, dirnames, filenames in os.walk(r'test'): print(filenames)\"\"\"['1.txt', '2.txt', '3.txt']['4.txt', '5.txt', '6.txt']\"\"\" 4 拓展—获得目标路径下的所有文件的绝对路径 遍历目标路径下的各个文件，用os.path.join()方法将文件路径和文件名拼接在一起，就是各个文件的绝对路径了： 1234567891011for filepath, dirnames, filenames in os.walk(r'test'): for filename in filenames: print(os.path.join(filepath, filename))\"\"\"test\\1.txttest\\2.txttest\\3.txttest\\sub-dir\\4.txttest\\sub-dir\\5.txttest\\sub-dir\\6.txt\"\"\" X 参考 python遍历文件夹下的所有文件","categories":[{"name":"开发","slug":"开发","permalink":"https://Dragonliu2018.github.io/categories/开发/"}],"tags":[{"name":"python","slug":"python","permalink":"https://Dragonliu2018.github.io/tags/python/"}]},{"title":"python中防止字符串转义","slug":"python中防止字符串转义","date":"2022-02-09T07:31:55.000Z","updated":"2022-02-10T05:50:31.471Z","comments":true,"path":"2022/02/09/python中防止字符串转义/","link":"","permalink":"https://Dragonliu2018.github.io/2022/02/09/python中防止字符串转义/","excerpt":"","text":"1 问题引入 最近在做xml解析、可视化时遇到一个问题：将字符串（文件路径）中的转义字符不进行转义123\\tabc，正常print会将\\t看作转义字符tab，需求是使字符串按原样输出。下面是不同场景下的解决方法： 2 字符串常量 如果是字符串常量，则在字符串前加r 即可： 1234print(\"123\\tabc\")# 123 abcprint(r\"123\\tabc\") # test_str = r\"123\\tabc\"# 123\\tabc 3 字符串变量 如果字符串是变量，使用 repr() 方法： 123456str1 = \"123\\tabc\"str2 = repr(str1)print(str1) # 123 abcprint(str2) # '123\\tabc'print(str2.strip(\"\\'\")) # 123\\tabc 注意：字符串使用 repr 函数后输出是会在字符串前后自动加上单引号（见print第二行），print第三行是去掉了字符串首尾的单引号。关于strip函数，详见博客。 4 文件读取 123file1 = open(\"test.txt\", \"r\") # 123\\tabcprint(file1.read()) # 123\\tabc 文本文件读取测试发现字符串未发生转义。 拓展阅读：关于python中open函数读取和写入windows记事本的换行问题研究 X 参考 python中防止字符串转义 python如何实现对变量的禁止转义操作","categories":[{"name":"开发","slug":"开发","permalink":"https://Dragonliu2018.github.io/categories/开发/"}],"tags":[{"name":"python","slug":"python","permalink":"https://Dragonliu2018.github.io/tags/python/"}]},{"title":"python模块graphviz使用教程","slug":"python模块graphviz使用教程","date":"2022-02-03T03:11:14.000Z","updated":"2022-02-12T05:00:43.685Z","comments":true,"path":"2022/02/03/python模块graphviz使用教程/","link":"","permalink":"https://Dragonliu2018.github.io/2022/02/03/python模块graphviz使用教程/","excerpt":"","text":"1 情景引入 前几个月师姐给了个任务——恶意样本行为可视化，输入为xml文件，一个文件代表一个恶意样本。请教学姐学长同学等，加上观看效果图，得出实现思路：python解析xml文件，使用python模块graphviz进行可视化；之后使用图数据库neo4j进行对比。 之后发现neo4j创建多个图数据库比较麻烦，但是按照行为分类等都比较直观，所以做辅助作用应该不错。 下面对graphviz进行整理。 2 Graphviz Graphviz 是一个自动排版的作图软件，可以生成 png pdf 等格式。 Graphviz官网 Graphviz 画图的一些总结 3 python graphviz python graphviz则是graphviz的python实现。我们可以通过python graphviz实现轻松完成各种流程图的绘制。 python graphviz官方文档 [python] python模块graphviz使用入门 3.1 安装 安装python graphviz木块（本机使用的是python3.9）: 1pip install graphviz 除了python安装外，本机还需要安装Graphviz(下载页面)，并确保包含dot可执行文件的目录在系统路径上。安装过程中需要添加PATH： 否则出现下面的报错：(重启Pycharm生效) 1graphviz.backend.execute.ExecutableNotFound: failed to execute WindowsPath('dot'), make sure the Graphviz executables are on your systems' PATH graphviz.backend.ExecutableNotFound: failed to execute [‘dot’, ‘-Tpng’, ‘-O’, ‘t est.gv’]问题解决方法 解决报错：添加环境变量 3.2 使用 该graphviz模块提供了两个类：Graph和 Digraph。它们分别以DOT语言为无向图和有向图创建图描述。它们具有相同的 API。示例如下： 1234567891011121314151617181920212223from graphviz import Digraphdot = Digraph(comment='恶意样本行为可视化', format='jpg')# 初始化端点dot.node(name='n1', label='端点A', color=\"#008000\", fontcolor=\"#000000\", style=\"filled\", shape=\"rectangle\", fontname=\"Microsoft YaHei\")dot.node(name='n2', label='端点B', color=\"#FFD700\", fontcolor=\"#000000\", style=\"filled\", shape=\"circle\", fontname=\"Microsoft YaHei\")dot.node(name='n3', label='端点C', color=\"#0000FF\", fontcolor=\"#FFFFFF\", style=\"filled\", shape=\"oval\", fontname=\"Microsoft YaHei\")# 布局 L-左 R-右 T-上 B-下dot.attr(rankdir='LR') # 自左向右# dot.attr(rankdir='RL')# dot.attr(rankdir='TB') # 默认# dot.attr(rankdir='BT')# 初始化边dot.edge('n1', 'n2', label=\"边1\", color=\"#000000\", fontcolor=\"#000000\", style=\"\", fontname=\"Microsoft YaHei\")dot.edge('n1', 'n3', label=\"边2\", color=\"#FF0000\", fontcolor=\"#FF0000\", style=\"dashed\", fontname=\"Microsoft YaHei\")# 保存文件，view=False时将不自动打开文件# dot.render(\"test_graphviz.gv\", format='jpg', view=True)# 不保存文件，仅仅自动打开u = dot.unflatten(stagger=1)u.view() 显示如下： 3.3 中文乱码 如果出现中文乱码，多半是因为没有设置fontname为支持中文显示的字体，只需要在node或者edge中添加fontname=&quot;Microsoft YaHei&quot;，即可正常显示。 参考 3.4 端点、边、字体颜色 在node或者edge中添加color=&quot;#000000&quot;, fontcolor=&quot;#000000&quot;即可，具体颜色可以参考： 官网颜色 维基百科——X11名称编码 3.5 端点的形状 在node中添加shape=&quot;xxx&quot;即可，具体需要什么形状可以在官网中查找。 3.6 Rank GraphViz DOT有向图 (四)node节点布局控制之rank,group,subgraph 3.7 排版 如上面的示例，使用dot.attr(rankdir='xx')来确定排版，作用范围为使用该行代码之后，下一个dot.attr(rankdir='xx')代码之前。 3.8 name参数中不能有英文冒号 123dot.node(name='n1', label='n1')dot.node(name='n2:3', label='n2:3')dot.edge('n1', 'n2:3') dot.node(name=&quot;xxx&quot;) 如果name参数含有英文逗号，则会报错，导致画图错误： 1Warning: node n2, port 3 unrecognized 常见的思路是使用python将name参数改成中文冒号，label参数是原来的英文冒号，达到正确显示的目的。 123string = \"http://gsstudio.info/panel\"label = repr(string)name = repr(string.replace(\":\", \"：\")) repr函数是防止字符串转义的，详细见博客——python中防止字符串转义。 3.9 报错：graphviz.backend.execute.CalledProcessError 报错信息： 123subprocess.CalledProcessError: Command '[WindowsPath('dot'), '-Kdot', '-Tjpg', '-O', '57630-0.xml.gv']' returned non-zero exit status 3221225477....graphviz.backend.execute.CalledProcessError: Command '[WindowsPath('dot'), '-Kdot', '-Tjpg', '-O', '57630-0.xml.gv']' returned non-zero exit status 3221225477. [stderr: b'dot: graph is too large for cairo-renderer bitmaps. Scaling by 0.876568 to fit\\r\\n'] 现象： .gv文件可以正常生成，图片文件.jpg无法生成。 定位报错语句： 123dot = Digraph(comment='恶意样本行为可视化', format='jpg')...dot.render(output_dir + \"\\\\\" + file_name + \".gv\", format='jpg') 原因： 生成的graph太大，dot无法导出，换成pdf或svg就可以了，png和jpg都不行。 最后选择pdf格式，因为导出的文件小。 123dot = Digraph(comment='恶意样本行为可视化', format='pdf')...dot.render(output_dir + \"\\\\\" + file_name + \".gv\", format='pdf') X 参考","categories":[{"name":"环境与工具","slug":"环境与工具","permalink":"https://Dragonliu2018.github.io/categories/环境与工具/"},{"name":"开发","slug":"开发","permalink":"https://Dragonliu2018.github.io/categories/开发/"}],"tags":[{"name":"python","slug":"python","permalink":"https://Dragonliu2018.github.io/tags/python/"}]},{"title":"VMWare虚拟机Ubuntu20.04 LTS磁盘空间不足的解决方法整理","slug":"VMWare虚拟机Ubuntu20-04-LTS磁盘空间不足的解决方法整理","date":"2022-02-02T09:38:02.000Z","updated":"2022-02-02T10:50:40.204Z","comments":true,"path":"2022/02/02/VMWare虚拟机Ubuntu20-04-LTS磁盘空间不足的解决方法整理/","link":"","permalink":"https://Dragonliu2018.github.io/2022/02/02/VMWare虚拟机Ubuntu20-04-LTS磁盘空间不足的解决方法整理/","excerpt":"","text":"1 引入 之前设置磁盘大小为40G，现在搭建cuckoo环境，磁盘空间不足。 在Ubuntu虚拟机的命令行输入 df -l 查看磁盘使用情况： 12345➜ Desktop df -lFilesystem 1K-blocks Used Available Use% Mounted onudev 4019184 0 4019184 0% /devtmpfs 810936 2032 808904 1% /run/dev/sda5 102431704 46674596 51153504 99% / 可以看到 /dev/sda5 对应的根目录 / 已经满载了。 下面是一些解决方法： 2 删除回收站所有文件 使用下面命令即可： 1sudo rm -rf ~/.local/share/Trash/ 3 删除日志文件 删除所有日志文件：（可能存在权限不够，无法删除的情况） 1sudo /dev/null &gt; /var/log/**.log 下面这个可以推荐使用：（删除30天之前的旧文件） 1sudo find /var/log/ -type f -mtime +30 -exec rm -f &#123;&#125; \\; 4 删除快照（对磁盘空间大小无影响） 但是对于Ubuntu虚拟机整体目录大小有关。 5 删除无关用户 使用下面命令即可： 1sudo userdel -r &lt;newuser&gt; 6 挂载新磁盘 拓展磁盘空间：链接 设置挂载的文件夹访问权限：sudo chmod 777 ××× （每个人都有读和写以及执行的权限） 7 拓展磁盘空间（不改变原有磁盘内容，推荐） 跳转 8 总结 扩展磁盘空间完成，df再看一下： 12345➜ Desktop df -lFilesystem 1K-blocks Used Available Use% Mounted onudev 4019184 0 4019184 0% /devtmpfs 810936 2032 808904 1% /run/dev/sda5 102431704 46674596 51153504 48% / 现在已经完成任务。","categories":[{"name":"环境与工具","slug":"环境与工具","permalink":"https://Dragonliu2018.github.io/categories/环境与工具/"}],"tags":[]},{"title":"Cuckoo Sandbox 安装教程","slug":"Cuckoo-Sandbox-安装教程","date":"2022-01-30T13:56:31.000Z","updated":"2022-02-02T13:05:07.104Z","comments":true,"path":"2022/01/30/Cuckoo-Sandbox-安装教程/","link":"","permalink":"https://Dragonliu2018.github.io/2022/01/30/Cuckoo-Sandbox-安装教程/","excerpt":"","text":"0 简介 Cuckoo Sandbox 是一个开源的自动分析可疑文件的软件。它通过在独立环境内使用自定义组件来监控恶意进程的行为。 它可以分析出以下几种类型的结果: 跟踪恶意软件产生函数调用. 恶意软件执行期间的文件操作，包括新建，删除以及文件下载. 恶意软件的内存转储. PCAP格式的网络流量捕获. 恶意软件运行时的截屏. 虚拟机的完整内存转储文件. Cuckoo 由一个宿主机（管理组件）加上多个沙箱（物理机或者虚拟机）组成。 宿主机上的管理组件负责了一个样本分析的全部过程，样本的执行过程都是在沙箱中进行。 官网 官方文档-英文 官方文档-中文 1 环境准备 本次搭建Cuckoo环境，主要参考教程，使用一个宿主机+一个沙箱(guest)的模式，具体如下： 软件 host guest1 guest2 VMware 16 Pro Ubuntu20.04 LTS(推荐GNU/Linux) VM window7-64bit(推荐64位Win7或WinXP) VM Ubuntu虚拟机 virtualbox win7 其中Win7需要关闭UAC(User Access Control)。 guest打算使用VMWare下直接虚拟机——win7，但是失败了； 成功实现的guest是Ubuntu下的virtualbox下的win7。 2 host安装 2.1 创建 Ubuntu20.04 LTS 虚拟机 网上好多参考教程 注意: Ubuntu20.04虚拟机需要至少4GB的RAM和60–80GB的硬盘，因为你将在里面运行一个windows7虚拟机 请确保不要将您的用户名称为“cuckoo”，否则这可能会与以后的安装冲突。 确保您的虚拟机已启用VT-x功能 Vmware中虚拟机启用VT-x功能后，再打开Ubuntu虚拟机出现报错此平台不支持虚拟化的 AMD-V/RVI。 解决：关闭 Windows 功能 里的 虚拟机平台，重启后即可。 2.2 依赖 2.2.1 安装 Python 库 (Ubuntu/Debian-based) Cuckoo的管理组件完全由Python脚本编写，所以就需要适合的Python版本。 当前，我们完全兼容的Python版本是 2.7。 老版本的Python和Python 3（未来可能会支持） 目前都是不支持的。 依赖库：(注意：Ubuntu20中已将python2移除) 12345678910111213141516# step1 安装python2sudo apt install python2# step2 安装pip2，Ubuntu 20已经无法通过apt来安装python2的pip2了wget https://bootstrap.pypa.io/pip/2.7/get-pip.pysudo python2 get-pip.py# 使用：python2 -m pip install numpy# step3 安装Virtualenvsudo apt-get install virtualenv# 使用： virtualenv --python=python2 env# step4 安装其他的sudo apt install python-dev libffi-dev libssl-devsudo apt-get install libjpeg-dev zlib1g-dev swigsudo apt install python-setuptools 如果要使用我们基于Django开发的Web界面, 则MongoDB是必须要安装的： 1sudo apt-get install mongodb 如果要使用PostgreSQL数据库(推荐), PostgreSQL也必须安装： 1sudo apt-get install postgresql libpq-dev 如果使用KVM的话，则需要安装KVM相关依赖： 1234sudo apt-get install qemu-kvmsudo apt-get install libvirt-dev libvirt-daemon libvirt-clients# 未完成libvirt-bin ubuntu-vm-builder bridge-utils python-libvirt 安装Yara：（可选） 1sudo -H pip install yara-python==3.6.3 安装ssdeep： 1sudo apt-get install -y ssdeep 安装pydeep：(可选，未完成) 1sudo pip install -U pip setuptools 安装openpyxl： 1sudo -H pip install openpyxl 安装ujson: 1sudo -H pip install ujson 现在安装jupyter： 1sudo -H pip install jupyter 2.2.2 虚拟化软件 Cuckoo沙箱支持大部分的虚拟化软件，可以很方便的添加和使用各种虚拟化支持。 本文档以VirtualBox为例，选择哪种虚拟机软件并不影响后续的分析。 安装VirtualBox： 1sudo apt-get install virtualbox 2.2.3 安装 tcpdump Tcpdump用于抓取恶意软件运行过程中产生的所有流量。 安装命令： 12sudo apt-get install tcpdump apparmor-utilssudo aa-disable /usr/sbin/tcpdump AppArmor 只有当PCAP文件生成没有权限的时候才需要，可以参考 Permission denied for tcpdump Tcpdump需要root权限，如果不想运行在root用户下，需要做以下设置： 1sudo setcap cap_net_raw,cap_net_admin=eip /usr/sbin/tcpdump 可以用以下命令验证是否配置正确： 12$ getcap /usr/sbin/tcpdump/usr/sbin/tcpdump = cap_net_admin,cap_net_raw+eip 如果没有setcap命令， 则需要安装下面的包: 1$ sudo apt-get install libcap2-bin 或者 (不推荐) 1$ sudo chmod +s /usr/sbin/tcpdump 需要注意的是 setcap 命令不安全，有可能造成提权漏洞，我们建议将Cuckoo安装在专有的环境里。 2.2.4 安装 Volatility Volatility 用于分析内存转储文件的可选工具. Cuckoo与Volatility配合，可以更深度和全面的分析，可以防止恶意软件利用rookit技术逃逸沙箱的监控。 为了能够工作正常，Cuckoo要求Volatility版本不低于 2.3， 推荐最新版本2.5。 可以从官网下载 official repository. 可以查阅Volatility官方文档的安装说明. 1234git clone https://github.com/volatilityfoundation/volatility.git cd volatilitysudo python setup.py buildsudo python setup.py install 安装Distorm3： 1sudo -H pip install distorm3==3.4.4 2.2.5 安装 M2Crypto 当前 M2Crypto 库需要 SWIG 支持. Ubuntu/Debian-like 系统下可以通过以下命令安装: 1sudo apt-get install swig SWIG 安装好之后，通过以下命令安装 M2Crypto: 1sudo python2 -m pip install m2crypto 2.2.6 安装 guacd(未完成) guacd 是RDP，SSH，VNC等远程控制的代理层， 是Cuckoo的Web界面的远程终端中使用，可选。 没有它，远程控制功能就无法使用，版本要求0.9.9及以上。我们推荐安装最新版本 使用如下命令安装: 1sudo apt install libguac-client-rdp0 libguac-client-vnc0 libguac-client-ssh0 guacd 2.3 Cuckoo 安装 2.3.1 创建用户（没使用，使用dragon用户下） Cuckoo可以运行在已有用户下面，也可以新建一个用户来跑Cuckoo。 但是要保证虚拟机和Cuckoo运行在相同的用户下。（让一个单独的用户来运行沙盒是一种很好的安全习惯。） 创建新用户：（密码为root，其他回车即可） 1sudo adduser cuckoo 若使用virtualBox则创建一个cuckoo用户，将其添加到vboxusers组里（VirtualBox安装后创建）。 1sudo usermod -a -G vboxusers cuckoo 将该用户添加到sudo组。输入： 1sudo adduser cuckoo sudo 如果使用KVM，要将用户加入到Libvirtd用户组: 1sudo usermod -a -G libvirtd cuckoo 2.3.2 安装 Cuckoo 全局安装Cuckoo是没有问题的，但是 强力推荐 用 virtualenv 来安装： 1234$ virtualenv --python=python2 venv$ . venv/bin/activate(venv)$ pip install -U pip setuptools(venv)$ pip install -U cuckoo 提醒：cuckoo下载较慢，30min左右 为什么推荐使用 virtualenv 呢: Cuckoo的依赖并不是用的最新版本，可能会与系统已有的版本冲突. 系统中其他软件的安装，可能会导致Cuckoo的依赖产生问题. 使用virtualenv，可以让非root用户也可以安装相关软件. 简单来说virtualenv是最佳实践. 2.4 Cuckoo 工作目录 123456# 切换用户cuckoosu cuckoo# 进入虚拟环境. ./venv/bin/activate# 首次运行cuckoo -d 出现以下界面： 12345678910111213141516171819202122232425262728293031323334353637/home/dragon/graduation/venv/lib/python2.7/site-packages/sflock/decode/office.py:12: CryptographyDeprecationWarning: Python 2 is no longer supported by the Python core team. Support for it is now deprecated in cryptography, and will be removed in the next release. from cryptography.hazmat.backends import default_backend sSSs .S S. sSSs .S S. sSSs_sSSs sSSs_sSSs d%%SP .SS SS. d%%SP .SS SS. d%%SP~YS%%b d%%SP~YS%%b d%S' S%S S%S d%S' S%S S&amp;S d%S' `S%b d%S' `S%b S%S S%S S%S S%S S%S d*S S%S S%S S%S S%S S&amp;S S&amp;S S&amp;S S&amp;S S&amp;S .S*S S&amp;S S&amp;S S&amp;S S&amp;S S&amp;S S&amp;S S&amp;S S&amp;S S&amp;S_sdSSS S&amp;S S&amp;S S&amp;S S&amp;S S&amp;S S&amp;S S&amp;S S&amp;S S&amp;S~YSSY%b S&amp;S S&amp;S S&amp;S S&amp;S S&amp;S S&amp;S S&amp;S S&amp;S S&amp;S `S% S&amp;S S&amp;S S&amp;S S&amp;S S*b S*b d*S S*b S*S S% S*b d*S S*b d*S S*S. S*S. .S*S S*S. S*S S&amp; S*S. .S*S S*S. .S*S SSSbs SSSbs_sdSSS SSSbs S*S S&amp; SSSbs_sdSSS SSSbs_sdSSS YSSP YSSP~YSSY YSSP S*S SS YSSP~YSSY YSSP~YSSY SP Y Cuckoo Sandbox 2.0.7 www.cuckoosandbox.org Copyright (c) 2010-2018======================================================================= Welcome to Cuckoo Sandbox, this appears to be your first run! We will now set you up with our default configuration. You will be able to see and modify the Cuckoo configuration, Yara rules, Cuckoo Signatures, and much more to your likings by exploring the /home/cuckoo/.cuckoo directory. Among other configurable items of most interest is the new location for your Cuckoo configuration: /home/cuckoo/.cuckoo/conf=======================================================================Cuckoo has finished setting up the default configuration.Please modify the default settings where required andstart Cuckoo again (by running `cuckoo` or `cuckoo -d`). 3 guest安装(在Ubuntu20.04中的VirtualBox中) 3.1 设置virtualbox环境 安装网络工具：sudo apt install -y net-tools，现在键入ifconfig以查找虚拟机的IP地址信息。 创建一个只支持主机的网络适配器：vboxmanage hostonlyif create 为虚拟接口设置IP地址：vboxmanage hostonlyif ipconfig vboxnet0 --ip 192.168.56.1 再次运行ifconfig，将看到刚刚设置的接口和IP地址： 我们要使这些更改在重新启动后仍然有效，并在系统启动期间自动设置。所以我们需要建立一个新的目录： 1sudo mkdir /opt/systemd/ 然后： 1sudo vim /opt/systemd/vboxhostonly 并将以下代码复制到文件中： 123!/bin/bashhostonlyif createvboxmanage hostonlyif ipconfig vboxnet0 --ip 192.168.56.1 现在我们需要使文件可执行： 12cd /opt/systemd/sudo chmod a+x vboxhostonly 现在我们需要创建一个服务： 1sudo touch /etc/systemd/system/vboxhostonlynic.service 编辑文件： 1sudo vim /etc/systemd/system/vboxhostonlynic.service 然后： 1234567Description=Setup VirtualBox Hostonly AdapterAfter=vboxdrv.service[Service]Type=oneshotExecStart=/opt/systemd/vboxhostonly[Install]WantedBy=multi-user.target 现在安装服务并确保它在引导时加载: 12systemctl daemon-reloadsystemctl enable vboxhostonlynic.service 网络部分完成。 3.2 创建Win7-x64虚拟机 选择镜像 win7-x64-sp1 启动Oracle VirtualBox Manager 单击New图标创建一个新的虚拟机guest1，选择合适的操作系统： 现在单击下一步。选择要分配的RAM大小。理想情况下，最小值为4GB。我将设置为4096MB（4GB）: 单击下一步。通过单击“创建”创建虚拟硬盘： 选择VDI并单击Next，选择“动态分配”，然后单击“下一步”。 选择你的硬盘大小。我已设置为32GB，现在单击“创建”。 现在你需要把Windows7ISO文件装载到你的Ubuntu虚拟机上。 单击“确定”。这将把Windows7.iso安装到虚拟机中。现在单击VirtualBox中的设置，然后转到存储。现在单击CD（空）。在右侧或光盘驱动器上，单击CD旁边的向下箭头，然后选择主机驱动器作为CD选项。 单击“确定”关闭，然后开始启动虚拟机。按照正常的Windows7安装。我把我的Windows7虚拟机叫做guest1。 现在您的Windows7虚拟机已构建，请登录。（卡顿的原因可能是Ubuntu虚拟机磁盘空间不足，解决方法） 3.3 进行配置 我们将进行一些更改，以使虚拟机故意易受攻击。转到“开始”并键入组。您应该看到“编辑组策略”选项。 展开“计算机配置”&gt;“Windows设置”&gt;“安全设置”&gt;“本地策略”&gt;“安全选项”。向下滚动到用户帐户控制选项。 右键单击“用户帐户控制：管理员批准模式中管理员的提升权限提示的行为”，然后选择“属性”。使用下拉菜单选择“不提示，直接提升”，然后单击“确定”。 右键单击“用户帐户控制：检测应用程序安装并提示提升”，然后选择属性。选中“禁用”选项，然后单击“确定”。 右键单击“用户帐户控制：以管理员批准模式运行所有管理员”，然后选择属性。选中“禁用”选项，然后单击“确定”。 现在我们关闭windows防火墙和自动更新，原因为他们可能影响恶意软件的行为。 接下来我们需要禁用Windows Defender，将“自动扫描”和“实时保护”关闭： 3.4 安装软件 单击VirtualBox窗口中的设备并选择InstallVirtualBox Guest Additions完成安装； 添加一个共享文件夹，使用Downloads文件夹： 转到Windows中的文件资源管理器并键入\\\\vboxsvr\\*Downloads 即可访问Ubuntu中的文件夹。 物理机下载python2.7，将此安装包放入共享文件夹并从Windows7虚拟机运行，安装的时侯选择 add python to path； 下载Python Pillow，将安装包放入共享文件夹并从Windows 7虚拟机运行。 （未完成）现在安装Adobe Reader、Flash、Java和Microsoft Office（可选）以及您认为可能需要的任何其他应用程序。 （未完成）打开Internet Explorer和Adobe Reader以及任何其他可能有可能干扰cuckoo客户端操作的闪屏的应用程序。 3.5 安装客户端 上传agent.py文件至win7虚拟机： 12cd /home/cuckoo/.cuckoo/agentcp agent.py ~/Downloads 自启动：复制agent.py文件并将其放置在C:\\Users\\*USERNAME*\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup 这将在启动虚拟机时启动agent.py。在Windows7虚拟机上，需要显示隐藏的文件和文件夹才能看到AppData文件夹。 您可以通过进入“文件资源管理器”，然后进入“组织”&gt;“文件夹选项”来完成此操作。 一旦您对安装了所有必需的软件感到满意，请重新启动Windows7虚拟机并登录。你应该得到一个空白的命令窗口出现。如果出现网络弹出窗口，请单击“允许”。 现在可以最小化虚拟机。 3.6 创建沙盒环境 现在我们已经创建了Windows7虚拟机，我们需要设置网络来创建沙盒环境。单击VirtualBox管理器，然后单击Windows 7虚拟机的设置。选择网络，然后更改附加到：仅主机适配器，然后在名称中选择vboxnet0。单击“确定”。 现在你需要让这个持久化。 1sudo apt-get install -y iptables-persistent 现在我们需要配置IP转发，以便将internet连接从主机路由到来宾虚拟机。我们将使用iptables设置这些网络转发规则： 123sudo iptables -A FORWARD -o eth0 -i vboxnet0 -s 192.168.56.0/24 -m conntrack --ctstate NEW -j ACCEPTsudo iptables -A FORWARD -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPTsudo iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE 您可以通过运行sudo iptables-L来检查您的规则 现在在内核中启用IP转发，以便将这些设置设置为活动（WWW Internet访问需要）： 12echo 1 | sudo tee -a /proc/sys/net/ipv4/ip_forwardsudo sysctl -w net.ipv4.ip_forward=1 现在我们需要确保IP转发在重新启动后启动： 1sudo vim /etc/sysctl.conf 把#从net.ipv4.ip_forward=1项移除，保存退出。 现在运行sudo su -然后iptables-save &gt; /etc/iptables/rules.v4 现在我们需要配置Windows7虚拟机的IP地址信息。在中打开网络适配器并设置以下信息： 单击“确定”和“确定”之后，您应该再次获得internet连接。 我们现在要拍摄虚拟机的快照，所以单击Machine&gt;takesnapshot。将其命名为Snapshot 1，然后单击ok。 3.7 配置cuckoo服务 我们现在需要在ubuntu20上完成cuckoo服务的配置。所有cuckoo配置文件都位于 1~/.cuckoo/conf 或您的主目录 1cd .cuckoo/ 切换到config目录： 1cd /home/cuckoo/.cuckoo/conf 通过 1sudo vim cuckoo.conf 编辑buckoo.conf文件确保设置了以下内容：machine=virtualbox 和memory_dump=yes 和resultserver ip=192.168.56.1， 保存退出即可 通过 1sudo vim auxiliary.conf 编辑auxiliary.conf文件确保启用了 sniffer=yes 保存退出 通过 1sudo vim virtualbox.conf 编辑virtualbox.conf文件，并确保 virtualbox mode=gui 和machines=cuckoo1 （如果需要，将名称更改为您的Windows 7虚拟机名称，label=cuckoo1和platform=Windows和ip=192.168.56.101和snapshot=snapshot 1）， 保存退出 通过 1sudo vim processing.conf 编辑processing.conf文件， 确保memory enabled=yes， 保存退出 使用 1sudo vim memory.conf 编辑memory.conf文件， 确保basic guest_profile=Win7SP1x64， 保存退出 通过 1sudo vim reporting.conf 编辑reporting.conf文件，确保singlefile启用 report.html enabled=yes和mongodb enabled=yes的创建， 保存退出 3.8 启动cuckoo 现在关闭Windows7虚拟机，然后重新启动Ubuntu虚拟机。以同一用户身份重新登录（不要以cuckoo用户身份登录） dragon用户下激活虚拟环境： 12➜ graduation . ./venv/bin/activate(venv) ➜ graduation 现在要使用cuckoo你首先需要更新cuckoo的签名，所以打开一个终端并键入 12345(venv) ➜ graduation cuckoo community /home/dragon/graduation/venv/lib/python2.7/site-packages/sflock/decode/office.py:12: CryptographyDeprecationWarning: Python 2 is no longer supported by the Python core team. Support for it is now deprecated in cryptography, and will be removed in the next release. from cryptography.hazmat.backends import default_backend2022-02-02 20:54:28,277 [cuckoo.apps.apps] INFO: Downloading.. https://github.com/cuckoosandbox/community/archive/master.tar.gz2022-02-02 20:54:33,956 [cuckoo] INFO: Finished fetching &amp; extracting the community files! 现在在终端窗口1中键入cuckoo并按回车键。你将得到启动cuckoo，它将坐在等待分析任务。 在第二个终端窗口中键入 cuckoo web runserver 0.0.0.0:8000 现在您可以通过127.0.0.1:8000访问cuckoo网络服务器，或者通过浏览器访问本地网络上的虚拟机IP地址。 然后提交分析即可，生成报告如下： 4 guest安装(在Vmware中，与Ubuntu并列，未完成，失败) 4.1 创建win7-x64虚拟机 镜像下载：MSDN （需要Service Pack 1，否则vmtools安装报错： 1win7企业版安装vmtool提示无法进行，需要更新到SP1 此教程无效 按照步骤安装即可 安装VMware Tools（如果安装失败： 1Windows 无法验证此驱动程序软件的发布者 使用此ISO映像文件安装即可，教程的评论中提及的 4.2 依赖 4.2.1 安装python Python 是 Cuckoo 客户端（分析器） 正常工作的必须软件。 官网下载安装 Python2.7 版本； 如果安装的时侯选择 add python to path,则会自动完成环境变量配置；否则需要手动添加 Cuckoo 客户端组件依赖于部分额外的Python 库， 包括: Python Pillow: 截图组件需要用到。下载安装包后双击运行即可。 这些组件不是必须要安装的， 但是不安装的话，分析组件的部分功能就无法正常使用。 4.2.2 其他软件 至此，Cuckoo 正常工作所需的软件的已经安装完成了。 不过根据你需要分析的文件类型， 也同时需要安装相应的软件， 例如(谷歌)浏览器，PDF阅读器，Office软件等。 记得要关闭这些软件的检查更新和自动更新。 这些额外的软件是否需要安装，完全取决于你是否所需。 可以阅读 沙箱 章节了解更多的信息. 4.3 网络配置 4.3.1 Windows 设置 在配置底层网络之前，可能需要调整一些windows虚拟机的内部配置。 最重要的事情是关闭控制面板中的 Windows 防火墙 和 自动更新。 这些都会影响恶意软件的行为，进而影响Cuckoo对这些行为的分析。 4.3.2 虚拟网络 现在可以决定虚拟机如何访问互联网或者本地局域网。 以前老的版本中， Cuckoo 虚拟机和宿主机之间的数据是通过共享文件夹进行交互。 从0.4版本起，则通过XMLRPC 协议来交互。 所以，需要配置给虚拟机配置静态IP，配置完成后，通过PING来测试虚拟机与宿主机之间 的通信是否正常。不要使用DHCP， 每次IP都不同的情况下，无法正常通信。 这些配置都要依赖于你的需求和所选的虚拟机软件的特性。 警告：虚拟网络报错! 虚拟网络配置是非常重要的部分。大部分Cuckoo遇到的问题都与网络配置有关系。 在你配置完成之后， 尽量用PING和TELNET工具测试是否正常。 推荐使用 Host-Only 模式的虚拟网络。 win7虚拟机使用nat模式配置静态IP上网：（未完成） 链接 查看ubuntu20.04 LTS的ip地址，配置window7客户机的ipv4地址的默认网关和DNS地址为ubuntu的ip地址，如下： 使用NAT模式DHCP： Ubuntu：192.168.10.128 Win7：192.168.10.134 4.3 安装客户端 从0.4版本起， Cuckoo设计了以跨平台的交互客户端，可以在Windows， Android， Linux 和Mac OSX 系统上运行。 只有安装和启动了Cuckoo 客户端， 分析才能工作正常。 客户端的安装和启动是十分简单的。 在 $CWD/agent/ 目录中，可以找到 agent.py 文件。 把文件拷贝到虚拟机中， 然后将脚本启动起来。 客户端会启动一个小型的API服务，用于与宿主机通信。 在Windows系统中， 只要将脚本名称 从 agent.py 改为 agent.pyw ， 可以在运行的时候不显示终端的窗口。 将脚本拷贝到 启动 目录， 即可实现脚本开机自启动。 123456789101112reg add \"hklm\\software\\Microsoft\\Windows NT\\CurrentVersion\\WinLogon\" /v DefaultUserName /d &lt;USERNAME&gt; /t REG_SZ /freg add \"hklm\\software\\Microsoft\\Windows NT\\CurrentVersion\\WinLogon\" /v DefaultPassword /d &lt;PASSWORD&gt; /t REG_SZ /freg add \"hklm\\software\\Microsoft\\Windows NT\\CurrentVersion\\WinLogon\" /v AutoAdminLogon /d 1 /t REG_SZ /freg add \"hklm\\system\\CurrentControlSet\\Control\\TerminalServer\" /v AllowRemoteRPC /d 0x01 /t REG_DWORD /freg add \"HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\" /v LocalAccountTokenFilterPolicy /d 0x01 /t REG_DWORD /freg add \"hklm\\software\\Microsoft\\Windows NT\\CurrentVersion\\WinLogon\" /v DefaultUserName /d guest2 /t REG_SZ /freg add \"hklm\\software\\Microsoft\\Windows NT\\CurrentVersion\\WinLogon\" /v DefaultPassword /d root /t REG_SZ /freg add \"hklm\\software\\Microsoft\\Windows NT\\CurrentVersion\\WinLogon\" /v AutoAdminLogon /d 1 /t REG_SZ /freg add \"hklm\\system\\CurrentControlSet\\Control\\TerminalServer\" /v AllowRemoteRPC /d 0x01 /t REG_DWORD /freg add \"HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\" /v LocalAccountTokenFilterPolicy /d 0x01 /t REG_DWORD /f 5 参考 Cuckoo-Sandbox学习-安装篇 Ubuntu20.04系统Cuckoo sandbox所需环境搭建及安装(超详细图文)","categories":[{"name":"环境与工具","slug":"环境与工具","permalink":"https://Dragonliu2018.github.io/categories/环境与工具/"},{"name":"安全","slug":"安全","permalink":"https://Dragonliu2018.github.io/categories/安全/"}],"tags":[]},{"title":"示例-《xxx》纪录片","slug":"示例-《xxx》纪录片","date":"2022-01-21T15:12:43.000Z","updated":"2022-01-21T15:13:01.996Z","comments":true,"path":"2022/01/21/示例-《xxx》纪录片/","link":"","permalink":"https://Dragonliu2018.github.io/2022/01/21/示例-《xxx》纪录片/","excerpt":"","text":"Life is painting a picture, not doing a sum.","categories":[{"name":"影视","slug":"影视","permalink":"https://Dragonliu2018.github.io/categories/影视/"}],"tags":[{"name":"示例","slug":"示例","permalink":"https://Dragonliu2018.github.io/tags/示例/"},{"name":"纪录片","slug":"纪录片","permalink":"https://Dragonliu2018.github.io/tags/纪录片/"}]},{"title":"《乡村爱情系列》电视剧","slug":"《乡村爱情系列》电视剧","date":"2022-01-21T15:11:41.000Z","updated":"2022-02-12T06:50:57.690Z","comments":true,"path":"2022/01/21/《乡村爱情系列》电视剧/","link":"","permalink":"https://Dragonliu2018.github.io/2022/01/21/《乡村爱情系列》电视剧/","excerpt":"","text":"Life is painting a picture, not doing a sum. 1 乡村爱情（2006） 1.1 影片信息 片名：乡村爱情 又名：Rural Love Story 导演：张惠中 编剧：张继 主演：赵本山/范伟/王亚彬/于月仙/唐鉴军/王小利/贺树峰 播出：CCTV1 首播：2006-09-30（中国大陆） 类型：喜剧/剧情/爱情 集数：30 每集：45分钟 地区：中国大陆 语言：汉语普通话 1.2 剧情简介 乡村青年谢永强（贺树峰 饰）是个林业大学毕业生，回乡待业期间和同村女孩王小蒙（王亚彬 饰）谈起恋爱，但遭到父亲谢广坤（唐鉴军 饰）强烈反对，引起一直希望儿子出人头地，而王小蒙父亲王老七（蔡维利 饰）听闻此事倍感自尊受伤，也表态不许女儿嫁给谢永强。两个年轻人爱情遭遇阻挠，尚有村长女儿香秀（王君平 饰）适时表达对谢永强的爱慕，为了未来工作，谢永强在家人干涉下阴差阳错与香秀定了亲，那边厢王小蒙也受到村养殖场场长刘一水（闫光明 饰）和邻居赵玉田（吴云飞 饰）的追求。怎料工作分配结果下来，谢永强最终没有分到城里，一心想通过他当上城里人的香秀很失望，就此疏远了他，王小蒙和他重新拾起了感情，二人开始脚踏实地开发山里林果基地，怎料县里的录取通知书又突然到来…… 2 乡村爱情Ⅱ（2008） 2.1 影片信息 片名：乡村爱情Ⅱ 又名：乡村爱情2 导演：赵本山 编剧：张继 主演：赵本山/贺树峰/王亚彬/于月仙/小沈阳/王小宝/王小利/唐鉴军/蒋依杉/吴云飞/王君平/蔡维利/刘小光 首播：2008-02-10（中国大陆） 类型：喜剧 集数：41 每集：42分钟 地区：中国大陆 语言：汉语普通话 2.2 剧情简介 在第二部里，象牙山村中的年轻人们找到了各自事业的方向，不过他们的爱情却有一波三折。 王小蒙（王亚彬 饰）的豆腐厂上线，每天忙里忙外，不得清闲。谢永强（贺树峰 饰）则专注自己的果园，和小蒙几天都见不上一面。两个孩子忙事业始终推迟婚期，急坏永强的父亲谢广坤（唐鉴军 饰）；赵玉田（吴云飞 饰）和刘英（蒋依杉 饰）结婚后，开始忙于花圃的经营。来村中实习的女大学生陈艳南吸引了赵玉田的注意，刘英大吃其醋，无事忙刘能（王小利 饰）对女婿的做法也颇为不满；香秀（王君平 饰）迎来了新同事王天来（小沈阳 饰），李大国（王小虎 饰）担心嫉妒，从中作梗。王天来单恋陈艳南，又和赵玉田矛盾不断；长贵（王小宝 饰）一方面想吸引王大拿（赵本山 饰）来村里投资，一方面又怕谢大脚（于月仙 饰）被大拿抢走，他和大脚之间若即若离，忽冷忽热，闹出不少笑话。 矛盾归矛盾，误会归误会，所幸有情人终成眷属，象牙山的青年男女最终得到属于自己的幸福…… 3 乡村爱情故事（2010） 3.1 影片信息 片名：乡村爱情故事 又名：乡村爱情3/乡村爱情Ⅲ/乡村爱情Ⅲ前传 导演：赵本山/徐正超 编剧：张继 主演：于月仙/小沈阳/王小利/刘小光/赵本山/刘流/贺树峰/王小宝/毕畅 播出：CCTV1 首播：2010-02-16（中国大陆） 类型：喜剧 集数：36 每集：41分钟 地区：中国大陆 语言：汉语普通话 3.2 剧情介绍 自从象牙山的有情人们终成眷属之后，这个小小的山村发生了巨大的变化：王大拿（赵本山 饰）的王氏集团决定在此投资，谢永强（贺树峰 饰）担任投资工程的副总，却和刘大脑袋（刘流 饰）发生不和；王小蒙（毕畅 饰）的豆腐厂越做越大，开始考虑和上海的大企业合作；刘能（王小利 饰）撺掇老四（刘小光 饰）上镇上告长贵（王小宝 饰）的状，惹出了一堆笑话；赵玉田（吴云飞 饰）收心敛性开始好好过日子，而刘英则凭借怀孕的优势在赵家的地位陡然提升；谢广坤（唐鉴军 饰）陪儿媳妇去了一趟上海，不仅学得一口蹩脚的上海话，还迷上了对方公司的主管；刘一水专心自己的畜牧场，而老婆却希望他出任象牙山村的村主任…… 新的一年，新的故事，在这个我们熟悉的山村继续上演…… 4 乡村爱情交响曲（2011） 4.1 影片信息 片名：乡村爱情交响曲 又名：乡村爱情第四部/乡村爱情4 导演：徐正超 编剧：张继 主演：赵本山/贺树峰/毕畅/小沈阳/吴云飞/于月仙/王小宝/闫光明/王小利/唐鉴军/蔡维利/蒋依杉/王小虎/关婷娜/刘流 首播：2011-05-05（中国大陆） 类型：剧情/喜剧 集数：37 每集：45分钟 地区：中国大陆 语言：汉语普通话 4.2 剧情介绍 象牙山村的故事继续上演：谢兰和皮长生喜得贵子，美坏了外公谢广坤（唐鉴军 饰），整天抱着孩子招摇过市，这便急煞了刘能（王小利 饰）和赵四（刘小光 饰）。为早日实现传宗接代的大业，赵四将玉田（吴云飞 饰）和刘英（蒋依杉 饰）关在屋里，一门心思造人；广坤得意的同时，又给永强（贺树峰 饰）和小蒙（毕畅 饰）施加压力，逼他们早日要孩子，结果是纷争连连，也让相爱的两人心生离析；长贵（王小宝 饰）事业一帆风顺，升任水利站站长，由此变得有些飘飘然，开始想尽一切办法大拍齐镇长马屁，反而弄巧成拙。 此外，王天来（小沈阳 饰）、王大拿（赵本山 饰）、刘大脑袋（刘流 饰）、刘一水……各自有着各自的故事，有着各自的喜怒哀乐…… 5 乡村爱情小夜曲（2012） 5.1 影片信息 片名：乡村爱情小夜曲 又名：乡村爱情5 导演：赵本山/徐正超 编剧：张继 主演：赵本山/毕畅/贺树峰/王小利/于月仙/唐鉴军/王小宝/刘小光//蔡维利/刘流/蒋依杉/吴云飞/王小虎/王君平/小沈阳 播出：山东卫视 首播：2012-01-27（中国大陆） 类型：喜剧 集数：44 每集：44分钟 地区：中国大陆 语言：汉语普通话 5.2 剧情介绍 新的一年来到，我们熟悉的象牙山村发生了许许多多令人耳目一新的变化。家家户户用上了电脑，与外界的联系更为紧密；服装和潮流紧跟时代的步伐，村民们更潮了；大脚超市规模扩大，俨然正“做大做强”。就在红火生活的另一边，人们的烦恼又徒然增多。谢大脚（于月仙 饰）和长贵（王小宝 饰）因苏玉红的存在矛盾不断，婚姻走向破裂；谢广坤（唐鉴军 饰）看着刘能即将抱上外孙心急火燎，于是试图拆散小蒙（毕畅 饰）和永强（贺树峰 饰）的婚姻；王大拿（赵本山 饰）本好心帮大脚夫妇结尾，谁曾想惹来杨小燕猜忌；刘能则和赵四为了外孙展开连番较量。 新的喜悦，新的烦恼，穿插在象牙山村可爱的村民之间…… 6 乡村爱情变奏曲（2013） 6.1 影片信息 片名：乡村爱情变奏曲 又名：乡村爱情6 导演：刘流/周英男 编剧：张继 主演：赵本山/刘小光/唐鉴军 / 贺树峰/毕畅/ 于月仙/刘流/ 王小利/ 蒋依杉/吴云飞/ 王小宝/葛珊珊/闫光明/杜肖雄 / 蔡维利/ 王小虎 / 王君平 /孟令宇/ 李琳/ 王晓曦/ 金玫玫/ 吴一迪/金鸿鸣/关婷娜/ 王卓/ 董三毛/付小兰/赵海燕/王小华 / 孙立荣/ 筱素清/ 张小飞 /高贺迪 首播：2013-02-12（中国大陆） 类型：剧情 集数：50 地区：中国大陆 语言：汉语普通话 6.2 剧情介绍 新的一年，象牙村百姓们平凡而有趣的故事如期上演。饱受家庭、事业危机困扰的长贵（王小宝 饰）否极泰来，因见义勇为重新获得了村民的尊敬和领导的信任，一时间有点飘飘然；山庄上，刘大脑袋（刘流 饰）欲擒故纵，成功从王大拿（赵本山 饰）手中得权，并好好整治了好高骛远的王天来（小沈阳 饰）；不小心流产的王小蒙（毕畅 饰），得到蒙在鼓里的谢广坤（唐鉴军 饰）无微不至的照顾，心中充满不安的她与永强的关系似乎也悄悄发生变化；徐会计扶正支书职务，赵玉田（吴云飞 饰）也勉为其难担任村主任，胸怀大志的一群人外出考察，却将骗子带回象牙村。 除此之外，还有我们熟悉的刘能、老四、香秀等等，各自上演引人入胜的小故事…… 7 乡村爱情圆舞曲（2014） 7.1 影片信息 片名：乡村爱情圆舞曲 又名：乡村爱情7 导演：刘流/周英男 编剧：张继 主演：王小利/赵本山/毕畅/小沈阳 播出：山东/江苏/天津/辽宁/黑龙江卫视 首播：2014-02-03（中国大陆） 类型：喜剧/爱情 集数：66 地区：中国大陆 语言：汉语普通话 7.2 剧情介绍 新的一年，象牙山村悲欢离合的故事继续上演。长贵（王小虎 饰）为救小梁溺水身亡，愧疚满怀的小梁执意要认大脚当干妈。大脚悲伤挠头之余，还不得不一次次张罗给青莲介绍对象的事。谢广坤（唐鉴军 饰）一直为孙子大业发愁，眼瞅着小蒙生育无望，他想出抱养的点子。抱了外孙女的刘能（王小利 饰）趾高气昂，时不时调侃老四（刘小光 饰）和广坤，还为竞选理事会长大费周章。山庄那里也不闲着，保安队长晓峰自信心膨胀，令刘大脑袋（刘流 饰）和王大拿（赵本山 饰）焦头烂额，而久未露面的王木生（田娃 饰）突然回归，又使得山庄的权力斗争和家族内务波谲云诡…… 所有人的命运都发生着变化，他们的生活将呈现怎样的格局？ 8 乡村爱情浪漫曲（2015） 8.1 影片信息 片名：乡村爱情浪漫曲 又名：乡村爱情8/Country Love Romance 导演：孟令宇 编剧：张继 主演：赵本山/毕畅/吴云飞/王小利/刘小光 播出：腾讯视频 首播：2015-12-11（中国大陆） 类型：剧情/喜剧 集数：65 每集：40 地区：中国大陆 语言：汉语普通话 8.2 剧情介绍 风光秀美的象牙山又迎来了极其闹腾的一年。嘚嘚瑟瑟的谢广坤（唐鉴军 饰）祖坟冒了青烟，王小蒙（毕畅 饰）居然给他生了龙凤胎孙伙计，这可把广坤时刻想要显摆的心美坏了，他大张旗鼓要搞庆祝，这期间却忽略了腾飞的感受。广坤的死对头刘能（王小利 饰）看在眼里，气在心头，一门心思地要干帮超，将希望全都寄托在闺女刘英的肚皮上。亲家赵四（刘晓光 饰）的生意越做越红火，眼瞅着就不把刘能放在眼里了，新的矛盾由此产生。香秀即将迎来新生命，但她和李大国的婚姻却走向破裂边缘。新的政策出台，让山庄的效益直线下降，王大拿（赵本山 饰）发愁之际，后院似乎也见到了火苗子。 大大小小的人物，继续装点着他们各自的人生…… 9 乡村爱情进行曲（2017） 9.1 影片信息 片名：乡村爱情进行曲 又名：乡村爱情9 导演：孟令宇/付滃 编剧：张继 主演：赵本山/ 贺树峰/ 毕畅/ 唐鉴军/ 金玫玫/ 周弋楠/小沈阳 /王小利/ 刘小光/于月仙/ 蔡维利/王小虎 播出：腾讯视频 首播：2017-02-01（中国大陆） 类型：剧情/喜剧 集数：60 每集：45 地区：中国大陆 语言：汉语普通话 9.2 剧情介绍 象牙山村的成绩不太理想，徐支书很头疼。村民得知香秀和马忠经常吵架以为马忠欺负香秀了，受过长贵恩惠的徐支书听闻此事，带着村民找马忠评理。镇里觉得徐支书做法过激，撤掉他职务并委派一位“第一书记”主持村里工作。第一书记到来，做了三件事—— 重新选村主任，扶植小蒙豆腐厂为村办企业标杆以及带领村民网上销售农副产品。而大脚遇到了长得和长贵一样的外村大夫王福根并展开了追求，在村民的帮助下，福根终于同意在象牙山村生活，并带来了长得俊俏一儿一女，引起了村民的骚动。晓燕怀孕了，大拿在木生的唆使下，对孩子的身世产生怀疑，晓燕伤心不已。在村民共同努力下，宋晓峰当上了村主任并让象牙山村重回优秀村的行列；刘能和玉田的电商生意如火如荼；永强在大家的帮助下站了起来；大拿和晓燕重归于好；象牙山在一片欣欣向荣的景象中迎接新年。 10 乡村爱情协奏曲（2018） 10.1 影片信息 片名：乡村爱情协奏曲 又名：乡村爱情10 导演：付滃/孟令宇 编剧：张继 主演：毕畅/ 贺树峰/ 唐鉴军/ 王小利/ 刘小光 / 蔡维利/ 于月仙/赵本山/ 关婷娜/刘流/王小宝/王小虎/宋晓峰/田娃/闫光明/ 蒋依杉/吴云飞 / 王君平/ 金玫玫/ 周弋楠/ 付滃/ 赵海燕/毛毛/ 曹桐睿 播出：腾讯视频 首播：2018-02-05（中国大陆） 类型：剧情/喜剧 集数：60 每集：45 地区：中国大陆 语言：汉语普通话 10.2 剧情介绍 该剧本季主要围绕象牙山年轻人的婚恋故事展开，刘能、谢广坤携手成立“大龄青年婚姻理事会”，为解决大龄青年单身问题出谋划策，却闹出一系列嘀笑皆非的故事。 11 乡村爱情11（2019） 11.1 影片信息 片名：乡村爱情11 又名：乡村爱情11狂欢曲 导演：付滃/孟令宇 编剧：李海兵/杨景标 主演：赵本山/ 狄龙/ 毕畅/ 贺树峰/ 王小利/ 刘小光/唐鉴军/ 宋晓峰/蔡维利/ 于月仙/ 马心怡/闫光明/ 唐娜 播出：优酷 首播：2019-01-26（中国大陆） 类型：剧情/喜剧/爱情 集数：60 每集：45 地区：中国大陆 语言：汉语普通话 11.2 剧情介绍 《乡村爱情11》于2019年1月26日优酷全网独播，每周一至周六早上10:00更新。本剧讲述了以刘能、广坤、赵四为首的象牙山村民在新时代背景下，就“精准扶贫”“招商引资”等国家惠农政策的误解，与新到任大学生村官杜小双以及到象牙山投资的神秘富豪，发生的一系列依旧搞笑无解的故事。 12 乡村爱情12（2020） 12.1 影片信息 片名：乡村爱情12 又名：乡村爱情第十二部 导演：付滃/孙博 编剧：何庆魁/李海兵 主演：赵本山/ 毕畅/ 贺树峰/ 王小利/ 刘小光/唐鉴军/曹桐睿/ 宋晓峰/蔡维利/ 于月仙/ 马心怡/闫光明/ 唐娜 播出：优酷 首播：2020-01-25（中国大陆） 类型：喜剧/爱情 集数：60 每集：42 地区：中国大陆 语言：汉语普通话 12.2 剧情介绍 镇里新派来的女村官杜小双和刘一水承担起了建设生态新农庄的重任，二人一路磕磕碰碰，即将修成正果之时刘一水却意外查到得了慢性胰腺炎，最终拒绝杜小双追求独自进了手术室，一水的手术是否顺利，他和杜小双的结局究竟如何。富二代李成继承公司后续情感线又将走向何处。被挖墙角的大拿狗场又将面临怎样的局面。象牙山F4，刘能、赵四、谢广坤、王老七又将上演什么样的相爱相杀。 13 乡村爱情13（2021） 13.1 影片信息 片名：乡村爱情13 导演：付滃/孟令宇 主演：赵本山/ 倪大红/ 唐鉴军/刘小光/ 田娃/ 毕畅/贺树峰/于月仙/蒋依杉/吴云飞/曹桐睿/马心怡/赵海燕/孙立荣/赵明远/刘流/高赫迪/张小伟 / 董三毛/金鸿鸣/ 付滃/ 蔡维利/魏欣宇/筱素清/王小宝 /张小飞/关婷娜/王小华 / 葛珊珊/ 王悦/陈爽/ 王小虎/王君平/闫光明/ 金玫玫/ 燕飞/张可/ 曹兴/ 霍云龙 播出：优酷 首播：2021-02-16（中国大陆） 类型：喜剧/爱情 集数：40 每集：45 地区：中国大陆 语言：汉语普通话 13.2 剧情介绍 为搭乘“线上经济”的快车，象牙山又刮起强劲的“网络风”。谁能想到王大拿与杨晓燕的婚烟会隔着手机屏拉警报？而F4组合谢广坤、刘能、赵四和王老七趁机也起幺蛾子，王小蒙和刘英难免又入坑。宋富贵和宋晓峰互使连环套，哪是翁婿？分明是冤家。小山村里锅边炕沿的故事又会带给我们怎样的欢乐？ 14 乡村爱情14（2022） 14.1 影片信息 片名：乡村爱情14 导演：付滃/孟令宇 编剧：李海兵 主演：唐鉴军/王小利/ 刘小光 / 宋晓峰/ 倪大红 / 蔡维利/ 毕畅/ 贺树峰/田娃/ 关婷娜/ 曹桐睿/蒋依杉/吴云飞/赵海燕/ 孙立荣 /马心怡/刘流/张小伟/董三毛 / 付翁/ 王小宝/ 张小飞/闫光明/孟令宇 播出：优酷 首播：2022-01-24（中国大陆） 类型：喜剧/爱情 集数：40 每集：45 地区：中国大陆 语言：汉语普通话 14.2 剧情介绍 淘宝直播基地的建成，无疑为已踏入小康的象牙山，又翻开了新的篇章。过了色彩斑斓的深秋，就会迎来白雪皑皑的冬季，市里提出了“打造乡村冬季生态游”的号召，大学生村官杜小双积极响应，决定举办“舌尖上的象牙山”。为充分调动大家参与的积极性，并在对外宣传上造势，宣布“冠军”奖金十万。 X 解说 刘老师说电影","categories":[{"name":"影视","slug":"影视","permalink":"https://Dragonliu2018.github.io/categories/影视/"}],"tags":[{"name":"电视剧","slug":"电视剧","permalink":"https://Dragonliu2018.github.io/tags/电视剧/"}]},{"title":"示例-《城南旧事》电影","slug":"示例-《城南旧事》电影","date":"2022-01-21T15:10:36.000Z","updated":"2022-01-21T15:11:12.016Z","comments":true,"path":"2022/01/21/示例-《城南旧事》电影/","link":"","permalink":"https://Dragonliu2018.github.io/2022/01/21/示例-《城南旧事》电影/","excerpt":"","text":"Life is painting a picture, not doing a sum.","categories":[{"name":"影视","slug":"影视","permalink":"https://Dragonliu2018.github.io/categories/影视/"}],"tags":[{"name":"示例","slug":"示例","permalink":"https://Dragonliu2018.github.io/tags/示例/"},{"name":"电影","slug":"电影","permalink":"https://Dragonliu2018.github.io/tags/电影/"}]},{"title":"示例-旅行","slug":"示例-旅行","date":"2022-01-21T15:08:44.000Z","updated":"2022-01-21T15:09:34.611Z","comments":true,"path":"2022/01/21/示例-旅行/","link":"","permalink":"https://Dragonliu2018.github.io/2022/01/21/示例-旅行/","excerpt":"","text":"Life is painting a picture, not doing a sum.","categories":[{"name":"旅行","slug":"旅行","permalink":"https://Dragonliu2018.github.io/categories/旅行/"}],"tags":[{"name":"示例","slug":"示例","permalink":"https://Dragonliu2018.github.io/tags/示例/"}]},{"title":"示例-《你是人间的四月天》歌曲","slug":"示例-《你是人间的四月天》","date":"2022-01-21T14:38:55.000Z","updated":"2022-01-22T13:12:41.105Z","comments":true,"path":"2022/01/21/示例-《你是人间的四月天》/","link":"","permalink":"https://Dragonliu2018.github.io/2022/01/21/示例-《你是人间的四月天》/","excerpt":"","text":"1 简介 「——你是爱，是暖， 是希望，你是人间的四月天！」 草长莺飞的四月，李宇春受大型诗词音乐文化节目《经典咏流传》邀请，将于央视一套演绎林徽因经典名作《你是人间的四月天》。通过诗歌和音乐，遥望并呼应85年前林徽因笔下的春深光景，用温柔嗓音传递恒久的美与爱。 在歌曲创作阶段，李宇春用一个多月的时间浏览相关书籍和影像，对创作者背景和时代风貌进行了详细调研，从众多经典诗词中选择《你是人间的四月天》进行演绎，并邀请音乐人彭青为这首诗词谱曲。两位女性音乐人以敏锐而温柔的视角，还原并呈现了诗歌的韵律与意象，将春日的轻灵喜悦和诗歌的东方之美进行了生动表达。 歌曲将丰盛藏于淡泊，乍听水波不兴，细节却暗藏波澜。虽然是经典的中文诗歌，编曲上却并未过多使用中国乐器元素，仅用五声调式钢琴和弦乐突显诗歌韵脚，酝酿出清丽的氛围。李宇春则用轻如呢喃的演唱方式，将「雪化后那片鹅黄」 「新鲜初放芽的绿」等春天意象，唱得格外柔软。 作为一名具有先锋态度的音乐人，同时也是一位不断探索音乐、艺术、时尚等领域多元文化价值的当代女性，李宇春与终其一生传递美的价值的林徽因一样，在自我内化和丰富的同时，凭借旺盛的生命力和开阔的视野，在各领域中勇敢地创新美的表达，延展美的样态，自由地传递一种生动而有力量的美感。 2 歌手 李宇春（英语：Chris Li Yu-chun，1984年3月10日－），出生于中国四川成都，为中国大陆女歌手、词曲创作人、电影演员、演唱会导演。 百度百科 维基百科 3 歌词 你是人间的四月天 (Live) - 李宇春 词：林徽因 曲：彭青 编曲：郑楠 演唱：李宇春 音乐总监：刘卓 乐团：V Band 弦乐：靳海音®弦乐团 混音：周天澈 混音团队 我说你是人间的四月天 笑响点亮了四面风 轻灵在春的光艳中 交舞着变 你是四月早天里的云烟 黄昏吹着风的软 星子在无意中闪 细雨点洒在花前 那轻 那娉婷 你是 鲜妍百花的冠冕 你戴着 你是天真是庄严 你是夜夜的月圆 雪化后那片鹅黄 你像 新鲜初放芽的绿 你是 柔嫩喜悦 水光浮动着你梦 浮动着你梦期待中白莲 雪化后那片鹅黄 你像 新鲜初放芽的绿 你是 柔嫩喜悦 水光浮动着你梦 浮动着你梦期待中白莲 你是四月早天里的云烟 黄昏吹着风的软 星子在无意中闪 细雨点洒在花前 那轻 那娉婷 你是 鲜妍百花的冠冕 你戴着 你是天真是庄严 你是夜夜的月圆 雪化后那片鹅黄 你像 新鲜初放芽的绿 你是 柔嫩喜悦 水光浮动着你梦 浮动着你梦期待中白莲 雪化后那片鹅黄 你像 新鲜初放芽的绿 你是 柔嫩喜悦 水光浮动着你梦 浮动着你梦期待中白莲 你是一树一树的花开 是燕在梁间呢喃 你是爱 是暖 是希望 你是人间的四月天 4 自评 xxx 5 他评 四月春风，余味隽永。女中音把林徽因的词演绎得柔美而鲜活，听者微醺。以情带声是本事，她的声线是上天赐予的礼物。 —— 引自 豆瓣 espionage 人间四月芳菲尽，山寺桃花始盛开。人生悲欢有各自缘法，不要喟叹于眼前的春光消逝，心怀旷达，自然会在别处看见更旖旎的风光和更广阔的天地。 —— 引自 QQ音乐 陌离","categories":[{"name":"音乐","slug":"音乐","permalink":"https://Dragonliu2018.github.io/categories/音乐/"}],"tags":[{"name":"示例","slug":"示例","permalink":"https://Dragonliu2018.github.io/tags/示例/"}]},{"title":"摘抄第一章","slug":"示例-摘抄","date":"2022-01-21T14:27:39.000Z","updated":"2022-02-12T04:43:23.259Z","comments":true,"path":"2022/01/21/示例-摘抄/","link":"","permalink":"https://Dragonliu2018.github.io/2022/01/21/示例-摘抄/","excerpt":"","text":"Life is painting a picture, not doing a sum. —— 引自 网络 上山的人不要嘲笑下山的人，因为他们也曾风光无限。 —— 引自 B站","categories":[{"name":"阅读","slug":"阅读","permalink":"https://Dragonliu2018.github.io/categories/阅读/"}],"tags":[{"name":"摘抄","slug":"摘抄","permalink":"https://Dragonliu2018.github.io/tags/摘抄/"}]},{"title":"《俗世奇人全本》书籍","slug":"《俗世奇人全本》书籍","date":"2022-01-21T14:01:48.000Z","updated":"2022-01-29T08:15:26.922Z","comments":true,"path":"2022/01/21/《俗世奇人全本》书籍/","link":"","permalink":"https://Dragonliu2018.github.io/2022/01/21/《俗世奇人全本》书籍/","excerpt":"","text":"1 简介 天津卫本是水陆码头，居民五方杂处，性格迥然相异。然燕赵故地，血气刚烈；水咸土碱，风习强悍。近百余年来，举凡中华大灾大难，无不首当其冲，因生出各种怪异人物，既在显耀上层，更在市井民间。故而随想随记，始作于今；每人一篇，各不相关，冠之总名《俗世奇人》耳。 2019年，冯骥才先生又创作了18篇“俗世奇人”新作，现集成《俗世奇人全本》,呈现给读者完整的54篇“俗世奇人”系列，并收录冯骥才先生亲自手绘的58幅生动插图。 自上世纪九十年代至今，冯骥才先生先后创作了五十四篇“俗世奇人”系列短篇小说。其风格统一、传奇色彩浓郁、充满生活气息、人物形象活灵活现，书写了清末民初天津卫的地域风貌、风土人情、生活风尚，也展现出我国民间文化的精巧技艺与其中蕴藏的智慧。 2 作者 冯骥才，浙江宁波慈溪人，1942年2月9日生于天津，作家、画家。 早年在天津从事绘画工作，后专职文学创作和民间文化研究。 百度百科 维基百科 3 摘抄 酒的诀窍，还是在酒缸里。老板人奸，往酒里掺水。酒鬼们对眼睛里的世界一片模糊，对肚子里的酒却一清二楚，但谁也不肯把这层纸捅破，喝美了也就算了。老板缺德，必得报应，人近六十，没儿没女，八成要绝后。可一日，老板娘爱酸爱辣，居然有喜了老板给佛爷叩头时，动了良心，发誓今后老实做人，诚实卖酒，再不往酒里掺水掺假了。 就是这日，酒婆来到这家小酒馆，进门照例还是掏出包儿来，层层打开，花钱买酒，举手扬脖，把改假为真的“炮打灯”倒进肚里……真货就有真货色。这次酒婆还没出屋，人就转悠起来了。而且今儿她一路上摇晃得分外好看，上身左摇，下身右摇，愈转愈疾，初时赛风中的大鹏鸟，后来竟赛一个黑黑的大漩涡首善街的人看得惊奇，也看得纳闷，不等多想，酒婆已到路口，竟然没有酒醒，破天荒头一遭转悠到大马路上，下边的惨事就甭提了…… 自此，酒婆在这条街上绝了迹。小酒馆里的人们却不时念叨起她来。说她才算真正够格的酒鬼。她喝酒不就菜，照例一饮而尽，不贪解馋，只求酒劲。在酒馆既不多事，也无闲话，交钱喝酒，喝完就走，从来没赊过账。真正的酒鬼，都是自得其乐，不搅和别人。 老板听着，忽然想到，酒婆出事那日，不正是自己不往酒里掺假的那天吗？原来祸根竟在自己身上他便别扭开了，心想这人间的道理真是说不清道不明了。到底骗人不对，还是诚实不对？不然为嘛几十年拿假酒骗人，却相安无事，都喝得挺美，可一旦认真起来反倒毁了？ —— 引自 酒婆 “你以为人家的名气全是虚的？那你是在骗自己。好好学本事吧！” —— 引自 刷子李 杨巴的脑筋飞快地一转两转三转，主意来了！只见他脑袋撞地，“咚咚咚”叩得山响，一边叫道：“中堂大人息怒！小人不知道中堂大人不爱吃压碎的芝麻粒，惹恼了大人。大人不记小人过，饶了小人这次，今后一定痛改前非！”说完又是一阵响头。 自此，杨巴在天津城威名大震。那“杨家茶汤”也被人们改称作“杨巴茶汤”了。杨七反倒渐渐埋没，无人知晓。杨巴对此毫不内疚，因为自己成名靠的是自己一张好嘴，李中堂并没有喝茶汤呀 —— 引自 好嘴杨巴 再看信封，照片竟卡在里边，他捏住照片抻出来一瞧，有点别扭，不大对劲，他再细瞧，竟傻了。那老美倒是站在他那字的前边照了相，可是字儿却挂倒了，全朝下了！ —— 引自 青云楼主 能人全都死在能耐上。 —— 引自 大回 他等着院里的人一个个走出来，却一直没等到她出来。他有点心急。 直到院静人空。一个守门的老人出来关大门时，木头上去问，刚刚那个演白娘子的人呢，怎么没见她出来。 守门人说：“最后出来的一个就是呀。” 木头很诧异，说：“那是个瘦高结实的汉子，穿青布袄。” 守门人说：“正是。” 木头更诧异，说：“怎么是个男的？我说的是白娘子——女的！” 守门人一听一怔，随后笑道：“我们高跷会从来不准女人入会。演女的，全是男扮女装。” —— 引自 跟会 那你这就不明白了，人的腻歪都是不愁日子不愁钱——闲出来的。穷了犯愁，富了才会腻歪。 —— 引自 腻歪 4 自评 这本书第一次读还是在高中，转眼间，现在大四了。 本文文字精简利落，半文半百，读起来并不晦涩。冯骥才将津味融入字里行间，如句子中带“嘛”，或者将“胜过”说成“赛”；其次作者的语言中带有天津特有的幽默，读起来有如在听相声。 在俗世俗人俗事间向读者传递一些人生道理：如酒婆之死、刷子李中的“你以为人家的名气全是虚的？那你是在骗自己。好好学本事吧！”、大回中的能人全都死在能耐上。等等。 《刷子李》、《好嘴杨巴》、《泥人张》被选入义务教育课程标准实验教材语文书。目前还没有影视作品的拓展，感觉拍成情景式短剧可能不错，人人都是主角。下面评论中提到了做成卡牌类手游，想法新颖。 5 他评 笔记体的天津的市井风俗与奇人群像。不知道为何会想到可以做一款卡牌类手游，就叫《大天津》 —— 引自 豆瓣 RO 《俗世奇人》| 人间烟火处见大雅 说书人于台上鲜活热闹，角儿们一个个穿着长袍马褂，举着酒盏、嬉笑着眉眼摇身登场，刹那间便驻足了一个时代。 《俗世奇人》一书以清末民初天津卫为背景，讲述了一十九个绝技与风骨并存的码头人物生平。卷轴缓缓展开，张大力丢下石锁大笑离去，北地豪气快哉纸上；苏七块挥起袖子接筋续骨，规矩不动然医道不改；刷子李、风筝魏、泥人张凭借精到手艺博得满堂彩，站在大街中央吃荤、亮堂；好嘴杨巴叩头佯罪，巧妙化解不识芝麻粒的李中堂的尴尬……想来世事洞明皆学问，人情练达即文章。 文如其人，文载其道；欲评其文，须先知其人。 冯骥才有此二身份：一乃民间艺术工作者，曾专职民间文化研究；二乃“文革”后崛起的“伤痕文学运动”代表作家，以“文化反思小说”影响文坛。 这两重身份带来了两种视角，两种视角深刻地渗透在了《俗世奇人》的文学内容与语言艺术之中。 大隐隐于市，大雅始于俗。此俗，乃民俗的俗。诗经首篇便是收录民歌的《国风》，俗世生活是一种别样的美，它蕴藏着原生态的力量与智慧。才子佳人素来为文人所道，读多了却尝到了种“为雅而雅”的拘谨刻意，于文学角度略显单薄。津门传说中的小人物则不同，无论是活出殡的刘道元，卖家产的蔡二少爷，还是干鸡鸣狗盗之事的小达子，看似上不得台面，却都因豁达质朴的性子与洋溢在灵魂中的坦诚智慧而鲜活灵动起来。“这些人空前绝后，却都是俗世里的俗人；这些事匪夷所思，却都是真人真事”，他们饱含着对生活的热爱和追求，嬉笑怒骂间定格为天津民俗画中一景，谱写了时代的大雅之章。 诚觉世人尽可爱，也觉世事尽可戏。世态炎凉在冯骥才笔下无伤春悲秋之造作，反而展现出原生态的赤裸裸的生命热情。众人皆知底层小人物生活辛酸艰难，他偏独辟蹊径，以善意、豁达的笔笑世间形形色色——这世道不公却不公得有趣，奇闻轶事显妙趣横生，皮囊下的灵魂们热闹繁华，每个人都未曾受到奚落。当今文学基调多悲观，彷若于严肃中才能看到生命的厚重，殊不知我们正是需要一种洒脱可爱、人生如戏的智慧；也唯有在这轻快智慧的基调上，我们才能寻觅到追求本我的勇气与力量。 窃以为经历文革动荡且怀有良知的作家可分两类，一类以沉重笔调记录黑色，一类跳脱出了时代，俯视中将昏暗看成了彩色。二者皆有思考与感悟，不论高下。于个人而言，我偏爱于后者——如王小波，如冯骥才。对时代与命运，他们是消极的，但他们选择了在消极的基调上热情快乐地活着，一如赤子。 《俗世奇人》中有一篇写酒婆：酒婆举手仰脖，将山芋干造的假酒一饮而尽，出门走路时赛在地上画天书，然从未出事；一天酒老板良心发现，做了真酒，酒婆出门便被撞死了。关于这个故事，冯骥才站在酒老板的角度，于结尾写道：“到底骗人不对，还是诚实不对？”我却更愿站在酒婆的角度看，这样一来，冯和酒婆便有了共通之处： 酒婆佯醉只求一时欢乐，辨不清骗人还是骗己；冯骥才以澄明轻快的心境回执过往不堪经历，又不知是否为“一晌贪欢”之举？快乐与痛苦本就分不清，既如此，那唯求它鲜活真实。 民国小影，旧时一瞥。书籍以白描入笔，半文半白，三言两拍。语言结实、神气、不拘泥，形象俏皮，颇具古典传奇色彩，风土人情味儿浓厚。对民俗语言的精准驾驭体现出冯骥才的深厚功力，这与他对民间文化的热爱与研究紧密相关。 后记里言：“倘若再写，算我无能。说不尽津门的爽利。” 《俗世奇人》通篇不过百页，故事性与文学性兼具，单个拎出便是说书人口中的一段风月，具有极高的文学艺术价值。其如下酒小菜，初见惊艳，吃罢，回味悠长。 —— 引自 豆瓣 ciel丫丫 6 拓展 是否被拍成影视作品？（无）","categories":[{"name":"阅读","slug":"阅读","permalink":"https://Dragonliu2018.github.io/categories/阅读/"}],"tags":[{"name":"书评","slug":"书评","permalink":"https://Dragonliu2018.github.io/tags/书评/"}]},{"title":"jupyter使用","slug":"jupyter使用","date":"2022-01-17T01:44:22.000Z","updated":"2022-01-21T13:28:01.888Z","comments":true,"path":"2022/01/17/jupyter使用/","link":"","permalink":"https://Dragonliu2018.github.io/2022/01/17/jupyter使用/","excerpt":"","text":"1 安装 打开cmd，使用pip进行安装： 1pip install jupyterlab 2 使用 cmd输入： 1jupyter-lab 在浏览器输入：http://localhost:8888/","categories":[{"name":"环境与工具","slug":"环境与工具","permalink":"https://Dragonliu2018.github.io/categories/环境与工具/"},{"name":"开发","slug":"开发","permalink":"https://Dragonliu2018.github.io/categories/开发/"}],"tags":[{"name":"python","slug":"python","permalink":"https://Dragonliu2018.github.io/tags/python/"}]},{"title":"matplotlib使用","slug":"matplotlib","date":"2022-01-17T01:44:22.000Z","updated":"2022-01-21T12:24:01.868Z","comments":true,"path":"2022/01/17/matplotlib/","link":"","permalink":"https://Dragonliu2018.github.io/2022/01/17/matplotlib/","excerpt":"","text":"1 基础知识 官方文档 画板figure，画纸Sublpot画质，可多图绘画 画纸上最上方是标题title，用来给图形起名字 坐标轴Axis，横轴叫x坐标轴label，纵轴叫y坐标轴ylabel 图例Legend 代表图形里的内容 网格Grid，图形中的虚线，True显示网格 点 Markers：表示点的形状。 2 绘图步骤 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#导入matplotlib的pyplot模块import matplotlib.pyplot as plt#1 基础绘图#第1步：定义x和y坐标轴上的点 x坐标轴上点的数值x=[1, 2, 3, 4]#y坐标轴上点的数值y=[1, 4, 9, 16]#第2步：使用plot绘制线条第1个参数是x的坐标值，第2个参数是y的坐标值plt.plot(x,y)#第3步：显示图形plt.show()#2 定义绘图属性'''color：线条颜色，值r表示红色（red）marker：点的形状，值o表示点为圆圈标记（circle marker）linestyle：线条的形状，值dashed表示用虚线连接各点'''plt.plot(x, y, color='r',marker='o',linestyle='dashed')#plt.plot(x, y, 'ro')'''axis：坐标轴范围语法为axis[xmin, xmax, ymin, ymax]，也就是axis[x轴最小值, x轴最大值, y轴最小值, y轴最大值]'''plt.axis([0, 6, 0, 20])plt.show()#3 给图片提阿甲注释和标题等#第1步：定义x和y坐标轴上的点 x坐标轴上点的数值x=[1, 2, 3, 4]#y坐标轴上点的数值y=[1, 4, 9, 16]#第2步：使用plot绘制线条 第1个参数是x的坐标值，第2个参数是y的坐标值plt.plot(x,y)#添加文本 #x轴文本plt.xlabel('x坐标轴')#y轴文本plt.ylabel('y坐标轴')#标题plt.title('标题')#添加注释 参数名xy：箭头注释中箭头所在位置，参数名xytext：注释文本所在位置，#arrowprops在xy和xytext之间绘制箭头, shrink表示注释点与注释文本之间的图标距离plt.annotate('我是注释', xy=(2,5), xytext=(2, 10), arrowprops=dict(facecolor='black', shrink=0.01), )#第3步：显示图形plt.show() 3 多图绘制 123456789101112131415161718192021222324252627282930313233343536373839404142434445# 柱形图fig, axs = plt.subplots(nrows=2, ncols=2, figsize=(20, 12), dpi=100)axs[0][0].set_title('HeatLoadLight')axs[0][0].set_xlabel('DateTime')axs[0][0].set_ylabel('LoadValue')axs[0][0].bar(range(12), list, fc='g')axs[0][1].set_title('HeatLoadHeavy')axs[0][1].set_xlabel('DateTime')axs[0][1].set_ylabel('LoadValue')axs[0][1].bar(range(12), list, fc='g')axs[1][0].set_title('CoolLoadLight')axs[1][0].set_xlabel('DateTime')axs[1][0].set_ylabel('LoadValue')axs[1][0].bar(range(12), list, fc='g')axs[1][1].set_title('CoolLoadHeavy')axs[1][1].set_xlabel('DateTime')axs[1][1].set_ylabel('LoadValue')axs[1][1].bar(range(12), list, fc='g')fig.autofmt_xdate()plt.show()# 折线图fig, axs = plt.subplots(nrows=1, ncols=2, figsize=(20, 6), dpi=100)axs[0].set_title('xxx')axs[0].set_xlabel('Hour')axs[0].set_ylabel('Value')axs[0].plot(range(168), Q_trans_light, c='red', label='Light')axs[0].plot(range(168), Q_trans_heavy, c='blue', label='Heavy')axs[0].legend(loc='best')axs[1].set_title(\"xxx\")axs[1].set_xlabel('Hour')axs[1].set_ylabel('Value')axs[1].plot(range(168), Q_trans_light, c='red', label='Light')axs[1].plot(range(168), Q_trans_heavy, c='blue', label='Heavy')axs[1].legend(loc='best')fig.autofmt_xdate()plt.show()","categories":[{"name":"环境与工具","slug":"环境与工具","permalink":"https://Dragonliu2018.github.io/categories/环境与工具/"},{"name":"开发","slug":"开发","permalink":"https://Dragonliu2018.github.io/categories/开发/"}],"tags":[{"name":"python","slug":"python","permalink":"https://Dragonliu2018.github.io/tags/python/"}]},{"title":"python读取文件整理","slug":"读取文件","date":"2022-01-17T01:44:22.000Z","updated":"2022-02-09T08:01:49.708Z","comments":true,"path":"2022/01/17/读取文件/","link":"","permalink":"https://Dragonliu2018.github.io/2022/01/17/读取文件/","excerpt":"","text":"1 按行读取文本文件 1234file_path = 'xxx'with open(file_path) as f: for line in f.readlines(): print(line) open详解","categories":[{"name":"开发","slug":"开发","permalink":"https://Dragonliu2018.github.io/categories/开发/"}],"tags":[{"name":"python","slug":"python","permalink":"https://Dragonliu2018.github.io/tags/python/"}]},{"title":"Win10安装Ubuntu子系统","slug":"Win10安装Ubuntu子系统","date":"2021-10-27T01:44:22.000Z","updated":"2022-01-21T13:30:54.687Z","comments":true,"path":"2021/10/27/Win10安装Ubuntu子系统/","link":"","permalink":"https://Dragonliu2018.github.io/2021/10/27/Win10安装Ubuntu子系统/","excerpt":"","text":"0 情景导入 在Windows10 Home版操作系统下安装Linux子系统(WSL2)，用于轻量需求，方便快捷。 在微软商店内安装Linux子系统会默认安装到C盘，根据官方文档指示可以安装到其他盘（未成功）。 自定义Linux子系统，安装到非C盘。 1 安装WSL2（未成功） 微软WSL官方安装文档（中文） 微软WSL官方安装文档（英文） 1.1 启用Windows子系统功能 在安装子系统之前，启用Windows子系统功能，在Windows10的Powershell中输入： 1dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart 1.2 检查WSL2依赖是否满足 For x64 systems: Version 1903 or higher, with Build 18362 or higher. For ARM64 systems: Version 2004 or higher, with Build 19041 or higher. Builds lower than 18362 do not support WSL 2. Use the Windows Update Assistant to update your version of Windows. 检查Windows版本：win+R，输入winver 1.3 启用虚拟机功能 管理员模式打开Powershell： 1dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart 1.4 下载Linux内核更新包 下载最新安装包：跳转 点击安装上述的安装包 1.5 将 WSL 2 设置为默认版本 在Powershell中运行： 1wsl --set-default-version 2 1.6 安装Linux发行版 1.6.1 微软商店安装（只能安装在C盘） 1.6.2 命令行安装（可以安装在其他盘） cmd下，在自定义目录中下载： 1curl.exe -L -o ubuntu-1604.appx https://aka.ms/wsl-ubuntu-2004 安装： 1Add-AppxPackage .\\app_name.appx 但是出错： 123456789101112PS D:\\virtual_machine\\WSL\\Ubuntu&gt; Add-AppxPackage .\\Ubuntu2004.appxAdd-AppxPackage : 部署失败，原因是 HRESULT: 0x80073CF3, 包无法进行更新、相关性或冲突验证。从 (Ubuntu2004.appx) 使用程序包 CanonicalGroupLimited.Ubuntu20.04onWindows_2004.2020.424.0_x64__79rhkp1fndgsc 中的目标卷 C: 执行的部署 Add 操作失败，错误为 0x80073CF3。有关诊断应用部署问题的帮助，请参阅 http://go.microsoft.com/fwlink/?LinkId=235160。注意: 有关其他信息，请在事件日志中查找 [ActivityId] a0925605-afc5-0005-a072-92a0c5afd701，或使用命令行 Get-AppPackageLog -ActivityID a0925605-afc5-0005-a072-92a0c5afd701所在位置 行:1 字符: 1+ Add-AppxPackage .\\Ubuntu2004.appx+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : WriteError: (D:\\virtual_mach...Ubuntu2004.appx:String) [Add-AppxPackage], IOException + FullyQualifiedErrorId : DeploymentError,Microsoft.Windows.Appx.PackageManager.Commands.AddAppxPackageCommand 问题解决，应该是home版的windows有关，暂时没有解决。 2 安装自定义系统（成功） 微软WSL官方安装文档（中文） 安装后的问题： ping baidu.com反应慢，ping 8.8.8.8还可以 2.1 从容器中导出 tar 在Ubuntu虚拟机中进行操作： 123456789101112131415161718192021# 安装docker# https://www.runoob.com/docker/ubuntu-docker-install.htmlcurl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun# 启动 Docker 服务sudo service docker start# 下载指定系统镜像sudo docker pull registry.cn-hangzhou.aliyuncs.com/pwndocker/pwndocker-nocbtm:1.0# 查看系统镜像sudo docker images# 使用 ubuntu 镜像启动一个容器，参数为以命令行模式进入该容器sudo docker run -it ImageID /bin/bash# 启动容器sudo docker start ContainerID# 查看容器sudo docker ps -a# 进入容器sudo docker attach ContainerID# 使用 grep 和 awk 获取 CentOS 容器 IDdockerContainerID=$(sudo docker container ls -a | grep -i &#123;容器名称&#125; | awk '&#123;print $1&#125;')# 根据容器 ID 导出 tar 文件：sudo docker export $dockerContainerID &gt; ubuntu.tar 2.2 将 tar 文件导入 WSL 在Windows的powershell中操作： 12345678910# 在选定目录下导入 tar 文件： wsl --import &lt;DistroName&gt; &lt;InstallLocation&gt; &lt;InstallTarFile&gt;wsl --import Ubuntu .\\Ubuntu .\\ubuntu.tar# 检查已安装的子系统实例wsl -l -v# 启动Ubuntu子系统wsl -d Ubuntu# 停止Ubuntu子系统wsl --terminate Ubuntu #停止# 卸载Ubuntu子系统wsl --unregister Ubuntu 3 安装Terminus终端 Terminus下载安装，点击设置，修改Profiles，使得默认标签页打开wsl（Ubuntu） 将Tabby(Terminus)添加到右键打开： 123456789101112131415161718192021222324252627@echo offset ICON=D:\\software\\terminus\\soft\\Tabby\\Tabby.exe #改成自己的set LABEL=Open terminal hereset COMMAND=D:\\software\\terminus\\soft\\Tabby\\Tabby.exe \\\"%%V\\\" #改成自己的set SLUG=Terminalreg delete \"HKCU\\Software\\Classes\\Directory\\Background\\shell\\%SLUG%\" /freg delete \"HKCU\\Software\\Classes\\Directory\\shell\\%SLUG%\" /freg delete \"HKCU\\Software\\Classes\\Drive\\shell\\%SLUG%\" /freg delete \"HKCU\\Software\\Classes\\LibraryFolder\\Background\\shell\\%SLUG%\" /freg add \"HKCU\\Software\\Classes\\Directory\\Background\\shell\\%SLUG%\" /f /ve /t REG_SZ /d \"%LABEL%\"reg add \"HKCU\\Software\\Classes\\Directory\\Background\\shell\\%SLUG%\" /f /v \"Icon\" /t REG_SZ /d \"%ICON%\"reg add \"HKCU\\Software\\Classes\\Directory\\Background\\shell\\%SLUG%\\command\" /f /ve /t REG_SZ /d \"%COMMAND%\"reg add \"HKCU\\Software\\Classes\\Directory\\shell\\%SLUG%\" /f /ve /t REG_SZ /d \"%LABEL%\"reg add \"HKCU\\Software\\Classes\\Directory\\shell\\%SLUG%\" /f /v \"Icon\" /t REG_SZ /d \"%ICON%\"reg add \"HKCU\\Software\\Classes\\Directory\\shell\\%SLUG%\\command\" /f /ve /t REG_SZ /d \"%COMMAND%\"reg add \"HKCU\\Software\\Classes\\Drive\\shell\\%SLUG%\" /f /ve /t REG_SZ /d \"%LABEL%\"reg add \"HKCU\\Software\\Classes\\Drive\\shell\\%SLUG%\" /f /v \"Icon\" /t REG_SZ /d \"%ICON%\"reg add \"HKCU\\Software\\Classes\\Drive\\shell\\%SLUG%\\command\" /f /ve /t REG_SZ /d \"%COMMAND%\"reg add \"HKCU\\Software\\Classes\\LibraryFolder\\Background\\shell\\%SLUG%\" /f /ve /t REG_SZ /d \"%LABEL%\"reg add \"HKCU\\Software\\Classes\\LibraryFolder\\Background\\shell\\%SLUG%\" /f /v \"Icon\" /t REG_SZ /d \"%ICON%\"reg add \"HKCU\\Software\\Classes\\LibraryFolder\\Background\\shell\\%SLUG%\\command\" /f /ve /t REG_SZ /d \"%COMMAND%\" 4 配置oh-my-zsh zsh是一个Linux下强大的shell, 由于大多数Linux产品安装以及默认使用bash shell, 但是丝毫不影响极客们对zsh的热衷, 几乎每一款Linux产品都包含有zsh，通常可以用apt-get、urpmi或yum等包管理器进行安装。 zsh是bash的增强版，其实zsh和bash是两个不同的概念，zsh更加强大。 通常zsh配置起来非常麻烦，且相当的复杂，所以oh-my-zsh是为了简化zsh的配置而开发的，因此oh-my-zsh算是zsh的配置。 4.1 安装zsh 安装zsh 1apt install zsh -y 检查安装是否成功： 123456789cat /etc/shells# /etc/shells: valid login shells/bin/sh/bin/bash/bin/rbash/bin/dash/usr/bin/tmux/bin/zsh/usr/bin/zsh zsh设为默认shell，新开标签页生效 1chsh -s /bin/zsh 4.2 oh-my-zsh安装与配置 Ubuntu | 安装oh-my-zsh 安装： 123sh -c \"$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"# 或者sh -c \"$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)\" 出现安装报错： 1curl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused 解决： 如果科学上网应该不会出现此情况； 如果不能科学上网可以这样做： 打开网站: https://www.ipaddress.com/， 查询一下 raw.githubusercontent.com对应的IP 地址 在hosts文件中添加：sudo vim /etc/hosts 1199.232.28.133 raw.githubusercontent.com 主题使用robbyrussell，vim ~/.zshrc 安装插件： 1234567891011121314# 修改配置文件 vim ~/.zshrc## 添加内容plugins=(git zsh-autosuggestions zsh-syntax-highlighting autojump extract)# 解压插件，解压一个命令x全搞定extract # 不用安装# 安装autojump自动跳转插件apt install autojump# 安装zsh-autosuggestions语法历史记录插件git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions# 安装zsh-syntax-highlighting语法高亮插件git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $ZSH_CUSTOM/plugins/zsh-syntax-highlighting# 配置文件生效source ~/.zshrc","categories":[{"name":"环境与工具","slug":"环境与工具","permalink":"https://Dragonliu2018.github.io/categories/环境与工具/"}],"tags":[]},{"title":"物理机安装Ubuntu+Win10双系统","slug":"安装Ubuntu物理机(Win10+Ubuntu双系统)","date":"2021-10-27T01:44:22.000Z","updated":"2022-01-30T14:22:50.400Z","comments":true,"path":"2021/10/27/安装Ubuntu物理机(Win10+Ubuntu双系统)/","link":"","permalink":"https://Dragonliu2018.github.io/2021/10/27/安装Ubuntu物理机(Win10+Ubuntu双系统)/","excerpt":"","text":"0 情景导入 宿舍中闲置一台华硕电脑，为充分利用资源，装上Ubuntu系统(20.04)； 搭建开发环境，练习远程开发； 目前在局域网中即可满足需求，后续可能配置内网穿透。 1 制作启动U盘 1.1 准备工具 4G以上的U盘 启动U盘制作工具：Ubuntu官方推荐的Rufus Ubuntu系统镜像：官网；（清华源下载速度快） 1.2 制作U盘 运行Rufus，一般情况下，选择插入的U盘设备，和刚下载的Ubuntu镜像，其它保持默认即可开始U盘制作，等待制作完成即可。 2 磁盘分区 打开控制面板，找到磁盘管理； 如果整个卷都用于磁盘分区，则删除卷，否则需要压缩卷，出现下面的未分配即可使用： 删除卷的话并不是抹除这部分空间，只是这部分空间会被系统保留出来，没有任何文件格式，对于这部分空间系统不会进行任何操作。它相当于一个无人区。 压缩卷就是把一个盘里面的空间抽出一部分变成一个没有任何文件格式和名称的盘，你接下来要对压缩出来的盘进行格式化操作，这样压缩出来的卷才可以用。 3 安装Ubuntu 3.1 U盘启动 将制作好的启动U盘插入到闲置电脑，重启(开机)按F2键进入BIOS界面；（进入BIOS需要按的键每个品牌的电脑不同） 在Boot Priority栏，将UEFI:***选项拖到开始，使其开机启动进入U盘； 保存修改退出即可，一会儿自动重启。 3.2 安装系统 从U盘启动后，在启动引导页选择安装Ubuntu进入Ubuntu； 一路默认选项，直到Installation type选择Something else，进入分区配置页面，找到free space，也就是在Windows系统中整好的磁盘分区； 分区 分区类型 分区位置 用于 挂载点 大小 boot(启动分区) 主分区 起始 ext4文件系统 /boot 1G-2G swap(交换空间) 逻辑分区 起始 交换分区 无 与物理内存一致 / 主分区 起始 ext4文件系统 / 剩余的空间 只有/是必须分区的，其它如果没有必要都不建议建议独立分区，按默认挂在root下就行。 点击下一步完成后续安装即可正确安装Ubuntu。 拔出U盘，重启即可使用双系统。 4 配置Ubuntu 4.1 apt换源并安装必要软件 点击Settings -&gt; About -&gt; Software Updates，选择合适的镜像； 安装必要软件： 1234sudo apt install vimsudo apt install net-toolssudo apt install makesudo apt install git * 4.2 科学上网 4.3 配置oh-my-zsh 参考Win10安装Ubuntu子系统 4.4 xshell连接 使用xshell连接，被拒绝(port 22): Connection failed 123456789# 查看服务器22端口是否启动lsof -i:22# 若没启动sudo apt-get install openssh-server openssh-client # 开启sshservice ssh startssh localhost# 此时检查22是否启动lsof -i:22 笔记本设置合盖不休眠：修改Login Manager配置文件。 12345678910111213sudo vim /etc/systemd/logind.conf### 修改 #### 找到其中一行：#HandleLidSwitch=suspend# 将其改为：HandleLidSwitch=ignore# 重启服务：重启计算机即可sudo restart systemd-logind # 或者service systemd-logind restart# 或者sudo shutdown -r now 4.5 查看硬件配置 1234567891011121314# 查看系统内核uname -a# 查看CPUcat /proc/cpuinfo | grep model\\ name# 查看内存cat /proc/meminfo | grep MemTotal# 查看显卡lspci | grep 'VGA'# 查看声卡lspci | grep -i 'Audio'# 查看网卡lspci | grep -i 'Network'# 查看硬盘df -lh 5 参考 装了5次Ubuntu，告诉你win10+Ubuntu双系统的正确打开方式","categories":[{"name":"环境与工具","slug":"环境与工具","permalink":"https://Dragonliu2018.github.io/categories/环境与工具/"}],"tags":[]},{"title":"C++单元测试","slug":"C++单元测试","date":"2021-09-27T01:44:22.000Z","updated":"2022-01-21T13:22:03.090Z","comments":true,"path":"2021/09/27/C++单元测试/","link":"","permalink":"https://Dragonliu2018.github.io/2021/09/27/C++单元测试/","excerpt":"","text":"0 情景导入 在实习时，用到了C++中的单元测试，整理一下。分别在Windows和子系统（Ubuntu）中安装配置。 1 安装googletest 1.1 环境配置 下载gtest：git clone https://github.com/google/googletest.git 安装cmake： CMake 是一个开源的跨平台的自动化构建系统，主要用于 C++ 的工程构建、测试以及打包等自动化操作。它能根据开发者编写的 CMakeLists.txt 规则文件，在不同的平台输出所需要的工程文件，然后开发者可以按照常见的构建方式使用生成的工程文件编译最终的程序。 CMake 是 Cross platform Make 的缩写，虽然名字中含有“make”，但是 CMake 和 Linux 上常见的 make 系统有所区别，是更上一层的构建系统。 Windows：首先打开 CMake 官方网站，在下载页面选择 Windows win64-x64 Installer 下载并安装 Ubuntu：apt-get install cmake windows配置clion编译环境：Window10上CLion极简配置教程 1.2 编译gtest库 使用clion打开googletest代码目录，选择gtest项目编译生成： 显示下面的信息表明编译成功（显示Error running，不用管他），生成的libgtestd.a即为gtest的库文件，项目中引用这个库文件就能使用gtest了。 2 使用googletest 2.1 引入库 新建测试项目cliontest，将libgtestd.a文件拷贝到该代码根路径的lib路径下，在CMakeList.txt中加上以下内容： 123456# 添加上库文件的路径，注意相对路径link_directories(lib/)# 添加可执行文件add_executable(cliontest main.cpp)# 链接gtest库文件target_link_libraries(cliontest libgtestd.a) 2.2 引入头文件 拷贝googletest/include下的gtest目录到项目下的include目录下，然后在CMakeList.txt中添加上对应的调用： 123include_directories( include/) 然后在代码中添加头文件gtest/gtest.h就可以使用了。 2.3 测试 修改main.cpp并运行： 12345678910111213141516171819202122#include \"gtest/gtest.h\" int add(int a, int b) &#123; return a + b;&#125; TEST(add, zero) &#123; EXPECT_EQ(0, add(0, 0));&#125; TEST(add, positive_number) &#123; EXPECT_EQ(3, add(1, 2));&#125; TEST(add, negative_number) &#123; EXPECT_EQ(-3, add(-1, -2));&#125; int main() &#123; ::testing::InitGoogleTest(); return RUN_ALL_TESTS();&#125; 3 gtest的使用教程 参考文档：Googletest Primer，google官方出品。 https://www.dyxmq.cn/program/usage-of-googletest.html 4 参考 CMake 安装指南","categories":[{"name":"环境与工具","slug":"环境与工具","permalink":"https://Dragonliu2018.github.io/categories/环境与工具/"},{"name":"开发","slug":"开发","permalink":"https://Dragonliu2018.github.io/categories/开发/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://Dragonliu2018.github.io/tags/C/"}]},{"title":"C++项目的全量覆盖率和增量覆盖率","slug":"C++项目的全量覆盖率和增量覆盖率","date":"2021-09-27T01:44:22.000Z","updated":"2022-01-21T13:24:36.167Z","comments":true,"path":"2021/09/27/C++项目的全量覆盖率和增量覆盖率/","link":"","permalink":"https://Dragonliu2018.github.io/2021/09/27/C++项目的全量覆盖率和增量覆盖率/","excerpt":"","text":"0 情景导入 2021.09.26华为实习任务复现，要求实现多次SR合并后的增量覆盖率。 关于报错 12###强制回滚到某版本git reset --hard 36409abd22dcc9f9252152b34fa9e929f7c883ec 123###解决：https://stackoverflow.com/questions/3411048/unexpected-operator-in-shell-programming/3411061./srCover.sh: 17: [: h: unexpected operator ./srCover.sh: 21: [: h: unexpected operator 1 思路 强行cherry-pick，可能存在冲突的情况： 不冲突，是准确的 冲突，使用指定版本的代码解决冲突，是不准确的 2 cherry-pick 3 生成增量覆盖率报告 3.1 生成差异文件 v1版本：dir1目录， v2版本：dir2目录， 执行： 12# diff -r -N -x \".git\" -x \"*.gcov\" -u &lt;old_src_path&gt; &lt;new_src_path&gt; &gt; diff.txtdiff -r -N -x \".git\" -x \"*.gc*\" -x \"result\" -x \"hello\" -x \"hello.info\" -u dir1 dir2 &gt; diff.txt 3.2 生成v2版本的全量覆盖率报告 代码覆盖工具(gcov、lcov)的使用 gcov是Linux下GCC自带的一个C/C++代码覆盖率分析工具,因此只要安装了gcc，就不需要再次安装了。 gcov能够生成代码覆盖信息，但是不够直观，因此需要借助lcov直观展示覆盖率，主要特点有： 基于Html输出，并生成一棵完整的HTML树 输出包括概述、覆盖率百分比、图表，能快速浏览覆盖率数据 支持大项目，提供三个级别的视图：目录视图、文件视图、源码视图 安装lcov： 12345git clone https://github.com/linux-test-project/lcov.git# 进入项目目录cd lcov# 编译make install 以hello.c为例： 123456789101112131415#include&lt;stdio.h&gt;int main()&#123; int num = 1; if (num == 0) &#123; printf(\"num is zero\\n\"); &#125; else if (num == 1) &#123; printf(\"num is one\\n\"); &#125; else &#123; printf(\"num is NAN\\n\"); &#125; printf(\"hello world\\n\"); return 0;&#125; 测试： 123456789101112131415161718192021222324252627282930313233# 编译时候加两个参数：-fprofile-arcs -ftest-coverage, 此时会生成：hello.gcnogcc -fprofile-arcs -ftest-coverage hello.c -o hello# 此时会生成： hello.gcda, hello.gcno和hello.gcda是gcov引用的关键文件)./hello# gcov根据上面的文件生成了：hello.c.gcov,就是代码覆盖信息，但看起来并不直观gcov hello.c### 内容如下：➜ dir2 cat hello.c.gcov -: 0:Source:hello.c -: 0:Graph:hello.gcno -: 0:Data:hello.gcda -: 0:Runs:1 -: 0:Programs:1 -: 1:#include&lt;stdio.h&gt; -: 2: 1: 3:int main() -: 4:&#123; 1: 5: int num = 1; 1: 6: if (num == 0) &#123; #####: 7: printf(\"num is zero\\n\"); 1: 8: &#125; else if (num == 1) &#123; 1: 9: printf(\"num is one\\n\"); -: 10: &#125; else &#123; #####: 11: printf(\"num is NAN\\n\"); -: 12: &#125; 1: 13: printf(\"hello world\\n\"); 1: 14: return 0; -: 15:&#125;# 借助lcov对hello.c.gcov进行改造，可以看见生成了hello.infolcov -d . -t 'Hello test' -o 'hello.info' -b . -c# 生成了result文件夹，借助web服务器，我们就可以很直观的看到结果了genhtml -o result hello.info 查看生成的全量覆盖率报告，用浏览器打开result文件夹内的index.html： 3.3 使用addlcov生成增量代码覆盖率文件 addlcov --diff &lt;full_cov_file&gt; diff.txt -o &lt;add_cov_file&gt; --strip &lt;depth&gt; --path &lt;new_src_path&gt; &lt;full_cov_file&gt;为之前统计的v2版本上的全量覆盖率； &lt;add_cov_file&gt;为输出的增量覆盖率info文件； 是要截取的代码深度； &lt;new_src_path&gt;是v2版本源码 执行： 1addlcov --diff diff.txt -o &lt;add_cov_file&gt; --strip &lt;depth&gt; --path &lt;new_src_path&gt; 报错 12345678910111213141516➜ Test1 ./addlcov --diff hello.info diff.txt -o addhello.info --strip 5 --path ./dir2Reading tracefile hello.infoReading diff diff.txtRemoving /mnt/e/Code/cpp/Test1/dir1/hello.c1 entry converted, 0 entries left unchanged.Writing data to addhello.infoSummary coverage rate: lines......: no data found functions..: no data found branches...: no data found ### bug addlcov脚本无法匹配# Try to match diff filename with filename# if ($filename =~ /^\\Q$diff_path$sep$_\\E$/) 修改为下面语句，if (1 == 1)### 单文件出现上述问题，多文件无问题 python中执行shell命令：https://blog.51cto.com/zhou123/1284377","categories":[{"name":"环境与工具","slug":"环境与工具","permalink":"https://Dragonliu2018.github.io/categories/环境与工具/"},{"name":"开发","slug":"开发","permalink":"https://Dragonliu2018.github.io/categories/开发/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://Dragonliu2018.github.io/tags/C/"}]},{"title":"Hexo迁移到新电脑","slug":"Hexo迁移到新电脑","date":"2021-09-21T15:28:58.000Z","updated":"2022-01-21T13:25:08.792Z","comments":true,"path":"2021/09/21/Hexo迁移到新电脑/","link":"","permalink":"https://Dragonliu2018.github.io/2021/09/21/Hexo迁移到新电脑/","excerpt":"","text":"0 情景导入 换了一台电脑，将旧电脑的hexo博客写作环境迁移到新电脑上。 1 Git下载及配置 从官网Git下载git并安装，下面设置无密push+pull； 打开git bash，在用户主目录(其他目录也可)下运行：ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 把其中的邮件地址换成自己的邮件地址，然后一路回车； 最后完成后，会在用户主目录下生成.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH key密钥对，id_rsa是私钥，千万不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人； 登陆GitHub，打开「Settings」-&gt;「SSH and GPG keys」，然后点击「new SSH key」，填上任意Title，在Key文本框里粘贴公钥id_rsa.pub文件的内容（千万不要粘贴成私钥了！），最后点击「Add SSH Key」，你就应该看到已经添加的Key。 注意：不要在git版本库中运行ssh，然后又将它提交，这样就把密码泄露出去了 2 安装Node.js Hexo基于Node.js，Node.js下载地址：Download | Node.js 下载安装包，注意安装Node.js会包含环境变量及npm的安装，安装后，检测Node.js是否安装成功，在命令行中输入 node -v； 检测npm是否安装成功，在命令行中输入npm -v 3 安装Hexo 新建文件夹，在此文件夹内使用npm命令全局安装Hexo，输入： 1cnpm install -g hexo-cli 输入hexo -v检查是否安装成功。 npm加速： 装cnpm 12&gt; npm install -g cnpm --registry=https://registry.npm.taobao.org&gt; 使用cnpm 12&gt; cnpm install xxx&gt; 参考：npm使用国内镜像加速的几种方法 4 复制原电脑上的数据 4.1 需要复制的 _config.yml：站点配置 package.json：说明使用那些包 scaffolds：文章的模板 source：自己写的博客文件 themes：主题 .gitignore：限定在提交的时候哪些文件可以忽略 4.2 需要删除的 .git：无论是在站点根目录下，还是主题目录下的.git文件，都可以删掉。 node_modules：在用npm install会重新生成 public：hexo g会重新生成 .deploy_git：在使用hexo d时也会重新生成 db.json文件 其实上面这些文件也就是.gitignore文件里面记载的可以忽略的内容。 5 npm install 在git bash中切换目录到新拷贝的文件夹里，使用npm install 命令，进行模块安装。很明显我们这里没用hexo init初始化，因为有的文件我们已经拷贝生成过来了，所以不必用hexo init去整体初始化，如果不慎在此时用了hexo init，则站点的配置文件_config.yml里面内容会被清空使用默认值，所以这一步一定要慎重，不要用hexo init。 6 安装其他必要组件 123npm install hexo-deployer-git --save # 为了使用hexo d来部署到git上 npm install hexo-generator-feed --save # 为了建立RSS订阅npm install hexo-generator-sitemap --save # 为了建立站点地图 插件安装后，有的需要对配置文件_config.yml进行配置，具体怎么配置，可以参考上面插件在github主页上的具体说明 7 验证 首先本地执行，在博客根目录下执行： 12hexo ghexo s 此时可访问浏览器：http://localhost:4000/ ，查看是否转移成功。 接下来验证部署，执行： 1hexo g 在线访问出错，无法访问。开始排查： .deploy_git文件夹内的文件大小均为0kb，也就是生成了一些空文件； public文件夹内的文件大小均为0kb，但是本地可以正常访问，不知道为啥 其实在执行hexo s时，后台存在报错 12345678INFO Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.(node:23336) Warning: Accessing non-existent property 'lineno' of module exports inside circular dependency(Use `node --trace-warnings ...` to show where the warning was created)(node:23336) Warning: Accessing non-existent property 'column' of module exports inside circular dependency(node:23336) Warning: Accessing non-existent property 'filename' of module exports inside circular dependency(node:23336) Warning: Accessing non-existent property 'lineno' of module exports inside circular dependency(node:23336) Warning: Accessing non-existent property 'column' of module exports inside circular dependency(node:23336) Warning: Accessing non-existent property 'filename' of module exports inside circular dependency 解决方法：Node版本太高，切换一个低版本Node可以（我这里是14.17.6切换成12.5.0就没有这个问题了） 问题已解决，可以在线访问博客了。 参考 GitHub+Hexo 搭建个人网站详细教程 使用hexo，如果换了电脑怎么更新博客？","categories":[{"name":"环境与工具","slug":"环境与工具","permalink":"https://Dragonliu2018.github.io/categories/环境与工具/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://Dragonliu2018.github.io/tags/Hexo/"}]},{"title":"python中的全局变量——list","slug":"list全局变量","date":"2021-06-27T01:44:22.000Z","updated":"2022-01-21T13:28:10.431Z","comments":true,"path":"2021/06/27/list全局变量/","link":"","permalink":"https://Dragonliu2018.github.io/2021/06/27/list全局变量/","excerpt":"","text":"1 List python中list作为全局变量无需global声明的原因： https://www.cnblogs.com/yym2013/p/5915980.html python中list变量作为全局变量时，在函数中可以直接修改。 而普通变量则需要先在函数中global声明，否则会报错。 例如： 12345678a = 1def fun(): global a a = 2 b = [1,2]def fun(): b[0] = 2 在函数中直接修改list则是可以的。 原因是： 普通变量如果在函数中赋值 a = 2 会有歧义。因为它既可以是表示引用全局变量a，也可以是创建一个新的局部变量，所以在python中，默认它的行为是创建局部变量，除非显式声明global。 而对列表list变量进行赋值 b[0] = 2 则不会有歧义。它是“明确的”，因为如果把b当作是局部变量的话，它会报KeyError，所以它只能是引用全局的b,故不需要多此一举显式声明global。","categories":[{"name":"开发","slug":"开发","permalink":"https://Dragonliu2018.github.io/categories/开发/"}],"tags":[{"name":"python","slug":"python","permalink":"https://Dragonliu2018.github.io/tags/python/"}]},{"title":"MAC地址泛洪与欺骗","slug":"MAC地址欺骗","date":"2021-03-04T13:47:39.000Z","updated":"2022-01-21T13:27:18.796Z","comments":true,"path":"2021/03/04/MAC地址欺骗/","link":"","permalink":"https://Dragonliu2018.github.io/2021/03/04/MAC地址欺骗/","excerpt":"","text":"1 理论 1.1 原理 MAC地址欺骗是数据链路层攻击，它是利用交换机端口学习的漏洞，通过客户端向交换机发送欺骗报文、攻击交换机的CAM表的方式，使交换机CAM表的记录与真实的主机对应MAC地址不一致，从而使交换机将报文错误转发给攻击者。 MAC地址泛洪攻击，每台交换机的CAM表都有最大记录条数，当交换机端口学习得到的记录大于交换机CAM表条数上限时，交换机收到一个网络帧，只要其目标主机的MAC地址不存在于该交换机CAM表中，那么该帧会以广播的方式发向交换机的每一个端口，此时的交换机就相当于一个集线器HUB，我们就可以监听网络中的所有通讯报文。 与ARP攻击不同：MAC地址欺骗改变的是端口/MAC地址映射关系，ARP攻击改变的是IP/MAC地址映射关系。 MAC地址泛洪攻击针对路由器不行，原因是路由器仅仅转发特定地址的数据包，不传送不支持路由协议的数据包传送和未知目标网络数据包的传送，从而可以防止广播风暴。参考：交换机和路由器的区别在哪里 一针见血通俗解答 实验网络拓扑如下： 1.2 知识储备 MAC地址：它是一个用来确认网络设备位置的位址。在OSI模型中，第三层网络层负责IP地址，第二层数据链路层则负责MAC位址。MAC地址用于在网络中唯一标示一个网卡，一台设备若有一或多个网卡，则每个网卡都需要并会有一个唯一的MAC地址。由网络设备制造商生产时烧录在网卡(Network lnterface Card)的EPROM(一种闪存芯片，通常可以通过程序擦写)。IP地址与MAC地址在计算机里都是以二进制表示的，IP地址是32位的，而MAC地址则是48位的，通常表示为12个16进制数，如：00-16-EA-AE-3C-40就是一个MAC地址。 交换机：主要功能是在局域网内的主机之间转发数据帧，工作核心是端口/MAC地址映射表，这张表里记录了交换机每个端口同与之相连的主机MAC地址之间的对应关系。交换机接收从主机上传来的比特流之后，要先将其缓存成数据帧，然后通过分析帧头中的MAC地址，交换机就可以判断出数据的发送方和接收方，在映射表里查找与数据帧的目的MAC地址相对应的端口。若找到则发给目的主机；若找不到则以广播的方式将这个数据帧向除了源端口以外的其它所有端口转发，从而将数据发送给了目的主机，并记录端口与MAC地址的对应关系。 2 实战 2.1 MAC地址欺骗 准备：没有交换机物理设备，vmware中桥接模式中有虚拟交换机(但是无法登陆后台)，所以只能利用路由器测试(也无法进入后台)，只能查看现象了。 此处未进行实践，可参考：MAC地址欺骗与MAC地址泛洪攻击（eNSP环境演示） 2.2 MAC地址泛洪攻击 以kali为攻击机，使用macof命令向网络中发送大量网络不存在的源mac地址，堵塞交换机(路由器)的CAM表； 攻击前，Win物理机可以ping通kali、node01、node02、node03； 攻击后，按道理此时的路由器中的CAM表中存在大量陌生MAC地址记录，但是目前无法查看；现象为：请求超时或间断ping通，但可以ping通外网及局域网内其它主机。 3 存在问题 没有物理交换机，虚拟交换机无法登陆后台 用路由器测试，但是无法登录后台查看CAM表，可参考：小米路由器开启SSH 4 参考 百度百科-MAC地址 MAC泛洪***的实施与防御 MAC地址欺骗与MAC地址泛洪攻击（eNSP环境演示） 亁颐堂现任明教教主CCNA Security 2019 7 第三天 2 MAC泛洪MAC欺骗","categories":[{"name":"安全","slug":"安全","permalink":"https://Dragonliu2018.github.io/categories/安全/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://Dragonliu2018.github.io/tags/Web/"}]},{"title":"ARP攻击","slug":"ARP欺骗-断网攻击","date":"2021-02-17T04:03:04.000Z","updated":"2022-01-21T13:34:37.181Z","comments":true,"path":"2021/02/17/ARP欺骗-断网攻击/","link":"","permalink":"https://Dragonliu2018.github.io/2021/02/17/ARP欺骗-断网攻击/","excerpt":"","text":"1 理论 1.1 原理 ARP攻击主要是通过伪造IP地址和MAC地址进行欺骗。假设A、B、C位于同一局域网内，A是PC主机，B是攻击主机，C是路由器。攻击过程如下： A将包含目标IP地址(10.0.1.1)信息的ARP Request，广播到网络中的所有主机，源主机A的IP地址和MAC地址都包括在ARP请求中； C确定ARP请求中的IP地址与自己的IP地址匹配，则将主机A的IP地址和MAC地址映射添加到本地ARP缓存中；并将包含其MAC地址的ARP回复消息直接发送回主机A； 当主机A收到从C发来的ARP回复消息时，会用C的IP和MAC地址映射更新ARP缓存； 攻击主机B向A发送伪造的ARP应答包，在这个伪造的应答包中，IP地址为C的IP地址，而MAC地址为B的MAC地址； A在接收到这个应答包后，会刷新它的ARP缓存，这样在A的ARP缓存表中就出现了IP-C与MAC-B的映射； 攻击主机B向C发送伪造的ARP应答包，在这个伪造的应答包中，IP地址为A的IP地址，而MAC地址为B的MAC地址； C在接收到这个应答包后，会刷新它的ARP缓存，这样在C的ARP缓存表中就出现了IP-A与MAC-B的映射。 这样一来，A与C之间的流量交换都会经过B，可以进行监听、篡改信息、断网攻击。 1.2 知识储备 网关：网关(Gateway)在网络层以上实现网络互连。由于历史的原因，许多有关TCP/IP的文献曾经把网络层使用的路由器称为网关，在今天很多局域网采用路由来接入网络，因此通常指的网关就是路由器的IP！ Bridged(桥接模式)：将主机网卡与虚拟机虚拟的网卡利用虚拟网桥进行通信。其网络结构如下图所示： 2 实战 2.1 断网攻击 准备：kali虚拟机，设置桥接模式，否则断网无效； 查看自己的网卡信息 找到目标IP：nmap扫描内网(命令nmap -sP 192.168.1.*)或使用安卓端的Net Analyzer进行LAN Scan； arpspoof进行攻击：执行下面命令后目的主机无法上网； 12arpspoof -i 自己网卡信息 -t 目标IP -r 网关例：arpspoof -i eth0 -t 192.168.1.7 -r 192.168.1.1 2.2 窃听 开启IP转发：echo 1 &gt;/proc/sys/net/ipv4/ip_forward arp攻击：arpspoof -i eth0 -t targetIP -r gateway（具体参考上面） 窃听：driftnet -i eth0（你的网卡）或wireshark 3 存在问题 攻击局域网其他系统时，kali虚拟机可以上网，但是其宿主机(物理机win10)无法上网；开启IP转发可以解决 窃听时目标主机虽然可以ping通，当时网速太慢且不稳定；driftnet无法正确抓取图片； 4 参考 百度百科-ARP 百度百科-ARP攻击 百度百科-ARP欺骗 百度百科-网关 vmware 虚拟机三种网络模式—“桥接、NAT 、仅主机”区别？ Kali Linux使用arpspoof命令进行断网攻击（ARP欺骗）【VMware一定要设置桥接模式，否则断网会无效】 使用kali进行ARP攻击与欺骗 使用kali进行局域网ARP欺骗攻击与监听 秦柯-ARP攻击","categories":[{"name":"安全","slug":"安全","permalink":"https://Dragonliu2018.github.io/categories/安全/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://Dragonliu2018.github.io/tags/Web/"}]},{"title":"图像滤波整理","slug":"图像滤波整理","date":"2020-11-08T13:53:34.000Z","updated":"2022-01-21T13:34:00.544Z","comments":true,"path":"2020/11/08/图像滤波整理/","link":"","permalink":"https://Dragonliu2018.github.io/2020/11/08/图像滤波整理/","excerpt":"","text":"图像滤波 基础知识 定义：图像滤波，即在尽量保留图像细节特征的条件下对目标图像的噪声进行抑制，是图像预处理中不可缺少的操作，其处理效果的好坏将直接影响到后续图像处理和分析的有效性和可靠性。 **比喻：**我们可以把滤波器想象成一个包含加权系数的窗口，当使用这个滤波器平滑处理图像时，就把这个窗口放到图像之上，透过这个窗口来看我们得到的图像。 公式： $$O(i, j) = \\sum_{m,n}I(i+m,j+n)K(m,n)$$ 其中O(i, j)是像素输出值，I(i+m, j+n)是像素输入值，K为滤波器（核：二维矩阵，核的不同值表示不同的算法。） 种类：低通滤波器可以消除噪声、模糊化，高通滤波器可以提取边缘。白话文讲计算机视觉-第三讲-滤波器 作用：图像滤波可以更改或者增强图像。通过滤波，可以强调一些特征或者去除图像中一些不需要的部分。滤波是一个邻域操作算子，利用给定像素周围的像素的值决定此像素的最终的输出值。常见的应用包括去噪、图像增强、检测边缘、检测角点、模板匹配等。 非学习类型算法 0x01 均值滤波 定义：用其像素点周围像素的平均值代替元像素值，在滤除噪声的同时也会滤掉图像的边缘信息。 代码：Python调用OpenCV实现均值滤波的核心函数：result = cv2.blur(原始图像, 核大小) 其中，核大小是以（宽度，高度）表示的元组形式，常见的形式包括：核大小（3，3）和（5，5）。boxFilter也可实现。 0x02 方框滤波 定义：方框滤波和均值滤波核基本一致，区别是需不需要均一化处理。 代码： OpenCV调用boxFilter()函数实现方框滤波。函数：result = cv2.boxFilter(原始图像, 目标图像深度, 核大小, normalize属性) 其中，目标图像深度是int类型，通常用“-1”表示与原始图像一致；核大小主要包括（3，3）和（5，5）；normalize属性表示是否对目标图像进行归一化处理，当normalize为true时需要执行均值化处理，当normalize为false时，不进行均值化处理，实际上为求周围各像素的和，很容易发生溢出，溢出时均为白色，对应像素值为255。 0x03 中值滤波 **定义：**中值滤波用测试像素周围邻域像素集中的中值代替原像素。中值滤波去除椒盐噪声和斑块噪声时，效果非常明显。在OpenCV中，可以使用函数medianBlur进行操作。 代码： OpenCV主要调用medianBlur()函数实现中值滤波。图像平滑里中值滤波的效果最好。dst = cv2.medianBlur(src, ksize) 其中，src表示源文件，ksize表示核大小。核必须是大于1的奇数，如3、5、7等。 0x04 高斯滤波 定义：加权平均，距离越近的点权重越大，距离越远的点权重越小。由于图像是二维矩阵，则采用二维高斯函数(正态分布)$$f(x,y)= \\frac{1}{2πσ^2} e{\\frac{-(x2+y2)}{2σ2}}$$ 。如果原图是彩色图片，可以对RGB三个通道分别做高斯模糊。参考：高斯模糊（高斯滤波）的原理与算法 边界处理：把已有的点拷贝到另一面的对应位置，模拟出完整的矩阵。 公式：以 q为中心的窗口中，某一点 p在高斯滤波过程中。 权重(空间)： $$G§ = \\frac{1}{2πσ^2} e{\\frac{-||p-q||2}{2σ^2}}$$ 代码：Python中OpenCV主要调用GaussianBlur函数：dst = cv2.GaussianBlur(src, ksize, sigmaX) 其中，src表示原始图像；ksize表示核大小，核大小（N, N）必须是奇数；sigmaX表示X方向方差，主要控制权重，sigmaX小，表现在高斯曲线上就是曲线越高越尖，表现在滤波效果上就是模糊程度小（sigmaX大，表现在高斯曲线上就是曲线越矮越平缓，表现在滤波效果上就是模糊程度大）。 1234567891011121314151617181920212223242526272829303132333435363738#encoding:utf-8\"\"\"@author: Dragon LiuOperating environment: Python 3.7.1lib: opencv-pythonDate: 2020/3/16\"\"\"#导入库import cv2 import numpy as np import matplotlib.pyplot as plt #读取图片img = cv2.imread('02.png')source = cv2.cvtColor(img,cv2.COLOR_BGR2RGB) #方框滤波img_box = cv2.boxFilter(source, -1, (5,5), normalize=1)# 均值滤波img_blur = cv2.blur(source, (5,5))#中值滤波img_median = cv2.medianBlur(source, 3)# 高斯滤波img_Guassian = cv2.GaussianBlur(source, (5,5), 0)#显示图形titles = ['Source Image', 'BoxFilter Image', 'Blur Image', 'Median Image', 'Guassian Image'] images = [source, img_box, img_blur, img_Guassian, img_median] for i in range(5): plt.subplot(2, 3, i+1), plt.imshow(images[i], 'gray') plt.title(titles[i]) plt.xticks([]),plt.yticks([]) plt.show() 参考：我跳 0x05 双边滤波 – 边缘保护滤波 定义：高斯滤波只考虑了周边点与中心点的空间距离来计算得到权重，会模糊掉边缘。在高斯滤波的基础上加入了像素值(灰度)权重项，也就是说既要考虑距离因素，也要考虑像素值差异的影响，像素值越相近，权重越大。参考：双边滤波详解、【图像处理】——双边滤波 公式： 像素值权重 $$G_r= exp(-{\\frac{||I_p-I_q||2}{2σ2_r}})$$ 空间距离权重 $$G_s= exp(-{\\frac{||p-q||2}{2σ2_s}})$$ 滤波窗口内每个像素值的权重和 $$W(q) = \\sum_{p\\in S} G_s§G_r§$$ —用于权重的归一化 滤波结果： $$BF = \\frac {1}{W_q}\\sum_{p\\in S} G_s§G_r§*I_p$$ 代码：OpenCV在Python中双边滤波函数是**cv2.bilateralFilter(src, d, sigmaColor, sigmaSpace）**时间复杂度 $$O(Nr^2)$$ ① src是输入图像； ② d是在过滤期间使用的每个像素邻域的直径，如果输入d非0，则sigmaSpace由d计算得出，如果sigmaColor没输入，则sigmaColor由sigmaSpace计算得出； ③ sigmaColor是灰度值相似性高斯函数标准差，色彩空间的标准方差，一般尽可能大， 较大的参数值意味着像素邻域内较远的颜色会混合在一起， 从而产生更大面积的半相等颜色； ④ sigmaSpace是空间高斯函数标准差，坐标空间的标准方差(像素单位)，一般尽可能小。 参数值越大意味着只要它们的颜色足够接近，越远的像素都会相互影响。 当d &gt; 0时，它指定邻域大小而不考虑sigmaSpace。 否则，d与sigmaSpace成正比。 12345678910111213141516171819202122232425262728#encoding:utf-8\"\"\"@author: Dragon LiuOperating environment: Python 3.7.1lib: opencv-pythonDate: 2020/3/16\"\"\"#导入库import cv2 import numpy as np import matplotlib.pyplot as plt #读取图片img = cv2.imread('02.png')source = cv2.cvtColor(img,cv2.COLOR_BGR2RGB) #双边滤波img_bilateral = cv2.bilateralFilter(source, 7, 50, 50)#显示图形titles = ['Source Image', 'bilateralFilter Image'] images = [source, img_bilateral] for i in range(2): plt.subplot(1, 2, i+1), plt.imshow(images[i], 'gray') plt.title(titles[i]) plt.xticks([]),plt.yticks([]) #禁止输出坐标轴 plt.show() 0x06 引导滤波 – 边缘保护滤波 1. 定义 引导滤波的思想用一张引导图像产生权重，从而对输入图像进行处理。引导滤波除了可以用于图像平滑，还可以用于HDR压缩、细节增强、图像去雾、联合上采样等图像处理任务。引导滤波中空间域的贡献自然取决于窗口的大小，即由参数 r 决定。而标准差则是评判颜色差异性的参数，窗口中标准差越大，说明局部的像素相似性越差。 2. 公式：【图像处理】引导滤波 权重 $$W_{ij}(i,j) = \\frac{1}{|ω|^2} \\sum_{k:(i,j)\\in ω_k} (1+ \\frac{(I_i-μ_k)(I_j-μ_k)}{σ_k^2+ϵ})$$ (局部窗口 $$ω_k$$ ；ϵ是 $$L_2$$ 范数正则化系数，防止$$a_k$$ 过大； $$μ_k$$与 $$ σ_k$$ 表示 $$ I_i$$ 在窗口内的均值、标准差； $$∣w∣$$ 表示窗口内像素块的总数 ) 结果 $$q_i = \\sum_{j}{W_{ij}(I)*p_j}$$ (q、I、p分表表示输出图像、引导图像和输入图像 ，i、j 分别表示图像中像素点的索引。权重 W 仅与引导图像 I 有关，而在双边滤波中权重 W 由输入图像自身决定。) 3. 代码1(引导滤波)： 第一个代码块是手写实现引导滤波。时间复杂度O(N)，当 r 与 ϵ 越大，图像被平滑的程度越大。伪代码中：r是窗口半径， $$f_{mean}(I,r)$$​ 表示在(r, r)窗口对图像做均值滤波。大佬博客：我跳 第二个代码块是使用的现有库。参考：我跳 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182# -*- coding: utf-8 -*-\"\"\"@First_author: 不用先生@Second_author: Dragon LiuOperating environment: Python 3.7.1lib: opencv-pythonDate: 2020/3/16\"\"\"import cv2import numpy as npinput_fn = '03.png'# 函数名：my_guidedFilter_oneChannel# 函数功能：用于单通道图像（灰度图）的引导滤波函数；# 参数：srcImg：输入图像，为单通道图像；# 参数：guideImg：引导图像，为单通道图像，尺寸与输入图像一致；# 参数：rad：滤波器大小r，应该保证为奇数，默认值为9；# 参数：eps：防止a过大的正则化参数ϵ，# 返回：dstImg：输出图像，尺寸、通道数与输入图像吻合；def my_guidedFilter_oneChannel(srcImg, guidedImg, rad=13, eps=0.1): # 转换数值类型，并归一化 srcImg = srcImg/255.0 guidedImg = guidedImg/255.0 img_shape = np.shape(srcImg)#查看矩阵或者数组的维数。 # 在(rad, rad)窗口的内对图像做均值滤波。 P_mean = cv2.boxFilter(srcImg, -1, (rad, rad), normalize=True) # p的均值平滑 I_mean = cv2.boxFilter(guidedImg,-1, (rad, rad), normalize=True) # I的均值平滑 I_square_mean = cv2.boxFilter(np.multiply(guidedImg, guidedImg), -1, (rad, rad), normalize=True) #I*I的均值平滑 I_mul_P_mean = cv2.boxFilter(np.multiply(srcImg, guidedImg), -1, (rad, rad), normalize=True)# I*p的均值平滑 var_I = I_square_mean-np.multiply(I_mean,I_mean)# 方差 cov_I_P = I_mul_P_mean-np.multiply(I_mean,P_mean)# 协方差 a = cov_I_P/(var_I+eps)# 相关因子a b = P_mean-np.multiply(a,I_mean)# 相关因子b a_mean = cv2.boxFilter(a, -1, (rad, rad), normalize=True) # 对a进行均值平滑 b_mean = cv2.boxFilter(b, -1, (rad, rad), normalize=True) # 对b进行均值平滑 dstImg = np.multiply(a_mean,guidedImg)+b_mean return dstImg*255.0 # 函数名：my_guidedFilter_threeChannel# 函数功能：用于三通道图像（RGB彩色图）的引导滤波函数；# 参数：srcImg：输入图像，为三通道图像；# 参数：guideImg：引导图像，为三通道图像，尺寸与输入图像一致；# 参数：rad：滤波器大小r，应该保证为奇数，默认值为9；# 参数：eps：防止a过大的正则化参数ϵ，# 返回：dstImg：输出图像，尺寸、通道数与输入图像吻合；def my_guidedFilter_threeChannel(srcImg, guidedImg, rad=9, eps=0.01): img_shape = np.shape(srcImg) dstImg = np.zeros(img_shape, dtype=float) for ind in range(0,img_shape[2]): dstImg[:,:,ind] = my_guidedFilter_oneChannel(srcImg[:,:,ind], guidedImg[:,:,ind], rad, eps) dstImg = dstImg.astype(np.uint8) return dstImgdef main(): img = cv2.imread(input_fn)#读入图像 print( np.shape(img) ) dstimg = my_guidedFilter_threeChannel(img, img, 9 , 0.01)#输入图像作为自身的引导图 print( np.shape(dstimg) ) # cv2.imwrite('output.jpg',dstimg) cv2.imshow('output', dstimg) cv2.waitKey(0) if __name__ == '__main__': main() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# -*- coding: utf-8 -*-\"\"\"@First_author: Jin ZhangYu@Second_author: Dragon LiuOperating environment: Python 3.7.1lib: opencv-contrib-pythonDate: 2020/3/16\"\"\"# 导入库import argparseimport cv2import matplotlib.pyplot as pltimport skimageimport numpy as np# 构造参数解析器# ap = argparse.ArgumentParser()# ap.add_argument(\"-H:\\project_work\\Machine_Vision_Lab\\thesis\\Gaussian\\code\", \"--02.png\", required=True, help = \"Path to the image\")# args = vars(ap.parse_args())# 加载图像并显示input_fn = '02.png'# img = cv2.imread(args[\"image\"],1)img = cv2.imread(input_fn)img = img[:,:,::-1]guide = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)# 进行导向滤波dst1 = cv2.ximgproc.guidedFilter( guide=guide, src=img, radius=16, eps=50, dDepth=-1)dst2 = cv2.ximgproc.guidedFilter( guide=guide, src=img, radius=16, eps=200, dDepth=-1)dst3 = cv2.ximgproc.guidedFilter( guide=guide, src=img, radius=16, eps=1000, dDepth=-1)# 绘制图片images = [img,[dst1,dst2,dst3]]titles = [ 'Original', ['Guided Filter eps=50','Guided Filter eps=200','Guided Filter eps=1000'] ]# 绘制原图plt.figure(figsize=(9,4))plt.subplot(2, 3, 2),plt.imshow(images[0])plt.title(titles[0], fontsize=10),plt.xticks([]), plt.yticks([])plt.subplot(2, 3, 4),plt.imshow(images[1][0])plt.title(titles[1][0], fontsize=10),plt.xticks([]), plt.yticks([])plt.subplot(2, 3, 5),plt.imshow(images[1][1])plt.title(titles[1][1], fontsize=10),plt.xticks([]), plt.yticks([])plt.subplot(2, 3, 6),plt.imshow(images[1][2])plt.title(titles[1][2], fontsize=10),plt.xticks([]), plt.yticks([])# plt.savefig('1_out.png', transparent=True, dpi=300, pad_inches = 0)plt.show() 4. 代码2(快速导向滤波) 通过下采样减少像素点，计算mean_a &amp; mean_b后进行上采样恢复到原有的尺寸大小。假设缩放比例为s,那么缩小后像素点的个数为 $$\\frac {N}{s^2}$$ ，那么时间复杂度变为 $$O(\\frac {N}{s^2})$$​ 。伪代码中：fmean代表均值平滑，fsubsample代表图像下采样即缩小图像，fupsample代表图片上采样即放大图像，s为缩小系数。参考：我跳 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071# -*- coding: utf-8 -*-\"\"\"@First_author: SongpingWangSongpingWangs@Second_author: Dragon LiuOperating environment: Python 3.7.1lib: opencv-pythonDate: 2020/3/16\"\"\"import cv2import numpy as npdef guideFilter(I, p, winSize, eps, s): # 输入图像的高、宽 h, w = I.shape[:2] # 缩小图像 size = (int(round(w * s)), int(round(h * s))) small_I = cv2.resize(I, size, interpolation=cv2.INTER_CUBIC) small_p = cv2.resize(I, size, interpolation=cv2.INTER_CUBIC) # 缩小滑动窗口 X = winSize[0] small_winSize = (int(round(X * s)), int(round(X * s))) # I的均值平滑 p的均值平滑 mean_small_I = cv2.blur(small_I, small_winSize) mean_small_p = cv2.blur(small_p, small_winSize) # I*I和I*p的均值平滑 mean_small_II = cv2.blur(small_I * small_I, small_winSize) mean_small_Ip = cv2.blur(small_I * small_p, small_winSize) # 方差、协方差 var_small_I = mean_small_II - mean_small_I * mean_small_I cov_small_Ip = mean_small_Ip - mean_small_I * mean_small_p small_a = cov_small_Ip / (var_small_I + eps) small_b = mean_small_p - small_a * mean_small_I # 对a、b进行均值平滑 mean_small_a = cv2.blur(small_a, small_winSize) mean_small_b = cv2.blur(small_b, small_winSize) # 放大 size1 = (w, h) mean_a = cv2.resize(mean_small_a, size1, interpolation=cv2.INTER_LINEAR) mean_b = cv2.resize(mean_small_b, size1, interpolation=cv2.INTER_LINEAR) q = mean_a * I + mean_b return q if __name__ == '__main__': eps = 0.01 winSize = (16,16) #类似卷积核（数字越大，磨皮效果越好） image = cv2.imread(r'02.png', cv2.IMREAD_ANYCOLOR) image = cv2.resize(image,None,fx=0.8,fy=0.8,interpolation=cv2.INTER_CUBIC) I = image/255.0 #将图像归一化 p =I s = 3 #步长 guideFilter_img = guideFilter(I, p, winSize, eps,s) # 保存导向滤波结果 guideFilter_img = guideFilter_img * 255 #(0,1)-&gt;(0,255) guideFilter_img[guideFilter_img &gt; 255] = 255 #防止像素溢出 guideFilter_img = np.round(guideFilter_img ) guideFilter_img = guideFilter_img.astype(np.uint8) cv2.imshow(\"image\",image) cv2.imshow(\"winSize_16\", guideFilter_img ) cv2.waitKey(0) cv2.destroyAllWindows() 0x07 高通滤波 – 边缘检测/高反差保留 定义： 代码：使用的函数有：cv2.Sobel() , cv2.Schar() , cv2.Laplacian() Sobel, scharr其实是求一阶或者二阶导数。scharr是对Sobel的优化。 Laplacian是求二阶导数。cv2.Sobel() 是一种带有方向过滤器。参考：我跳 123456789101112131415161718192021222324252627282930313233343536373839404142# -*- coding: utf-8 -*-\"\"\"@First_author: SongpingWang@Second_author: Dragon LiuOperating environment: Python 3.7.1lib: opencv-pythonDate: 2020/3/16\"\"\"\"\"\"dst = cv2.Sobel(src, ddepth, dx, dy[, dst[, ksize[, scale[, delta[, borderType]]]]])src: 需要处理的图像；ddepth: 图像的深度，-1表示采用的是与原图像相同的深度。 目标图像的深度必须大于等于原图像的深度；dx和dy: 求导的阶数，0表示这个方向上没有求导，一般为0、1、2。dst 不用解释了；ksize： Sobel算子的大小，必须为1、3、5、7。 ksize=-1时，会用3x3的Scharr滤波器， 它的效果要比3x3的Sobel滤波器要好 scale： 是缩放导数的比例常数，默认没有伸缩系数；delta： 是一个可选的增量，将会加到最终的dst中， 默认情况下没有额外的值加到dst中borderType： 是判断图像边界的模式。这个参数默认值为cv2.BORDER_DEFAULT。\"\"\"import cv2img=cv2.imread('02.png',cv2.IMREAD_COLOR)x=cv2.Sobel(img,cv2.CV_16S,1,0)y=cv2.Sobel(img,cv2.CV_16S,0,1)absx=cv2.convertScaleAbs(x)absy=cv2.convertScaleAbs(y)dist=cv2.addWeighted(absx,0.5,absy,0.5,0)cv2.imshow('original_img',img)cv2.imshow('y',absy)cv2.imshow('x',absx)cv2.imshow('dsit',dist)cv2.waitKey(0)cv2.destroyAllWindows() 0x08 窗口感知的高斯引导滤波 gr.m 1234function result = gr(px, py, qx, qy, dr)% 高斯空间核函数 result = exp( - ( (qx - px)^2 + (qy - py)^2 ) / (2 * dr^2) );end gzeta.m 1234function result = gzeta(guide_img, div, px, py, qx, qy, dzeta)% 高斯频域核函数 result = exp( - ( ( guide_img(px, py, div) - guide_img(qx, qy, div) )^2 ) / (2 * dzeta^2) );end GS.m 123456789101112function output = GS(image, r, dr, px, py, div)% 求解高斯空间域滤波，返回指定像素点(p)的输出 Upsilon = 0;%τ，归一化系数 output = 0; for i = -r : r % 以p为中心的窗口半径为2r+1的区域 for j = -r : r Upsilon = Upsilon + gr(px, py, px + i, py + j, dr); output = output + gr(px, py, px + i, py + j, dr) * image(px + i,py + j,div); end end output = output / Upsilon ;end WGGF.m 1234567891011121314151617181920212223function output = WGGF(guide_img, source, r, dzeta, px, py, div, lambda)% 窗口感知的高斯引导滤波%求解WGGF在每个像素点p的输出并返回 Upsilon = 0;%τ，归一化系数 output = 0; flag = 0; for i = -r : r for j = -r : r temp = abs( guide_img(px + i, py + 1, div) - guide_img(px, py, div) ); if temp &lt;= lambda flag = flag + 1; Upsilon = Upsilon + gzeta(guide_img, div, px, py, px+i, py+j, dzeta); output = output + guide_img(px + i,py + j,div) * gzeta(guide_img, div, px, py, px+i, py+j, dzeta); end end end if flag == 1 %不满足窗口感知的要求，返回3*3窗口中的像素点中值 output = medfilt2( source( (px - 1):(px + 1), (py - 1):(py + 1), j), [3,3] ); else %满足条件 output = output / Upsilon ; endend Main.m 1234567891011121314151617181920212223242526272829303132333435363738394041%% 读取图片source = im2double( imread('01.jpg') );guide_img = source;%% 求解高斯引导滤波[m ,n, div] = size(source);r = 5; %窗口半径dr = 0.5; %空域带宽for k = 1 : div for i = 1 : m for j = 1 : n if i &lt;= r || i &gt;= m - r || j &lt;= r || j &gt;= n - r %图片四周处理(原像素) continue; else guide_img(i,j,k) = GS(source, r, dr, i, j, k); %空间域滤波 end end endend%% 求解WGGFtarget = guide_img;r = 5; %窗口半径dzeta = 0.1; %频域带宽lambda = 0.12; % λ为一选定的阈值 for k = 1 : div for i = 1 : m for j = 1 : n if i &lt;= r || i &gt;= m - r || j &lt;= r || j &gt;= n - r%图片四周处理(引导像素) continue; else target(i, j, k) = WGGF(guide_img, source, r, dzeta, i, j, k, lambda); end end endend%% 显示图形figure;subplot(1,2,1), imshow(source), title('Source image');subplot(1,2,2), imshow(target), title('WGGF image'); WGGF.py(Bug) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#encoding:utf-8\"\"\"@author: Dragon LiuOperating environment: Python 3.7.1lib: opencv-pythonDate: 2020/3/22BUG: 时间复杂度O(m*n*div*r*r)，不可行，另外存在img[]访问问题\"\"\"#导入库import mathimport cv2 import numpy as np import matplotlib.pyplot as plt# 高斯空间核函数def gr(px, py, qx, qy, dr): nut = math.exp( - ( pow((qx - px), 2) + pow((qy - py), 2) ) ) #分子 det = 2 * pow(dr, 2) #分母 result = nut / det return result# 高斯频域核函数def gzeta(guide_img, div, px, py, qx, qy, dzeta): guide_img = guide_img nut = math.exp( - ( pow( ( guide_img[px, py, div] - guide_img[qx, qy, div] ), 2 ) ) ) #分子 det = 2 * pow(dzeta, 2) result = nut / det return result# 求解高斯空间域滤波，返回指定像素点(p)的输出def GS(image, r, dr, px, py, div): Upsilon = 0 #τ，归一化系数 output = 0 for i in range(r, -(r+1), -1):# 以p为中心的窗口半径为2r+1的区域 for j in range(r, -(r+1), -1): Upsilon = Upsilon + gr(px, py, px + i, py + j, dr) output = output + gr(px, py, px + i, py + j, dr) * image[px + i,py + j,div] output = output / Upsilon return output#求解指定窗口(3*3)的中值def medbox(img, x, y, div, length, width): nums = [] length = width = 3 for i in range(math.floor(length/2), -math.floor(length/2)-1, -1): for j in range(math.floor(width/2), -math.floor(width/2)-1, -1): nums.append( img[x+i, y+j, div]) return np.median(nums)#窗口感知的高斯引导滤波#求解WGGF在每个像素点p的输出并返回def WGGF(guide_img,source,r,dzeta,px,py,div, lam): guide_img = guide_img source = source Upsilon = 0 #τ，归一化系数 output = 0 flag = 0 for i in range(r, -(r+1), -1):# 以p为中心的窗口半径为2r+1的区域 for j in range(r, -(r+1), -1): temp = abs( guide_img[px + i, py + 1, div] - guide_img[px, py, div] ) if temp &lt;= lam: flag = flag + 1 Upsilon = Upsilon + gzeta(guide_img, div, px, py, px+i, py+j, dzeta) output = output + guide_img[px + i,py + j,div] * gzeta(guide_img, div, px, py, px+i, py+j, dzeta) if flag == 1 or Upsilon == 0: #不满足窗口感知的要求，返回3*3窗口中的像素点中值 output = medbox( source, px, py, j, 3, 3 ) else: #满足条件 output = output / Upsilon return output# 主函数，测试def main(): #读取图片 img = cv2.imread('02.png', 1) source = cv2.cvtColor(img, cv2.COLOR_BGR2RGB) source = source / 255.0 guide_img = source print(1.666) #求解高斯引导滤波 [m ,n, div] = np.shape(source)#查看矩阵或者数组的维数。 r = 5 #窗口半径 dr = 0.5 #空域带宽 # 高斯滤波 guide_img = cv2.GaussianBlur(source, (r,r), dr) print(2.666) #求解WGGF target = guide_img r = 5 #窗口半径 dzeta = 0.1 #频域带宽 lam = 0.12 #λ为一选定的阈值 num = 0 for k in range(div): for i in range(m): for j in range(n): if i &lt;= r or i &gt;= m - r or j &lt;= r or j &gt;= n - r: #图片边界处理(引导像素) continue else: target[i, j, k] = WGGF(guide_img, source, r, dzeta, i, j, k, lam) num = num + 1 print(num) print(3.666) #显示图形 titles = ['Source Image', 'WGGF Image'] images = [source*255.0, target*255.0] for i in range(2): plt.subplot(1, 2, i+1), plt.imshow(images[i], 'gray') plt.title(titles[i]) plt.xticks([]),plt.yticks([]) #禁止输出坐标轴 plt.show() if __name__ == '__main__': main()","categories":[{"name":"折腾","slug":"折腾","permalink":"https://Dragonliu2018.github.io/categories/折腾/"}],"tags":[{"name":"CV","slug":"CV","permalink":"https://Dragonliu2018.github.io/tags/CV/"}]},{"title":"区块链综述","slug":"区块链的那些事","date":"2020-06-27T01:44:22.000Z","updated":"2022-01-21T12:32:38.545Z","comments":true,"path":"2020/06/27/区块链的那些事/","link":"","permalink":"https://Dragonliu2018.github.io/2020/06/27/区块链的那些事/","excerpt":"","text":"有人说区块链是一场伟大的实验，有人说区块链是一场革命，有人说区块链是一个世纪骗局，还有人说区块链是百年难得一遇的良机，人人参与是社会发展的必然趋势**[1]。而且，区块链的发明者中本聪是何许人也？仍然未知，无疑为其蒙上了一层神秘面纱。 这里需要指出的是不要将区块链与比特币混淆，区块链是以比特币为代表的加密货币的底层支撑技术；比特币是区块链的一个应用。巴菲特表示：“这是一个赌博的东西……有很多欺诈与之有关。比特币没有产生任何价值[2]。” 换言之，与其说比特币用来投资，倒不如说是用来投机。否定比特币并不意味着否定区块链，恰恰相反，我们应该好好领悟区块链的技术原理。国家支持区块链的技术的发展：在2019年10月24日中央政治局第十八次集体学习中，习总书记指出：区块链技术应用已延伸到数字金融、物联网、智能制造、供应链管理、数字资产交易等多个领域，要加快推动区块链技术和产业创新发展，积极推进区块链和经济社会融合发展[3]。 2020年4月20日国家发改委也正式将区块链技术纳入新基建范畴[3]**。 表明立场，谈技术。技术主要是来自于《比特币白皮书》，我跳。 01 介绍 区块链技术依靠共识机制和分布式账本，不需要第三方信用机构就可以避免双重支付问题；同时，通过“工作量证明”（POW，proof of work）及“权益证明”（proof of stake），区块链使得所有参与者可以在某些方面达成一致，无需信任单个节点，从而解决拜占庭将军问题。 比特币网络的全节点时时刻刻都在进行数学运算（挖矿、工作量证明），每个节点贡献自己的算力来竞争解决一个动态可调整的数学问题（进行 SHA256 运算的结果小于某个值），成功解决该数学问题的节点将获得一定数量的比特币以及该区块的记账权，并且该节点将当前时间段的所有交易打包计入一个新的区块，获得基于自愿原则的交易手续费，所有的交易都会经过算法处理（SHA256），并且经过验证，产生一定格式的区块并将该区块链接到主链上。整个比特币网络周而复始，比特币网络顺利运行。 中本聪在其比特币白皮书中非常详细地介绍了区块链系统的建立过程： 第１步 新的交易向全网所有节点广播； 第２步 每个节点把收到的交易都写入到一个区块中； 第３步 每个节点都在新的区块上进行计算，寻找一个工作量证明解； 第４步 某个节点找到工作量证明解时，就把其所在区块向全网进行广播； 第５步 其他节点收到广播的这个区块后对其进行验证，只有所有交易都被 验证是有效的且未被使用的之后，该区块才能被认可； 第６步 每个节点通过将此区块的哈希值作为父哈希值来进行下一个区块的 计算，表示节点认可了此区块有效。 由于每个区块都带有前一区块的特征，想要篡改一个区块的交易记录，必须要重新计算该块之后的所有区块，需要修改时间越久的区块，所花费的算力越大。一般来说，一个区块后面有 6 个区块，这个区块就无法被修改了，也就是认为这个区块可信。[6] 02 自问自答 问：比特币就是区块链吗？ 答：虽然前面有提及，但仍需再重复一遍。以比特币为代表的加密货币的底层支撑技术被称为区块链技术，比特币是区块链的一个应用。 问：为什么要设计工作量证明呢？ 答：这个问题从两个方面回答： 为了控制比特币生成的速度。中本聪的设计是比特币最多被细分到小数点后8位，之后将再也无法被细分。且第一个区块会有50个比特币奖励，每过21万个区块，比特币的产量减半。中本聪通过调节工作量证明的难度，使每一个新区块生成大概需要10分钟。所以比特币每四年产出速度减半一次，直到2140年，每一个区块的比特币将不能再被细分，这时比特币就开采完毕了，等比数列求和可得总量约为2100万个。 如果不设计工作量证明，将无法抵御黑客的攻击。例如，你在饿了么上支付了18元你的外卖费用。你作为黑客，如果想要修改这一笔交易，就必须重新玩一次这个区块上的新的跳一跳到1000分，且这笔交易所在的区块，之后的所有区块，你都必须完成游戏并修改直到你的链子是全网络最长的一条时，你才修改成功了。当然，中本聪实际设计的“游戏”要比跳一跳难的多，他会消耗全网巨大的CPU算力，只要黑客手上的算力无法达到全网算力的51%,要改变任意一笔交易将会变得很难，且难度系数会随着时间成指数增长。 03 常见攻击 0x01 doublespend 翻译为双重支付，或直译为“双花”。所表达的意思也很简单，一笔数字资产既支付给了A，又支付给了B。结合51％的攻击力一起食用。 0x02 Selfish mining ​ 目前还没有找到中文解释，先直译为“私自挖矿攻击”。正常挖矿过程中，矿工挖到矿了都会立刻广播结果，生怕别人跟我来抢这个区块。但是在Selfish mining中则不然。假设目前所有矿工都工作在区块0上。这时攻击者首先发信新的区块（区块1），他会保留刚挖到的区块，把该区块当做自己的私有链，在私有连上进行挖下一个区块。假如攻击者又挖到了第二个区块（区块2），而这时其他矿工挖到了新区块（区块1’，因为没有听到区块1，还工作在区块0上），攻击者会直接提交两个区块。因为这时候0-1-2这条链长于0-1’这条链，0-1-2会被选做主链。因此，攻击者能获得2个区块的奖励，而别人的算力浪费了，无法获得奖励。[3] 0x03 DoS &amp; DDoS 计算中的分布式拒绝服务（DDOS）攻击是一种攻击，其中犯罪者试图通过向网络充斥大量多余请求以试图使系统过载，使其用户无法使用网络资源。这是一种攻击不仅是区块链，而且任何在线服务都会受到影响。 [5] 0x04 Sybil 女巫攻击 Sybil 攻击是通过创建多个虚假身份来尝试操纵 P2P 网络。 对于观察者来说，这些不同的身份看起来像个人用户，但在幕后，单个实体一次控制所有这些假实体。特别是当您考虑在线投票时，这种类型的攻击非常重要。 我们看到 Sybil 攻击的另一个领域是社交网络，过多假账户可以引导公众的讨论。 Sybil 攻击的另一个可能用途是审查某些参与者。 许多 Sybil 节点可以围绕您的节点，并阻止它连接到网络上的其他诚实节点。这样可以防止您向网络发送或接收信息。 缓解 Sybil 攻击的一种方法是引入或提高创建身份的成本。这个成本必须仔细平衡。它必须足够低，以便不限制新参与者加入网络并创建合法身份。它同时也必须足够高，以至于在短时间内创建大量身份变得非常困难。在 PoW 区块链中，实际对交易打包的节点是挖矿节点。有一个现实世界的成本，即购买矿机的成本，与创建虚假的“采矿标识”相关联。另外，拥有大量挖掘节点仍然不足以对网络产生巨大影响。要产生大影响，你还需要大量的算力。换句话说，您需要大型计算机集群。相关的成本使 Sybil 难以对工作证明区块链发起攻击。[5] 0x05 51％的攻击力 对公共 PoW 区块链的最著名的攻击类型是 51％的攻击。51％攻击的目标是执行双重花费，这意味着将硬币同时花出去两次。要对区块链网络执行 51％的攻击，您需要控制网络的大部分哈希率或计算能力，正如名字一样，需要控制 51% 的算力才能发起攻击。 想要执行双花攻击的恶意矿工，他首先创建一个常规交易，再将其硬币存到交易所，再换成好币或其它货币。这发生在下面的40 区块中。与此同时，他们将开始私下挖出一条私链。这意味着他们将遵循通常的挖掘协议，但有两个例外。 首先，他们不会将自己的交易打包在自己的私人开采的链中。其次，他们不会将他们找到的块广播到网络，因此我们将其称为私有链。 如果他们控制大部分算力，他们的链条平均出块速度将比诚实链条快。PoW 区块链中的最长链规则，也称为中本聪共识，用于在这种情况下发生的情况。具有更多区块的分支链，被认为是有效链。 一旦攻击者收到用他们的硬币购买的货币或其他货币，他们就会将私链广播到整个网络。所有诚实的矿工将放弃诚实的链条，并开始挖掘恶意链。攻击者的交易视为从未发生过，因为攻击者未将其包含在恶意链中。攻击者仍在控制他们的资金，现在可以再次使用它们。 04 名词解释 0x01 Inter-block time This is the time elapsed between the generation of each block. For bitcoin the blocks are generated every 10 minutes, for litecoin it’s 2.5 minutes. Any value can be used but an appropriate value is usually between a few minutes; if the generation time is too fast it might destabilize the blockchain, if it’s too slow it may not attract many users[4]. 0x02 proof of work(PoW) 工作证明（Proof Of Work，POW），也称为工作量的证明。这里的工作是指找到一个合理的区块哈希值，它需要不断地进行大量的计算，计算时间取决于当前目标的难度和机器的运算速度。当一个节点找到这个值之后，就说明该节点确实经过了大量的计算，这就是工作量证明。由于验证只需对结果值进行一次哈希运算，因此ＰＯＷ的验证效率很高。 0x03 Hash 哈希（也称为散列）算法将任意长度的输入值映射为较短的固定长度的二进制值。例如，SHA256算法就是将任意长度的输入映射为长度为256位的固定长度输出，这个二进制值称为哈希值（也称为散列值）。数据的哈希值可以检验数据的完整性，一般用于快速查找和加密算法。哈希算法广泛应用于区块链中，区块链通常不保存原始数据，而是保存该数据的哈希值。 0x04 Merkle 树 Merkle树是由Ralph Merkle发明的一种基于数据哈希构建的树。区块链系统采用二叉树型的 Merkle树对该区块的所有交易进行归纳表示，同时生成该交易集合的数字签名。 0x05 时间戳服务 区块链系统通过给每一笔交易盖上正确的时间戳，以此证明在这个时刻这笔交易确实发生，交易中资金的所属权已经转移，之前资金所有者再次使用这笔资金时就会报错，从而解决重复支付问题。另外，每一个区块也会盖上正确的时间戳，从而形成一个按时间顺序发展的正确链表。 0x06 拜占庭将军问题(Byzantine failures) 拜占庭将军问题，是由莱斯利·兰伯特提出的点对点通信中的基本问题。含义是在存在消息丢失的不可靠信道上试图通过消息传递的方式达到一致性是不可能的。 拜占庭将军问题是一个协议问题，拜占庭帝国军队的将军们必须全体一致的决定是否攻击某一支敌军。问题是这些将军在地理上是分隔开来的，并且将军中存在叛徒。叛徒可以任意行动以达到以下目标：欺骗某些将军采取进攻行动；促成一个不是所有将军都同意的决定，如当将军们不希望进攻时促成进攻行动；或者迷惑某些将军，使他们无法做出决定。如果叛徒达到了这些目的之一，则任何攻击行动的结果都是注定要失败的，只有完全达成一致的努力才能获得胜利。[7] 05 发展现状 0x01 信息共享领域 区块链与其他行业融合的应用，其中最直接的一个领域就是信息领域。首先，区块链本身就是需要保持各个节点的数据一致性的，可以说是自带信息共享功能；其次，实时的问题通过区块链的P2P技术可以实现；最后，利用区块链的不可篡改和共识机制，可构建其一条安全可靠的信息共享通道。[1] 0x02 版权保护 区块链 + 鉴证证明 流程简化：区块链应用到鉴证证明后，无论是登记还是查询都非常方便，无需再奔走于各个部门之间。 安全可靠：区块链的去中心化存储，保证没有一家机构可以任意篡改数据。 应用案例：2017年12月,微众银行 仲裁委(广州仲裁委) 杭州亦笔科技有限公司共同推出的仲裁联盟链,用于司法场景下的存证;2018年3月,广州首个 仲裁链 判决书出炉。[1] 0x03 物流链 区块链没有中心化节点，各节点是平等的，掌握单个节点无法实现修改数据；需要掌控足够多的节点，才可能伪造数据，大大提高伪造数据的成本。 区块链天生的开放、透明，使得任何人都可以公开查询，伪造数据被发现的概率大增。 区块链的数据不可篡改性，也保证了已销售出去的产品信息已永久记录，无法通过简单复制防伪信息蒙混过关，实现二次销售。 物流链的所有节点接入区块链后，商品从生产商到消费者手里都有迹可循，形成完整链条；商品缺失的环节越多，将暴露出其是伪劣产品概率更大。 应用案例：目前,入局物流链的玩家较多,包括腾讯 阿里 京东 沃尔玛等。[1] 06 参考 [1] 知乎：区块链怎么赚钱，有什么经济前景？ [2] 巴菲特:比特币是一种“赌博” 很多欺诈行为与之有关 [3] 【区块链技术】区块链技术如何赋能智能制造？ [4] Mastering Blockchain - Second Edition by Imran Bashir [5] 科普：区块链里常见的攻击 [6] 区块链技术概述 [7] 百度百科：拜占庭将军问题 回形针视频介绍：区块链到底是什么？ 比特币和区块链啥原理？矿机挖矿咋回事？李永乐老师讲比特币(1) 比特币交易如何防伪？私钥公钥地址啥意思？李永乐老师讲比特币(2) 拜占庭将军问题是什么？区块链如何解决防范恶意节点？ 【官方双语】想知道比特币（和其他加密货币）的原理吗？ 区块链入门教程 比特币挖矿攻击中的PAW和BSM 比特币中的挖矿攻击 区块链数字货币的9种共识机制比较 从POW到POS看区块链共识的发展 07 一些网站 寻找中本聪：Satoshi Nakamoto Institute Blockchain","categories":[{"name":"折腾","slug":"折腾","permalink":"https://Dragonliu2018.github.io/categories/折腾/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"https://Dragonliu2018.github.io/tags/区块链/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-09-13T10:30:49.000Z","updated":"2022-01-20T08:05:25.036Z","comments":true,"path":"2019/09/13/hello-world/","link":"","permalink":"https://Dragonliu2018.github.io/2019/09/13/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start install Hexo 1npm install hexo -g upgrade Hexo 1npm update hexo -g init Blog 1hexo init Create a new post 12hexo new \"My New Post\" hexo n \"My New Post\" More info: Writing Run server 1hexo server More info: Server Generate static files 12hexo generatehexo g More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment Clear cache 1hexo clean Local Testing 1234hexo server #Hexo会监视文件变动并自动更新，无须重启服务器hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IP","categories":[{"name":"环境与工具","slug":"环境与工具","permalink":"https://Dragonliu2018.github.io/categories/环境与工具/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://Dragonliu2018.github.io/tags/Hexo/"}]}],"categories":[{"name":"阅读","slug":"阅读","permalink":"https://Dragonliu2018.github.io/categories/阅读/"},{"name":"开发","slug":"开发","permalink":"https://Dragonliu2018.github.io/categories/开发/"},{"name":"环境与工具","slug":"环境与工具","permalink":"https://Dragonliu2018.github.io/categories/环境与工具/"},{"name":"安全","slug":"安全","permalink":"https://Dragonliu2018.github.io/categories/安全/"},{"name":"影视","slug":"影视","permalink":"https://Dragonliu2018.github.io/categories/影视/"},{"name":"旅行","slug":"旅行","permalink":"https://Dragonliu2018.github.io/categories/旅行/"},{"name":"音乐","slug":"音乐","permalink":"https://Dragonliu2018.github.io/categories/音乐/"},{"name":"折腾","slug":"折腾","permalink":"https://Dragonliu2018.github.io/categories/折腾/"}],"tags":[{"name":"书评","slug":"书评","permalink":"https://Dragonliu2018.github.io/tags/书评/"},{"name":"python","slug":"python","permalink":"https://Dragonliu2018.github.io/tags/python/"},{"name":"示例","slug":"示例","permalink":"https://Dragonliu2018.github.io/tags/示例/"},{"name":"纪录片","slug":"纪录片","permalink":"https://Dragonliu2018.github.io/tags/纪录片/"},{"name":"电视剧","slug":"电视剧","permalink":"https://Dragonliu2018.github.io/tags/电视剧/"},{"name":"电影","slug":"电影","permalink":"https://Dragonliu2018.github.io/tags/电影/"},{"name":"摘抄","slug":"摘抄","permalink":"https://Dragonliu2018.github.io/tags/摘抄/"},{"name":"C++","slug":"C","permalink":"https://Dragonliu2018.github.io/tags/C/"},{"name":"Hexo","slug":"Hexo","permalink":"https://Dragonliu2018.github.io/tags/Hexo/"},{"name":"Web","slug":"Web","permalink":"https://Dragonliu2018.github.io/tags/Web/"},{"name":"CV","slug":"CV","permalink":"https://Dragonliu2018.github.io/tags/CV/"},{"name":"区块链","slug":"区块链","permalink":"https://Dragonliu2018.github.io/tags/区块链/"}]}